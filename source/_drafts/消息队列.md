---
title: 消息队列RabbitMQ
tags:
categories:
---
# 对比
## 与python中的原生queue对比
* 线程queue：同一个进程下进程间的交互
* 进程Queue：父子进程交互，或同属于一个进程下的多个子进程间交互
* 不同程序间的交互选择：
    - socket
    - disk
    - 消息中间件（比如rabbitmq）

## 同类产品对比
* RabbitMQ
    - Mozilla出品，由高并发语言Erlang编写
    - 基于AMQP协议实现
    - 为了保证消息的可靠性，有消息确认机制、支持事务，不支持批量操作
* Kafka
    - linkedin开源的产品，目前归属apache基金会
    - 追求吞吐量，内部采用消息的批量处理
    - 数据的存储和获取是本地磁盘顺序批量操作
* RocketMQ：阿里巴巴基于kafka，使用java重写的产品

# 基本概念
* broker：简单来说就是消息队列服务器实体
* Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列；目前支持的规则类型
    - Direct：精确匹配，完全根据key进行消息投递
    - Topic：模式匹配，对key进行模式匹配后进行消息投递（符 号"#"匹配一个或多个词，符号"*"匹配正好一个词。例如"abc.#"匹配"abc.def.ghi"，"abc.*"只匹配"abc.def"）
    - fanout：广播功能，不需要key，此时会把所有发送到该exchange的消息路由到与它绑定的Queue中
* Queue：消息队列载体，每个消息都会被投入到一个或多个队列
* Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来
* Routing Key：路由关键字，exchange根据这个关键字进行消息投递
* vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离
* producer：消息生产者，就是投递消息的程序
* consumer：消息消费者，就是接受消息的程序
* channel：消息通道，在客户端的每个连接里，都可以建立多个channel，每个channel代表一个会话任务

# 使用过程
* 客户端连接到消息队列服务器（vhost、账号、密码），打开一个channel
* 客户端声明一个exchange，并设置相关属性
* 客户端声明一个queue，并设置相关属性
* 客户端使用routing key，在exchange和queue之间建立绑定关系
* 客户端投递消息到exchange

# 消息持久化
rabbitMQ支持消息持久化，持久化包含三个部分

* exchange：声明时指定durable =》1
* queue：声明时指定durable =》1
* message：在投递时指定delivery_mode =》2（1是非持久化）

只有exchange和queue都是持久化的，那么他们的binding才是持久化的；如果两者，一个持久化，一个非持久化，就不允许建立绑定。

# 安装
* ubuntu/centos仓库安装：install rabbitmq-server
* 自定义版本安装
    - 安装erlang语言
    - 下载指定格式rabbitmq-server软件包

# 管理
* rabbitmqctl add_vhost celery     添加虚拟机
* rabbitmqctl add_user ever01 Theistyle     #添加用户
* rabbitmqctl set_permissions -p celery ever01 ".*" ".*" ".*"   对虚拟机进行用户授权【后面三个".*"代表ever01用户拥有对celery的配置、写、读全部权限】

# python客户端
* pika
* Celery(分布式任务队列)
