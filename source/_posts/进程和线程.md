---
title: 进程和线程
date: 2018-03-02 14:25:00
tags: ['进程', '线程', 'IPC']
categories: python
---
# 进程与线程
## 概念
* 进程是资源集合，至少包含一个线程；线程是程序运行的最小单位
* 一个进程的多个线程共享内存空间
* 无论多进程或多线程，数量增加到一定程度，任务开销就会急剧上升，效率就会下降
* 计算密集型任务，更多使用cpu，注重代码的执行效率，更适合使用C语言开发；而如web应用等io密集型【磁盘和网络】，瓶颈不在cpu和内存，所以适合使用python这样代码少的语言提高开发效率
* 利用操作系统对异步io的支持，可以用单进程单线程来执行多任务，这种模型即为事件驱动模型，对应到python即为协程
* 要实现多任务，通常采用master-worker模式，master负责分配任务，worker负责执行任务

## 优缺点
|   -    |                            优点                           |                            缺点                           |                                应用范例                                |
|--------|-----------------------------------------------------------|-----------------------------------------------------------|------------------------------------------------------------------------|
| 多进程 | 稳定性高,一个进程的崩溃不会影响到其他进程                 | 创建进程的开销大,Unix下fork还好,windows下特别明显         | Apache默认采用进程模型                                                 |
| 多线程 | 通常线程模式比进程模式执行快,windows下iis就采用多线程模式 | 但是由于多线程共享内存,一个线程的崩溃会导致整个进程的崩溃 | 现在apache和iis都出现了多进程多线程混合模式,在保证稳定性的同时提高效率 |

# 进程
## Process范例
```python
from multiprocessing import Process
import os, random, time

def run_proc(name):
    print('子进程 %s(%s)开始' % (name, os.getpid()))
    time.sleep(random.randint(3, 6))
    print('子进程 %s(%s)结束' % (name, os.getpid()))


if __name__ == '__main__':
    print('父进程%s开始' % os.getpid())
    # Process产生用于执行函数的子进程
    p1 = Process(target=run_proc, args=('test1',))
    p2 = Process(target=run_proc, args=('test2',))
    # 开启子进程,此时p1与p2并行执行
    p1.start()
    p2.start()
    # 等待子进程结束
    p1.join()
    p2.join()
    print('父进程%s结束' % os.getpid())

# 假如程序为如下顺序，则p1与p2串行执行
# 子程序1
p1.start()
p1.join()  
# 子程序2
p2.start()
p2.join()

# 其他进程方法
# 查看子进程名称
print(p1.name)
# 子进程pid
print(p1.pid)
# 进程是否存活
print(p1.is_alive())
# 终止进程
p1.terminate()
```

# 进程池
## Pool范例
```python
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('运行任务 %s(%s)' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 10)
    end = time.time()
    print('任务 %s 运行 %0.2f seconds' % (name, (end - start)))

if __name__ == '__main__':
    print('主进程 %s 开始' % os.getpid())
    # Pool默认产生和cpu核数相等的子进程
    p = Pool(5)
    for i in range(5):
    # apply_async用于产生并行子进程，一个进程结束又会有新的进程进入，维持进程总数不变
        p.apply_async(long_time_task, args=(i,))
    # 关闭进程池
    p.close()
    # 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。
    p.join()
    print('主进程 %s 结束' % os.getpid())
```

# IPC
>IPC (Inter-process communication))：进程间的通讯

## 队列使用范例
```python
from multiprocessing import Process, Queue, Pool, Manager
import os, time, random

def write(q):
    print('Process to write: %s' % os.getpid())
    for value in ['A', 'B', 'C']:
        print('put %s to queue...' % value)
        q.put(value)

def read(q):
    print('Process to read: %s' % os.getpid())
    for i in range(q.qsize()):
        value = q.get(True)
        print('get %s from queue' % value)

# 进程模式下队列使用【使用原生的queue】
# if __name__ == '__main__':
#     q = Queue()
#     pw = Process(target=write, args=(q,))
#     pr = Process(target=read, args=(q,))
#     pw.start()
#     pr.start()
#     pw.join()
#     pr.join()

# 进程池模式下队列使用【使用Manager的queue】
if __name__ == '__main__':
    manager = Manager()
    q = manager.Queue()
    p = Pool()
    p.apply_async(write, args=(q,))
    p.apply_async(read, args=(q,))
    p.close()
    p.join()
```

# 线程
* 任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程 
* 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改
* 为了保证一个变量不被多个线程同时修改，可以在一个线程执行前加锁，执行完后释放锁，然后其他线程再执行操作【 由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突】
* GIL【global iterpretor lock】 Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
* Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。

## 线程锁Lock
```python
import time, threading, random

balance = 0
lock = threading.Lock()

def change_it(n):
    global balance
    balance = balance + n
    print(balance)
    balance = balance - n
    print(balance)
    time.sleep(random.random() * 2)

def run_thread(n):
    for i in range(10):
        lock.acquire()
        try:
            change_it(n)
        finally:
            lock.release()

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print('final balance is %d' % balance)
```
## 线程隔离Local
* 全局变量local_school是一个threadlocal对象，每个线程都可以对它的student属性操作，而互不影响
* threadlocal常用于为每个线程绑定一个数据库连接、http请求、用户身份信息等

```python
import threading

local_school = threading.local()

def process_thread(name):
    local_school.student = name
    print('Hello, %s (in %s)' % (local_school.student, threading.current_thread().name))

t1 = threading.Thread(target=process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target=process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()
```

