<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>elk-安全和访问控制</title>
    <url>/blog/2020/11/01/ELK/elk-%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>本文主要基于<a href="https://www.elastic.co/cn/blog/getting-started-with-elasticsearch-security" target="_blank" rel="noopener">通过 TLS 加密和基于角色的访问控制确保 Elasticsearch 的安全</a>完成</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从elastic stack 6.8和7.1开始，会在软件分发版本中免费提供多项安全功能，例如elasticsearch之间的TLS加密通信，kibana中基于角色的访问控制(RBAC)等.</p>
<p>在完成下列操作前，应当完成以下操作：</p>
<ul>
<li>创建一个3节点的elasticsearch集群</li>
<li>elasticsearch集群安装并使用elasticsearch-head插件</li>
<li>已安装filebeat、logstash、kibana等组件</li>
</ul>
<h1 id="ES间TLS通信设置"><a href="#ES间TLS通信设置" class="headerlink" title="ES间TLS通信设置"></a>ES间TLS通信设置</h1><p>在es的配置文件elasticsearch.yml的同级目录生成证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch-certutil cert -out config/elastic-certificates.p12 -pass &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>修改配置文件elasticsearch.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate</span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</span><br></pre></td></tr></table></figure>
<p>将证书复制到其他节点相应位置、修改配置文件elasticsearch.yml</p>
<p>重启所有节点elasticsearch服务</p>
<h1 id="ES设置密码"><a href="#ES设置密码" class="headerlink" title="ES设置密码"></a>ES设置密码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure>
<p>可以在任意节点，使用上述命令交互式的设置用户密码，交互过程中会产生如下用户：</p>
<ul>
<li>elastic：超级用户</li>
<li>kibana：kibana连接es用户</li>
<li>logstash_system：logstash连接es用户</li>
<li>filebeat_system：filebeat连接es用户</li>
<li>apm_system</li>
<li>remote_monitoring_user</li>
</ul>
<p>为了操作方便，可以将如上用户密码设置一致</p>
<h1 id="ES客户端密码访问设置"><a href="#ES客户端密码访问设置" class="headerlink" title="ES客户端密码访问设置"></a>ES客户端密码访问设置</h1><h2 id="logstash设置"><a href="#logstash设置" class="headerlink" title="logstash设置"></a>logstash设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">   user =&gt; &quot;elastic&quot;</span><br><span class="line">   password =&gt; &quot;123456&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置范例如上，设置后重启logstash；</p>
<p>如果使用logstash_system会出现如下错误，解决方案未知，暂时使用超级用户连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oct 31 23:40:21 elk-2 logstash: [2020-10-31T23:40:21,881][ERROR][logstash.outputs.elasticsearch] Encountered a retryable error. Will Retry with exponential backoff  &#123;:code=&gt;403, :url=&gt;&quot;http://192.168.31.222:9200/_bulk&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kibana设置"><a href="#kibana设置" class="headerlink" title="kibana设置"></a>kibana设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch.username: &quot;kibana&quot;</span><br><span class="line">elasticsearch.password: &quot;123456&quot;</span><br></pre></td></tr></table></figure>
<p>设置后重启kibana，此时kibana即可连接elasticsearch；</p>
<p>当web登录kibana时使用超级管理员(即elastic/123456)进行认证</p>
<h2 id="elasticsearch-head设置"><a href="#elasticsearch-head设置" class="headerlink" title="elasticsearch-head设置"></a>elasticsearch-head设置</h2><ul>
<li><p>修改elasticsearch.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用如下连接方式登录elasticsearch-head</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://&#123;host&#125;:9100/?auth_user=elastic&amp;auth_password=123456</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="API访问设置"><a href="#API访问设置" class="headerlink" title="API访问设置"></a>API访问设置</h2><ul>
<li><p>curl方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -u username:password</span><br></pre></td></tr></table></figure>
</li>
<li><p>postman方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authorization ==&gt; Basic Auth ==&gt; Username/Password</span><br></pre></td></tr></table></figure>
</li>
<li><p>python api</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from elasticsearch import Elasticsearch</span><br><span class="line"></span><br><span class="line">node_list = [</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.221&quot;, &quot;port&quot;: 9200&#125;,</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.222&quot;, &quot;port&quot;: 9200&#125;,</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.223&quot;, &quot;port&quot;: 9200&#125;</span><br><span class="line">]</span><br><span class="line">es = Elasticsearch(hosts=node_list, http_auth=(&apos;elastic&apos;, &apos;123456&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="kibana中配置基于角色的访问控制-RBAC"><a href="#kibana中配置基于角色的访问控制-RBAC" class="headerlink" title="kibana中配置基于角色的访问控制(RBAC)"></a>kibana中配置基于角色的访问控制(RBAC)</h1><ul>
<li><p>创建角色(roles)</p>
<ul>
<li>选择索引模式名称(例如：logstash-nginx-access*)</li>
<li>选择可以对索引的权限(例如：read)</li>
</ul>
</li>
<li><p>创建用户</p>
<ul>
<li>设置用户名和密码</li>
<li>选择角色名称【需要为用户额外分配<strong>kibana_user</strong>角色(因为该用户将会查看 Kibana 中的数据)】</li>
</ul>
</li>
</ul>
<p>使用创建的用户登录，即可管理(查看)相应的索引数据</p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>xpack</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>elk-stack安装</title>
    <url>/blog/2020/08/14/ELK/elk-stack%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><ul>
<li>elasticsearch：基于Lucene的搜索服务器，用于数据收集、分析、存储</li>
<li>logstash：日志收集、过滤、转换</li>
<li>kibana：数据可视化</li>
<li>kafka：数据缓冲队列；提高系统扩展性，可以使关键组件顶住峰值访问压力</li>
<li>filebeat：使用go编写的收集文件数据的轻量级客户端；隶属于beats系列，其他beats客户端<ul>
<li>metricbeat：可以采集指标数据，如系统、文件、进程、服务等</li>
<li>packetbeat：收集网络数据</li>
<li>winlogbeat：收集windows事件日志</li>
<li>heartbeat：健康检查</li>
</ul>
</li>
</ul>
<h1 id="架构和数据流"><a href="#架构和数据流" class="headerlink" title="架构和数据流"></a>架构和数据流</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/elk-kafka.png" alt></p>
<p>filebeat==》kafka《==logstash==》elasticsearch《==kibana</p>
<ul>
<li>filebeat收集数据写入消息队列kafka</li>
<li>logstash从kafka中读取数据，并写入elasticsearch集群</li>
<li>kibana从elasticsearch读取数据并在web界面展示</li>
</ul>
<h1 id="源码安装要求"><a href="#源码安装要求" class="headerlink" title="源码安装要求"></a>源码安装要求</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>jdk【1.8.0_251】：<a href="https://www.injdk.cn/" target="_blank" rel="noopener">https://www.injdk.cn/</a><ul>
<li>checksum：<a href="https://www.oracle.com/webfolder/s/digest/8u251checksum.html" target="_blank" rel="noopener">https://www.oracle.com/webfolder/s/digest/8u251checksum.html</a></li>
</ul>
</li>
<li>elasticsearch/logstash/kibana/filebeat【6.5.4】：<a href="https://mirrors.huaweicloud.com/" target="_blank" rel="noopener">https://mirrors.huaweicloud.com/</a></li>
<li>kafka【2.11-2.0.0】：<a href="https://mirrors.bfsu.edu.cn/apache/kafka/" target="_blank" rel="noopener">https://mirrors.bfsu.edu.cn/apache/kafka/</a></li>
</ul>
<h2 id="节点规划"><a href="#节点规划" class="headerlink" title="节点规划"></a>节点规划</h2><table>
<thead>
<tr>
<th>ip/主机名</th>
<th>组件</th>
<th>配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.31.221/elk-1</td>
<td>es(jdk)/kafka(zookeeper)/cerebro</td>
<td>&gt;=2C3G</td>
</tr>
<tr>
<td>192.168.31.222/elk-2</td>
<td>es(jdk)/kafka(zookeeper)/kibana</td>
<td>&gt;=2C3G</td>
</tr>
<tr>
<td>192.168.31.223/elk-3</td>
<td>es(jdk)/kafka(zookeeper)/logstash</td>
<td>&gt;=2C3G</td>
</tr>
<tr>
<td>192.168.31.250/-</td>
<td>filebeat</td>
<td>&gt;=2G</td>
</tr>
</tbody>
</table>
<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><ul>
<li><p>清空iptables</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -F &amp;&amp; \</span><br><span class="line">iptables -X &amp;&amp; \</span><br><span class="line">iptables -Z</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭firewalld</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld </span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭selinux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config </span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure>
</li>
<li><p>主机hosts设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.31.221 elk-1</span><br><span class="line">192.168.31.222 elk-2</span><br><span class="line">192.168.31.223 elk-3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h1><ul>
<li>解压软件包：tar xzf jdk-8u251-linux-x64.tar.gz -C /usr/local/</li>
<li>配置环境变量：source /etc/profile.d/java.sh</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;</span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_251</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH&quot; &gt; /etc/profile.d/java.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>测试安装：java -version</li>
</ul>
<h1 id="elasticsearch安装"><a href="#elasticsearch安装" class="headerlink" title="elasticsearch安装"></a>elasticsearch安装</h1><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><ul>
<li><p>新建普通用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd elastic</span><br><span class="line">echo &quot;123456&quot;|passwd --stdin elastic</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压软件包：tar xzf elasticsearch-6.5.4.tar.gz -C /usr/local/</p>
</li>
<li><p>创建es数据和日志目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -pv /data/elasticsearch/&#123;data,logs&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改安装目录和存储目录权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R elastic.elastic /usr/local/elasticsearch-6.5.4/</span><br><span class="line">chown -R elastic.elastic /data/elasticsearch/</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加最大内存映射和禁用swap【/etc/sysctl.conf】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;</span><br><span class="line">vm.swappiness = 0</span><br><span class="line">vm.max_map_count=655300&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加最大进程数、最大文件打开数、内存锁定限制【/etc/security/limits.conf】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 32000</span><br><span class="line">* hard nproc 32000</span><br><span class="line">* hard memlock unlimited</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">&quot; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  实时生效【/etc/systemd/system.conf】</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;</span><br><span class="line">DefaultLimitNOFILE=65536</span><br><span class="line">DefaultLimitNPROC=32000</span><br><span class="line">DefaultLimitMEMLOCK=infinity&quot; &gt;&gt; /etc/systemd/system.conf</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><p>主配置【/usr/local/elasticsearch-6.5.4/config/elasticsearch.yml】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.name: elk</span><br><span class="line">node.name: 221</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line">network.host: 192.168.31.221</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">discovery.zen.ping_timeout: 100s</span><br><span class="line">discovery.zen.fd.ping_timeout: 100s</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.31.222&quot;,&quot;192.168.31.223&quot;]</span><br><span class="line">discovery.zen.fd.ping_interval: 10s</span><br><span class="line">discovery.zen.fd.ping_retries: 10</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
<p>配置文件含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.name:                                        集群名称【集群中唯一】</span><br><span class="line">node.name:                                           节点名称【每个节点都不同】</span><br><span class="line">node.master:                                         是否可以成为master</span><br><span class="line">node.data:                                           是否为数据节点</span><br><span class="line">path.data:                                           数据存储目录</span><br><span class="line">path.logs:                                           日志存储</span><br><span class="line">bootstrap.memory_lock:                               内存锁定，是否禁用swap</span><br><span class="line">bootstrap.system_call_filter:                        系统调用过滤器</span><br><span class="line">network.host:                                        绑定节点ip【每个节点都不同】</span><br><span class="line">http.port:                                           rest api地址</span><br><span class="line">discovery.zen.minimum_master_nodes:                  集群可正常工作，参与master选举的节点数；官方推荐(N/2)+1，N为集群中所有具有master选择资格的节点数</span><br><span class="line">discovery.zen.ping_timeout:                          单播超时时间</span><br><span class="line">discovery.zen.fd.ping_timeout:                       节点发现超时时间</span><br><span class="line">discovery.zen.ping.unicast.hosts:                    向集群的其他节点发送单播【集群中的其他节点ip】</span><br><span class="line">discovery.zen.fd.ping_interval:                      启动节点发现的时间间隔</span><br><span class="line">discovery.zen.fd.ping_retries:                       节点发现重试次数</span><br><span class="line">http.cors.enabled:                                   是否允许跨域访问，开启后可以使用elasticsearch-head访问es</span><br><span class="line">http.cors.allow-origin:                              允许的源域</span><br></pre></td></tr></table></figure>
</li>
<li><p>jvm设置【/usr/local/elasticsearch-6.5.4/config/jvm.options】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms1g #程序启动时占用的最小内存</span><br><span class="line">-Xmx1g #程序运行时占用的最大内存</span><br></pre></td></tr></table></figure>
<ul>
<li>堆内存最大和最小值相等，防止程序运行过程中改变堆内存大小</li>
<li>如果系统内存足够大，将最大和最小值设置为31G，因为jvm有32G性能瓶颈</li>
<li>堆内存大小设置为系统内存1/2，最大不超过2/3</li>
</ul>
</li>
</ul>
<h2 id="启动-supervisor"><a href="#启动-supervisor" class="headerlink" title="启动-supervisor"></a>启动-supervisor</h2><ul>
<li><p>安装supervisor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install supervisor -y</span><br><span class="line">systemctl start supervisord</span><br><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑elasticsearch配置：/etc/supervisord.d/es.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:es]</span><br><span class="line">command=/usr/local/elasticsearch-6.5.4/bin/elasticsearch</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/jdk1.8.0_251&quot;</span><br><span class="line">startsec=30</span><br><span class="line">priority=10</span><br><span class="line">directory=/usr/local/elasticsearch-6.5.4/</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=elastic</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl update</span><br><span class="line">supervisorctl start elasticsearch</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="cerebro安装"><a href="#cerebro安装" class="headerlink" title="cerebro安装"></a>cerebro安装</h2><blockquote>
<p>可以通过cerebro以web方式访问elasticsearch</p>
</blockquote>
<ul>
<li><p>安装并启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line">vim /etc/docker/daemon.json #docker加速设置</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动cerebro</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name cerebro --restart=always -d -p 9000:9000 lmenezes/cerebro</span><br></pre></td></tr></table></figure>
</li>
<li><p>web访问：<a href="http://192.168.31.221:9000/" target="_blank" rel="noopener">http://192.168.31.221:9000/</a></p>
</li>
</ul>
<h2 id="elasticsearch-head安装"><a href="#elasticsearch-head安装" class="headerlink" title="elasticsearch-head安装"></a>elasticsearch-head安装</h2><blockquote>
<p>可以通过elasticsearch-head以web方式访问elasticsearch</p>
</blockquote>
<ul>
<li><p>安装phantomjs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2</span><br><span class="line">tar xjf phantomjs-2.1.1-linux-x86_64.tar.bz2 -C /usr/local/</span><br><span class="line">ln -s /usr/local/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin/</span><br><span class="line">yum install fontconfig freetype2 -y</span><br><span class="line">phantomjs -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://cdn.npm.taobao.org/dist/node/v14.8.0/node-v14.8.0-linux-x64.tar.xz</span><br><span class="line">tar xJf node-v14.8.0-linux-x64.tar.xz -C /usr/local/</span><br><span class="line">echo &quot;</span><br><span class="line">PATH=/usr/local/node-v14.8.0-linux-x64/bin:$PATH</span><br><span class="line">export PATH&quot; &gt;&gt;  /etc/profile.d/node.sh</span><br><span class="line">source /etc/profile.d/node.sh</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装elasticsearch-head</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置</p>
<ul>
<li><p>Gruntfile.js添加hostname，此处设置head的访问地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect: &#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                        port: 9100,</span><br><span class="line">                        base: &apos;.&apos;,</span><br><span class="line">                        keepalive: true,</span><br><span class="line">                        hostname: &apos;*&apos;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>_site/app.js修改es的访问地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://192.168.31.221:9200&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>启动elasticsearch-head</p>
<ul>
<li>命令行方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<ul>
<li>supervisor方式【npm install -g grunt-cli】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:es-head]</span><br><span class="line">command=grunt server</span><br><span class="line">environment=PATH=/usr/local/node-v14.8.0-linux-x64/bin</span><br><span class="line">startsec=10</span><br><span class="line">priority=15</span><br><span class="line">directory=/usr/local/src/elasticsearch-head</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
</li>
<li><p>web访问：<a href="http://192.168.31.221:9100" target="_blank" rel="noopener">http://192.168.31.221:9100</a></p>
</li>
</ul>
<h1 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h1><ul>
<li><p>解压安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf kibana-6.5.4-linux-x86_64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置【config/kibana.yml】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;192.168.31.222&quot;</span><br><span class="line">elasticsearch.url: &quot;http://192.168.31.221:9200&quot;</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br><span class="line">i18n.locale: &quot;zh-CN&quot; #6.7版本以上支持直接汉化</span><br></pre></td></tr></table></figure>
</li>
<li><p>supervisor启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:kibana]</span><br><span class="line">command=/usr/local/kibana-6.5.4-linux-x86_64/bin/kibana</span><br><span class="line">startsec=30</span><br><span class="line">priority=20</span><br><span class="line">directory=/usr/local/kibana-6.5.4-linux-x86_64</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
</li>
<li><p>web访问：<a href="http://192.168.31.222:5601" target="_blank" rel="noopener">http://192.168.31.222:5601</a></p>
</li>
<li><p>【可选】使用nginx明文认证方式反向代理kibana</p>
</li>
</ul>
<h1 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h1><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><ul>
<li><p>解压软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf kafka_2.11-2.0.0.tgz -C /usr/local/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据和日志目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -pv /data/zookeeper/&#123;data,logs&#125;</span><br><span class="line">mkdir -pv /data/kafka/logs</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><p>配置文件修改-zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/^[^#]/#&amp;/&apos; config/zookeeper.properties </span><br><span class="line">echo &quot;</span><br><span class="line">dataDir=/opt/data/zookeeper/data</span><br><span class="line">dataLogDir=/opt/data/zookeeper/logs</span><br><span class="line">clientPort=2181</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=20</span><br><span class="line">syncLimit=20</span><br><span class="line">server.1=192.168.31.221:2888:3888</span><br><span class="line">server.2=192.168.31.222:2888:3888</span><br><span class="line">server.3=192.168.31.223:2888:3888&quot; &gt;&gt; config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>配置详情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir            zk数据目录</span><br><span class="line">dataLogDir         zk日志目录</span><br><span class="line">clientPort         客户端访问zk服务的端口</span><br><span class="line">tickTime=2000      zk服务器之间或客户端与服务器之间心跳间隔</span><br><span class="line">initLimit=20       follower（相对于leader而言的客户端）连接到leader进行初始化超时时间，以tickTime为单位</span><br><span class="line">syncLimit=20       follower与leader同步超时时间</span><br><span class="line">server.1=192.168.31.221:2888:3888     2888为follower与leader数据交换端口，3888是执行leader选举的通信端口</span><br><span class="line">server.2=192.168.31.222:2888:3888</span><br><span class="line">server.3=192.168.31.223:2888:3888</span><br></pre></td></tr></table></figure>
<p>为每个kafka节点设置不同id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /data/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件-kafka</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/^[^#]/#&amp;/&apos; config/server.properties</span><br><span class="line">echo &quot;</span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://192.168.31.221:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=3</span><br><span class="line">transaction.state.log.replication.factor=3</span><br><span class="line">transaction.state.log.min.isr=3</span><br><span class="line">default.replication.factor=3</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.31.221:2181,192.168.31.222:2181,192.168.31.223:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0&quot; &gt;&gt; config/server.properties</span><br></pre></td></tr></table></figure>
<p>配置详情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">broker.id          每个server需要配置单独的broker id【每个节点不同】，如果不配置系统会自动配置；与上一步骤的id保持一致</span><br><span class="line">listeners             服务监听地址【每个节点不同】</span><br><span class="line">num.network.threads   收发信息的线程数</span><br><span class="line">num.io.threads        处理请求的线程数，包含磁盘IO</span><br><span class="line">socket.send.buffer.bytes          socket发送缓冲区</span><br><span class="line">socket.receive.buffer.bytes       socket接收缓冲区</span><br><span class="line">socket.request.max.bytes          socket接收请求最大字节数</span><br><span class="line">log.dirs              日志文件目录</span><br><span class="line">num.partitions        新建Topic时默认的分区数</span><br><span class="line">num.recovery.threads.per.data.dir          每个数据目录启动时恢复日志、关闭时刷盘日志使用的线程数</span><br><span class="line">offsets.topic.replication.factor           用于配置偏移量话题的复制因子</span><br><span class="line">transaction.state.log.replication.factor   事务主题的复制因子</span><br><span class="line">transaction.state.log.min.isr              覆盖事务主题的min.insync.replicas配置</span><br><span class="line">default.replication.factor                 自动创建topic时的默认副本的个数 </span><br><span class="line">log.retention.hours                        日志保留时间</span><br><span class="line">log.segment.bytes                          单个日志文件大小</span><br><span class="line">log.retention.check.interval.ms            检查日志是否需要保留的时间间隔</span><br><span class="line">zookeeper.connect                          zk连接地址</span><br><span class="line">zookeeper.connection.timeout.ms            zk连接超时</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h2><ul>
<li><p>supervisor启动zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:zk]</span><br><span class="line">command=/usr/local/kafka_2.11-2.0.0/bin/zookeeper-server-start.sh /usr/local/kafka_2.11-2.0.0/config/zookeeper.properties</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/jdk1.8.0_251&quot;</span><br><span class="line">startsec=10</span><br><span class="line">priority=10</span><br><span class="line">directory=/usr/local/kafka_2.11-2.0.0</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
<p>使用nc验证zk启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nc -y</span><br><span class="line">echo conf|nc 192.168.31.221 2181 #配置</span><br><span class="line">echo stat|nc 192.168.31.221 2181 #集群状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>supervisor启动kafka</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:kafka]</span><br><span class="line">command=/usr/local/kafka_2.11-2.0.0/bin/kafka-server-start.sh /usr/local/kafka_2.11-2.0.0/config/server.properties</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/jdk1.8.0_251&quot;</span><br><span class="line">startsec=10</span><br><span class="line">priority=15</span><br><span class="line">directory=/usr/local/kafka_2.11-2.0.0</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>环境变量设置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;PATH=/usr/local/kafka_2.11-2.0.0/bin/:\$PATH\nexport PATH&quot; &gt; /etc/profile.d/kafka.sh</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>  创建topic</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic testtopic </span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure>
<p>  模拟生产者和消费者【不同终端】</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-console-producer.sh --broker-list 192.168.31.221:9092 --topic testtopic</span><br><span class="line">kafka-console-consumer.sh --bootstrap-server 192.168.31.222:9092 --topic testtopic --from-beginning</span><br></pre></td></tr></table></figure>
<h2 id="web管理工具"><a href="#web管理工具" class="headerlink" title="web管理工具"></a>web管理工具</h2><p>kafka-manager：<a href="https://github.com/yahoo/CMAK" target="_blank" rel="noopener">https://github.com/yahoo/CMAK</a></p>
<h1 id="logstash安装"><a href="#logstash安装" class="headerlink" title="logstash安装"></a>logstash安装</h1><ul>
<li><p>安装要求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf logstash-6.5.4.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">kafka&#123;</span><br><span class="line">  type =&gt; &quot;nginx_kafka&quot;</span><br><span class="line">  codec =&gt; &quot;json&quot;</span><br><span class="line">  topics =&gt; &quot;nginx&quot;</span><br><span class="line">  decorate_events =&gt; true</span><br><span class="line">  bootstrap_servers =&gt; &quot;192.168.31.221:9092,192.168.31.222:9092,192.168.31.223:9092&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">  if[type] == &quot;nginx_kafka&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [&quot;192.168.31.221&quot;,&quot;192.168.31.222&quot;,&quot;192.168.31.223&quot;]</span><br><span class="line">      index =&gt; &quot;logstash-nginx-%&#123;+YYYY-MM-dd&#125;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input&#123;                       //数据来源</span><br><span class="line">kafka&#123;                       //来源于kafka</span><br><span class="line">  type =&gt; &quot;nginx_kafka&quot;     //自定义的数据分类</span><br><span class="line">  codec =&gt; &quot;json&quot;           //解码数据格式</span><br><span class="line">  topics =&gt; &quot;nginx&quot;          //从kafka的哪个topic获取数据</span><br><span class="line">  decorate_events =&gt; true    //可向事件添加Kafka元数据，比如主题、消息大小的选项</span><br><span class="line">  bootstrap_servers =&gt; &quot;192.168.31.221:9092,192.168.31.222:9092,192.168.31.223:9092&quot; //kafka服务地址</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;                         //数据流向</span><br><span class="line">  if[type] == &quot;nginx_kafka&quot;&#123;    //数据分类判断</span><br><span class="line">    elasticsearch &#123;             //数据写入es</span><br><span class="line">      hosts =&gt; [&quot;192.168.31.221&quot;,&quot;192.168.31.222&quot;,&quot;192.168.31.223&quot;]            //es服务地址</span><br><span class="line">      index =&gt; &quot;logstash-nginx-%&#123;+YYYY-MM-dd&#125;&quot;                  //向es写入数据时创建的索引</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>supervisor启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:logstash]</span><br><span class="line">command=/usr/local/logstash-6.5.4/bin/logstash -r -f /usr/local/logstash-6.5.4/config/logstash.conf</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/jdk1.8.0_251&quot;</span><br><span class="line">startsec=10</span><br><span class="line">priority=20</span><br><span class="line">directory=/usr/local/logstash-6.5.4</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181 --list #可以看到nginx这个topic</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="filebeat安装"><a href="#filebeat安装" class="headerlink" title="filebeat安装"></a>filebeat安装</h1><ul>
<li><p>安装要求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf filebeat-6.5.4-linux-x86_64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/nginx/access.log</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line">output.kafka:</span><br><span class="line">  hosts: [&quot;192.168.31.221:9092&quot;,&quot;192.168.31.222:9092&quot;,&quot;192.168.31.223:9092&quot;]</span><br><span class="line">  topic: &apos;nginx&apos;</span><br></pre></td></tr></table></figure>
<p>配置详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log                      # 输入数据类型，日志文件log，标准输入stdin</span><br><span class="line">  paths:                               # 日志文件路径</span><br><span class="line">    - /var/log/nginx/access.log</span><br><span class="line">  json.keys_under_root: true           # 让字段位于根节点</span><br><span class="line">  json.add_error_key: true             # 将解析错误的消息存储在error.message字段</span><br><span class="line">  json.message_key: log                # 合并多行json日志，需要配置multiline</span><br><span class="line">output.kafka:                          # 输出到kafka</span><br><span class="line">  hosts: [&quot;192.168.31.221:9092&quot;,&quot;192.168.31.222:9092&quot;,&quot;192.168.31.223:9092&quot;]</span><br><span class="line">  topic: &apos;nginx&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>supervisor启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:filebeat]</span><br><span class="line">command=/usr/local/filebeat-6.5.4-linux-x86_64/filebeat -e -c /usr/local/filebeat-6.5.4-linux-x86_64/filebeat.yml</span><br><span class="line">startsec=10</span><br><span class="line">priority=25</span><br><span class="line">directory=/usr/local/filebeat-6.5.4-linux-x86_64</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="YUM方式安装"><a href="#YUM方式安装" class="headerlink" title="YUM方式安装"></a>YUM方式安装</h1><blockquote>
<p>elk安装6.8版本，安装要求和配置同上；安装顺序：elasticsearch、kibana、logstash、beats</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装jdk</span><br><span class="line">yum install -y java-1.8.0-openjdk</span><br><span class="line"></span><br><span class="line"># 配置elk yum源</span><br><span class="line">cat &gt;&gt; /etc/yum.repos.d/elk.repo &lt;&lt; EOF</span><br><span class="line">[elasticsearch-6.x]</span><br><span class="line">name=Elasticsearch repository for 6.x packages</span><br><span class="line">baseurl=https://mirrors.cloud.tencent.com/elasticstack/6.x/yum/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line">EOF</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"># 安装elk</span><br><span class="line">yum -y install elasticsearch</span><br><span class="line">yum -y install kibana</span><br><span class="line">yum -y install logstash</span><br><span class="line"></span><br><span class="line"># 查看集群状态</span><br><span class="line">curl http://192.168.31.221:9200/_cat/health?v</span><br><span class="line"></span><br><span class="line"># 查看节点状态</span><br><span class="line">curl http://192.168.31.221:9200/_cat/nodes?v</span><br><span class="line">ip             heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">节点ip         堆内存使用百分比 内存使用百分比 cpu使用率    1/5/15分钟负载    集群角色   节点名称</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>logstash</tag>
        <tag>filebeat</tag>
        <tag>kafka</tag>
        <tag>kibana</tag>
        <tag>cerebro</tag>
        <tag>elasticsearch-head</tag>
      </tags>
  </entry>
  <entry>
    <title>filebeat学习</title>
    <url>/blog/2020/09/24/ELK/filebeat%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>filebeat由2个组件组成：inputs和harvester </p>
<ul>
<li><p>harvester：负责单个文件的读取；如果文件在读取时被删除或重命名，filebeat依然可以读取文件【harvester运行时占用一个文件描述符保证相关的文件依然被保留】</p>
</li>
<li><p>inputs：负责管理harvester并查找所有可以读取的资源；如果输入类型是日志，则查找器查找路径匹配的所有文件，并为每个文件启动一个harvester；支持多种inputs类型，例如log、stdin、tcp、udp、docker、redis、syslog等</p>
</li>
</ul>
<p>filebeat如何保持文件状态？</p>
<p>Filebeat会保留每个文件的状态，并经常将状态刷新到注册表文件(registry)中的磁盘。该状态用于记住收割机正在读取的最后一个偏移量，并确保发送所有日志行。如果无法到达输出（例如Elasticsearch或Logstash），Filebeat会跟踪发送的最后几行，并在输出再次可用时继续读取文件。当Filebeat运行时，状态信息也保存在内存中，用于每个输入。重新启动Filebeat时，将使用注册表文件中的数据来重建状态，并且Filebeat会将每个收割机继续到最后一个已知位置。</p>
<p>对于每个输入，Filebeat会保持找到的每个文件的状态。由于可以重命名或移动文件，因此文件名和路径不足以标识文件。对于每个文件，Filebeat都存储唯一的标识符以检测文件是否以前被收获过。</p>
<p>注册表文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.registry_file: $&#123;path.data&#125;/registry</span><br></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>可以将常见的日志进行格式化，直接输出到elasticsearch或kibana【此时就不需要再设置filebeat.inputs】</p>
<ul>
<li>在elasticsearch中安装ingest-geoip和ingest-user-agent</li>
</ul>
<blockquote>
<p>安装要求：<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/filebeat-modules-quickstart.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/6.5/filebeat-modules-quickstart.html</a></p>
<p>其他版本说明：<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.7/ingest-geoip.html" target="_blank" rel="noopener">v6.7之后作为elasticsearch的ingest processor无需安装</a></p>
<p>docker方式：docker启动的elasticsearch已默认安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bin/elasticsearch-plugin install ingest-geoip</span><br><span class="line">sudo bin/elasticsearch-plugin install ingest-user-agent</span><br></pre></td></tr></table></figure>
<ul>
<li>启停模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./filebeat modules enable nginx</span><br><span class="line">./filebeat modules list</span><br><span class="line">./filebeat modules disable nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>模块配置参数【modules.d/nginx.yml】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  access:</span><br><span class="line">    enabled: true</span><br><span class="line">    var.paths: [&quot;/var/log/nginx/access.log*&quot;] #设置nginx日志位置</span><br><span class="line">  error:</span><br><span class="line">    enabled: true</span><br><span class="line">    var.paths: [&quot;/var/log/nginx/error.log*&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>filebeat的主配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.config.modules:</span><br><span class="line">  reload.enabled: true                 # 运行动态加载配置</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml # 加载的模块位置</span><br></pre></td></tr></table></figure>
<h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  filebeat [flags]</span><br><span class="line">  filebeat [command]</span><br><span class="line"></span><br><span class="line">命令选项：</span><br><span class="line">export   # 导出配置</span><br><span class="line">modules  # 模块管理</span><br><span class="line">test     # 测试配置</span><br><span class="line">setup    # 在相关环境中进行初始化设置</span><br><span class="line">* --dashboards      在kibana中创建dashboard【kibana可用】</span><br><span class="line">* --machine-learnin 设置机器学习的job配置【机器学习节点可用】</span><br><span class="line">* --pipelines       在es中创建pipeline【es的ingest节点可用】</span><br><span class="line">* --template        在es中设置索引mappings模板</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-c filebeat.yml  # 指定配置文件名称(默认filebeat.yml)，相对于path.config</span><br><span class="line">-d publish       # 指定字符串调试</span><br><span class="line">-e               # filebeat日志记录到标准输出</span><br><span class="line">--path.data      # 数据目录       </span><br><span class="line">--path.home      # 根目录</span><br><span class="line">--path.logs      # 日志目录</span><br><span class="line"></span><br><span class="line">启动范例：</span><br><span class="line">./filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br></pre></td></tr></table></figure>
<h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuring-howto-filebeat.html" target="_blank" rel="noopener">配置选项</a></h1><h2 id="inputs设置"><a href="#inputs设置" class="headerlink" title="inputs设置"></a>inputs设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log                  # 输入数据类型，日志文件-log</span><br><span class="line">  enabled: true              # 开启log类型功能,默认true</span><br><span class="line">  paths:                     # 日志文件路径,使用通配符</span><br><span class="line">  - /usr/local/filebeat-6.5.4/*.log</span><br><span class="line">  exclude_files: [&apos;.gz$&apos;]    # 排除指定的文件</span><br><span class="line">  include_lines: [&quot;^ERR&quot;, &quot;^WARN&quot;] # 只发送包含这些字样的日志【默认包含所有；在exclude_lines之前调用】</span><br><span class="line">  exclude_lines: [&quot;^OK&quot;]     # 不发送包含这些字样的日志</span><br><span class="line">  tags: [&quot;nginx&quot;, &quot;web&quot;]     # 添加标签</span><br><span class="line">  fields:                    # 添加字段，默认添加到子节点fields下</span><br><span class="line">    env: staging</span><br><span class="line">  fields_under_root: true    # 添加字段到根节点下</span><br><span class="line">  ignore_older: &quot;24h&quot;        # 超过 24小时没更新内容的文件不再监听。</span><br><span class="line">  scan_frequency: &quot;10s&quot;      # 每 10秒钟扫描一次目录，更新通配符匹配上的文件列表</span><br><span class="line">  tail_files: false          # 是否从文件末尾开始读取</span><br><span class="line">  harvester_buffer_size: 16384 # 实际读取文件时，每次读取 16384 字节</span><br><span class="line">  backoff: &quot;1s&quot;              # 每 1 秒检测一次文件是否有新的一行内容需要读取</span><br></pre></td></tr></table></figure>
<h2 id="多行日志-multiline"><a href="#多行日志-multiline" class="headerlink" title="多行日志-multiline"></a><a href="https://blog.csdn.net/UbuntuTouch/article/details/106272704" target="_blank" rel="noopener">多行日志-multiline</a></h2><ul>
<li>multiline.pattern：指定要匹配的正则表达式模式。</li>
<li>multiline.negate：定义是否为否定模式，也就是和上面定义的模式相反。 默认为false。</li>
<li>multiline.match：如何将模式匹配和不匹配的行组合到一个事件中</li>
</ul>
<table>
<thead>
<tr>
<th>pattern：^b 匹配以b开始的行</th>
<th>negate</th>
<th>match</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200522095441298.png" alt></td>
<td>false</td>
<td>after</td>
<td>模式匹配的连续行追加到不匹配的行之后<br>【1-bb行追加到a行之后，2-bb行追加到c行之后】</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200522095832263.png" alt></td>
<td>false</td>
<td>before</td>
<td>模式匹配的连续行添加到下一个不匹配的行之前<br>【1-bb行添加到a行之前，2-bb行追加到c行之前】</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200522100310568.png" alt></td>
<td>true</td>
<td>after</td>
<td>模式不匹配的连续行添加到匹配行之后<br>【ac行追加到1-b行之后，de行追加到2-b行之后】</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200522100724855.png" alt></td>
<td>true</td>
<td>before</td>
<td>模式不匹配的连续行添加到下一个匹配行之前<br>【ac行添加到1-b行之前，de行添加到2-b行之前】</td>
</tr>
</tbody>
</table>
<ul>
<li><p>multiline.max_lines：单个事件中可以包含的最大行数，默认500</p>
</li>
<li><p>multiline.timeout：单个事件的读取超时时间，默认5s</p>
</li>
<li><p>multiline.flush_pattern：可以指定单个事件的结束匹配模式，这对于事件以特定标记开始和结束有用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2015-08-24 11:49:14,389] Start new event</span><br><span class="line">[2015-08-24 11:49:14,395] Content of processing something</span><br><span class="line">[2015-08-24 11:49:14,399] End event</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiline.pattern: ‘Start new event’</span><br><span class="line">multiline.negate: true</span><br><span class="line">multiline.match: after</span><br><span class="line">multiline.flush_pattern: ‘End event’</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​       当看到“Start new event”模式并且以下几行与该模式不匹配时，它们将被追加到与该模式匹配的前一行。<br>​       当看到以“End event”开头的一行时，flush_pattern选项将指示多行事件结束。</p>
<ul>
<li>范例1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">        at com.example.myproject.Book.getTitle(Book.java:16)</span><br><span class="line">        at com.example.myproject.Author.getBookTitles(Author.java:25)</span><br><span class="line">        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiline.pattern: ^[[:space:]] # 匹配空格开始的行</span><br><span class="line">multiline.negate: false         # 连续多行与匹配模式相同</span><br><span class="line">multiline.match: after          # 将匹配的行添加到不匹配的行之后</span><br></pre></td></tr></table></figure>
<ul>
<li>范例2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[beat-logstash-some-name-832-2015.11.28] IndexNotFoundException[no such index]</span><br><span class="line">    at org.elasticsearch.cluster.metadata.IndexNameExpressionResolver$WildcardExpressionResolver.resolve(IndexNameExpressionResolver.java:566)</span><br><span class="line">    at org.elasticsearch.cluster.metadata.IndexNameExpressionResolver.concreteIndices(IndexNameExpressionResolver.java:133)</span><br><span class="line">    at org.elasticsearch.cluster.metadata.IndexNameExpressionResolver.concreteIndices(IndexNameExpressionResolver.java:77)</span><br><span class="line">    at org.elasticsearch.action.admin.indices.delete.TransportDeleteIndexAction.checkBlock(TransportDeleteIndexAction.java:75)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiline.pattern: ^\[   # 匹配以[开始的行</span><br><span class="line">multiline.negate: true   # 连续多行与匹配模式相反</span><br><span class="line">multiline.match: after   # 将不匹配的行放在匹配行之后</span><br></pre></td></tr></table></figure>
<ul>
<li>范例3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: A book has a null property</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:38)</span><br><span class="line">       at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">       at com.example.myproject.Book.getId(Book.java:22)</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:35)</span><br><span class="line">       ... 1 more</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiline.pattern: &apos;^[[:space:]]+(at|\.&#123;3&#125;)[[:space:]]+\b|^Caused by:&apos; # 匹配2个条件之一，条件如下</span><br><span class="line">multiline.negate: false # 连续多行与匹配模式相同</span><br><span class="line">multiline.match: after  # 将匹配的行放到不匹配的行之后</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以空白开始，接着是 at 或3个点，再一个空白之后接任意字符</p>
<p>以 Caused by: 开始</p>
</blockquote>
<h2 id="内部队列"><a href="#内部队列" class="headerlink" title="内部队列"></a>内部队列</h2><p>Filebeat在发布事件之前使用内部队列存储事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue.mem:</span><br><span class="line">  events: 4096          # 队列可以存储的事件数，默认4096</span><br><span class="line">  flush.min_events: 512 # 发布所需的最小事件数。如果将此值设置为0，则输出可以开始发布事件，而无需额外的等待时间。否则，输出必须等待更多事件可用。默认2048</span><br><span class="line">  flush.timeout: 5s    # 发布需要等待的最大等待时间flush.min_events。如果设置为0，事件将立即可供使用。默认1s</span><br></pre></td></tr></table></figure>
<h2 id="output设置"><a href="#output设置" class="headerlink" title="output设置"></a>output设置</h2><ul>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/elasticsearch-output.html" target="_blank" rel="noopener">Elasticsearch</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;https://localhost:9200&quot;]</span><br><span class="line">  index: &quot;filebeat-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">  username: &quot;filebeat_internal&quot;</span><br><span class="line">  password: &quot;YOUR_PASSWORD&quot;</span><br><span class="line">  ssl.certificate_authorities: [&quot;/etc/pki/root/ca.pem&quot;]</span><br><span class="line">  ssl.certificate: &quot;/etc/pki/client/cert.pem&quot;</span><br><span class="line">  ssl.key: &quot;/etc/pki/client/cert.key&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/logstash-output.html" target="_blank" rel="noopener">Logstash</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;127.0.0.1:5044&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/kafka-output.html" target="_blank" rel="noopener">Kafka</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.kafka:</span><br><span class="line">  hosts: [&quot;kafka1:9092&quot;, &quot;kafka2:9092&quot;, &quot;kafka3:9092&quot;]</span><br><span class="line">  topic: &apos;%&#123;[fields.log_topic]&#125;&apos;  # 读取inputs中设置的自定义字段fields.log_topic的值</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/redis-output.html" target="_blank" rel="noopener">Redis</a></p>
</li>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/file-output.html" target="_blank" rel="noopener">File</a></p>
</li>
<li><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/console-output.html" target="_blank" rel="noopener">Console</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.console:</span><br><span class="line">  pretty: true</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="负载均衡output主机"><a href="#负载均衡output主机" class="headerlink" title="负载均衡output主机"></a>负载均衡output主机</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;localhost:5044&quot;, &quot;localhost:5045&quot;]</span><br><span class="line">  loadbalance: true</span><br></pre></td></tr></table></figure>
<h2 id="elasticsearch模板"><a href="#elasticsearch模板" class="headerlink" title="elasticsearch模板"></a>elasticsearch模板</h2><p>filebeat可以在elasticsearch中创建索引，相关设置：<strong>setup.template.*</strong></p>
<p>开启方式：</p>
<ul>
<li>命令行方式：filebeat setup –template</li>
<li>配置文件方式：setup.template.enabled: true【默认true】</li>
</ul>
<p>其他模板设置选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 1  </span><br><span class="line">  index.number_of_replicas: 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据模板创建的默认索引名称(按天分隔)：”filebeat-%{[beat.version]}-*”</p>
</blockquote>
<h2 id="kibana仪表盘"><a href="#kibana仪表盘" class="headerlink" title="kibana仪表盘"></a>kibana仪表盘</h2><p>filebeat(beats系列)可以在kibana中创建dashboard，相关设置：<strong>setup.dashboards-*</strong>、<strong>setup.kibana</strong></p>
<p>开启方式：</p>
<ul>
<li>命令行方式：filebeat setup –dashboards</li>
<li>配置文件方式：setup.dashboards.enabled: false【默认false】</li>
</ul>
<p>其他模板设置选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup.dashboards.enabled: true              # filebeat启动，在kibana创建filebeat类的dashboard</span><br><span class="line">setup.kibana:                               # kibana连接地址</span><br><span class="line">  host: &quot;localhost:8601&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>filebeat在kibana中创建的dashboard默认引用的索引名称是：filebeat-*</p>
</blockquote>
<h2 id="filebeat日志"><a href="#filebeat日志" class="headerlink" title="filebeat日志"></a>filebeat日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.level: info</span><br><span class="line">logging.to_files: true</span><br><span class="line">logging.files:</span><br><span class="line">  path: /var/log/filebeat</span><br><span class="line">  name: filebeat</span><br><span class="line">  keepfiles: 7</span><br><span class="line">  permissions: 0644</span><br></pre></td></tr></table></figure>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>系统日志</li>
<li>nginx访问/错误日志</li>
<li>java、tomcat日志</li>
</ul>
<h2 id="配置范例"><a href="#配置范例" class="headerlink" title="配置范例"></a>配置范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/messages</span><br><span class="line">  fields:</span><br><span class="line">    type: syslog</span><br><span class="line">  fields_under_root: true</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/nginx/access.log*</span><br><span class="line">  fields:</span><br><span class="line">    type: nginx-access</span><br><span class="line">  fields_under_root: true</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/nginx/error.log*</span><br><span class="line">  fields:</span><br><span class="line">    type: nginx-error</span><br><span class="line">  fields_under_root: true</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/nginx/tomcat.log*</span><br><span class="line">  fields:</span><br><span class="line">    type: tomcat</span><br><span class="line">  fields_under_root: true</span><br><span class="line">  multiline.pattern: &apos;^[[:space:]]+(at|\.&#123;3&#125;)[[:space:]]+\b|^Caused by:&apos;</span><br><span class="line">  multiline.negate: false</span><br><span class="line">  multiline.match: after</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>filebeat</tag>
      </tags>
  </entry>
  <entry>
    <title>logstash学习</title>
    <url>/blog/2020/10/29/ELK/logstash%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a><a href="https://www.elastic.co/guide/en/logstash/6.8/configuration.html" target="_blank" rel="noopener">配置文件语法</a></h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区块标识 <code>{}</code></li>
<li>变量赋值 <code>nginx =&gt; 5</code></li>
<li>变量引用 <code>[nginx]</code><ul>
<li>双引号下引用变量 <code>&quot;%{nginx}&quot;</code></li>
<li>引用数组 <code>[arry][1]</code></li>
</ul>
</li>
</ul>
<h2 id="变量数据类型"><a href="#变量数据类型" class="headerlink" title="变量数据类型"></a>变量数据类型</h2><ul>
<li>数字</li>
<li>字符串</li>
<li>布尔值</li>
<li>数组【列表】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match =&gt; [&quot;datetime&quot;, &quot;UNIX&quot;, &quot;ISO8601&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希【字典】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options =&gt; &#123;</span><br><span class="line">  key1 =&gt; &quot;value1&quot;,</span><br><span class="line">  key2 =&gt; &quot;value2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if EXPRESSION &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else if EXPRESSION &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>==（等于）!=（不等于） &lt; &lt;=（小于，小于等于）&gt;&gt;=（大于，大于等于）</li>
<li>=~（匹配正则）!~（不匹配正则）</li>
<li>in（包含）not in（不包含）</li>
<li>and（与）or（或）nand（非与）xor（非或）</li>
<li>（）（复合表达式）!()（复合表达式取反）</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>logstash事件处理管道有三个阶段：inputs → filters → outputs。input和output都支持编解码器。常见的几种插件类型如下：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/logstash/6.8/input-plugins.html" target="_blank" rel="noopener">Input</a>：产生事件；使用input将数据获取到Logstash</li>
<li><a href="https://www.elastic.co/guide/en/logstash/6.8/filter-plugins.html" target="_blank" rel="noopener">Filter</a>：定义事件；如果事件符合特定条件，则可以将过滤器与条件语句结合使用以对事件执行操作。</li>
<li><a href="https://www.elastic.co/guide/en/logstash/6.8/output-plugins.html" target="_blank" rel="noopener">Output</a>：将事件传送到任何位置。output是Logstash管道的最后阶段。一个事件可以传递给多个output，只有完成所有output处理，该事件才执行完成。</li>
<li><a href="https://www.elastic.co/guide/en/logstash/6.8/codec-plugins.html" target="_blank" rel="noopener">Codec</a>：编解码器</li>
</ul>
<p>插件管理命令如下：</p>
<ul>
<li>bin/logstash-plugin install         # 安装</li>
<li>bin/logstash-plugin remove      # 删除</li>
<li>bin/logstash-plugin update      # 更新</li>
<li>bin/logstash-plugin list             # 列表显示</li>
</ul>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>input类插件包含一些通用配置项：add_field(增加的字段)、codec(编解码器)、tags(标签)、type(类型)</p>
<ul>
<li><p>stdin：标准输入，主要用于调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  stdin&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>file：读取文件，类似unix下的tail -0f命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file &#123;</span><br><span class="line">  path =&gt; &quot;/var/log/messages&quot;</span><br><span class="line">  type =&gt; &quot;syslog&quot;</span><br><span class="line">  tags =&gt; [&quot;syslog&quot;, &quot;test&quot;]</span><br><span class="line">  start_position =&gt; &quot;beginning&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>beats：处理由beats发送的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis：从redis中读取数据，redis一般作为filebeat的数据缓冲服务</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; <span class="string">"127.0.0.1"</span></span><br><span class="line">    port =&gt; <span class="string">"6379"</span></span><br><span class="line">    password =&gt; <span class="string">"123456"</span></span><br><span class="line">    key =&gt; <span class="string">"logstash"</span></span><br><span class="line">    data_type =&gt; <span class="string">"list"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter插件包含一些通用选项：add_field、add_tag、remove_field、remove_tag</p>
<ul>
<li><p>mutate：对事件字段执行常规转换。您可以重命名，删除，替换和修改事件中的字段。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO] 2020-09-26 12:07:15 [cn.itcast.dashboard.Main] - DAU|4903|提交订单|2020-09-26 01:01:14</span><br><span class="line">[INFO] 2020-09-26 12:07:16 [cn.itcast.dashboard.Main] - DAU|2589|查看订单|2020-09-26 12:05:03</span><br><span class="line">[INFO] 2020-09-26 12:07:17 [cn.itcast.dashboard.Main] - DAU|8259|使用优惠券|2020-09-26 09:05:13</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; &quot;message&quot; =&gt; &quot;|&quot; &#125; # 内容分割</span><br><span class="line">    add_field =&gt; &#123;                # 添加字段</span><br><span class="line">      &quot;userID&quot; =&gt; &quot;%&#123;message[1]&#125;&quot;</span><br><span class="line">      &quot;visit&quot; =&gt; &quot;%&#123;message[2]&#125;&quot;</span><br><span class="line">      &quot;date&quot; =&gt; &quot;%&#123;message[3]&#125;&quot;</span><br><span class="line">     &#125;</span><br><span class="line">    convert =&gt; &#123;                  # 转换数据类型</span><br><span class="line">      &quot;userID&quot; =&gt; &quot;integer&quot;</span><br><span class="line">      &quot;visit&quot; =&gt; &quot;string&quot;</span><br><span class="line">      &quot;date&quot; =&gt; &quot;string&quot;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>geoip：将ip地址解析为相应的经纬度、国家、城市等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">   source =&gt; &quot;message&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dissect：可以处理有明显分隔符的文本；不使用正则表达式解析，速度也更快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Dec 14 10:35:01 opserver12 CRON[25115]: (root) CMD (command -v debian-sa1 &gt; /dev/null &amp;&amp; debian-sa1 1 1)</span><br><span class="line">dissect &#123;</span><br><span class="line">    mapping =&gt; &#123;</span><br><span class="line">       &quot;message&quot; =&gt; &quot;%&#123;ts&#125; %&#123;+ts/2&#125; %&#123;+ts/1&#125; %&#123;src&#125; %&#123;prog&#125;[%&#123;pid&#125;]: %&#123;msg&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   convert_datatype =&gt; &#123;</span><br><span class="line">       pid =&gt; &quot;int&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* %&#123;key&#125;    表示字段</span><br><span class="line">* %&#123;+key/n&#125; n表示聚合字段附加的第几次内容【原始字段%&#123;key&#125;等同%&#123;+key/0&#125;】</span><br><span class="line">* convert_datatype：转换输出数据类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># http://www.baidu.com/test?he=123</span><br><span class="line">dissect &#123;</span><br><span class="line">    mapping =&gt; &#123;</span><br><span class="line">        &quot;message&quot; =&gt; &quot;http://%&#123;domain&#125;/%&#123;?url&#125;?%&#123;?arg1&#125;=%&#123;&amp;arg1&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* %&#123;?string&#125; 表示只是占位符，不会生产捕获字段最终的event【不会显示字段】</span><br><span class="line">* %&#123;?string&#125; %&#123;&amp;string&#125; 表示这是一个键值对</span><br></pre></td></tr></table></figure>
</li>
<li><p>date：处理日期文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  date &#123;</span><br><span class="line">   locale =&gt; &quot;en_US&quot; # 语言环境</span><br><span class="line">   match =&gt; [&quot;message&quot;, &quot;dd/MM/yyyy:HH:mm:ss&quot;, &quot;MMM  d HH:mm:ss&quot;, &quot;MMM dd HH:mm:ss&quot;, &quot;ISO8601&quot;] # 匹配文本</span><br><span class="line">   timezone =&gt; &quot;Asia/Shanghai&quot; # 文本表示的时区</span><br><span class="line">   target =&gt; &quot;logdate&quot; # 将文本赋值给字段</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>grok：通过正则表达式匹配任意文本</p>
</li>
</ul>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><ul>
<li><p>stdout：标准输出，主要用于调试</p>
</li>
<li><p>file：写入事件到文件</p>
</li>
<li><p>elasticsearch：将事件数据发送到Elasticsearch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">   hosts =&gt; [&quot;192.168.31.221:9200&quot;,&quot;192.168.31.222:9200&quot;,&quot;192.168.31.223:9200&quot;]</span><br><span class="line">   index =&gt; &quot;logstash-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  索引名称因为时区滞后8小时处理【新建日期字段】</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    ruby &#123;</span><br><span class="line">        code =&gt; &quot;event.set(&apos;index_date&apos;, event.get(&apos;@timestamp&apos;).time.localtime + 8*60*60)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        convert =&gt; [&quot;index_date&quot;, &quot;string&quot;]</span><br><span class="line">        gsub =&gt; [&quot;index_date&quot;, &quot;T([\S\s]*?)Z&quot;, &quot;&quot;]</span><br><span class="line">        gsub =&gt; [&quot;index_date&quot;, &quot;-&quot;, &quot;.&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">   hosts =&gt; [&quot;192.168.31.221:9200&quot;,&quot;192.168.31.222:9200&quot;,&quot;192.168.31.223:9200&quot;]</span><br><span class="line">   index =&gt; &quot;logstash-%&#123;type&#125;-%&#123;index_date&#125;&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><ul>
<li><p>json：编解码json格式数据</p>
</li>
<li><p>multiline：将多行文本事件（例如Java异常和stacktrace消息）合并到单个事件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">      codec =&gt; multiline &#123;</span><br><span class="line">        pattern =&gt; &quot;^\s&quot; # 以空白开始的行合并到上边非空白开始的行</span><br><span class="line">        what =&gt; &quot;previous&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="grok插件"><a href="#grok插件" class="headerlink" title="grok插件"></a>grok插件</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>可以使用正则表达式匹配任意文本，根据正则表达式位置的不同可以分为：</p>
<ul>
<li><p>实时解析模式：在match中定义正则表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?&lt;field_name&gt;the pattern here)</span><br></pre></td></tr></table></figure>
</li>
<li><p>预编译模式：单独定义模式后，在match中引用模式名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;PATTERN_NAME:field_name:data_type&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>预编译模式可以直接使用内置的模式，也可以自定义模式：</p>
<ul>
<li>内置模式：约有120种，通过<a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">logstash-patterns-core</a>插件实现</li>
<li>自定义模式：可以在任意目录的任意文件里定义，只需通过patterns_dir参数加载目录即可使用</li>
</ul>
<h2 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h2><p>预编译模式使用步骤：【在线调试工具：<a href="http://grokdebug.herokuapp.com/" target="_blank" rel="noopener">http://grokdebug.herokuapp.com/</a> 】</p>
<ul>
<li><p>模式的定义：<code>PATTERN_NAME  pattern</code>（内置模式无需定义，可以直接使用；）</p>
<ul>
<li><p>正则表达式默认不匹配换行，如果需要，则在正则前加(?m)</p>
</li>
<li><p>语法范例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USERNAME [a-z0-9.-]+    定义模式USERNAME是由小写字母数字等组成</span><br><span class="line">NGINXLOG %&#123;COMBINEDAPACHELOG&#125; (%&#123;QS:proxyip&#125;|-) (%&#123;BASE16FLOAT:upstream_response_time&#125;|-) (%&#123;BASE16FLOAT:request_time&#125;)   使用内置的模式组合定义</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>模式的应用：%{PATTERN_NAME:field_name:data_type} </p>
<ul>
<li>PATTERN_NAME：引用的模式名称</li>
<li>field_name：模式匹配的文本输出到指定字段</li>
<li>data_type：定义输出字段数据类型</li>
</ul>
</li>
</ul>
<h2 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># patterns/custom</span><br><span class="line">CUSTOM_DATE [0-9]&#123;1,4&#125;\-[0-9]&#123;1,2&#125;\-[0-9]&#123;1,2&#125; [0-9]&#123;1,2&#125;\:[0-9]&#123;1,2&#125;\:[0-9]&#123;1,2&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    patterns_dir =&gt; &quot;./patterns&quot;</span><br><span class="line">    match =&gt; &#123; # 字典方式</span><br><span class="line">      &quot;message&quot; =&gt; [</span><br><span class="line">         &quot;%&#123;CUSTOM_DATE:date&#125;&quot;, # 如果是日期类型使用date字段存储数据</span><br><span class="line">         &quot;%&#123;WORD:any&#125;&quot;          # 如果是其他文字使用any字段存储</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   # match =&gt; [&quot;message&quot;, &quot;%&#123;CUSTOM_DATE:date&#125;&quot;, &quot;%&#123;WORD:any&#125;&quot;] 列表方式</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h1><ul>
<li>-f 指定配置文件路径</li>
<li>-e 指定配置字符串</li>
<li>-t 测试配置语法并退出</li>
<li>-r 自动加载配置更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/logstash -r -f grok.rb</span><br></pre></td></tr></table></figure>
<h1 id="实践范例-nginx日志"><a href="#实践范例-nginx日志" class="headerlink" title="实践范例-nginx日志"></a><a href="https://www.elastic.co/guide/en/logstash/6.8/config-examples.html" target="_blank" rel="noopener">实践范例-nginx日志</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NGINXLOG %&#123;IPORHOST:remote_addr&#125; - %&#123;USER:remote_user&#125; \[%&#123;HTTPDATE:time_local&#125;\] \&quot;%&#123;WORD:method&#125; %&#123;URIPATH:baseurl&#125;(?:\?%&#123;NOTSPACE:param&#125;|) HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:http_status&#125; %&#123;NUMBER:body_bytes_sent&#125; \&quot;%&#123;GREEDYDATA:http_referer&#125;\&quot; \&quot;%&#123;GREEDYDATA:http_user_agent&#125;\&quot; \&quot;(?&lt;http_x_forwarded_for&gt;.*?)\&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  ruby &#123;</span><br><span class="line">      code =&gt; &quot;event.set(&apos;index_date&apos;, event.get(&apos;@timestamp&apos;).time.localtime + 8*60*60)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">      convert =&gt; [&quot;index_date&quot;, &quot;string&quot;]</span><br><span class="line">      gsub =&gt; [&quot;index_date&quot;, &quot;T([\S\s]*?)Z&quot;, &quot;&quot;]</span><br><span class="line">      gsub =&gt; [&quot;index_date&quot;, &quot;-&quot;, &quot;.&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  if [type] == &quot;nginx-access&quot; &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      patterns_dir =&gt; &quot;/etc/logstash/conf.d/patterns&quot;</span><br><span class="line">      match =&gt; [&quot;message&quot;, &quot;%&#123;NGINXLOG&#125;&quot;]</span><br><span class="line">      remove_field =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">      source =&gt; &quot;remote_addr&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">   hosts =&gt; [&quot;192.168.31.221:9200&quot;,&quot;192.168.31.222:9200&quot;,&quot;192.168.31.223:9200&quot;]</span><br><span class="line">   index =&gt; &quot;logstash-%&#123;type&#125;-%&#123;index_date&#125;&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>kibana学习</title>
    <url>/blog/2020/10/30/ELK/kibana%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install filebeat -y</span><br></pre></td></tr></table></figure>
<p>配置选项</p>
<ul>
<li>server.port: 5601</li>
<li>server.host: “192.168.31.222”</li>
<li>elasticsearch.url: “<a href="http://192.168.31.221:9200&quot;" target="_blank" rel="noopener">http://192.168.31.221:9200&quot;</a></li>
<li>kibana.index: “.kibana”</li>
<li>i18n.locale: “zh-CN” #6.7版本以上支持直接汉化</li>
</ul>
<h1 id="页面功能"><a href="#页面功能" class="headerlink" title="页面功能"></a>页面功能</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Discovery         发现：索引数据搜索</span><br><span class="line">Visualize         可视化：根据索引数据创建可视化界面</span><br><span class="line">Dashboard         仪表盘：将多个可视化界面聚合为一个仪表盘</span><br><span class="line">Dev tools         开发工具：可用于调试es语法、logstash的grok语法</span><br><span class="line">Management        管理：索引管理</span><br></pre></td></tr></table></figure>
<h1 id="内置范例"><a href="#内置范例" class="headerlink" title="内置范例"></a>内置范例</h1><ul>
<li>安装nginx软件</li>
<li>使用filebeat的nginx modules抓取nginx日志并格式化</li>
<li>filebeat对接elasticsearch，并在elasticsearch中自动创建索引filebeat-*</li>
<li>使用filebeat的kibana设置，在kibana中创建dashboards（默认使用索引filebeat-*）</li>
<li>在kibana中搜索es索引<ul>
<li>在discovery中查看文本型nginx日志</li>
<li>在dashboard中查看图表型nginx访问记录</li>
</ul>
</li>
</ul>
<h1 id="自定义功能"><a href="#自定义功能" class="headerlink" title="自定义功能"></a>自定义功能</h1><ul>
<li><p>在Visualize中创建单个可视化图表并保存</p>
<ul>
<li>设置Y轴，一般为数据</li>
<li>设置X轴，一般是时间</li>
</ul>
</li>
<li><p>在dashboard最终创建仪表盘并保存</p>
<ul>
<li>在仪表盘中添加可视化图表并调整位置</li>
</ul>
</li>
</ul>
<h1 id="实践范例-nginx日志"><a href="#实践范例-nginx日志" class="headerlink" title="实践范例-nginx日志"></a>实践范例-nginx日志</h1><ul>
<li>可视化：<ul>
<li>PV统计（折线）</li>
<li>URI访问TOP 10（表格）</li>
<li>UV统计（折线）</li>
<li>用户地理位置分布（坐标地图）</li>
<li>IP访问TOP 10（表格）</li>
</ul>
</li>
<li>仪表盘：<ul>
<li>资源访问：PV统计、URI访问TOP 10</li>
<li>IP访问：UV统计、用户地理位置分布、IP访问TOP 10</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生技术简介</title>
    <url>/blog/2019/10/23/%E5%AE%B9%E5%99%A8%E5%8C%96/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><p>以”云”为基础的软件架构设计的思想，应用从设计到部署都在云上进行</p>
<h1 id="官方支持"><a href="#官方支持" class="headerlink" title="官方支持"></a>官方支持</h1><p>CNCF：<a href="https://www.cncf.io/" target="_blank" rel="noopener">云原生基金会</a></p>
<h1 id="云原生技术生态"><a href="#云原生技术生态" class="headerlink" title="云原生技术生态"></a><a href="https://landscape.cncf.io/" target="_blank" rel="noopener">云原生技术生态</a></h1><p><img src="https://landscape.cncf.io/images/landscape.png" alt></p>
<h1 id="云原生实现流程"><a href="#云原生实现流程" class="headerlink" title="云原生实现流程"></a>云原生实现流程</h1><blockquote>
<p>即CNCF路线图Trail map</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png" alt></p>
<h3 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h3><ul>
<li>一般使用docker作为容器</li>
<li>任何程序及其依赖都可以容器化</li>
<li>使用微服务切割程序、开发新的功能</li>
</ul>
<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><ul>
<li>设置持续集成和持续部署（CI/CD）以使源代码的变更能自动反映在容器化的构建、测试，部署到准生产环境甚至是生产环境</li>
<li>设置自动发布、回滚、测试</li>
</ul>
<h3 id="编排和程序定义"><a href="#编排和程序定义" class="headerlink" title="编排和程序定义"></a>编排和程序定义</h3><ul>
<li>kubernetes(成熟)是市场领先的编排解决方案</li>
<li>应当选用一个认证的kubernetes发行版、主机平台、或安装器：cncf.io/ck</li>
<li>Helm Charts(孵化中)可以实现定义、安装、升级大多数复杂的kubernetes应用</li>
</ul>
<h3 id="观察和分析"><a href="#观察和分析" class="headerlink" title="观察和分析"></a>观察和分析</h3><ul>
<li>选取合适的监控、日志、调用链追踪解决方案</li>
<li>考虑使用CNCF项目，Prometheus(成熟)作为监控、Fluentd(成熟)作为日志、jaeger(孵化中)作为调用链追踪的解决方案</li>
<li>对于调用链追踪，寻找open-tracing(孵化中)兼容的实现方式，比如jaeger</li>
</ul>
<h3 id="以下为可选内容"><a href="#以下为可选内容" class="headerlink" title="以下为可选内容"></a>以下为可选内容</h3><h3 id="服务代理-发现-网格"><a href="#服务代理-发现-网格" class="headerlink" title="服务代理/发现/网格"></a>服务代理/发现/网格</h3><ul>
<li>CoreDNS(成熟)是一个快速且富有弹性的工具，适用于服务发现</li>
<li>Envoy(成熟)和Linkerd(孵化中)都可以开启服务网格编排</li>
<li>它们也可以提供健康检查、路由和负载均衡功能</li>
</ul>
<h3 id="网络和策略"><a href="#网络和策略" class="headerlink" title="网络和策略"></a>网络和策略</h3><ul>
<li>为了开启更富弹性的网络，可以使用CNI(Container Network Interface 成熟)兼容的网络项目，比如Calico、Flannel、Weave Net  </li>
<li>Open Policy Agent(OPA 孵化中)是一个通用的策略引擎，可以用于授权、认证许可、数据过滤</li>
</ul>
<h3 id="分布式数据库和存储"><a href="#分布式数据库和存储" class="headerlink" title="分布式数据库和存储"></a>分布式数据库和存储</h3><ul>
<li>如果想要从单一数据库之外获取更多的弹性和可扩展性，vitess(孵化中)是通过分片大规模运行mysql的好选择</li>
<li>Rook(孵化中)是一个存储编排器，可将各种存储解决方案集成到kubernetes中</li>
<li>作为kubernetes的大脑，etcd(孵化中)提供了跨主机的集群级别可靠数据存储</li>
<li>TiKV(孵化中)使用Rust实现了一个高性能的分布式事务级别的KV存储</li>
</ul>
<h3 id="流和消息"><a href="#流和消息" class="headerlink" title="流和消息"></a>流和消息</h3><ul>
<li>如果需要比JSON-REST更高的性能，考虑使用gRPC或者NATS</li>
<li>gRPC(孵化中)是一个通用RPC框架</li>
<li>NATS(孵化中)是一个多模式消息系统，包含请求/响应、发布/订阅、负载均衡队列</li>
</ul>
<h3 id="容器仓库和运行环境"><a href="#容器仓库和运行环境" class="headerlink" title="容器仓库和运行环境"></a>容器仓库和运行环境</h3><ul>
<li>harbor(孵化中)是一个实现存储、鉴权、扫描内容的仓库</li>
<li>也可以使用其他容器运行环境</li>
<li>最常见的，containerd(成熟)和CRI-O(孵化中)都是符合OCI规范的</li>
</ul>
<h3 id="软件分发"><a href="#软件分发" class="headerlink" title="软件分发"></a>软件分发</h3><p>假如需要实现安全的软件分发，可以评估Notary(孵化中)，一个实现更新的框架</p>
<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><ul>
<li>不可变基础设施：即容器镜像；</li>
<li>应用编排理论：即容器设计模式，当前为kubernetes的内容</li>
</ul>
<h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><ul>
<li>cgroups：google早期的容器技术</li>
<li>docker：当前容器事实标准；docker是应用运行的最小单位，不依赖任何paas</li>
</ul>
<h2 id="容器编排技术"><a href="#容器编排技术" class="headerlink" title="容器编排技术"></a>容器编排技术</h2><ul>
<li>swarm，docker维护的项目，偏重生态；2017年，docker公司核心产品内置kubernetes服务，swarm项目停止维护</li>
<li>mesos：技术较强</li>
<li>kubernetes：兼顾生态和技术，在swarm停止维护后，从三者【swarm、mesos、k8s】竞争中胜出，是容器编排的事实标准</li>
</ul>
<h1 id="技术范畴"><a href="#技术范畴" class="headerlink" title="技术范畴"></a>技术范畴</h1><h2 id="应用定义和开发流程"><a href="#应用定义和开发流程" class="headerlink" title="应用定义和开发流程"></a>应用定义和开发流程</h2><ul>
<li>应用定义与镜像制作</li>
<li>CI/CD</li>
<li>消息和流</li>
<li>数据库</li>
</ul>
<h2 id="应用编排和管理"><a href="#应用编排和管理" class="headerlink" title="应用编排和管理"></a>应用编排和管理</h2><blockquote>
<p>kubernetes关注的部分</p>
</blockquote>
<ul>
<li>应用编排和调度</li>
<li>服务发现治理</li>
<li>远程调用</li>
<li>API网关</li>
<li>service mesh</li>
</ul>
<h2 id="监控和分析"><a href="#监控和分析" class="headerlink" title="监控和分析"></a>监控和分析</h2><ul>
<li>监控</li>
<li>日志收集</li>
<li>tracing</li>
<li>破坏性测试【即混沌工程】</li>
</ul>
<h2 id="底层技术：运行-存储-网络"><a href="#底层技术：运行-存储-网络" class="headerlink" title="底层技术：运行/存储/网络"></a>底层技术：运行/存储/网络</h2><ul>
<li>容器运行时</li>
<li>存储</li>
<li>网络</li>
</ul>
<h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><ul>
<li>流程自动化与配置管理</li>
<li>镜像仓库</li>
<li>安全技术</li>
<li>云端密码管理</li>
</ul>
<h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><ul>
<li>paas的特殊形态，是一种应用编写方式，包含faas和baas</li>
<li>典型特点就是按实际使用计费</li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>cncf</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch介绍</title>
    <url>/blog/2020/08/25/ELK/elasticsearch%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="数据分类和搜索"><a href="#数据分类和搜索" class="headerlink" title="数据分类和搜索"></a>数据分类和搜索</h2><ul>
<li>结构化数据：数据有固定格式和长度，在数据存储前定义表结构；通过对常用的字段建立索引进行搜索</li>
<li>非结构化数据：没有预定义的结构化特征(比如：文章、网页、邮件等)；需要对全文数据建立倒排索引进行搜索【全文搜索】</li>
</ul>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul>
<li><p>索引：对于关系型数据库，一般是针对字段名称建立索引，然后索引指向一条数据记录</p>
</li>
<li><p>倒排索引：是针对文档(字段)内容建立索引，然后索引指向文档(数据记录)，实现了term到doc list的映射</p>
</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>索引(index)：由分片构成的逻辑集合，也是文档在物理上的容器，相当于mysql的库；此处索引就是倒排索引，准确的说是一组倒排索引，即多个【term与doc list】的映射</li>
<li>映射(mapping)和类型(type)：<ul>
<li>映射：是将文档转变为索引的过程，类似于定义mysql的表结构，也是文档进行结构化存储的过程</li>
<li>类型：是不同的映射分类(相当于mysql中的不同表)，是文档的逻辑分类；<ul>
<li>v6.0之前：一个索引可以有多个类型</li>
<li>v6.0-v7.0：一个索引只能有一个类型</li>
<li>v7.0之后：删除类型定义，直接映射中定义数据类型【默认创建为_doc类型，文档操作也是在_doc类型/接口下完成】</li>
</ul>
</li>
</ul>
</li>
<li>分片(shard)：将索引的数据分解为大小合适的片段(分片)分散在不同节点进行存储；这样可以提升数据读写速度、扩充集群存储容量</li>
<li>副本(replicas)：主分片的完全复制品，它和主分片内容完全一样；保证了分片的高可用，同时也可以响应读请求</li>
<li>文档(doc)：一条记录，是es中数据存储和检索的基本单位；相当于mysql的一行记录；以json格式存储，由元数据(metadata)和数据(_source)组成；元数据包括：<ul>
<li>_index：文档所在索引</li>
<li>_type：文档类型，每个类型都有自己的映射(mapping)</li>
<li>_id：文档id</li>
<li>_version：文档版本</li>
</ul>
</li>
<li>字段(field)：一个文档的数据(_source)由若干个字段组成，每个字段可以有不同的数据类型<ul>
<li>基本类型：比如字符串、数值、日期、布尔、字节、范围</li>
<li>扩展类型：数组(列表)、对象(字典)</li>
<li>多数据类型：让一个字段同时具备多种数据类型特征</li>
</ul>
</li>
<li>项(term)：索引的最小单位<ul>
<li>某个field对应的内容如果是text类型，会将内容进行分词为若干term</li>
<li>如果是不分词的字段(如keyword类型)，那么该字段的内容就是一个term</li>
</ul>
</li>
</ul>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/modules-node.html" target="_blank" rel="noopener">节点</a></h2><ul>
<li>master节点：控制集群状态；node.master设置为true，节点具有成为master的资格【默认true】</li>
<li>data节点：执行数据CRUD、搜索、聚合操作的节点；设置参数：node.data【默认true】</li>
<li>ingest节点：在数据创建索引前对数据进行处理，代替部分logstash功能；设置参数：node.ingest【默认true】</li>
<li>协调节点：接收客户端搜索、批量索引等请求，将请求转发到相应的数据节点执行；最后，将来自数据节点的执行结果合并后返回给客户端<ul>
<li>每个节点都是一个隐含的协调节点，都可以接受客户端请求</li>
<li>node.master、node.data、node.ingest都设置为false时，节点是一个专用协调节点</li>
</ul>
</li>
<li>部落节点：特殊类型的协调节点，可以连接不同集群，执行跨集群搜索；tribe.*</li>
</ul>
<h2 id="分片-shard"><a href="#分片-shard" class="headerlink" title="分片(shard)"></a>分片(shard)</h2><p>分片(shard)：将索引的数据分解为大小合适的片段(分片)分散在不同节点进行存储</p>
<ul>
<li>分片可以提升数据读写速度、扩充集群存储容量</li>
<li>每一个分片都是一个Lucene实例，都是一个完整的搜索引擎，应用程序不会和它直接通信。</li>
<li>每个文档都属于一个单独的主分片</li>
<li>索引建立后分片数不可调整，主分片的数量决定了索引能够存储多少数据</li>
</ul>
<h2 id="副本-replicas"><a href="#副本-replicas" class="headerlink" title="副本(replicas)"></a>副本(replicas)</h2><p>副本：主分片的完全复制品，它和主分片内容完全一样</p>
<ul>
<li>保证了分片的高可用</li>
<li>也可以响应读请求，多个分片以轮询的方式响应请求</li>
<li>索引建立后，副本数可以调整【应用程序刚接入集群时，可以先关闭副本功能，减轻集群负载压力】</li>
</ul>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>读写操作时，确定文档所在主分片的位置</p>
<p>shard=hash(routing) % number_of_primary_shards</p>
<ul>
<li>routing是一个随机字符串，默认为文档_id，可以自定义</li>
<li>这个routing字符串通过hash函数生成一个数字，然后除以主分片数得到一个余数，余数的范围永远是0到number_of_primary_shards - 1,这个数字就是特定文档所在的分片【这也决定了主分片数一旦确定就不能修改：增加主分片会造成无法定位之前的文档位置】</li>
</ul>
<h1 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a><a href="https://www.cnblogs.com/huangying2124/p/12230177.html" target="_blank" rel="noopener">存储原理</a></h1><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>es存储文档也就是建立倒排索引，流程如下：</p>
<ul>
<li>将文档中的关键字(term)提取出来，即文档分析(analysis)</li>
<li>将关键字与文档的对应关系保存起来</li>
<li>对关键字本身做索引排序</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>倒排索引包含以下几个部分</p>
<ul>
<li>某个关键词的doc list</li>
<li>某个关键词在所有doc的数量：IDF（inverse document frequency）</li>
<li>某个关键词在每个doc中出现的次数：TF（term frequency）</li>
<li>某个关键词在这个doc中的次序</li>
<li>某个doc的长度</li>
<li>某个关键词在所有doc的平均长度</li>
</ul>
<p>记录这些信息，就是为了方便搜索和_score分值计算</p>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>倒排索引写入磁盘后就是不可变的，这样由几个好处：</p>
<ul>
<li>索引不需要更新，可以不需要锁，可以支持高并发</li>
<li>如果cache内存足够，索引不更新，索引可以一直保存在os cache中，可以提高IO性能</li>
<li>如果数据不变，filter cache会一直驻留在内存中</li>
<li>索引数据可以压缩，从而可以节省cpu、内存、磁盘等资源</li>
</ul>
<h2 id="文档底层原理"><a href="#文档底层原理" class="headerlink" title="文档底层原理"></a>文档底层原理</h2><h3 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h3><ul>
<li><p>新文档先写入索引的内存buffer中；为了安全，也一起写到translog</p>
</li>
<li><p>内存buffer的数据每隔一段时间(默认1s)写入index segment中(即编入索引)，并写入os cache中【此时文档就可以搜索】</p>
<ul>
<li><p>index segment数据写入os cache中，并打开搜索的过程叫refresh，默认1s一次</p>
</li>
<li><p>如果希望该文档能立刻被搜索，可以手动调用refresh操作</p>
</li>
<li><p>日志量较大，但实时性要求不高的系统，可以增大refresh参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;refresh_interval&quot;: &quot;30s&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>等待操作系统将os cache中的数据刷新到磁盘中</p>
</li>
<li><p>数据刷新到磁盘后，buffer数据被清空，同时打开一个新的index segment</p>
</li>
</ul>
<h3 id="文档修改和删除"><a href="#文档修改和删除" class="headerlink" title="文档修改和删除"></a>文档修改和删除</h3><p>被修改和删除的文档，会被标记为deleted，信息记录在.del文件中</p>
<p>修改文档时会创建新文档【segment是不可变内容】</p>
<p>被标记为deleted的文档不会被物理删除，也会被搜索到，但是在最终结果处理时会被过滤掉</p>
<p>执行segment合并时，被标记为deleted的文档会被物理删除掉</p>
<h3 id="translog"><a href="#translog" class="headerlink" title="translog"></a>translog</h3><p>translog是一种日志预写机制，在对数据操作的同时，也将对数据的增删改操作记录在日志文件中，防止数据在持久化之前丢失；translog的相关设置如下：</p>
<ul>
<li><p>translog写磁盘方式(参数：index.translog.durability)：定义了在每次index、delete、update、bulk操作后是否提交并刷新translog到磁盘；包含：同步(request)、异步(async)</p>
<ul>
<li><p>request(默认)：每次请求，都提交并刷新translog到磁盘；主分片和副本分片都会触发，保障了数据安全性，但是有性能损失；设置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">     &quot;index.translog.durability&quot;: &quot;request&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>async：不管写操作如何，仅在_index.translog.sync_interval_时间间隔后将translog刷新到磁盘【默认5s，不能小于100ms】；设置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">     &quot;index.translog.durability&quot;: &quot;async&quot;,</span><br><span class="line">     &quot;index.translog.sync_interval&quot;: &quot;5s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定义flush操作：flush会将内存中的数据(segment和translog)都刷新到磁盘中；产生新的translog，旧的translog被归档</p>
<ul>
<li><p>参数定义：index.translog.flush_threshold_size：translog大小达到多少时，执行flush操作</p>
</li>
<li><p>手动执行flush操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST twitter/_flush</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>translog文件设置</p>
<ul>
<li>index.translog.retention.size：保留的translog文件总大小，默认512mb；保留更多的translog，可以使用本地translog进行故障恢复，而非基于文件同步进行</li>
<li>index.translog.retention.age：translog最长保留时间，默认12h</li>
</ul>
</li>
</ul>
<h3 id="segment合并"><a href="#segment合并" class="headerlink" title="segment合并"></a>segment合并</h3><p>当索引数据不断增长时，对应的segment也会不断的增多(默认，每秒执行一次refresh，产生一个新的segment文件)，查询性能也会下降。因此，Elasticsearch会触发segment合并的线程，把很多小的segment合并成更大的segment，然后删除小的segment。   </p>
<p>标记为deleted的文档在合并时会被丢弃（delete请求只是将文档标记为deleted状态，真正的物理删除是在段合并的过程中）</p>
<p>手动执行segment合并：【参数：max_num_segments：最终合并为几个segment】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /twitter/_forcemerge</span><br><span class="line">&#123;</span><br><span class="line">  &quot;max_num_segments&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分布式原理"><a href="#分布式原理" class="headerlink" title="分布式原理"></a>分布式原理</h1><h2 id="文档写操作"><a href="#文档写操作" class="headerlink" title="文档写操作"></a>文档写操作</h2><blockquote>
<p>新建、索引、删除文档</p>
</blockquote>
<ul>
<li>客户端发送请求到任意节点(协调节点)，该节点根据文档id确定文档的主分片位置，并将请求转发到主分片所在的节点</li>
<li>在主分片执行写操作完成后，将相关操作复制到所有副本分片上</li>
<li>副本分片执行完成后向主分片报告成功状态，主分片再向协调节点报告成功状态，最后协调节点向客户端报告成功状态</li>
</ul>
<h2 id="文档读操作"><a href="#文档读操作" class="headerlink" title="文档读操作"></a>文档读操作</h2><blockquote>
<p>搜索(单个文档)、查询文档</p>
</blockquote>
<p>读操作和写操作流程类似，但是为了负载均衡读请求，协调节点会将读请求以循环的方式发送给所有的副本分片(包含主分片)</p>
<p>可能的情况是，文档已存在主分片上，但还未同步到副本分片上，(假如请求转发到此分片上)副本分片会向协调节点报告文档未找到，由主分片返回文档信息。</p>
<h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><ul>
<li>分散(scatter阶段)<ul>
<li>客户端发送搜索请求到协调节点，协调节点创建一个from+size的空队列</li>
<li>协调节点将搜索请求转发到所有的分片(主分片、副本分片)</li>
<li>每个分片在本地执行查询并将结果放到from+size的本地队列中</li>
<li>每个分片返回文档id和文档在队列中的排序值给协调节点，协调节点将这些值合并产生全局排序结果</li>
</ul>
</li>
<li>收集(gather阶段)<ul>
<li>协调节点根据排序结果中的文档id向相关分片发出get请求取回相关文档</li>
<li>当协调节点取回所有文档后向客户端返回结果</li>
</ul>
</li>
</ul>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><ul>
<li>elasticsearch支持全文搜索，但全文数据在存储前会做分析并提取词项，但文档中的数据并不是都需要如此：比如文档创建时间、文章标题、作者等，这些本来就是结构化数据，不需要进行分析</li>
<li>通过预定义字段可以增加数据搜索的维度，提升搜索质量</li>
<li>通过预定义字段的数据类型也可以优化存储结构</li>
</ul>
<h2 id="es自动判断数据类型"><a href="#es自动判断数据类型" class="headerlink" title="es自动判断数据类型"></a>es自动判断数据类型</h2><table>
<thead>
<tr>
<th>json type</th>
<th>field type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean: true or false</td>
<td>boolean</td>
</tr>
<tr>
<td>number: 123</td>
<td>long</td>
</tr>
<tr>
<td>float: 123.45</td>
<td>double</td>
</tr>
<tr>
<td>date: “2014-09-15”</td>
<td>date</td>
</tr>
<tr>
<td>string: “foo bar”</td>
<td>string</td>
</tr>
</tbody>
</table>
<h2 id="es数据类型"><a href="#es数据类型" class="headerlink" title="es数据类型"></a>es数据类型</h2><table>
<thead>
<tr>
<th>主类型</th>
<th>子类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>text、keyword</td>
</tr>
<tr>
<td>number</td>
<td>byte、shot、integer、long</td>
</tr>
<tr>
<td>float</td>
<td>float、double</td>
</tr>
<tr>
<td>boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>date</td>
<td>date</td>
</tr>
</tbody>
</table>
<ul>
<li><p>text：该字段要被全文搜索，可以被分词</p>
</li>
<li><p>keyword：不能被分词，比如email地址、主机名、状态码和标签；字段可以用于过滤、排序、聚合等操作；keyword字段只能通过精确值搜索到</p>
</li>
</ul>
<h2 id="mappings操作"><a href="#mappings操作" class="headerlink" title="mappings操作"></a>mappings操作</h2><ul>
<li><p>创建包含mappings的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /索引</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;number_of_shards&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;number_of_replicas&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;person&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;age&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;mail&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;hobby&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询索引mappings信息：/索引/_mappings</p>
</li>
</ul>
<h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><p>分词：将文本转化为一系列单词的过程，也叫文本分析，在elasticsearch中称作Analysis</p>
<p>例如：我是中国人=》我、是、中国人</p>
<p>分词api：/_analyze【仅用于文本分析测试；text文本存储时会调用分词器(默认standard，可自定义)进行分词】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中文分词器IK"><a href="#中文分词器IK" class="headerlink" title="中文分词器IK"></a>中文分词器IK</h2><p>项目地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>安装：【插件需要在集群的每个节点都安装，安装后重启elasticsearch】</p>
<p>方式1：下载预编译安装包<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<ul>
<li>创建插件目录：cd your-es-root/plugins/ &amp;&amp; mkdir ik</li>
<li>解压插件到目录your-es-root/plugins/ik</li>
</ul>
<p>方式2：使用es插件命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/elasticsearch-analysis-ik-6.5.4.zip</span><br></pre></td></tr></table></figure>
<h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h2><p>例如：创建映射的text类型字段时，自定义分词器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;number_of_shards&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;number_of_replicas&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;person&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;age&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;mail&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;hobby&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                    &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pipeline-ingest-node"><a href="#pipeline-ingest-node" class="headerlink" title="pipeline/ingest node"></a><a href="https://hacpai.com/article/1512990272091" target="_blank" rel="noopener">pipeline/ingest node</a></h1><p>预处理：对原始数据进行加工后再存入es集群中，比如使用logstash的grok进行数据处理</p>
<p>ingest node：可以对数据进行预处理的节点，默认所有节点都是ingest node</p>
<p>pipeline：在ingest node中定义的数据处理管道，对经过此管道的数据进行预处理</p>
<p>Processors：对数据加工操作的抽象包装，例如：转换数据类型的Processors：convert</p>
<h2 id="创建pipeline"><a href="#创建pipeline" class="headerlink" title="创建pipeline"></a>创建pipeline</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /_ingest/pipeline/my-pipeline-id </span><br><span class="line">&#123;</span><br><span class="line">    &quot;description&quot;:&quot;describe pipeline&quot;,</span><br><span class="line">    &quot;processors&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;convert&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查看pipeline结构"><a href="#查看pipeline结构" class="headerlink" title="查看pipeline结构"></a>查看pipeline结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_ingest/pipeline/my-pipeline-id</span><br></pre></td></tr></table></figure>
<h2 id="使用pipeline处理数据"><a href="#使用pipeline处理数据" class="headerlink" title="使用pipeline处理数据"></a>使用pipeline处理数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /haoke/user?pipeline=my-pipeline-id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;hejingqi&quot;,</span><br><span class="line">    &quot;age&quot;: 32,</span><br><span class="line">    &quot;sex&quot;: &quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索插入结果"><a href="#搜索插入结果" class="headerlink" title="搜索插入结果"></a>搜索插入结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /haoke/user/_search?q=hejingqi</span><br></pre></td></tr></table></figure>
<h1 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h1><ul>
<li><p>创建索引：settings中设置分片数、副本数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT  /索引</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;number_of_shards&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;number_of_replicas&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  /索引</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="索引-增加"><a href="#索引-增加" class="headerlink" title="索引/增加"></a>索引/增加</h2><ul>
<li>指定id</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT 索引/类型/id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot; : &quot;kimchy&quot;,</span><br><span class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</span><br><span class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动产生id</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  索引/类型</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">    &quot;age&quot;: 20,</span><br><span class="line">    &quot;sex&quot;: &quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li><p>全量更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  索引/类型/id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">    &quot;age&quot;: 25,</span><br><span class="line">    &quot;sex&quot;: &quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部更新：请求体是doc封装的key/value信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  索引/类型/id/_update</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;李四&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  索引/类型/id</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET  索引/类型/id</span><br></pre></td></tr></table></figure>
<ul>
<li>数据格式化：GET  索引/类型/id?pretty</li>
<li>返回指定字段：GET  索引/类型/id?_source=字段1,字段2。。。</li>
<li>返回源数据：GET  索引/类型/id/_source</li>
</ul>
<h3 id="存在性判断"><a href="#存在性判断" class="headerlink" title="存在性判断"></a>存在性判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD   索引/类型/id</span><br></pre></td></tr></table></figure>
<p>根据http返回码<em>200/404</em>判断文档是否存在</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><ul>
<li><p>批量查询：mget</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET  索引/类型/_mget</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ids&quot;: [&quot;y6zSIHQB2fO-rT1snG4Q&quot;, &quot;yqw2G3QB2fO-rT1sk26f&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量索引、插入、修改、删除：bulk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  索引/类型/_bulk接口</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;itcast&quot;,&quot;_type&quot;:&quot;person&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;mail&quot;:&quot;111@qq.com&quot;,&quot;hobby&quot;:&quot;羽毛球、篮球、足球&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;:&quot;haoke&quot;,&quot;_type&quot;:&quot;user&quot;,&quot;_id&quot;:2001&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;小一&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;haoke&quot;,&quot;_type&quot;:&quot;user&quot;,&quot;_id&quot;:2001&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;:&quot;小五&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;haoke&quot;,&quot;_type&quot;:&quot;user&quot;,&quot;_id&quot;:2001&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>_bulk接口支持的操作：create、update、delete、index</li>
<li>每两行为一组，第一行定义要操作的文档，第二行定义文档数据【delete时没有第二行】</li>
<li>每行末尾都需要有换行符\n【包含最后一行】</li>
<li>index操作时，不需要添加id；没有文档时为create操作、有文档时为update操作。</li>
</ul>
<ul>
<li><p>delete_by_query接口条件删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST logstash-nginx-access-2020.10.29/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;ids&quot;: &#123;</span><br><span class="line">            &quot;values&quot;: [</span><br><span class="line">              &quot;BbyIc3UByBVJ-pL9-P6X&quot;,</span><br><span class="line">              &quot;BryIc3UByBVJ-pL9-P6X&quot;,</span><br><span class="line">              &quot;B7yIc3UByBVJ-pL9-P6X&quot;,</span><br><span class="line">              &quot;BLyIc3UByBVJ-pL9-P6X&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h1><p>基于_search接口的查询，根据参数位置的不同可以分为：</p>
<ul>
<li>基于URI的搜索(GET)：/_search?q=字符串查询语法</li>
<li>基于请求体的搜索(POST)</li>
</ul>
<p>_search接口直接返回最多10条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://49.232.17.71:8200/haoke/user/_search</span><br></pre></td></tr></table></figure>
<h2 id="基于URI"><a href="#基于URI" class="headerlink" title="基于URI"></a>基于URI</h2><ul>
<li><p>全文(全字段)搜索：直接写搜索的单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=alex</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段搜索：在搜索单词之前加上字段名和冒号，比如如果知道单词first 肯定出现在 mesg 字段，可以写作  mesg:first</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=age:25</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段–多条件组合：可以使用  NOT  ,  AND  和  OR  来组合检索，注意必须是大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=(name:alex)%20AND%20(age:28)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段–是否存在：<code>_exists_:user</code>  表示要求 user 字段存在， <code>_missing_:user</code>  表示要求 user 字段不存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=_exists_:name</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>字段-<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl-query-string-query.html#_ranges" target="_blank" rel="noopener">范围搜索</a>：对日期、数字、字符串都可以使用范围搜索。【[]包含边界 {}不包含边界】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=age:%20[22%20TO%2025]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>全文-通配符：用  ?  表示单字符， *  表示0或多个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=alex?</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>全文-模糊搜索：用  ~  表示搜索单词可能有一两个字母写的不对，比如  frist~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/_search?q=alex~</span><br></pre></td></tr></table></figure>
</li>
<li><p>全文-<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax" target="_blank" rel="noopener">正则表达式</a></p>
</li>
</ul>
<h2 id="基于请求体-词项"><a href="#基于请求体-词项" class="headerlink" title="基于请求体-词项"></a>基于请求体-词项</h2><blockquote>
<p>此处为基于词项的查询，只对一个字段设置查询条件</p>
</blockquote>
<ul>
<li><p>term：单个值匹配：数字、日期、布尔值、以及not_analyzed的字符串(未经分析的text类型)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: 23</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>terms：多个值匹配(数组)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: [23, 20, 28]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>range：范围查询【操作符：lt/小于、lte/小于等于、gt/大于、gte/大于等于】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: &#123;</span><br><span class="line">                &quot;gte&quot;: 23,</span><br><span class="line">                &quot;lt&quot;: 30 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>exists：是否包含某字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;exists&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;age&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于id查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;ids&quot;: &#123;</span><br><span class="line">            &quot;values&quot;: [&quot;FONNOHQBDlTN8HRyeJoX&quot;, &quot;F-NNOHQBDlTN8HRyeJoY&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式匹配</p>
<ul>
<li>prefix：前缀模糊匹配</li>
<li>wildcard：通配符匹配</li>
<li>regexp：正则匹配</li>
</ul>
</li>
</ul>
<h1 id="全文搜索-1"><a href="#全文搜索-1" class="headerlink" title="全文搜索"></a>全文搜索</h1><p>全文搜索vs词项搜索：全文搜索会对查询条件做分析；使用的分析器可以在创建索引时设置analyzer参数或search_analyzer参数，也可以在搜索时，在搜索接口_search设置analyzer参数</p>
<p>全文搜索两个重要方面：</p>
<ul>
<li>相关性(Relvance)：评价查询和其结果间相关性程度，并根据这种相关性排序；这种计算方式可以是TF/IDF方法、地理位置临近、模糊相似等算法</li>
<li>分词(Analysis)：将文本转换为有区别的、规范化的token的过程</li>
</ul>
<h2 id="词项匹配-match单值"><a href="#词项匹配-match单值" class="headerlink" title="词项匹配-match单值"></a>词项匹配-match单值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &quot;音乐&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的过程如下：</p>
<ul>
<li>检查字段类型：hobby是一个text类型（指定IK分词器），这意味着查询字符串本身也应该被分词</li>
<li>分析查询字符串：将查询字符串“音乐”传入IK分词器中，输出单个项(term)：音乐，因为只有一个单词项，所以match查询执行的是单个term查询</li>
<li>查询匹配文档：用term查询在倒排索引中查找包含“音乐”的一组文档</li>
<li><p>为每个文档评分并排序：用term查询计算每个文档的相关度评分_score，这个将词频(term frequency)【即“音乐”在相关文档hobby字段中出现的频率】、反向文档频率(inverse document frequency)【即“音乐”在所有文档的hobby字段出现的频率】、字段长度【即字段越短相关度越高】相结合的计算方式</p>
<p>查询结果如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 20,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 2,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;max_score&quot;: 0.7438652,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;itcast&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;person&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;F-NNOHQBDlTN8HRyeJoY&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.7438652,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;赵六&quot;,</span><br><span class="line">                    &quot;age&quot;: 23,</span><br><span class="line">                    &quot;mail&quot;: &quot;444@qq.com&quot;,</span><br><span class="line">                    &quot;hobby&quot;: &quot;听音乐、看电影&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;highlight&quot;: &#123;</span><br><span class="line">                    &quot;hobby&quot;: [</span><br><span class="line">                        &quot;听&lt;em&gt;音乐&lt;/em&gt;、看电影&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="词项匹配-match多值"><a href="#词项匹配-match多值" class="headerlink" title="词项匹配-match多值"></a>词项匹配-match多值</h2><ul>
<li><p>默认：空格分隔的多个词为“逻辑或”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &quot;羽毛球 篮球&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置多个词为“逻辑与“关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;</span><br><span class="line">                &quot;query&quot;: &quot;羽毛球 篮球&quot;,</span><br><span class="line">                &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置相似度百分比minimum_should_match，避免多个词使用极端的and或or方式搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;</span><br><span class="line">                &quot;minimum_should_match&quot;: &quot;70%&quot;,</span><br><span class="line">                &quot;query&quot;: &quot;足球 篮球&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>minimum_should_match：相似度越高，包含的文档越少</p>
<blockquote>
<p>相似度设置，需要不断测试，以达到预期结果</p>
</blockquote>
<ul>
<li>100%相当于and</li>
<li>50%相当于or</li>
</ul>
</li>
</ul>
<h2 id="多字段-全文搜索"><a href="#多字段-全文搜索" class="headerlink" title="多字段/全文搜索"></a>多字段/全文搜索</h2><ul>
<li><p>multi_match：同时匹配多个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;multi_match&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;音乐&quot;,</span><br><span class="line">            &quot;fields&quot;: [&quot;name&quot;, &quot;hobby&quot;] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>query_string：和URI中/_search?q=语法类似，定义字段时在默认字段搜索，不定义字段时进行全文搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;query_string&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;音乐&quot;,</span><br><span class="line">            &quot;default_field&quot;:  &quot;hobby&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>simple_query_string：对query_string的查询进行简化，包括：忽略查询时的异常、引入更便捷的简化操作符</p>
</li>
</ul>
<h2 id="多条件搜索-bool-match"><a href="#多条件搜索-bool-match" class="headerlink" title="多条件搜索-bool/match"></a>多条件搜索-bool/match</h2><p>组合多个查询条件，可用的布尔子类型如下：</p>
<ul>
<li><p>must：查询结果必须要包含内容，相当于and；结果会根据<strong>相关性排序</strong></p>
</li>
<li><p>filter：查询结果必须要包含内容；但不影响结果排序</p>
</li>
<li><p>must_not：查询结果不能包含内容，相当于not；不影响结果排序</p>
</li>
<li><p>should</p>
<ul>
<li><p>单独使用时，多个查询条件至少有一个匹配【参数minimum_should_match调节，设置相关性】；结果会根据<strong>相关性排序</strong>【minimum_should_match为2表示，should中的多个词至少要满足2个】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;match&quot;: &#123;</span><br><span class="line">                        &quot;hobby&quot;: &quot;乒乓球&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;match&quot;: &#123;</span><br><span class="line">                        &quot;hobby&quot;: &quot;篮球&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;minimum_should_match&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和filter、must共同使用时，不影响查询结果，但影响结果<strong>相关性排序</strong>【包含should条件的排序更高】</p>
<p>minimum_should_match调节排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;sex&quot;: &quot;男&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;should&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;name&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;小&quot;,</span><br><span class="line">                        &quot;minimum_should_match&quot;: &quot;50%&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;sex&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权重调节排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;hobby&quot;: &quot;足球&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;hobby&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;乒乓球&quot;,</span><br><span class="line">                        &quot;boost&quot;: 10</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;hobby&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;篮球&quot;,</span><br><span class="line">                        &quot;boost&quot;: 2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h1><blockquote>
<p>类似sql查询中的group by</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;age_avg&quot;: &#123;</span><br><span class="line">            &quot;avg&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;age&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>aggs：指定聚合查询</li>
<li>age_avg：聚合名称</li>
<li>avg：聚合类型</li>
</ul>
<h1 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h1><ul>
<li><p>分页：from：跳过前m个结果，size：返回n条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;from&quot;: m,</span><br><span class="line">    &quot;size&quot;: n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>高亮显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">        &quot;hobby&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="信息查看-cat"><a href="#信息查看-cat" class="headerlink" title="信息查看-cat"></a>信息查看-cat</h1><ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/cat.html#common-parameters" target="_blank" rel="noopener">通用参数</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v                                     查看详情</span><br><span class="line">help                                  帮助信息</span><br><span class="line">h=column1,column2                     过滤特定表头header</span><br><span class="line">bytes=b                               数字类型格式化【bytes、size、time】</span><br><span class="line">format=json                           文本格式化【text、json、yaml】</span><br><span class="line">s=column1,column2:desc,column3        排序</span><br></pre></td></tr></table></figure>
<ul>
<li>常见用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 健康信息</span><br><span class="line">/_cat/health?v            </span><br><span class="line">* green：所有主分片和副本分片都可用</span><br><span class="line">* yellow：主分片都可用，副本分片部分可用</span><br><span class="line">* red：主分片部分可用</span><br><span class="line"></span><br><span class="line"># 索引信息</span><br><span class="line">/_cat/indices?v</span><br><span class="line"></span><br><span class="line"># 节点信息</span><br><span class="line">/_cat/nodes?v</span><br></pre></td></tr></table></figure>
<h1 id="过滤VS查询"><a href="#过滤VS查询" class="headerlink" title="过滤VS查询"></a>过滤VS查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;age&quot;: 23</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;hobby&quot;: &quot;足球&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>filter只过滤结果，结果不会排序，但会缓存【利用缓存特性，可以用于精确匹配的搜索，如term查询】</li>
<li>query查询结果会根据相关性排序(更耗时)，但不会缓存</li>
</ul>
<h1 id="客户端-python"><a href="#客户端-python" class="headerlink" title="客户端-python"></a>客户端-python</h1><blockquote>
<p>python客户端<a href="https://elasticsearch-py.readthedocs.org/" target="_blank" rel="noopener">elasticsearch-py</a>为低级客户端，只封装核心操作对象，需要自己构造json格式的DSL进行CRUD、搜索等操作</p>
</blockquote>
<ul>
<li><p>安装：pip install elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Elasticsearch 7.x</span><br><span class="line">elasticsearch&gt;=7.0.0,&lt;8.0.0</span><br><span class="line"></span><br><span class="line"># Elasticsearch 6.x</span><br><span class="line">elasticsearch&gt;=6.0.0,&lt;7.0.0</span><br><span class="line"></span><br><span class="line"># Elasticsearch 5.x</span><br><span class="line">elasticsearch&gt;=5.0.0,&lt;6.0.0</span><br><span class="line"></span><br><span class="line"># Elasticsearch 2.x</span><br><span class="line">elasticsearch&gt;=2.0.0,&lt;3.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from elasticsearch import Elasticsearch</span><br><span class="line"></span><br><span class="line">node_list = [</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.221&quot;, &quot;port&quot;: 9200&#125;,</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.222&quot;, &quot;port&quot;: 9200&#125;,</span><br><span class="line">    &#123;&quot;host&quot;: &quot;192.168.31.223&quot;, &quot;port&quot;: 9200&#125;</span><br><span class="line">]</span><br><span class="line">es = Elasticsearch(hosts=node_list)</span><br><span class="line">doc = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;赵七&quot;,</span><br><span class="line">    &quot;age&quot;: 33,</span><br><span class="line">    &quot;mail&quot;: &quot;424@qq.com&quot;,</span><br><span class="line">    &quot;hobby&quot;: &quot;听音乐、看电影、跑步&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 索引文档</span><br><span class="line"># res = es.index(&apos;haoke&apos;,doc_type=&apos;person&apos;, body=doc)</span><br><span class="line"># print(res[&apos;result&apos;])</span><br><span class="line"></span><br><span class="line"># 根据id查询单个文档</span><br><span class="line"># res = es.get(index=&apos;haoke&apos;, doc_type=&apos;person&apos;, id=&apos;0mblTHQBBnpVRgexf4YB&apos;)</span><br><span class="line"># print(res[&apos;_source&apos;])</span><br><span class="line"></span><br><span class="line"># 刷新索引，使刚变更的文档可查</span><br><span class="line"># es.indices.refresh(index=&apos;haoke&apos;)</span><br><span class="line"></span><br><span class="line"># 搜索文档</span><br><span class="line">query_json = &#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: 23</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = es.search(index=&apos;haoke&apos;, doc_type=&apos;person&apos;, body=query_json)</span><br><span class="line">for hit in res[&apos;hits&apos;][&apos;hits&apos;]:</span><br><span class="line">    print(&quot;%(name)s %(age)s %(hobby)s&quot; % hit[&apos;_source&apos;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a><a href="https://help.aliyun.com/document_detail/72660.html" target="_blank" rel="noopener">容量评估</a></h1><h2 id="磁盘总容量"><a href="#磁盘总容量" class="headerlink" title="磁盘总容量"></a>磁盘总容量</h2><ul>
<li>原始数据<ul>
<li>每日原始数据(GB)</li>
<li>每日增量数据</li>
<li>保留时间</li>
</ul>
</li>
<li>预留资源<ul>
<li>设置分片设置多少副本：至少1个</li>
<li>索引开销：通常比源数据大10%</li>
<li>操作系统预留：5%</li>
<li>Elasticsearch内部开销：段合并、日志等内部操作，预留20%。</li>
<li>安全阈值：通常至少预留15%的安全阈值。</li>
</ul>
</li>
</ul>
<p>原始数据 = 每日原始数据 * 保留天数 * 膨胀系数 </p>
<p>磁盘总存储 = 原始数据  *  (1 + 副本数) *（1 + 索引开销）* /（1 - Linux预留空间）/（1 - Elasticsearch开销）/（1 - 安全阈值）</p>
<p>​                    = 原始数据 *（1 + 副本数）* 1.7</p>
<p>​                    =  原始数据 * 3.4         </p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><ul>
<li>数据量和索引数<ul>
<li>创建多少索引(定期轮转、删除、合并)</li>
<li>每个索引的数据量</li>
<li>每个索引配置的主分片和副本分片</li>
</ul>
</li>
<li>分片大小：<ul>
<li>单个分片大小保持在10GB - 50GB之间(30GB最优);日志分析或者超大索引场景，建议单个shard大小不要超过100GB。</li>
<li>分片过大：可能使 ES 的故障恢复速度变慢</li>
<li>分片过小：可能导致非常多的分片，因为每个分片使用一些数量的 CPU 和内存，从而导致读写性能、内存不足等问题。</li>
</ul>
</li>
<li>分片数量：<ul>
<li>单节点分片数量(限额) = 当前节点的内存大小 * 30(TB级别以下)；在单节点上，7.x版本的实例默认的shard的上限为1000个</li>
<li>单索引分片数量(包括副本数)设置为接近数据节点的整数倍，方便分片在所有数据节点均匀分布。</li>
<li>当数据量很大时：选择多主1副本，降低Elasticsearch压力</li>
<li>当数据量较小(低于30GB)：使用单主多副本(负载均衡，提高性能)或者单主1副本。</li>
</ul>
</li>
</ul>
<h2 id="节点规格"><a href="#节点规格" class="headerlink" title="节点规格"></a>节点规格</h2><ul>
<li><p>集群最大节点数：集群最大节点数 = 单节点CPU数 * 5。</p>
</li>
<li><p>单节点磁盘最大容量：</p>
<p>使用场景不同，单节点最大承载数据量也会不同，具体如下：</p>
<ul>
<li>数据加速、查询聚合等场景：单节点磁盘最大容量 = 单节点内存大小（GB）* 10</li>
<li>日志写入、离线分析等场景：单节点磁盘最大容量 = 单节点内存大小（GB）* 50</li>
<li>通常情况：单节点磁盘最大容量 = 单节点内存大小（GB）* 30</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式存储-ceph</title>
    <url>/blog/2020/09/11/%E5%AE%B9%E5%99%A8%E5%8C%96/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8-ceph/</url>
    <content><![CDATA[<h1 id="Ceph介绍"><a href="#Ceph介绍" class="headerlink" title="Ceph介绍"></a>Ceph介绍</h1><p>ceph是一个可以同时提供对象存储、块存储、文件存储三种服务能力的分布式存储系统</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>高性能</strong></p>
<ul>
<li>摒弃了传统的集中式存储元数据寻址的方案，采用CRUSH算法，数据分布均衡，并行度高。</li>
<li>考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架感知等。</li>
<li>能够支持上千个存储节点的规模，支持TB到PB级的数据。</li>
</ul>
<p><strong>高可用性</strong></p>
<ul>
<li>副本数可以灵活控制。</li>
<li>支持故障域分隔，数据强一致性。</li>
<li>多种故障场景自动进行修复自愈。</li>
<li>没有单点故障，自动管理。</li>
</ul>
<p><strong>高可扩展性</strong></p>
<ul>
<li>去中心化。</li>
<li>扩展灵活。</li>
<li>随着节点增加而线性增长。</li>
</ul>
<p><strong>特性丰富</strong></p>
<ul>
<li>支持三种存储接口：块存储、文件存储、对象存储。</li>
<li>支持自定义接口，支持多种语言驱动。</li>
</ul>
<h2 id="与其他存储系统对比"><a href="#与其他存储系统对比" class="headerlink" title="与其他存储系统对比"></a>与其他存储系统对比</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/ceph-basic.png" style="zoom: 80%;"></p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/ceph-basic1.png" style="zoom: 80%;"></p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/ceph-high.png" style="zoom: 80%;"></p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/ceph-ext.png" style="zoom: 80%;"></p>
<h2 id="架构与组件"><a href="#架构与组件" class="headerlink" title="架构与组件"></a>架构与组件</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/ceph-arch.png" alt></p>
<ul>
<li>管理组件：<ul>
<li>MGR(ceph-mgr，Luminous之后)：<ul>
<li>收集集群状态的相关度量信息（例如，ceph df）</li>
<li>包括基于REST的API管理。注：API仍然是实验性质的，目前有一些限制，但未来会成为API管理的基础。</li>
<li>可以对接外部度量监控系统，例如cephmetrics、zabbix、calamari、promethus</li>
</ul>
</li>
<li>Admin【命令行工具】：Ceph常用管理接口通常都是命令行工具，如rados、ceph、rbd等命令，另外Ceph还有可以有一个专用的管理节点，在此节点上面部署专用的管理工具来实现近乎集群的一些管理工作，如集群部署，集群组件管理等。</li>
</ul>
</li>
<li>客户端组件：<ul>
<li>RGW：对象存储网关【可以使用LB(nginx)代理多个RGW服务实现负载均衡和高可用】</li>
<li>RBD：块存储接口</li>
<li>CephFS：文件存储接口</li>
</ul>
</li>
<li>核心组件：<ul>
<li>RADOS(Reliable Autonomic Distributed Object Store)：可靠的、自动化的、分布式对象存储系统。RADOS是Ceph集群的核心，它是一个抽象的存储系统</li>
<li>LIBRADOS：可以访问RADOS的库，上层的RBD、RGW和CephFS都是通过librados访问的；目前提供PHP、Ruby、Java、Python、C和C++支持。</li>
</ul>
</li>
<li>底层组件：<ul>
<li>OSD：负责物理存储的进程，一般配置成和硬盘一一对应，一个硬盘启动一个OSD进程；功能包括：存储数据、复制数据、平衡数据、恢复数据，以及与其它OSD间进行心跳检查，负责响应客户端请求返回具体数据的进程等</li>
<li>MON：保存OSD的元数据，维护集群的状态，管理集群客户端认证与授权</li>
<li>MDS(Ceph Metadata Server)：cephFS服务依赖的元数据服务，负责保存文件系统的元数据、目录结构等；<em>对象存储和块设备存储不需要此服务</em></li>
</ul>
</li>
<li>底层存储：<ul>
<li>bluestore(Luminous之后)：BlueStore通过直接管理物理HDD或SSD而不使用诸如XFS的中间文件系统来管理每个OSD存储的数据，这提供了更大的性能和功能；BlueStore内嵌支持使用zlib，snappy或LZ4进行压缩；BlueStore支持Ceph存储的所有的完整的数据和元数据校验。</li>
<li>filestore：相对于bluestore，使用xfs文件系统管理osd数据</li>
</ul>
</li>
</ul>
<h2 id="存储原理-Pool-PG"><a href="#存储原理-Pool-PG" class="headerlink" title="存储原理-Pool/PG"></a>存储原理-Pool/PG</h2><ul>
<li>CRUSH算法：一种为分布式存储的元数据提供一致性的算法，可以使ceph具有强大的扩展性</li>
<li>object：object是ceph最底层的存储单元，包含元数据和原始数据。</li>
<li>pool：存储对象的逻辑分区，它规定了数据的冗余类型(副本、纠错码)和对应副本的分布策略</li>
<li>PG(placement groups)：它是对象的集合；相同PG内的对象都会放到相同的硬盘上(OSD)；服务端数据均衡和恢复的最小粒度就是PG；</li>
</ul>
<p>PG与Pool关系：</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/pg-pool-osd.png" alt></p>
<ul>
<li>一个Pool里有很多PG</li>
<li>一个PG里有很多对象</li>
<li>PG有主从之分，一个PG分布在不同的OSD上(三副本类型)</li>
</ul>
<p>PG数量阈值：</p>
<p>默认每个osd最多250个pg【mon_max_pg_per_osd】，假如有6个osd，一共可以有(250*6)1500个pg</p>
<p>以每个pg有2个副本计算，集群中pool可以创建的pg总数为500【1500/3，剩余的1000个pg由集群根据副本机制自动创建】</p>
<h2 id="ceph的三种存储类型"><a href="#ceph的三种存储类型" class="headerlink" title="ceph的三种存储类型"></a>ceph的三种存储类型</h2><p>1、 块存储（RBD）  </p>
<ul>
<li><p>优点：</p>
<ul>
<li>通过Raid与LVM等手段，对数据提供了保护；</li>
<li>多块廉价的硬盘组合起来，提高容量；</li>
<li>多块磁盘组合出来的逻辑盘，提升读写效率；  </li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>采用SAN架构组网时，光纤交换机，造价成本高；</li>
<li>主机之间无法共享数据；</li>
</ul>
</li>
<li>使用场景<ul>
<li>docker容器、虚拟机磁盘存储分配；</li>
<li>日志存储；</li>
<li>文件存储；</li>
</ul>
</li>
</ul>
<p>2、文件存储（CephFS）</p>
<ul>
<li><p>优点：方便文件共享；</p>
</li>
<li><p>缺点：读写速率低、传输速率慢；</p>
</li>
<li>使用场景<ul>
<li>日志存储；</li>
<li>FTP、NFS；</li>
<li>其它有目录结构的文件存储  </li>
</ul>
</li>
</ul>
<p>3、对象存储（Object）(适合更新变动较少的数据)</p>
<ul>
<li>优点：<ul>
<li>具备块存储的读写高速；</li>
<li>具备文件存储的共享等特性；</li>
</ul>
</li>
</ul>
<ul>
<li>使用场景<ul>
<li>图片存储；</li>
<li>视频存储；</li>
</ul>
</li>
</ul>
<h1 id="Ceph安装"><a href="#Ceph安装" class="headerlink" title="Ceph安装"></a>Ceph安装</h1><p>可用安装方式如下，本文主要使用ceph-deploy安装</p>
<ul>
<li>ceph-deploy：<a href="https://docs.ceph.com/projects/ceph-deploy/en/latest/contents.html" target="_blank" rel="noopener">https://docs.ceph.com/projects/ceph-deploy/en/latest/contents.html</a></li>
<li>ceph-ansible：<a href="https://github.com/ceph/ceph-ansible" target="_blank" rel="noopener">https://github.com/ceph/ceph-ansible</a></li>
<li><a href="https://rook.io/" target="_blank" rel="noopener">rook</a>：在k8s内部署ceph集群</li>
<li>手动安装集群：<a href="https://ceph.readthedocs.io/en/latest/install/index_manual/#" target="_blank" rel="noopener">https://ceph.readthedocs.io/en/latest/install/index_manual/#</a></li>
</ul>
<h2 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h2><ul>
<li><p>主机：3台centos7主机，每台配置2C4G，每台机器额外挂载最少2块硬盘(每块不少于5G)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.31.201 node01</span><br><span class="line">192.168.31.202 node02</span><br><span class="line">192.168.31.203 node03</span><br></pre></td></tr></table></figure>
</li>
<li><p>ceph版本：nautilus</p>
</li>
</ul>
<h2 id="系统初始化设置"><a href="#系统初始化设置" class="headerlink" title="系统初始化设置"></a>系统初始化设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）关闭防火墙：</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">（2）关闭selinux：</span><br><span class="line">sed -i &apos;s/enforcing/disabled/&apos; /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line">（3）关闭NetworkManager</span><br><span class="line">systemctl disable NetworkManager &amp;&amp; systemctl stop NetworkManager</span><br><span class="line">（4）添加主机名与IP对应关系：</span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.31.201 node01</span><br><span class="line">192.168.31.202 node02</span><br><span class="line">192.168.31.203 node03</span><br><span class="line">（5）设置主机名：</span><br><span class="line">hostnamectl set-hostname node01</span><br><span class="line">hostnamectl set-hostname node02</span><br><span class="line">hostnamectl set-hostname node03</span><br><span class="line">（6）同步网络时间和修改时区</span><br><span class="line">systemctl restart chronyd.service &amp;&amp; systemctl enable chronyd.service</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">（7）设置文件描述符</span><br><span class="line">echo &quot;ulimit -SHn 102400&quot; &gt;&gt; /etc/rc.local</span><br><span class="line">cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line">EOF</span><br><span class="line">（8）内核参数优化</span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF</span><br><span class="line">kernel.pid_max = 4194303</span><br><span class="line">vm.swappiness = 0 </span><br><span class="line">EOF</span><br><span class="line">sysctl -p</span><br><span class="line">（9）在node01上配置root免密登录到node02、node03</span><br><span class="line"># 允许root登录</span><br><span class="line">sed -i &apos;/PermitRootLogin/s/^#/#&amp;/p&apos; /etc/ssh/sshd_config</span><br><span class="line">echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line">echo 123456|passwd root --stdin</span><br><span class="line"># 免秘钥</span><br><span class="line">ssh-copy-id root@node02</span><br><span class="line">ssh-copy-id root@node03</span><br><span class="line">(10) 调整磁盘文件预读参数，提高顺序读性能</span><br><span class="line">echo &quot;8192&quot; &gt; /sys/block/sda/queue/read_ahead_kb</span><br><span class="line">(11) 优化磁盘IO调度方式【SSD要用noop，SATA/SAS使用deadline】</span><br><span class="line">echo &quot;deadline&quot; &gt;/sys/block/sd[x]/queue/scheduler</span><br><span class="line">echo &quot;noop&quot; &gt;/sys/block/sd[x]/queue/scheduler</span><br></pre></td></tr></table></figure>
<h2 id="安装集群"><a href="#安装集群" class="headerlink" title="安装集群"></a>安装集群</h2><ul>
<li><p>设置yum源：ceph、epel</p>
<p>ceph</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/yum.repos.d/ceph.repo &lt;&lt; EOF</span><br><span class="line">[Ceph]</span><br><span class="line">name=Ceph packages for \$basearch</span><br><span class="line">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/\$basearch</span><br><span class="line">gpgcheck=0</span><br><span class="line">priority=1</span><br><span class="line">[Ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/noarch</span><br><span class="line">gpgcheck=0</span><br><span class="line">priority=1</span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/SRPMS</span><br><span class="line">gpgcheck=0</span><br><span class="line">priority=1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>epel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装ceph-deploy【node01】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ceph-deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：</p>
<p>[root@node01 my-cluster]# ceph-deploy -version<br>Traceback (most recent call last):<br>File “/bin/ceph-deploy”, line 18, in <module><br>from ceph_deploy.cli import main<br>File “/usr/lib/python2.7/site-packages/ceph_deploy/cli.py”, line 1, in <module><br>import pkg_resources<br>ImportError: No module named pkg_resources</module></module></p>
<p>解决： yum install python-pip -y</p>
</blockquote>
</li>
<li><p>创建工作目录【node01】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir my-cluster</span><br><span class="line">cd my-cluster/</span><br></pre></td></tr></table></figure>
</li>
<li><p>ceph节点初始化【node01】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy new node01 node02 node03</span><br></pre></td></tr></table></figure>
<p><strong>主要功能</strong>：确认可以免秘钥登录所有node、生成部署时需要的配置/root/.cephdeploy.conf、生成ceph集群配置文件ceph.conf和mon秘钥文件ceph.mon.keyring</p>
</li>
<li><p>安装ceph软件【每个节点】</p>
<blockquote>
<p>ceph-deploy install命令会使用ceph官方源和epel官方源，速度较慢</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ceph</span><br></pre></td></tr></table></figure>
<p><strong>主要功能</strong>：包含ceph-crash.service、ceph-mds.target、ceph-mgr.target、ceph-mon.target、ceph-osd.target服务【ceph.target为总的服务进程】</p>
</li>
<li><p>部署mon服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mon create-initial # 在所有初始化节点部署mon</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>推送admin配置到节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy admin node01 node02 node03</span><br></pre></td></tr></table></figure>
<p>admin配置如下：</p>
<p>ceph.client.admin.keyring：客户端认证秘钥</p>
<p>ceph.conf：客户端连接集群时的配置文件</p>
</li>
<li><p>部署mgr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mgr create node01 node02 node03</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署rgw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ceph-radosgw 【每个节点】</span><br><span class="line">ceph-deploy rgw create node01 node02 node03</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署mds</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mds create node01 node02 node03</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署osd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create --data /dev/sdb node01</span><br><span class="line">ceph-deploy osd create --data /dev/sdb node02</span><br><span class="line">ceph-deploy osd create --data /dev/sdb node03</span><br></pre></td></tr></table></figure>
<p>指定主机名【node01】和主机上的硬盘设备【/dev/sdb】</p>
</li>
</ul>
<p>确认集群状态：ceph -s</p>
<h2 id="ceph-conf"><a href="#ceph-conf" class="headerlink" title="ceph.conf"></a>ceph.conf</h2><p>1、该配置文件采用ini文件语法，#和;为注释，ceph集群在启动的时候会按照顺序加载所有的conf配置文件。 配置文件分为以下几大块配置。</p>
<pre><code>global：全局配置。
osd：osd专用配置，可以使用osd.N，来表示某一个OSD专用配置，N为osd的编号，如0、2、1等。
mon：mon专用配置，也可以使用mon.A来为某一个monitor节点做专用配置，其中A为该节点的名称，ceph-monitor-2、ceph-monitor-1等。使用命令 ceph mon dump可以获取节点的名称。
client：客户端专用配置。
</code></pre><p>2、配置文件可以从多个地方进行顺序加载，如果冲突将使用最新加载的配置，其加载顺序为。</p>
<pre><code>$CEPH_CONF环境变量
-c 指定的位置
/etc/ceph/ceph.conf
~/.ceph/ceph.conf
./ceph.conf
</code></pre><p>3、配置文件还可以使用一些元变量应用到配置文件，如。</p>
<pre><code>$cluster：当前集群名。
$type：当前服务类型。
$id：进程的标识符。
$host：守护进程所在的主机名。
$name：值为$type.$id。
</code></pre><p>4、ceph.conf详细参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">fsid = xxxxxxxxxxxxxxx                           #集群标识ID </span><br><span class="line">mon host = 10.0.1.1,10.0.1.2,10.0.1.3            #monitor IP 地址</span><br><span class="line">auth cluster required = cephx                    #集群认证</span><br><span class="line">auth service required = cephx                           #服务认证</span><br><span class="line">auth client required = cephx                            #客户端认证</span><br><span class="line">osd pool default size = 3                             #最小副本数 默认是3</span><br><span class="line">osd pool default min size = 1                           #PG 处于 degraded 状态不影响其 IO 能力,min_size是一个PG能接受IO的最小副本数</span><br><span class="line">public network = 10.0.1.0/24                            #公共网络(monitorIP段) </span><br><span class="line">cluster network = 10.0.2.0/24                           #集群网络</span><br><span class="line">max open files = 131072                                 #默认0#如果设置了该选项，Ceph会设置系统的max open fds</span><br><span class="line">mon initial members = node1, node2, node3               #初始monitor (由创建monitor命令而定)</span><br><span class="line">##############################################################</span><br><span class="line">[mon]</span><br><span class="line">mon data = /var/lib/ceph/mon/ceph-$id</span><br><span class="line">mon clock drift allowed = 1                             #默认值0.05 时间偏移量【超过多少时间认为节点不同步】</span><br><span class="line">mon osd min down reporters = 13                         #默认值1#向monitor报告down的最小OSD数</span><br><span class="line">mon osd down out interval = 600      #默认值300      #标记一个OSD状态为down和out之前ceph等待的秒数</span><br><span class="line">##############################################################</span><br><span class="line">[osd]</span><br><span class="line">osd data = /var/lib/ceph/osd/ceph-$id</span><br><span class="line">osd mkfs type = xfs                                     #格式化系统类型</span><br><span class="line">osd max write size = 512 #默认值90                   #OSD一次可写入的最大值(MB)</span><br><span class="line">osd client message size cap = 2147483648 #默认值100    #客户端允许在内存中的最大数据(bytes)</span><br><span class="line">osd deep scrub stride = 131072 #默认值524288         #在Deep Scrub时候允许读取的字节数(bytes)</span><br><span class="line">osd op threads = 16 #默认值2                         #并发文件系统操作数</span><br><span class="line">osd disk threads = 4 #默认值1                        #OSD密集型操作例如恢复和Scrubbing时的线程</span><br><span class="line">osd map cache size = 1024 #默认值500                 #保留OSD Map的缓存(MB)</span><br><span class="line">osd map cache bl size = 128 #默认值50                #OSD进程在内存中的OSD Map缓存(MB)</span><br><span class="line">osd mount options xfs = &quot;rw,noexec,nodev,noatime,nodiratime,nobarrier&quot; #默认值rw,noatime,inode64  #Ceph OSD xfs Mount选项</span><br><span class="line">osd recovery op priority = 2 #默认值10              #恢复操作优先级，取值1-63，值越高占用资源越高</span><br><span class="line">osd recovery max active = 10 #默认值15              #同一时间内活跃的恢复请求数 </span><br><span class="line">osd max backfills = 4  #默认值10                  #一个OSD允许的最大backfills数</span><br><span class="line">osd min pg log entries = 30000 #默认值3000           #修建PGLog是保留的最大PGLog数</span><br><span class="line">osd max pg log entries = 100000 #默认值10000         #修建PGLog是保留的最大PGLog数</span><br><span class="line">osd mon heartbeat interval = 40 #默认值30            #OSD ping一个monitor的时间间隔（默认30s）</span><br><span class="line">ms dispatch throttle bytes = 1048576000 #默认值 104857600 #等待派遣的最大消息数</span><br><span class="line">objecter inflight ops = 819200 #默认值1024           #客户端流控，允许的最大未发送io请求数，超过阀值会堵塞应用io，为0表示不受限</span><br><span class="line">osd op log threshold = 50 #默认值5                  #一次显示多少操作的log</span><br><span class="line">osd crush chooseleaf type = 0 #默认值为1              #CRUSH规则用到chooseleaf时的bucket的类型</span><br><span class="line">##############################################################</span><br><span class="line">[client]</span><br><span class="line">rbd cache = true #默认值 true      #RBD缓存</span><br><span class="line">rbd cache size = 335544320 #默认值33554432           #RBD缓存大小(bytes)</span><br><span class="line">rbd cache max dirty = 134217728 #默认值25165824      #缓存为write-back时允许的最大dirty字节数(bytes)，如果为0，使用write-through</span><br><span class="line">rbd cache max dirty age = 30 #默认值1                #在被刷新到存储盘前dirty数据存在缓存的时间(seconds)</span><br><span class="line">rbd cache writethrough until flush = false #默认值true  #该选项是为了兼容linux-2.6.32之前的virtio驱动，避免因为不发送flush请求，数据不回写</span><br><span class="line">              #设置该参数后，librbd会以writethrough的方式执行io，直到收到第一个flush请求，才切换为writeback方式。</span><br><span class="line">rbd cache max dirty object = 2 #默认值0              #最大的Object对象数，默认为0，表示通过rbd cache size计算得到，librbd默认以4MB为单位对磁盘Image进行逻辑切分</span><br><span class="line">      #每个chunk对象抽象为一个Object；librbd中以Object为单位来管理缓存，增大该值可以提升性能</span><br><span class="line">rbd cache target dirty = 235544320 #默认值16777216    #开始执行回写过程的脏数据大小，不能超过 rbd_cache_max_dirty</span><br></pre></td></tr></table></figure>
<h1 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h1><h2 id="RBD介绍"><a href="#RBD介绍" class="headerlink" title="RBD介绍"></a>RBD介绍</h2><p>RBD即RADOS Block Device的简称，RBD块存储是最稳定且最常用的存储类型。RBD块设备类似磁盘，可以被挂载。 RBD块设备具有快照、多副本、克隆和一致性等特性，数据以条带化的方式存储在Ceph集群的多个OSD中。</p>
<ul>
<li>RBD 就是 Ceph 里的块设备，一个 4T 的块设备的功能和一个 4T 的 SATA 类似，挂载的 RBD 就可以当磁盘用；</li>
<li>resizable：这个块可大可小；</li>
<li>data striped：这个块在Ceph里面是被切割成若干小块来保存，不然 1PB 的块怎么存的下；</li>
<li><p>thin-provisioned：精简配置；相当于存储空间的动态分配，就是块的大小和在 Ceph中实际占用大小是没有关系的，刚创建出来的块是不占空间，今后用多大空间，才会在 Ceph 中占用多大空间。</p>
</li>
<li><p>块存储本质就是将裸磁盘或类似裸磁盘(lvm)设备映射给主机使用，主机可以对其进行格式化并存储和读取数据，块设备读取速度快但是不支持共享。</p>
</li>
<li>ceph可以通过内核模块和librbd库提供块设备支持。客户端可以通过内核模块挂载rbd使用，客户端使用rbd块设备就像使用普通硬盘一样，可以对其就行格式化然后使用；典型的是云平台的块存储服务。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>云平台（OpenStack做为云的存储后端提供镜像存储）</li>
<li>K8s容器</li>
<li>map成块设备直接使用</li>
<li>ISCIS，安装Ceph客户端</li>
</ul>
<h2 id="RBD-IO流程"><a href="#RBD-IO流程" class="headerlink" title="RBD IO流程"></a>RBD IO流程</h2><p>（1）客户端创建一个pool，需要为这个pool指定pg的数量；<br>（2）创建pool/image rbd设备进行挂载；<br>（3）用户写入的数据进行切块，每个块的大小默认为4M，并且每个块都有一个名字，名字就是object+序号<br>（4）将每个object通过pg进行副本位置的分配；<br>（5）pg根据cursh算法会寻找3个osd，把这个object分别保存在这三个osd上；    </p>
<h2 id="RBD常见操作"><a href="#RBD常见操作" class="headerlink" title="RBD常见操作"></a>RBD常见操作</h2><ul>
<li><p>创建rbd块设备使用的pool</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool create rbd01  32 32</span><br><span class="line">ceph osd lspools # 查看pool列表</span><br></pre></td></tr></table></figure>
<ul>
<li><p>rbd01：pool的名称</p>
</li>
<li><p>【1】32：<a href="https://blog.csdn.net/qq_32485197/article/details/88892620" target="_blank" rel="noopener">pool中pg的数量</a>：osd数量 * 100/副本数 = 最接近2的幂次方的数【例如3个osd、3个副本，3*100/3=100~128=2ⁿ】</p>
</li>
<li><p>【2】32：pool中pgs的数量，一般设置和pg一样</p>
</li>
</ul>
</li>
<li><p>设置pool提供什么类型服务（如：cephfs、rbd、rgw）</p>
<p><strong>可选项</strong>(一般只对rbd类型设置标签、不设置会有warn提示)，相当于给pool打标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool application enable rbd01 rbd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RBD-增删使用"><a href="#RBD-增删使用" class="headerlink" title="RBD-增删使用"></a>RBD-增删使用</h3><ul>
<li><p>在pool上创建一个rbd块设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd create --size 4096 image01 -p rbd01</span><br></pre></td></tr></table></figure>
<p>–size         指定块设备大小，以MB为单位</p>
<p>image01   块设备名称</p>
<p>-p rbd01   指定使用的pool【如果存在默认的pool(<strong>rbd</strong>)，可以不指定此参数，则rbd命令的所有操作都在这个pool中进行】</p>
</li>
<li><p>查看块设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd ls -p rbd01</span><br><span class="line">rbd info image01 -p rbd01</span><br></pre></td></tr></table></figure>
</li>
<li><p>将块设备映射到操作系统内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd map image01 -p rbd01</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化块设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/rbd0</span><br></pre></td></tr></table></figure>
</li>
<li><p>mount到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /mnt                  # 卸载磁盘挂载</span><br><span class="line">rbd unmap image01 -p rbd01   # 取消块设备映射</span><br><span class="line">rbd rm image01 -p rbd01      # 删除块设备</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RBD-快照"><a href="#RBD-快照" class="headerlink" title="RBD-快照"></a>RBD-快照</h3><ul>
<li><p>创建快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd snap create image01@image01_snap01 -p rbd01</span><br></pre></td></tr></table></figure>
<p>image01：块设备名称</p>
<p>image01_snap01：块设备的快照名称</p>
</li>
<li><p>查看快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd snap list image01 -p rbd01            # 快照列表</span><br><span class="line">rbd info image01@image01_snap01 -p rbd01  # 查看快照详情</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /mnt</span><br><span class="line">rbd unmap image01 -p rbd01</span><br><span class="line">rbd snap rollback image01@image01_snap01 -p rbd01 #恢复快照</span><br><span class="line">rbd map image01 -p rbd01 </span><br><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd snap unprotect image01@image01_snap01 -p rbd01 #取消保护</span><br><span class="line">rbd snap remove image01@image01_snap01 -p rbd01    #删除快照</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RBD-快照克隆"><a href="#RBD-快照克隆" class="headerlink" title="RBD-快照克隆"></a>RBD-快照克隆</h3><blockquote>
<p>此处操作为基于快照的克隆，最后制作成可以独立使用的块设备</p>
</blockquote>
<ul>
<li><p>设置快照为保护状态【快照必须处于被保护状态才能被克隆】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd snap protect image01@image01_snap01 -p rbd01</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆快照：可以克隆到另一个命名空间或另一个pool中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd clone rbd01/image01@image01_snap01 rbd02/image01_clone1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看克隆结果：rbd ls -p rbd02</p>
</blockquote>
</li>
<li><p>克隆快照的处理【制作成可以独立使用的块设备】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 此时image01_clone1还是image01的快照复制品(只读)，不能作为独立的块设备使用</span><br><span class="line">rbd children image01 -p rbd01</span><br><span class="line">2. 去掉克隆快照与块设备的父子关系【完成操作后，image01_clone1和image01一样，可以作为块设备直接使用】</span><br><span class="line">rbd flatten rbd02/image01_clone1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在集群的另一主机挂载使用【同主机image01_clone1和image01具有相同uuid，mount会报错】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd map image01_clone1 -p rbd02</span><br><span class="line">mount /dev/rbd0 /mnt/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RBD-扩容缩容"><a href="#RBD-扩容缩容" class="headerlink" title="RBD-扩容缩容"></a>RBD-扩容缩容</h3><ul>
<li><p>rbd在线扩容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd resize --size 5100 image01 -p rbd01 # RBD扩容</span><br><span class="line">xfs_growfs /mnt #文件系统扩容</span><br></pre></td></tr></table></figure>
</li>
<li><p>RBD缩容</p>
<blockquote>
<p>rbd支持缩容，但是xfs文件系统不支持缩容(无在线缩容命令)；挂载点(例如/mnt)离线后，superblock丢失，无法重新挂载</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd resize --size 2048 foo --allow-shrink #RBD缩容</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="远程挂载RBD"><a href="#远程挂载RBD" class="headerlink" title="远程挂载RBD"></a>远程挂载RBD</h3><ul>
<li><p>配置yum源：ceph、epel</p>
</li>
<li><p>安装ceph客户端ceph-common</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install ceph-common -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端连接设置【/etc/ceph/】</p>
<blockquote>
<p>这2个文件都可以在ceph-deploy的工作目录my-cluster找到</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph.conf                  # 配置文件</span><br><span class="line">ceph.client.admin.keyring  # 认证文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd ls -p rbd02</span><br><span class="line">rbd map image01_clone1 -p rbd02</span><br><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RBD镜像导入导出"><a href="#RBD镜像导入导出" class="headerlink" title="RBD镜像导入导出"></a>RBD镜像导入导出</h3><ul>
<li><p>导出RBD镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd export image01 /tmp/image01 -p rbd01</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入RBD镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbd import /tmp/image01 rbd02/image02</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>快照使用：只对重要且数据量较小的rbd做快照</p>
<h1 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h1><h2 id="CephFS介绍"><a href="#CephFS介绍" class="headerlink" title="CephFS介绍"></a>CephFS介绍</h2><p>Ceph File System (CephFS) 是与 POSIX 标准兼容的文件系统, 能够提供对 Ceph 存储集群上的文件访问。CephFS 需要至少一个元数据服务器 (MDS) daemon (ceph-mds) 运行, MDS daemon 管理着与存储在 CephFS 上的文件相关的元数据, 并且协调着对 Ceph 存储系统的访问。  </p>
<p>CephFS依赖的底层组件:</p>
<ul>
<li>OSD (ceph-osd): CephFS 的数据和元数据就存储在 OSDs上</li>
<li>MDS (ceph-mds): Metadata Servers, 管理着 CephFS 的元数据</li>
<li>Mon (ceph-mon): Monitors 管理着集群 Map 的主副本</li>
</ul>
<p>Ceph 存储集群的协议层是 Ceph 原生的 librados 库, 与核心集群交互.</p>
<p>CephFS库层包括 CephFS 库 libcephfs, 工作在 librados 的顶层, 代表着 Ceph 文件系统.</p>
<p>最上层是能够访问 Ceph 文件系统的两类客户端：mount、fuse</p>
<h2 id="部署CephFS"><a href="#部署CephFS" class="headerlink" title="部署CephFS"></a>部署CephFS</h2><ul>
<li><p>部署mon、osd、mds服务</p>
</li>
<li><p>创建cephfs需要使用的pool：cephfs-data 和 cephfs-metadata, 分别存储文件数据和文件元数据</p>
<blockquote>
<p>一般 metadata pool 可以从相对较少的 PGs 启动, 之后可以根据需要增加 PGs. 因为 metadata pool 存储着 CephFS 文件的元数据, 为了保证安全, 最好有较多的副本数. 为了能有较低的延迟, 可以考虑将 metadata 存储在 SSDs 上.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool create cephfs-data 16 16</span><br><span class="line">ceph osd pool create cephfs-metadata 16 16</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建cephfs,名称为cephfs【默认配置时只能创建一个cephfs】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs new cephfs cephfs-metadata cephfs-data</span><br><span class="line">ceph fs status cephfs # 查看cephfs状态【至少有一个 MDS 已经进入 Active 状态】</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建访问cephfs的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph auth get-or-create client.cephfs mon &apos;allow r&apos; mds &apos;allow rw&apos; osd &apos;allow rw pool=cephfs-data, allow rw pool=cephfs-metadata&apos;</span><br><span class="line">ceph auth get client.cephfs # 查看key是否生效</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查cephfs和mds状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs status</span><br><span class="line">ceph mds stat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="客户端挂载"><a href="#客户端挂载" class="headerlink" title="客户端挂载"></a>客户端挂载</h2><ul>
<li><p>kernel client</p>
<ul>
<li><p>手动挂载：mount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t ceph 192.168.31.201:6789,192.168.31.202:6789,192.168.31.203:6789:/ /mnt -o name=cephfs,secret=AQBcH1ZfIsqIHBAAVTvqHwhUMbd6moEjjQBRUg==</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;192.168.31.201:6789,192.168.31.202:6789,192.168.31.203:6789:/ /mnt ceph name=cephfs,secretfile=/etc/ceph/cephfs.key,_netdev,noatime 0 0&quot; | sudo tee -a /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>fuse client：ceph-fuse</p>
<ul>
<li><p>安装ceph-fuse客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ceph-common ceph-fuse</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ceph配置文件ceph.conf和客户端认证文件ceph.client.cephfs.keyring复制到客户端</p>
<blockquote>
<p>ceph auth get client.cephfs获取ceph.client.cephfs.keyring文件内容</p>
</blockquote>
</li>
<li><p>手动挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-fuse --name client.cephfs --keyring /etc/ceph/ceph.client.cephfs.keyring -m 192.168.31.201:6789,192.168.31.202:6789,192.168.31.203:6789 /mnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;id=cephfs,conf=/etc/ceph/ceph.conf /mnt fuse.ceph _netdev,defaults 0 0&quot;| sudo tee -a /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fusermount -u /mnt/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="MDS主备和主主"><a href="#MDS主备和主主" class="headerlink" title="MDS主备和主主"></a>MDS主备和主主</h2><p>当cephfs的性能出现在MDS上时，就应该配置多个活动的MDS。通常是多个客户机应用程序并行的执行大量元数据操作，并且它们分别有自己单独的工作目录。这种情况下很适合使用多主MDS模式。</p>
<ul>
<li><p>配置MDS多主模式</p>
<p>每个cephfs文件系统都有一个max_mds设置，可以理解为它将控制创建多少个主MDS。注意只有当实际的MDS个数大于或等于max_mds设置的值时，mdx_mds设置才会生效。例如，如果只有一个MDS守护进程在运行，并且max_mds被设置为两个，则不会创建第二个主MDS。即使有多个活动的MDS，如果其中一个MDS出现故障，仍然需要备用守护进程来接管。因此，对于高可用性系统，实际配置max_mds时，最好比系统中MDS的总数少一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs set cephfs max_mds 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置备用MDS</p>
<p>如果你确信你的MDS不会出现故障，可以通过以下设置来通知ceph不需要备用MDS，否则会出现insufficient standby daemons available告警信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs set &lt;fs&gt; standby_count_wanted 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>还原为单主MDS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs set cephfs max_mds 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Ceph-Object"><a href="#Ceph-Object" class="headerlink" title="Ceph Object"></a>Ceph Object</h1><p>在部署完rgw服务(yum install -y ceph-radosgw)后，使用radosrgw-admin命令管理用户和角色(权限)，其他功能可以使用s3cmd完成</p>
<ul>
<li><p>RGW用户管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建rgw用户</span><br><span class="line">radosgw-admin user create --uid=user01 --display-name=user01</span><br><span class="line">2. 查看用户信息【包含access key和secret key】</span><br><span class="line">radosgw-admin user list</span><br><span class="line">radosgw-admin user info --uid=user01</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="管理工具-s3cmd"><a href="#管理工具-s3cmd" class="headerlink" title="管理工具-s3cmd"></a>管理工具-s3cmd</h2><ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install python-pip</span><br><span class="line">sudo pip install s3cmd</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置【~/.s3cfg】</p>
<blockquote>
<p>也可以使用s3cmd –configure，host为rgw网关地址【端口7480】</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">access_key = PDGJX31AU3Z2KCYX5TGD</span><br><span class="line">secret_key = VDBm1FUluuAp3XNAAqM5ScL98klYphAT3nm5yFuO</span><br><span class="line">host_base = 192.168.31.201:7480</span><br><span class="line">host_bucket = 192.168.31.201:7480/%(bucket)</span><br><span class="line">use_https = False</span><br></pre></td></tr></table></figure>
</li>
<li><p>bucket操作</p>
<ul>
<li><p>创建bucket：s3cmd mb s3://test1</p>
<blockquote>
<p>错误：ERROR: S3 error: 416 (InvalidRange)<br>解决：由于pg数不够，所以需要增加pg数或删除已存在的pool腾出pg容量</p>
</blockquote>
</li>
<li><p>显示bucket列表：s3cmd ls</p>
</li>
</ul>
</li>
<li><p>删除空bucket：s3cmd rb s3://test1</p>
<ul>
<li>显示bucket内容：s3cmd ls s3://test1</li>
</ul>
</li>
<li><p>object操作</p>
<ul>
<li>上传文件并重命名：s3cmd put README.md s3://test1/README.md</li>
<li>批量上传：s3cmd put ./*.yml s3://test1</li>
<li>下载文件并重命名：s3cmd get s3://test1/README.md 12.txt</li>
<li>批量下载：s3cmd get s3://test1/* .</li>
<li>显示object占用空间：s3cmd du s3://test1/README.md</li>
<li>删除文件：s3cmd del s3://test1/README.md</li>
</ul>
</li>
<li><p>权限设置</p>
<ul>
<li>上传时设置：<code>s3cmd put --acl-public file.txt s3://my-bucket-name/file.txt</code></li>
<li>单独设置：<code>s3cmd setacl s3://myexamplebucket.calvium.com/ --acl-public --recursive</code></li>
</ul>
</li>
</ul>
<h1 id="Ceph-Dashboard"><a href="#Ceph-Dashboard" class="headerlink" title="Ceph Dashboard"></a><a href="https://docs.ceph.com/en/nautilus/mgr/dashboard/" target="_blank" rel="noopener">Ceph Dashboard</a></h1><p>从Luminous开始，Ceph 提供了原生的Dashboard功能，通过Dashboard可以获取Ceph集群的各种状态信息、也可以执行一些CRUD操作</p>
<h2 id="启用dashboard"><a href="#启用dashboard" class="headerlink" title="启用dashboard"></a>启用dashboard</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、在每个mgr节点安装dashboard</span><br><span class="line"># yum install ceph-mgr-dashboard -y</span><br><span class="line">2、mgr开启dashboard功能</span><br><span class="line"># ceph mgr module enable dashboard</span><br><span class="line">3、生成自签名的证书【默认使用https(8443)方式提供服务】</span><br><span class="line"># ceph dashboard create-self-signed-cert  </span><br><span class="line">4、创建一个dashboard登录用户名/密码</span><br><span class="line"># ceph dashboard ac-user-create admin 123456 administrator </span><br><span class="line">5、查看服务访问方式</span><br><span class="line"># ceph mgr services</span><br></pre></td></tr></table></figure>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><blockquote>
<p>重启dashboard：ceph mgr module disable/enable dashboard</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用http方式访问集群(8080)【重启dashboard】</span><br><span class="line">ceph config set mgr mgr/dashboard/ssl false</span><br><span class="line"># 指定集群dashboard的访问IP【重启dashboard】</span><br><span class="line">ceph config set mgr mgr/dashboard/server_addr $IP </span><br><span class="line"># 指定集群dashboard的访问端口【重启dashboard】</span><br><span class="line">ceph config set mgr mgr/dashboard/server_port $PORT</span><br></pre></td></tr></table></figure>
<h2 id="开启Object-Gateway功能"><a href="#开启Object-Gateway功能" class="headerlink" title="开启Object Gateway功能"></a>开启Object Gateway功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建rgw用户</span><br><span class="line"># radosgw-admin user create --uid=user01 --display-name=user01 --system</span><br><span class="line"># radosgw-admin user info --uid=user01</span><br><span class="line">2、向Dashboard提供访问rgw的access-key/secret-key</span><br><span class="line"># ceph dashboard set-rgw-api-access-key $access_key</span><br><span class="line"># ceph dashboard set-rgw-api-secret-key $secret_key</span><br><span class="line">3、配置rgw主机名和端口</span><br><span class="line"># ceph dashboard set-rgw-api-host 192.168.31.201</span><br><span class="line"># ceph dashboard set-rgw-api-port 7480</span><br><span class="line">4、刷新web页面</span><br></pre></td></tr></table></figure>
<h1 id="prometheus-grafana监控"><a href="#prometheus-grafana监控" class="headerlink" title="prometheus+grafana监控"></a>prometheus+grafana监控</h1><h2 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a><a href="https://mirror.tuna.tsinghua.edu.cn/help/grafana/" target="_blank" rel="noopener">安装grafana</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、配置yum源文件【/etc/yum.repos.d/grafana.repo】</span><br><span class="line">[grafana]</span><br><span class="line">name=grafana</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/grafana/yum/rpm</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">2.通过yum命令安装grafana</span><br><span class="line"># sudo yum makecache</span><br><span class="line"># sudo yum install grafana</span><br><span class="line"></span><br><span class="line">3.启动grafana并设为开机自启</span><br><span class="line"># systemctl start grafana-server.service </span><br><span class="line"># systemctl enable grafana-server.service</span><br></pre></td></tr></table></figure>
<h2 id="安装prometheus"><a href="#安装prometheus" class="headerlink" title="安装prometheus"></a>安装prometheus</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载安装包，下载地址</span><br><span class="line">https://prometheus.io/download/</span><br><span class="line"></span><br><span class="line">2、解压压缩包</span><br><span class="line"># tar xzvf prometheus-2.14.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">3、将解压后的目录改名</span><br><span class="line"># mv prometheus-2.14.0.linux-amd64 /opt/prometheus</span><br><span class="line"></span><br><span class="line">4、查看promethus版本</span><br><span class="line"># /opt/prometheus/prometheus --version</span><br><span class="line"></span><br><span class="line">5、配置系统服务启动</span><br><span class="line"># vim /etc/systemd/system/prometheus.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Prometheus Monitoring System</span><br><span class="line">Documentation=Prometheus Monitoring System</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/prometheus/prometheus \</span><br><span class="line">  --config.file /opt/prometheus/prometheus.yml \</span><br><span class="line">  --web.listen-address=:9090</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">6、加载系统服务</span><br><span class="line"># systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">7、启动服务和添加开机自启动</span><br><span class="line"># systemctl start prometheus</span><br><span class="line"># systemctl enable prometheus</span><br></pre></td></tr></table></figure>
<h2 id="mgr开启prometheus功能"><a href="#mgr开启prometheus功能" class="headerlink" title="mgr开启prometheus功能"></a>mgr开启prometheus功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph mgr module enable prometheus</span><br><span class="line"># netstat -nltp | grep mgr 检查端口</span><br><span class="line"># curl 127.0.0.1:9283/metrics  测试返回值</span><br></pre></td></tr></table></figure>
<h2 id="配置prometheus"><a href="#配置prometheus" class="headerlink" title="配置prometheus"></a>配置prometheus</h2><ul>
<li>在 scrape_configs:配置项下添加【/opt/prometheus/prometheus.yml】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- job_name: &apos;ceph_cluster&apos;</span><br><span class="line">    honor_labels: true</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;192.168.31.201:9283&apos;]</span><br><span class="line">        labels:</span><br><span class="line">          instance: ceph</span><br></pre></td></tr></table></figure>
<ul>
<li>重启promethus服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart prometheus</span><br></pre></td></tr></table></figure>
<ul>
<li>检查prometheus服务器中是否添加成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器-》 http://x.x.x.x:9090 -》status -》Targets</span><br></pre></td></tr></table></figure>
<h2 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h2><p>1、浏览器登录 grafana 管理界面：<a href="http://x.x.x.x:3000" target="_blank" rel="noopener">http://x.x.x.x:3000</a><br>2、添加data sources，点击configuration–》data sources<br>3、添加dashboard，点击HOME–》find dashboard on grafana.com<br>4、搜索ceph的dashboard<br>5、点击HOME–》Import dashboard, 选择合适的dashboard，记录编号</p>
<h1 id="k8s对接ceph存储"><a href="#k8s对接ceph存储" class="headerlink" title="k8s对接ceph存储"></a>k8s对接ceph存储</h1><h2 id="k8s内置支持ceph-rbd"><a href="#k8s内置支持ceph-rbd" class="headerlink" title="k8s内置支持ceph rbd"></a>k8s内置支持ceph rbd</h2><p><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#ceph-rbd" target="_blank" rel="noopener">k8s原生支持ceph rbd</a>【但是目前不可用】使用限制和问题如下：</p>
<ul>
<li>当前测试支持的功能有：创建rbd image(创建pv/pvc)、删除rbd image(删除pv/pvc)、查看rbd image状态(查看pv/pvc)</li>
<li>ceph的管理操作：由controller-manager组件完成，controller-manager会调用rbd命令进行操作<ul>
<li>如果controller-manager部署在宿主机，则k8s master节点应当安装ceph-common组件</li>
<li>如果controller-manager使用kubeadm pod方式部署，默认镜像中不含rbd命令<ul>
<li>直接使用会报错：<a href="https://github.com/kubernetes/kubernetes/issues/38923" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/38923</a></li>
<li>可以构建包含rbd命令的controller-manager镜像：<a href="https://github.com/simple0426/kube-controller-manager.git" target="_blank" rel="noopener">https://github.com/simple0426/kube-controller-manager.git</a></li>
</ul>
</li>
</ul>
</li>
<li>ceph的客户端操作：由worker节点的kubelet调用的rbd命令完成，所以worker节点也需要安装ceph-common组件</li>
</ul>
<h2 id="k8s社区支持"><a href="#k8s社区支持" class="headerlink" title="k8s社区支持"></a>k8s社区支持</h2><p>可以使用社区开发的<a href="https://github.com/kubernetes-retired/external-storage/tree/master/ceph" target="_blank" rel="noopener">组件</a>完成ceph rbd、cephfs以storageclass方式向k8s提供存储。【<strong>组件功能有限、社区已停止维护，仅供学习</strong>】</p>
<h3 id="ceph-rbd"><a href="#ceph-rbd" class="headerlink" title="ceph rbd"></a>ceph rbd</h3><ul>
<li><p>介绍：这个组件是基于k8s内置的rbd功能扩展而成，除了以下功能外，其他功能操作会试图调用k8s controller-manager中的<a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/volume/rbd" target="_blank" rel="noopener">rbd组件</a>去完成</p>
</li>
<li><p>部署文档：<a href="https://github.com/kubernetes-retired/external-storage/tree/master/ceph/rbd#test-instruction" target="_blank" rel="noopener">https://github.com/kubernetes-retired/external-storage/tree/master/ceph/rbd#test-instruction</a></p>
</li>
<li><a href="https://github.com/kubernetes-retired/external-storage/blob/master/ceph/rbd/pkg/provision/rbd_util.go" target="_blank" rel="noopener">功能</a>：创建rbd image(创建pv/pvc)、删除rbd image(删除pv/pvc)、查看rbd image状态(查看pv/pvc)</li>
<li>使用限制：除了支持的功能外，其他功能使用会报错；例如：动态调整pvc/pv的容量(storageclass中需设置allowVolumeExpansion=true)：<a href="https://github.com/kubernetes-retired/external-storage/issues/992" target="_blank" rel="noopener">https://github.com/kubernetes-retired/external-storage/issues/992</a></li>
</ul>
<h3 id="cephfs"><a href="#cephfs" class="headerlink" title="cephfs"></a>cephfs</h3><ul>
<li><p>部署文档：<a href="https://github.com/kubernetes-retired/external-storage/tree/master/ceph/cephfs" target="_blank" rel="noopener">https://github.com/kubernetes-retired/external-storage/tree/master/ceph/cephfs</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph中创建cephfs</span><br><span class="line">ceph osd pool create cephfs-data 16 16</span><br><span class="line">ceph osd pool create cephfs-metadata 16 16</span><br><span class="line">ceph fs new cephfs cephfs-metadata cephfs-data</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用限制：默认<a href="https://github.com/kubernetes-retired/external-storage/tree/master/ceph/cephfs#known-limitations" target="_blank" rel="noopener">不支持配额和容量</a>；网络上解决存储配额的方案如下</p>
<ul>
<li><a href="https://jeremyxu2010.github.io/2019/09/kubernetes%E4%BD%BF%E7%94%A8ceph%E5%AD%98%E5%82%A8%E5%8D%B7/" target="_blank" rel="noopener">方式1</a></li>
<li><a href="https://www.cnblogs.com/ltxdzh/p/9173706.html" target="_blank" rel="noopener">方式2</a></li>
</ul>
</li>
</ul>
<h2 id="ceph官方支持"><a href="#ceph官方支持" class="headerlink" title="ceph官方支持"></a>ceph官方支持</h2><p>ceph官方以csi方式向k8s提供存储</p>
<ul>
<li>ceph rbd for kubernetes文档：<a href="https://docs.ceph.com/docs/master/rbd/rbd-kubernetes/" target="_blank" rel="noopener">https://docs.ceph.com/docs/master/rbd/rbd-kubernetes/</a></li>
<li>项目地址：<a href="https://github.com/ceph/ceph-csi" target="_blank" rel="noopener">https://github.com/ceph/ceph-csi</a></li>
</ul>
<h1 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h1><h2 id="集群状态查看"><a href="#集群状态查看" class="headerlink" title="集群状态查看"></a>集群状态查看</h2><ul>
<li><p>集群状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph -s            # 集群运行状态</span><br><span class="line">ceph -w            # 持续监控集群状态</span><br><span class="line">ceph health [detail] # 集群健康详情</span><br><span class="line">ceph df [detail]   # 集群空间使用量</span><br></pre></td></tr></table></figure>
</li>
<li><p>pg状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph pg stat      # pg状态</span><br><span class="line">ceph pg dump      # pg状态详情</span><br></pre></td></tr></table></figure>
</li>
<li><p>pool状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool stats</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>osd状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd df         # 查看osd中的存储容量使用、pg个数、osd状态</span><br><span class="line">ceph osd tree       # 查看节点包含的osd</span><br><span class="line">ceph osd stat       # 查看osd状态【简单】</span><br><span class="line">ceph osd dump       # 查看更详细信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>mon状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph mon stat</span><br><span class="line">ceph mon dump</span><br><span class="line">ceph quorum_status  # 主选举情况</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="集群配置管理-实时"><a href="#集群配置管理-实时" class="headerlink" title="集群配置管理-实时"></a>集群配置管理-实时</h2><p>有时候需要更改服务的配置，但不想重启服务，或者是临时修改。这时候就可以使用tell和daemon子命令来完成此需求。 </p>
<ul>
<li><p>daemon子命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line"># ceph daemon &#123;daemon-type&#125;.&#123;id&#125; config show </span><br><span class="line"></span><br><span class="line">命令举例：</span><br><span class="line"># ceph daemon osd.0 config show </span><br><span class="line"># ceph daemon mon.ceph-monitor-1 config set mon_allow_pool_delete false</span><br></pre></td></tr></table></figure>
</li>
<li><p>tell子命令</p>
<p>使用 tell 的方式适合对整个集群进行设置，使用 * 号进行匹配，就可以对整个集群的角色进行设置。而出现节点异常无法设置时候，只会在命令行当中进行报错，不太便于查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line"># ceph tell &#123;daemon-type&#125;.&#123;daemon id or *&#125; injectargs --&#123;name&#125;=&#123;value&#125; [--&#123;name&#125;=&#123;value&#125;]</span><br><span class="line">命令举例：</span><br><span class="line"># ceph tell osd.0 injectargs --debug-osd 20 --debug-ms 1</span><br></pre></td></tr></table></figure>
<ul>
<li>daemon-type：为要操作的对象类型如osd、mon、mds等。</li>
<li>daemon id：该对象的名称，osd通常为0、1等，mon为ceph -s显示的名称，这里可以输入*表示全部。</li>
<li>injectargs：表示参数注入，后面必须跟一个参数，也可以跟多个</li>
</ul>
</li>
</ul>
<h2 id="集群进程管理"><a href="#集群进程管理" class="headerlink" title="集群进程管理"></a>集群进程管理</h2><p>命令包含start、restart、status</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、启动所有守护进程</span><br><span class="line"># systemctl start ceph.target</span><br><span class="line">2、按类型启动守护进程</span><br><span class="line"># systemctl start ceph-mgr.target</span><br><span class="line"># systemctl start ceph-osd@id</span><br><span class="line"># systemctl start ceph-mon.target</span><br><span class="line"># systemctl start ceph-mds.target</span><br><span class="line"># systemctl start ceph-radosgw.target</span><br></pre></td></tr></table></figure>
<h2 id="MON节点管理-添加和删除"><a href="#MON节点管理-添加和删除" class="headerlink" title="MON节点管理-添加和删除"></a>MON节点管理-添加和删除</h2><p>一个集群可以只有一个 monitor，推荐生产环境至少部署 3 个。 Ceph 使用 Paxos 算法的一个变种对各种 map 、以及其它对集群来说至关重要的信息达成共识。建议（但不是强制）部署奇数个 monitor 。Ceph 需要 mon 中的大多数在运行并能够互相通信，比如单个 mon，或 2 个中的 2 个，3 个中的 2 个，4 个中的 3 个等。初始部署时，建议部署 3 个 monitor。后续如果要增加，请一次增加 2 个。</p>
<ul>
<li>新增一个monitor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph-deploy mon create $hostname</span><br><span class="line">注意：执行ceph-deploy之前要进入之前安装时候配置的目录。/my-cluster</span><br></pre></td></tr></table></figure>
<ul>
<li>删除Monitor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph-deploy mon destroy $hostname</span><br><span class="line">注意： 确保你删除某个 Mon 后，其余 Mon 仍能达成一致。如果不可能，删除它之前可能需要先增加一个。</span><br></pre></td></tr></table></figure>
<h2 id="OSD节点管理-添加和删除"><a href="#OSD节点管理-添加和删除" class="headerlink" title="OSD节点管理-添加和删除"></a>OSD节点管理-添加和删除</h2><ul>
<li><p>添加osd</p>
<p>进入到ceph-deploy执行目录/my-cluster，添加OSD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create --data /dev/sd&lt;id&gt; $hostname</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ceph-volume lvm zap  /dev/sdb --destroy</code>删除ceph-deploy在磁盘上创建的lvm信息，从而可以使硬盘重新加入集群</p>
</blockquote>
</li>
<li><p>删除OSD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、调整osd的crush weight为 0</span><br><span class="line">ceph osd crush reweight osd.&lt;ID&gt; 0.0</span><br><span class="line">ceph osd df #确认osd中没有pgs</span><br><span class="line">ceph -s # 确认集群所有pgs处于active+clean状态</span><br><span class="line">2、将osd进程stop</span><br><span class="line">systemctl stop ceph-osd@&lt;ID&gt;</span><br><span class="line">3、将osd设置out</span><br><span class="line">ceph osd out &lt;ID&gt;</span><br><span class="line">4、立即执行删除OSD中数据</span><br><span class="line">ceph osd purge osd.&lt;ID&gt; --yes-i-really-mean-it</span><br><span class="line">5、卸载磁盘</span><br><span class="line">umount /var/lib/ceph/osd/ceph-？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Pool管理"><a href="#Pool管理" class="headerlink" title="Pool管理"></a>Pool管理</h2><ul>
<li><p>列出存储池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd lspools</span><br><span class="line">ceph osd pool ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建存储池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line"># ceph osd pool create &#123;pool-name&#125; &#123;pg-num&#125; [&#123;pgp-num&#125;]</span><br><span class="line">命令举例：</span><br><span class="line"># ceph osd pool create rbd  32 32</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置存储池配额</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line"># ceph osd pool set-quota &#123;pool-name&#125; [max_objects &#123;obj-count&#125;] [max_bytes &#123;bytes&#125;]</span><br><span class="line">命令举例：</span><br><span class="line"># ceph osd pool set-quota rbd max_objects 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>重命名存储池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool rename &#123;current-pool-name&#125; &#123;new-pool-name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool delete &#123;pool-name&#125; &#123;pool-name&#125; --yes-i-really-really-mean-it</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看存储池统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rados df</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建存储池快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool mksnap &#123;pool-name&#125; &#123;snap-name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储池快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool rmsnap &#123;pool-name&#125; &#123;snap-name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取存储池选项值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool get &#123;pool-name&#125; &#123;key&#125;</span><br></pre></td></tr></table></figure>
<p>范例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool get rbd pg_num  # 查看pg设置</span><br><span class="line">ceph osd pool get rbd size    # 查看副本设置</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整存储池选项值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool set &#123;pool-name&#125; &#123;key&#125; &#123;value&#125;</span><br></pre></td></tr></table></figure>
<p>常见设置选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size：设置存储池中的对象副本数，详情参见设置对象副本数。仅适用于副本存储池。</span><br><span class="line">min_size：设置 I/O 需要的最小副本数，详情参见设置对象副本数。仅适用于副本存储池。</span><br><span class="line">pg_num：计算数据分布时的有效 PG 数。只能大于当前 PG 数。</span><br><span class="line">pgp_num：计算数据分布时使用的有效 PGP 数量。小于等于存储池的 PG 数。</span><br><span class="line">hashpspool：给指定存储池设置/取消 HASHPSPOOL 标志。</span><br><span class="line">target_max_bytes：达到 max_bytes 阀值时会触发 Ceph 冲洗或驱逐对象。</span><br><span class="line">target_max_objects：达到 max_objects 阀值时会触发 Ceph 冲洗或驱逐对象。</span><br><span class="line">scrub_min_interval：在负载低时，洗刷存储池的最小间隔秒数。如果是 0 ，就按照配置文件里的 osd_scrub_min_interval 。</span><br><span class="line">scrub_max_interval：不管集群负载如何，都要洗刷存储池的最大间隔秒数。如果是 0 ，就按照配置文件里的 osd_scrub_max_interval 。</span><br><span class="line">deep_scrub_interval：“深度”洗刷存储池的间隔秒数。如果是 0 ，就按照配置文件里的 osd_deep_scrub_interval 。</span><br></pre></td></tr></table></figure>
<p>范例：调整pg设置(一般为扩容)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool set &#123;pool-name&#125; pg_num 128</span><br><span class="line">ceph osd pool set &#123;pool-name&#125; pgp_num 128 </span><br><span class="line">1、扩容大小取跟它接近的2的N次方  </span><br><span class="line">2、在更改pool的PG数量时，需同时更改PGP的数量。PGP是为了管理placement而存在的专门的PG，它和PG的数量应该保持一致。如果你增加pool的pg_num，就需要同时增加pgp_num，保持它们大小一致，这样集群才能正常rebalancing。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Ceph 把数据以对象的形式存于各存储池中。Ceph 用户必须具有访问存储池的权限才能够读写数据。另外，Ceph 用户必须具有执行权限才能够使用 Ceph 的管理命令。<br>查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有用户信息</span><br><span class="line"># ceph auth list</span><br><span class="line">获取所有用户的key与权限相关信息</span><br><span class="line"># ceph auth get client.admin</span><br><span class="line">如果只需要某个用户的key信息，可以使用pring-key子命令</span><br><span class="line"># ceph auth print-key client.admin</span><br></pre></td></tr></table></figure>
<p>添加用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph auth add client.john mon &apos;allow r&apos; osd &apos;allow rw pool=liverpool&apos;</span><br><span class="line"># ceph auth get-or-create client.paul mon &apos;allow r&apos; osd &apos;allow rw pool=liverpool&apos;</span><br><span class="line"># ceph auth get-or-create client.george mon &apos;allow r&apos; osd &apos;allow rw pool=liverpool&apos; -o george.keyring</span><br><span class="line"># ceph auth get-or-create-key client.ringo mon &apos;allow r&apos; osd &apos;allow rw pool=liverpool&apos; -o ringo.key</span><br></pre></td></tr></table></figure>
<p>修改用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph auth caps client.john mon &apos;allow r&apos; osd &apos;allow rw pool=liverpool&apos;</span><br><span class="line"># ceph auth caps client.paul mon &apos;allow rw&apos; osd &apos;allow rwx pool=liverpool&apos;</span><br><span class="line"># ceph auth caps client.brian-manager mon &apos;allow *&apos; osd &apos;allow *&apos;</span><br><span class="line"># ceph auth caps client.ringo mon &apos; &apos; osd &apos; &apos;</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ceph auth del &#123;TYPE&#125;.&#123;ID&#125;</span><br><span class="line">其中， &#123;TYPE&#125; 是 client，osd，mon 或 mds 的其中一种。&#123;ID&#125; 是用户的名字或守护进程的 ID 。</span><br></pre></td></tr></table></figure>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="nearfull-osd-s-or-pool-s-nearfull"><a href="#nearfull-osd-s-or-pool-s-nearfull" class="headerlink" title="nearfull osd(s) or pool(s) nearfull"></a>nearfull osd(s) or pool(s) nearfull</h2><p>此时说明部分osd的存储已经超过阈值，mon会监控ceph集群中OSD空间使用情况。如果要消除WARN,可以修改这两个参数，提高阈值，但是通过实践发现并不能解决问题，可以通过观察osd的数据分布情况来分析原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;mon_osd_full_ratio&quot;: &quot;0.95&quot;,</span><br><span class="line">&quot;mon_osd_nearfull_ratio&quot;: &quot;0.85&quot;</span><br></pre></td></tr></table></figure>
<p>（1）自动处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd reweight-by-utilization</span><br><span class="line">ceph osd reweight-by-pg 105 cephfs_data(pool_name)</span><br></pre></td></tr></table></figure>
<p>（2）手动处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd reweight osd.2 0.8</span><br></pre></td></tr></table></figure>
<p>（3）利用balancer插件自动处理【nautilus版本中功能总是开启】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph mgr module ls|grep -C5 balancer</span><br><span class="line">ceph balancer on</span><br><span class="line">ceph balancer mode crush-compat</span><br><span class="line">ceph config-key set &quot;mgr/balancer/max_misplaced&quot;: &quot;0.01&quot;</span><br></pre></td></tr></table></figure>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><h2 id="PG状态"><a href="#PG状态" class="headerlink" title="PG状态"></a>PG状态</h2><p>PG状态概述<br>一个PG在它的生命周期的不同时刻可能会处于以下几种状态中:</p>
<p>Creating(创建中)<br>在创建POOL时,需要指定PG的数量,此时PG的状态便处于creating,意思是Ceph正在创建PG。</p>
<p>Peering(互联中)<br>peering的作用主要是在PG及其副本所在的OSD之间建立互联,并使得OSD之间就这些PG中的object及其元数据达成一致。</p>
<p>Active(活跃的)<br>处于该状态意味着数据已经完好的保存到了主PG及副本PG中,并且Ceph已经完成了peering工作。</p>
<p>Clean(整洁的)<br>当某个PG处于clean状态时,则说明对应的主OSD及副本OSD已经成功互联,并且没有偏离的PG。也意味着Ceph已经将该PG中的对象按照规定的副本数进行了复制操作。</p>
<p>Degraded(降级的)<br>当某个PG的副本数未达到规定个数时,该PG便处于degraded状态,例如:</p>
<p>在客户端向主OSD写入object的过程,object的副本是由主OSD负责向副本OSD写入的,直到副本OSD在创建object副本完成,并向主OSD发出完成信息前,该PG的状态都会一直处于degraded状态。又或者是某个OSD的状态变成了down,那么该OSD上的所有PG都会被标记为degraded。<br>当Ceph因为某些原因无法找到某个PG内的一个或多个object时,该PG也会被标记为degraded状态。此时客户端不能读写找不到的对象,但是仍然能访问位于该PG内的其他object。</p>
<p>Recovering(恢复中)<br>当某个OSD因为某些原因down了,该OSD内PG的object会落后于它所对应的PG副本。而在该OSD重新up之后,该OSD中的内容必须更新到当前状态,处于此过程中的PG状态便是recovering。</p>
<p>Backfilling(回填)<br>当有新的OSD加入集群时,CRUSH会把现有集群内的部分PG分配给它。这些被重新分配到新OSD的PG状态便处于backfilling。</p>
<p>Remapped(重映射)<br>当负责维护某个PG的acting set变更时,PG需要从原来的acting set迁移至新的acting set。这个过程需要一段时间,所以在此期间,相关PG的状态便会标记为remapped。</p>
<p>Stale(陈旧的)<br>默认情况下,OSD守护进程每半秒钟便会向Monitor报告其PG等相关状态,如果某个PG的主OSD所在acting set没能向Monitor发送报告,或者其他的Monitor已经报告该OSD为down时,该PG便会被标记为stale。</p>
<h2 id="OSD状态"><a href="#OSD状态" class="headerlink" title="OSD状态"></a>OSD状态</h2><p>单个OSD有两组状态需要关注,其中一组使用in/out标记该OSD是否在集群内,另一组使用up/down标记该OSD是否处于运行中状态。两组状态之间并不互斥,换句话说,当一个OSD处于“in”状态时,它仍然可以处于up或down的状态。</p>
<p>OSD状态为in且up<br>这是一个OSD正常的状态,说明该OSD处于集群内,并且运行正常。</p>
<p>OSD状态为in且down<br>此时该OSD尚处于集群中,但是守护进程状态已经不正常,默认在300秒后会被踢出集群,状态进而变为out且down,之后处于该OSD上的PG会迁移至其它OSD。</p>
<p>OSD状态为out且up<br>这种状态一般会出现在新增OSD时,意味着该OSD守护进程正常,但是尚未加入集群。</p>
<p>OSD状态为out且down<br>在该状态下的OSD不在集群内,并且守护进程运行不正常,CRUSH不会再分配PG到该OSD上。集群规划</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式存储-glusterfs</title>
    <url>/blog/2020/03/18/%E5%AE%B9%E5%99%A8%E5%8C%96/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8-glusterfs/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在实践kubernetes的statefulset及各种需要持久存储的功能时，通常需要用到PV的动态供给功能，而glusterfs就是这样一种可以提供动态供给功能的存储系统  </p>
<h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>ip地址</th>
<th>角色</th>
</tr>
</thead>
<tbody>
<tr>
<td>node1</td>
<td>172.17.8.101</td>
<td>glusterfs</td>
</tr>
<tr>
<td>node2</td>
<td>172.17.8.102</td>
<td>glusterfs</td>
</tr>
<tr>
<td>node3</td>
<td>172.17.8.103</td>
<td>glusterfs,heketi</td>
</tr>
</tbody>
</table>
<h1 id="部署glusterfs"><a href="#部署glusterfs" class="headerlink" title="部署glusterfs"></a>部署glusterfs</h1><ul>
<li><p>安装软件【三个节点都进行】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install centos-release-gluster -y</span><br><span class="line">yum --enablerepo=centos-gluster*-test install glusterfs-server -y</span><br><span class="line">systemctl start glusterd.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>在任意节点使用命令“发现”其他节点【例如node1】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gluster peer probe node2</span><br><span class="line">gluster peer probe node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看集群状态:<code>gluster peer status</code></p>
</li>
</ul>
<h1 id="部署heketi"><a href="#部署heketi" class="headerlink" title="部署heketi"></a>部署heketi</h1><p>heketi为管理glusterfs存储卷的生命周期提供了一个RESTful管理接口，<br>借助于heketi，kubernetes可以动态调配glusterfs存储卷；<br>在heketi中注册的设备(device)可以是裸分区或裸磁盘  </p>
<h2 id="安装heketi"><a href="#安装heketi" class="headerlink" title="安装heketi"></a>安装heketi</h2><ul>
<li>添加仓库：<code>wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></li>
<li>安装程序：<code>yum install heketi heketi-client</code></li>
</ul>
<h2 id="配置heketi到glusterfs的ssh"><a href="#配置heketi到glusterfs的ssh" class="headerlink" title="配置heketi到glusterfs的ssh"></a>配置heketi到glusterfs的ssh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -q -f /etc/heketi/heketi_key -N &apos;&apos;</span><br><span class="line">chmod 0600 /etc/heketi/heketi_key.pub </span><br><span class="line">chown heketi.heketi /etc/heketi/heketi_key*</span><br><span class="line">ssh-copy-id -i /etc/heketi/heketi_key.pub root@172.17.8.103</span><br><span class="line">ssh-copy-id -i /etc/heketi/heketi_key.pub root@172.17.8.102</span><br><span class="line">ssh-copy-id -i /etc/heketi/heketi_key.pub root@172.17.8.101</span><br></pre></td></tr></table></figure>
<h2 id="heketi配置文件"><a href="#heketi配置文件" class="headerlink" title="heketi配置文件"></a>heketi配置文件</h2><blockquote>
<p>/etc/heketi/heketi.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;port&quot;: &quot;8080&quot;, # 服务端口</span><br><span class="line">  &quot;use_auth&quot;: true, # 开启认证</span><br><span class="line">  &quot;jwt&quot;: &#123;</span><br><span class="line">    &quot;admin&quot;: &#123; #管理员及密码</span><br><span class="line">      &quot;key&quot;: &quot;admin secret&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;key&quot;: &quot;My Secret&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;glusterfs&quot;: &#123; #heketi管理glusterfs的方式</span><br><span class="line">    &quot;executor&quot;: &quot;ssh&quot;,</span><br><span class="line">    &quot;sshexec&quot;: &#123;</span><br><span class="line">      &quot;keyfile&quot;: &quot;/etc/heketi/heketi_key&quot;,</span><br><span class="line">      &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">      &quot;port&quot;: &quot;22&quot;,</span><br><span class="line">      &quot;fstab&quot;: &quot;/etc/fstab&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;db&quot;: &quot;/var/lib/heketi/heketi.db&quot;, #heketi数据库</span><br><span class="line">    &quot;loglevel&quot; : &quot;debug&quot; #日志</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动heketi服务"><a href="#启动heketi服务" class="headerlink" title="启动heketi服务"></a>启动heketi服务</h2><ul>
<li>systemctl enable heketi</li>
<li>systemctl start heketi</li>
</ul>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><ul>
<li>curl方式：<code>curl http://node3:8080/hello</code></li>
<li>内置命令：<code>heketi-cli --server http://node3:8080 --user admin --secret &quot;admin secret&quot; cluster list</code></li>
</ul>
<h1 id="heketi添加glusterfs"><a href="#heketi添加glusterfs" class="headerlink" title="heketi添加glusterfs"></a>heketi添加glusterfs</h1><ul>
<li><p>拓扑配置【/etc/heketi/heketi-topology.json】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;clusters&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;nodes&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;node&quot;: &#123;</span><br><span class="line">                        &quot;hostnames&quot;: &#123;</span><br><span class="line">                            &quot;manage&quot;: [&quot;172.17.8.101&quot;],</span><br><span class="line">                            &quot;storage&quot;: [&quot;172.17.8.101&quot;]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;zone&quot;: 1</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;devices&quot;: [&quot;/dev/sdb&quot;, &quot;/dev/sdc&quot;]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;node&quot;: &#123;</span><br><span class="line">                        &quot;hostnames&quot;: &#123;</span><br><span class="line">                            &quot;manage&quot;: [&quot;172.17.8.102&quot;],</span><br><span class="line">                            &quot;storage&quot;: [&quot;172.17.8.102&quot;]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;zone&quot;: 1</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;devices&quot;: [&quot;/dev/sdb&quot;, &quot;/dev/sdc&quot;]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;node&quot;: &#123;</span><br><span class="line">                        &quot;hostnames&quot;: &#123;</span><br><span class="line">                            &quot;manage&quot;: [&quot;172.17.8.103&quot;],</span><br><span class="line">                            &quot;storage&quot;: [&quot;172.17.8.103&quot;]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;zone&quot;: 1</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;devices&quot;: [&quot;/dev/sdb&quot;, &quot;/dev/sdc&quot;]</span><br><span class="line">                &#125;                </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>heketi添加glusterfs拓扑配置：<code>heketi-cli -s http://node3:8080 --user admin --secret &quot;admin secret&quot; topology load --json=/etc/heketi/heketi-topology.json</code></p>
</li>
<li>信息查看：<ul>
<li>查看集群信息：cluster list|cluster info ced9fc3405909cda59dd36101afea898</li>
<li>查看节点信息：node list|node info 96a281a85ce8cc8a97a74c88c9173442</li>
<li>存储卷信息：volume list</li>
</ul>
</li>
<li>测试<ul>
<li>创建存储卷：volume create –size=5</li>
<li>删除存储卷：volume delete volume_id</li>
</ul>
</li>
</ul>
<h1 id="k8s中使用glusterfs"><a href="#k8s中使用glusterfs" class="headerlink" title="k8s中使用glusterfs"></a>k8s中使用glusterfs</h1><h2 id="创建storageclass"><a href="#创建storageclass" class="headerlink" title="创建storageclass"></a>创建storageclass</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: glusterfs</span><br><span class="line">provisioner: kubernetes.io/glusterfs</span><br><span class="line">parameters:</span><br><span class="line">  resturl: &quot;http://172.17.8.103:8080&quot;</span><br><span class="line">  clusterid: &quot;ced9fc3405909cda59dd36101afea898&quot;</span><br><span class="line">  restauthenabled: &quot;true&quot;</span><br><span class="line">  restuser: &quot;admin&quot;</span><br><span class="line">  restuserkey: &quot;admin secret&quot;</span><br><span class="line">  # secretNamespace: &quot;default&quot;</span><br><span class="line">  # secretName: &quot;heketi-secret&quot;</span><br><span class="line">  volumetype: &quot;replicate:2&quot;</span><br></pre></td></tr></table></figure>
<h2 id="创建pvc"><a href="#创建pvc" class="headerlink" title="创建pvc"></a>创建pvc</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: myclaim</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: &quot;glusterfs&quot;</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>glusterfs</tag>
        <tag>heketi</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机管理-vagrant</title>
    <url>/blog/2019/11/18/%E5%AE%B9%E5%99%A8%E5%8C%96/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86-vagrant/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">简介</a></h1><ul>
<li>vagrant是一个命令行下的虚拟机管理程序，默认使用virtualbox(内置于vagrant)作为后台虚拟化技术，但也可以使用其他虚拟化技术（比如VirtualBox、Docker、Vmware、Hyper-V等）</li>
<li>软件安装<ul>
<li><a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">vagrant下载与安装</a></li>
<li><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox下载与安装</a></li>
</ul>
</li>
<li>存储位置设置<ul>
<li>box镜像位置(vagrant管理)：设置变量VAGRANT_HOME</li>
<li>虚拟机位置(virtualbox管理)：vboxmanage setproperty machinefolder “D:\virtualbox\vbox_home”</li>
</ul>
</li>
</ul>
<h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><ul>
<li><a href="#box管理">添加box</a></li>
<li>建立目录并进入：mkdir test &amp;&amp; cd test</li>
<li>创建Vagrantfile：vagant init box_name</li>
<li><a href="#Vagrantfile">配置Vagrantfile</a></li>
<li>启动虚拟机：vagrant up</li>
<li>进入虚拟机：vagrant ssh</li>
</ul>
<h1 id="box管理"><a href="#box管理" class="headerlink" title="box管理"></a>box管理</h1><ul>
<li>作用：作为运行中虚拟机的基础镜像（类似docker的镜像）</li>
<li>box镜像下载<ul>
<li><a href="http://cloud-images.ubuntu.com/" target="_blank" rel="noopener">ubuntu系列下载</a></li>
<li><a href="http://cloud.centos.org/" target="_blank" rel="noopener">centos系列下载</a></li>
</ul>
</li>
<li>命令：<ul>
<li>添加box：vagrant box add 【box_name local.box】、URL、username/box<ul>
<li>可以使用本地box文件【local.box】</li>
<li>可以指定远程的下载地址【URL】</li>
<li>可以指定<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">vagrantcloud</a>上的box【username/box】</li>
</ul>
</li>
<li>查看box列表：vagrant box list</li>
<li>删除box：vagrant box remove box_name</li>
</ul>
</li>
</ul>
<h1 id="虚拟机管理"><a href="#虚拟机管理" class="headerlink" title="虚拟机管理"></a>虚拟机管理</h1><ul>
<li>vagrant up：启动虚拟机<ul>
<li>如果本地没有box，则从远程下载box镜像</li>
<li>启动后，默认将宿主机Vagrantfile所在目录映射到/vagrant</li>
</ul>
</li>
<li>vagrant ssh：登录虚拟机</li>
<li>vagrant halt：关闭虚拟机</li>
<li>vagrant status：查看虚拟机状态</li>
<li>vagrant destroy：销毁虚拟机</li>
<li>vagrant package：打包运行中的虚拟机到一个box</li>
<li>vagrant reload：以新的配置文件重启虚拟机</li>
<li>vagrant resume：恢复一个挂起的虚拟机【vagrant up也可以恢复一个挂起的虚拟机】</li>
<li>vagrant suspend：挂起一个虚拟机</li>
<li>vagrant validate：检测Vagrantfile语法</li>
<li>vagrant snapshot：快照管理<ul>
<li>list：显示快照列表</li>
<li>save [vm_name] snapshot_name：保存快照</li>
<li>restore [vm_name]  snapshot_name：恢复快照</li>
<li>delete [vm_name] snapshot_name：删除快照</li>
</ul>
</li>
</ul>
<h1 id="插件管理-scp"><a href="#插件管理-scp" class="headerlink" title="插件管理-scp"></a>插件管理-scp</h1><ul>
<li>查看已安装插件列表：vagrant plugin list</li>
<li>安装插件(scp)：vagrant plugin install vagrant-scp</li>
<li>scp命令使用<ul>
<li>vagrant scp ..\docker-k8s-devops node1:~/docker-k8s-devops</li>
<li>注解：vagrant scp 源文件或目录名 虚拟机名称(Vagrantfile包含多机时):目标文件或目录名</li>
<li>注意事项：<ul>
<li>windows下不支持将跨盘符的文件或目录复制到虚拟机</li>
<li>不在当前目录进行复制操作时，需要指定复制的目标文件或目录名（不指定时，复制的目标文件或目录名会包含源路径）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h1><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><ul>
<li>端口转发（宿主机4567映射虚拟机80）：<code>config.vm.network :forwarded_port, guest: 80, host: 4567</code></li>
<li>设置公网ip（桥接模式）：<code>config.vm.network :public_network, ip: &quot;10.150.20.180&quot;</code></li>
<li>设置私有ip（host-only模式）：<code>config.vm.network &quot;private_network&quot;, ip: &quot;192.168.31.150&quot;</code></li>
</ul>
<h2 id="目录映射"><a href="#目录映射" class="headerlink" title="目录映射"></a>目录映射</h2><ul>
<li>设置：config.vm.synced_folder “src/“, “/srv/website”【src为宿主机目录，website为虚拟机目录】</li>
</ul>
<h2 id="虚拟化后台provider"><a href="#虚拟化后台provider" class="headerlink" title="虚拟化后台provider"></a>虚拟化后台provider</h2><h3 id="cpu和内存设置"><a href="#cpu和内存设置" class="headerlink" title="cpu和内存设置"></a>cpu和内存设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.vm.provider :virtualbox do |vb|</span><br><span class="line">    vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, &quot;1024&quot;, &quot;--cpus&quot;, &quot;4&quot;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="多机设置"><a href="#多机设置" class="headerlink" title="多机设置"></a>多机设置</h3><p>可以在一个Vagrantfile中配置多个虚拟机<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.vm.define &quot;web&quot;, primary: true do |web| #设置此机为默认主机</span><br><span class="line">  web.vm.box = &quot;ubuntu&quot;</span><br><span class="line">  web.vm.provision :shell, inline: &quot;echo web&quot;</span><br><span class="line">  web.vm.provider &quot;virtualbox&quot; do |vb|</span><br><span class="line">    vb.memory = &quot;1024&quot;</span><br><span class="line">    vb.cpus = &quot;1&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">config.vm.define &quot;db&quot;, autostart: false do |db| #设置此机默认不启动</span><br><span class="line">  db.vm.box = &quot;ubuntu&quot;</span><br><span class="line">  db.vm.provision :shell, inline: &quot;echo db&quot;</span><br><span class="line">  db.vm.provider &quot;virtualbox&quot; do |vb|</span><br><span class="line">    vb.memory = &quot;512&quot;</span><br><span class="line">    vb.cpus = &quot;1&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="使用docker作为虚拟化后台"><a href="#使用docker作为虚拟化后台" class="headerlink" title="使用docker作为虚拟化后台"></a>使用docker作为虚拟化后台</h3><ul>
<li><p>Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">COPY sources.list /etc/apt/sources.list</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y openjdk-7-jdk git wget</span><br><span class="line">RUN ln -fs /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java /etc/alternatives/java</span><br><span class="line">RUN mkdir -p /usr/local/vertx &amp;&amp; cd /usr/local/vertx &amp;&amp; \</span><br><span class="line">wget http://dl.bintray.com/vertx/downloads/vert.x-2.1.2.tar.gz -qO -|tar -xz</span><br><span class="line">ENV PATH /usr/local/vertx/vert.x-2.1.2/bin:$PATH</span><br><span class="line">RUN mkdir -p /usr/local/src</span><br><span class="line">WORKDIR /usr/local/src</span><br><span class="line">CMD [&quot;bash&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vagrantfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV[&apos;VAGRANT_DEFAULT_PROVIDER&apos;] = &apos;docker&apos;</span><br><span class="line">Vagrant.configure(&apos;2&apos;) do |config|</span><br><span class="line">  config.vm.define &quot;vertxdev&quot; do |a|</span><br><span class="line">    a.vm.provider &quot;docker&quot; do |d|</span><br><span class="line">      d.build_dir = &quot;.&quot;</span><br><span class="line">      d.build_args = [&apos;-t=vertxdev&apos;]</span><br><span class="line">      d.ports = [&quot;8080:8080&quot;]</span><br><span class="line">      d.name = &quot;vertxdev&quot;</span><br><span class="line">      d.remains_running = true</span><br><span class="line">      d.cmd = [&quot;vertx&quot;, &quot;run&quot;, &quot;vertx-examples/src/raw/java/httphelloworld/HelloWorldServer.java&quot;]</span><br><span class="line">      d.volumes = [&quot;/home/show/docker/vertx:/usr/local/src&quot;]</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像：vagrant docker-run vertxdev – git clone <a href="https://github.com/vert-x/vertx-examples.git" target="_blank" rel="noopener">https://github.com/vert-x/vertx-examples.git</a></p>
</li>
<li>启动虚拟机：vagrant up</li>
<li>查看日志：vagrant docker-logs</li>
</ul>
<h2 id="初始化工具Provision"><a href="#初始化工具Provision" class="headerlink" title="初始化工具Provision"></a>初始化工具Provision</h2><ul>
<li>作用：provision可以看作初始化系统的工具 </li>
<li>运行：<ul>
<li>在第一次启动(vagrant up)时自动执行</li>
<li>在vm运行时使用vagrant provision执行</li>
<li>重启时使用vagrant reload –provision 执行 </li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li><p>使用shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.vm.provision &quot;shell&quot;, inline: &quot;route add default gw 10.10.10.254&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;, inline: &quot;route del default gw 10.0.2.2&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;, path: &quot;script.sh&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ansible</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.vm.provision :ansible do |ansible|</span><br><span class="line"> ansible.host_key_checking = false</span><br><span class="line"> ansible.playbook = &quot;ansible/playbook.yml&quot;</span><br><span class="line"> ansible.inventory_path= &quot;ansible/hosts&quot;</span><br><span class="line"> ansible.sudo = true</span><br><span class="line"> ansible.verbose = &apos;vvv&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h2><ul>
<li>进入VirtualBox\ VMs下的虚拟机目录  </li>
<li>克隆vmdk类型磁盘为vdi类型[因为其可调整大小]<br><code>vboxmanage clonehd box-disk1.vmdk clone-disk1.vdi --format vdi</code>  </li>
<li>磁盘扩容[以Mb为单位]<br><code>vboxmanage modifyhd clone-disk1.vdi --resize 1048576</code>  </li>
<li>将调整的磁盘绑定在控制器上  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vboxmanage storageattach mg-s1_default_1414060662361_97909 --storagectl &quot;SATA Controller&quot; --port 0 --device 0 --type hdd --medium clone-disk1.vdi</span><br></pre></td></tr></table></figure>
<ul>
<li>虚拟机磁盘控制器查看:<br><code>vboxmanage showvminfo mg-s1_default_1414060662361_97909 |grep &quot;Storage&quot;</code></li>
</ul>
<h2 id="增加磁盘"><a href="#增加磁盘" class="headerlink" title="增加磁盘"></a>增加磁盘</h2><p><strong>虚拟机必须先存在,后通过更改Vagrantfile配置增加磁盘</strong><br>Vagrantfile配置:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.vm.provider &quot;virtualbox&quot; do |vb|</span><br><span class="line">    vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;vd1.vdi&quot;, &quot;--size&quot;, &quot;20480&quot;]</span><br><span class="line">    vb.customize [&quot;storageattach&quot;, &quot;test&quot;, &quot;--storagectl&quot;, &quot;SATA Controller&quot;, &quot;--port&quot;, &quot;1&quot;, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;vd1.vdi&quot;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="win10启动错误"><a href="#win10启动错误" class="headerlink" title="win10启动错误"></a>win10启动错误</h2><ul>
<li><p>现象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stderr: VBoxManage.exe: error: Call to WHvSetupPartition failed: ERROR_SUCCE</span><br><span class="line">VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：关闭windows系统的虚拟化相关程序【程序和功能-》启动或关闭windows功能】，如：containers、hyper-v、windows沙盒、虚拟机平台</p>
</li>
</ul>
<h2 id="虚拟机无法挂载文件系统"><a href="#虚拟机无法挂载文件系统" class="headerlink" title="虚拟机无法挂载文件系统"></a>虚拟机无法挂载文件系统</h2><ul>
<li><p>错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to mount folders in Linux guest. This is usually because the &quot;vboxsf&quot; file system is not available.   </span><br><span class="line">Please verify that the guest additions are properly installed in the guest and can work properly.   </span><br><span class="line">The command attempted was: mount -t vboxsf -o uid=id -u vagrant,gid=getent group vagrant | cut -d: -f3 vagrant /vagrant mount -t vboxsf -o uid=id -u vagrant,gid=id -g vagrant vagrant /vagrant   </span><br><span class="line">The error output from the last command was: stdin: is not a tty /sbin/mount.vboxsf: mounting failed with the error: No such device</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案</p>
<ul>
<li>虚拟机安装软件：sudo apt-get install virtualbox-guest-utils</li>
<li>重启虚拟机：vagrant reload</li>
</ul>
</li>
</ul>
<h2 id="虚拟机连接超时"><a href="#虚拟机连接超时" class="headerlink" title="虚拟机连接超时"></a>虚拟机连接超时</h2><ul>
<li><p>错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default: Error: Connection timeout. Retrying...</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://stackoverflow.com/questions/22575261/vagrant-stuck-connection-timeout-retrying" target="_blank" rel="noopener">解决</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vboxmanage list runningvms</span><br><span class="line">vboxmanage controlvm new_3_default_1446007372853_19687 keyboardputscancode 1c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/fjb2080/article/details/8926282" target="_blank" rel="noopener">linux下用vmware-mount挂载vmdk虚拟硬盘分区</a></li>
<li><a href="https://xliska.wordpress.com/2010/09/29/access-lvm2-partition-on-vmware-virtual-disk/" target="_blank" rel="noopener">如何访问vmdk磁盘上的lvm分区</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>服务网格-Istio</title>
    <url>/blog/2020/09/22/%E5%AE%B9%E5%99%A8%E5%8C%96/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-Istio/</url>
    <content><![CDATA[<h1 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h1><p>Service Mesh 的中文译为 “服务网格” ，是一个用于处理服务与服务之间<strong>通信的基础设施层</strong>，它负责为构建复杂的云原生应用<strong>传递可靠的网络请求</strong>。在实践中，它是一组和应用服务部署在一起的轻量级的<strong>网络代理</strong>，并且对应用服务<strong>透明</strong>。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。</p>
<p>第一，微服务治理与业务逻辑的解耦。服务网格把 SDK 中的<strong>大部分</strong>能力从应用中剥离出来，拆解为独立进程，以 sidecar的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</p>
<p>第二，异构系统的统一治理。通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。</p>
<p>此外，服务网格相对于传统微服务框架，还拥有三大技术优势：</p>
<ul>
<li>可观察性。因为服务网格是一个专用的基础设施层，所有的服务间通信都要通过它，所以它在技术堆栈中处于独特的位置，以便在服务调用级别上提供统一的监控指标。</li>
<li><p>流量控制。通过Service Mesh，可以为服务提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力。</p>
</li>
<li><p>安全。服务网格的安全相关的好处主要体现在以下三个核心领域：服务的认证、服务间通讯的加密、安全相关策略的强制执行。</p>
</li>
</ul>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul>
<li>增加了复杂度。服务网格将 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 代理和其它组件引入到已经很复杂的分布式环境中，会极大地增加整体链路和操作运维的复杂性。</li>
<li>运维人员需要更专业。在容器编排器（如 Kubernetes）上添加 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="noopener">Istio</a> 之类的服务网格，通常需要运维人员成为这两种技术的专家，以便充分使用二者的功能以及定位环境中遇到的问题。</li>
<li>延迟。从链路层面来讲，服务网格是一种侵入性的、复杂的技术，会为系统调用增加显著的延迟。这个延迟是毫秒级别的，但是在特殊业务场景下，这个延迟可能也是难以容忍的。</li>
<li>平台的适配。服务网格的侵入性迫使开发人员和运维人员适应高度自治的平台并遵守平台的规则。</li>
</ul>
<h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a><a href="https://istio.io/" target="_blank" rel="noopener">Istio</a></h1><p>Istio是Service Mesh的落地产品</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>流量管理(connect)：负载均衡、灰度发布、流量管理</li>
<li>安全(security)：认证、授权、证书管理</li>
<li>策略控制(policy)【不建议使用/功能逐步启用】：限流、ACL</li>
<li>可观察性(observe)：监控、调用链</li>
</ul>
<h2 id="与k8s的区别"><a href="#与k8s的区别" class="headerlink" title="与k8s的区别"></a>与k8s的区别</h2><p>k8s（部署运维）：应用部署、资源共享、资源隔离、弹性伸缩</p>
<p>Istio（服务治理）：流量管控、熔断限流、动态路由、链路追踪</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="noopener">Istio</a> 的架构由两部分组成，分别是数据平面（<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#data-plane" target="_blank" rel="noopener">Data Plane</a>）和控制平面（<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#control-plane" target="_blank" rel="noopener">Control Plane</a>）。</p>
<p><strong>数据平面</strong></p>
<p>由整个网格内的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 代理组成，这些代理以 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 的形式和应用服务一起部署。每一个 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 会接管进入和离开服务的流量，并配合控制平面完成流量控制等方面的功能。可以把数据平面看做是网格内 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 代理的网络拓扑集合。</p>
<p><strong>控制平面</strong></p>
<p>顾名思义，就是控制和管理数据平面中的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="noopener">sidecar</a> 代理，完成配置的分发、服务发现、和授权鉴权等功能。架构中拥有控制平面的优势在于，可以统一的对数据平面进行管理。在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="noopener">Istio</a> 1.5 版本中，控制平面由原来分散的、独立部署的几个组件整合为一个单体结构 istiod，变成了一个单进程、多模块的组织形态。</p>
<p><img src="https://www.servicemesher.com/istio-handbook/images/istio-mesh-arch.png" alt></p>
<p>主要实现组件如下：</p>
<h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>Istio使用Envoy代理的扩展版本。Envoy是使用C ++开发的高性能代理，网格内服务发送和接收的所有流量（data plane流量）都经由 Envoy 代理。Envoy代理是与数据平面流量交互的唯一Istio组件。Envoy代理被部署为服务的辅助工具，通过Envoy的许多内置功能在逻辑上增强了服务，例如：</p>
<ul>
<li>Dynamic service discovery：动态服务发现</li>
<li>Load balancing：负载均衡</li>
<li>TLS termination：tls加密通信</li>
<li>HTTP/2 and gRPC proxies：http/2和grpc代理</li>
<li>Circuit breakers：断路器</li>
<li>Health checks：健康检查</li>
<li>Staged rollouts with %-based traffic split：基于流量百分比切分的概率发布</li>
<li>Fault injection：故障注入</li>
<li>Rich metrics：丰富的指标数据</li>
</ul>
<h3 id="Istiod"><a href="#Istiod" class="headerlink" title="Istiod"></a>Istiod</h3><p>整合旧版本pilot、citadel、galley的功能，以单进程、多模块的组织形态提供<strong>服务发现、配置管理、证书管理</strong>功能</p>
<h1 id="核心功能-流量管理"><a href="#核心功能-流量管理" class="headerlink" title="核心功能-流量管理"></a>核心功能-流量管理</h1><p>为了在网格中导流，Istio 需要知道所有的 endpoint 在哪以及属于哪个服务。为了填充自己的服务注册表，Istio连接到服务发现系统。例如，如果您在 Kubernetes 集群上安装了 Istio，那么它将自动检测该集群中的service和endpoint。</p>
<h2 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h2><p>用户指定的目标或是路由规则设定的目标，定义将流量如何路由到给定目标地址；位于k8s中service的上一层或同一层，匹配服务网格内对service或指定域名、ip的访问。</p>
<ul>
<li><p>hosts可以是 IP 地址、DNS 名称，或者依赖于平台的一个简称（例如 Kubernetes 服务的短名称）；hosts 字段实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址；可以使用通配符（“*”）前缀，创建一组匹配所有服务的路由规则</p>
</li>
<li><p>http字段(使用tcp、tls来匹配tcp、tls流量)包含了虚拟服务的路由规则：</p>
<ul>
<li>match字段用来描述访问hosts的HTTP/1.1、HTTP2 和 gRPC 等流量的特征；可以在流量端口、header 字段、URI 等内容上设置匹配条件。</li>
<li>route字段包含了指定的请求要流向哪个目标地址</li>
<li>destination的host必须是存在于 Istio 服务注册中心的实际目标地址；可以是一个有代理的service，或者是一个通过Service Entry被添加进来的非网格服务。</li>
</ul>
</li>
</ul>
<p>路由规则优先级：<strong>路由规则</strong>按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级。本示例中，不满足第一个路由规则的流量均流向一个默认的目标，该目标在第二条规则中指定。因此，第二条规则没有 match 条件，直接将流量导向 v3 子集。</p>
<p>更多的路由路由规则：您可以使用 AND 向同一个 <code>match</code> 块添加多个匹配条件，或者使用 OR 向同一个规则添加多个 <code>match</code> 块。对于任何给定的虚拟服务也可以有多个路由规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">spec:</span><br><span class="line">  hosts:                            </span><br><span class="line">  - reviews</span><br><span class="line">  http:                              </span><br><span class="line">  - match:                           </span><br><span class="line">    - headers:</span><br><span class="line">        end-user:</span><br><span class="line">          exact: jason</span><br><span class="line">    route:                           </span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews                 # service名称</span><br><span class="line">        subset: v2                    # DestinationRule中定义的service下的不同工作负载(deployment/pod)</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v3</span><br></pre></td></tr></table></figure>
<h2 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h2><p>定义目标(service)的不同工作负载(deployment)、目标(service)到工作负载的负载均衡、tls安全、连接池等策略；位于service和pod中间的一层，实现的是kube-proxy的功能；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: DestinationRule</span><br><span class="line">metadata:</span><br><span class="line">  name: my-destination-rule</span><br><span class="line">spec:</span><br><span class="line">  host: my-svc             # service名称</span><br><span class="line">  trafficPolicy:           # 负载均衡策略</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: RANDOM</span><br><span class="line">  subsets:</span><br><span class="line">  - name: v1               # service的其中一个的工作负载名称</span><br><span class="line">    labels:                # 这个工作负载基于deployment/pod标签名称定义</span><br><span class="line">      version: v1</span><br><span class="line">  - name: v2</span><br><span class="line">    labels:</span><br><span class="line">      version: v2</span><br><span class="line">    trafficPolicy:</span><br><span class="line">      loadBalancer:</span><br><span class="line">        simple: ROUND_ROBIN</span><br><span class="line">  - name: v3</span><br><span class="line">    labels:</span><br><span class="line">      version: v3</span><br></pre></td></tr></table></figure>
<h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>管理进出网格的流量。网关被配置为运行在网格边界的独立 Envoy 代理（<code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code>），而不是服务工作负载的 sidecar 代理。和k8s中的ingress功能类似，部署时使用LoadBalancer类型的service资源，如果没有对接云厂商LB，可以使用NodePort访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: ext-host-gwy</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: my-gateway-controller</span><br><span class="line">  servers:             # 在网关处，匹配来自外部访问https://ext-host.example.com的流量</span><br><span class="line">  - port:</span><br><span class="line">      number: 443</span><br><span class="line">      name: https</span><br><span class="line">      protocol: HTTPS</span><br><span class="line">    hosts:                </span><br><span class="line">    - ext-host.example.com</span><br><span class="line">    tls:</span><br><span class="line">      mode: SIMPLE</span><br><span class="line">      serverCertificate: /tmp/tls.crt</span><br><span class="line">      privateKey: /tmp/tls.key</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: virtual-svc</span><br><span class="line">spec:                  # 在虚拟服务处，匹配来自网关ext-host-gwy中访问ext-host.example.com的流量</span><br><span class="line">  hosts:</span><br><span class="line">  - ext-host.example.com</span><br><span class="line">  gateways:  </span><br><span class="line">    - ext-host-gwy</span><br></pre></td></tr></table></figure>
<h2 id="Service-Entry"><a href="#Service-Entry" class="headerlink" title="Service Entry"></a>Service Entry</h2><p>添加一个入口到 Istio 内部维护的服务注册中心。添加了服务入口后，Envoy 代理可以向服务发送流量，就好像它是网格内部的服务一样。配置服务入口允许您管理运行在网格外的服务的流量。，它包括以下几种能力：</p>
<ul>
<li>为外部目标 redirect 和转发请求，例如来自 web 端的 API 调用，或者流向遗留老系统的服务。</li>
<li>为外部目标定义<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/#retries" target="_blank" rel="noopener">重试</a>、<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/#timeouts" target="_blank" rel="noopener">超时</a>和<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/#fault-injection" target="_blank" rel="noopener">故障注入</a>策略。</li>
<li>添加一个运行在虚拟机的服务来<a href="https://istio.io/latest/zh/docs/examples/virtual-machines/single-network/#running-services-on-the-added-VM" target="_blank" rel="noopener">扩展您的网格</a>。</li>
<li>从逻辑上添加来自不同集群的服务到网格，在 Kubernetes 上实现一个<a href="https://istio.io/latest/zh/docs/setup/install/multicluster/gateways/#configure-the-example-services" target="_blank" rel="noopener">多集群 Istio 网格</a>。</li>
</ul>
<p>您不需要为网格服务要使用的每个外部服务都添加服务入口。默认情况下，Istio将Envoy代理配置为将请求传递给未知服务。但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: ServiceEntry</span><br><span class="line">metadata:</span><br><span class="line">  name: svc-entry</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - ext-svc.example.com</span><br><span class="line">  ports:</span><br><span class="line">  - number: 443</span><br><span class="line">    name: https</span><br><span class="line">    protocol: HTTPS</span><br><span class="line">  location: MESH_EXTERNAL</span><br><span class="line">  resolution: DNS</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: DestinationRule</span><br><span class="line">metadata:</span><br><span class="line">  name: ext-res-dr</span><br><span class="line">spec:</span><br><span class="line">  host: ext-svc.example.com</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    tls:</span><br><span class="line">      mode: MUTUAL</span><br><span class="line">      clientCertificate: /etc/certs/myclientcert.pem</span><br><span class="line">      privateKey: /etc/certs/client_private_key.pem</span><br><span class="line">      caCertificates: /etc/certs/rootcacerts.pem</span><br></pre></td></tr></table></figure>
<h1 id="Istio安装"><a href="#Istio安装" class="headerlink" title="Istio安装"></a><a href="https://istio.io/latest/docs/setup/getting-started/" target="_blank" rel="noopener">Istio安装</a></h1><ul>
<li><p>下载并解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行脚本自动下载并解压</span><br><span class="line">curl -L https://istio.io/downloadIstio | sh -</span><br><span class="line"># 手动下载并解压</span><br><span class="line">https://github.com/istio/istio/releases</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin        # 二进制命令istioctl目录</span><br><span class="line">samples    # 应用范例</span><br><span class="line">manifests  # istio部署的各种资源文件</span><br><span class="line">tools      # 各种调试工具</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 移动二进制文件istioctl到PATH变量下</span><br><span class="line">mv bin/istioctl /usr/local/bin/</span><br><span class="line"># 命令行自动补全【~/.bashrc】</span><br><span class="line">source /root/istio-1.7.1/tools/istioctl.bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装选项</span><br><span class="line">istioctl profile list</span><br><span class="line">* default 适用生产环境，需要资源较高，包含istiod、istio-ingressgateway</span><br><span class="line">* demo 展示istio的核心功能，需要资源适中，包含：istiod、istio-egressgateway、istio-ingressgateway；适合Bookinfo范例和相关任务的使用；包含链路追踪和日志，不适合性能测试</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">istioctl install --set profile=demo</span><br><span class="line"></span><br><span class="line"># 安装结果检查</span><br><span class="line">kubectl get pod -n istio-system </span><br><span class="line">kubectl get svc -n istio-system</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="istio卸载"><a href="#istio卸载" class="headerlink" title="istio卸载"></a>istio卸载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istioctl x uninstall --purge</span><br><span class="line">kubectl delete namespace istio-system</span><br></pre></td></tr></table></figure>
<h1 id="Envoy-sidecar注入"><a href="#Envoy-sidecar注入" class="headerlink" title="Envoy sidecar注入"></a>Envoy sidecar注入</h1><ul>
<li><p>自动注入（命名空间）：添加名称空间标签，以指示Istio以后在相关名称空间部署应用程序时自动注入Envoy sidecar代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>手动注入：手动向k8s工作负载注入Envoy sidecar代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istioctl kube-inject </span><br><span class="line"></span><br><span class="line"># Update resources on the fly before applying.</span><br><span class="line">kubectl apply -f &lt;(istioctl kube-inject -f &lt;resource.yaml&gt;)</span><br><span class="line"></span><br><span class="line"># Create a persistent version of the deployment with Envoy sidecar</span><br><span class="line"># injected.</span><br><span class="line">istioctl kube-inject -f deployment.yaml -o deployment-injected.yaml</span><br><span class="line"></span><br><span class="line"># Update an existing deployment.</span><br><span class="line">kubectl get deployment -o yaml | istioctl kube-inject -f - | kubectl apply -f -</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Istio-web界面"><a href="#Istio-web界面" class="headerlink" title="Istio web界面"></a>Istio web界面</h1><ul>
<li><p>部署Kiali仪表板以及Prometheus，Grafana和Jaeger。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f samples/addons</span><br><span class="line">while ! kubectl wait --for=condition=available --timeout=600s deployment/kiali -n istio-system; do sleep 1; done</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动web服务kiali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istioctl dashboard kiali --address 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>web浏览器访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://x.x.x.x:20001/kiali</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="应用范例-Bookinfo"><a href="#应用范例-Bookinfo" class="headerlink" title="应用范例-Bookinfo"></a>应用范例-Bookinfo</h1><h2 id="应用介绍"><a href="#应用介绍" class="headerlink" title="应用介绍"></a>应用介绍</h2><p><img src="https://istio.io/latest/docs/examples/bookinfo/noistio.svg" alt></p>
<ul>
<li>productpage：前端页面，调用details和reviews服务</li>
<li>details：包含书籍信息</li>
<li>reviews：包含书籍评论信息，会调用ratings服务<ul>
<li>v1版本不调用ratings服务</li>
<li>v2版本调用ratings服务，将每个等级显示为1至5个黑色星星</li>
<li>v3版本调用ratings服务，将每个等级显示为1到5个红色星星</li>
</ul>
</li>
<li>ratings：包含有书评组成的评级信息</li>
</ul>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><ul>
<li><p>部署应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查部署结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get svc,pod</span><br></pre></td></tr></table></figure>
</li>
<li><p>在集群中检查应用是否正常运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl exec &quot;$(kubectl get pod -l app=ratings -o jsonpath=&apos;&#123;.items[0].metadata.name&#125;&apos;)&quot; -c ratings -- curl -s productpage:9080/productpage | grep -o &quot;&lt;title&gt;.*&lt;/title&gt;&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对外暴露应用"><a href="#对外暴露应用" class="headerlink" title="对外暴露应用"></a>对外暴露应用</h2><ul>
<li><p>部署gateway以使服务网格外部可以访问应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析配置是否有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istioctl analyze</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取ingress gateway的部署主机ip(pod)和NodePort(service)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&apos;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&apos;)</span><br><span class="line">export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&apos;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&apos;)</span><br><span class="line">export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=&apos;&#123;.items[0].status.hostIP&#125;&apos;)</span><br><span class="line">export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT</span><br><span class="line">echo &quot;$GATEWAY_URL&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>web浏览器访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo http://&quot;$GATEWAY_URL/productpage&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="金丝雀部署"><a href="#金丝雀部署" class="headerlink" title="金丝雀部署"></a>金丝雀部署</h2><p>上述部署中（bookinfo-gateway.yaml），没有针对每个service定义VirtualService，此时访问主页(http://$GATEWAY_URL/productpage)的流量都导向productpage服务，productpage服务以轮询的方式调用reviews服务的3种工作负载(v1、v2、v3)。以下主要对reviews服务进行金丝雀部署，逐步升级：v1–&gt;v2–&gt;v3</p>
<ul>
<li>使用v1版本【全部服务】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f destination-rule-all.yaml         # 定义各服务v1版本对应的工作负载(pod)</span><br><span class="line">kubectl apply -f virtual-service-all-v1.yaml       # 定义访问各服务时都访问服务的v1版本</span><br></pre></td></tr></table></figure>
<ul>
<li><p>A/B Test【jason用户访问v2，其他访问v1】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f virtual-service-reviews-test-v2.yaml </span><br><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">    - reviews</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - headers:</span><br><span class="line">        end-user:</span><br><span class="line">          exact: jason</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v2</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v1</span><br></pre></td></tr></table></figure>
</li>
<li><p>金丝雀部署【80%用户访问v1，20%用户访问v2】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f virtual-service-reviews-80-20.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">    - reviews</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v1</span><br><span class="line">      weight: 80</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v2</span><br><span class="line">      weight: 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>逐步增加v2版本访问权重(weight)，至最终完全访问v2</p>
</li>
<li><p>v2到v3的版本升级类似。</p>
</li>
</ul>
<h2 id="应用卸载"><a href="#应用卸载" class="headerlink" title="应用卸载"></a>应用卸载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 卸载</span><br><span class="line">samples/bookinfo/platform/kube/cleanup.sh</span><br><span class="line"># 确认</span><br><span class="line">kubectl get virtualservices   #-- there should be no virtual services</span><br><span class="line">kubectl get destinationrules  #-- there should be no destination rules</span><br><span class="line">kubectl get gateway           #-- there should be no gateway</span><br><span class="line">kubectl get pods              #-- the Bookinfo pods should be deleted</span><br></pre></td></tr></table></figure>
<h1 id="应用发布方案"><a href="#应用发布方案" class="headerlink" title="应用发布方案"></a><a href="https://my.oschina.net/izu/blog/3009733" target="_blank" rel="noopener">应用发布方案</a></h1><ul>
<li>蓝绿发布</li>
<li>滚动发布</li>
<li>金丝雀发布/灰度发布【A/B Test】</li>
</ul>
<h2 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h2><p>项目逻辑上分为AB组，在项目升级时，首先把A组从负载均衡中摘除，进行新版本的部署。B组仍然继续提供<br>服务。A组升级完成上线，将B组从负载均衡中摘除。B组资源预先保留一段时间，A组在一段时间内持续可用没有问题时，删除B组占用资源；如果A组有问题时，立即切换到B组资源。<br>特点：</p>
<ul>
<li>策略简单</li>
<li>升级/回滚速度快，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要两倍以上服务器资源，短时间内浪费一定资源成本</li>
<li>有问题影响范围大</li>
</ul>
<h2 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h2><p>每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版<br>升级新版本。这也是kubernetes的默认发布策略。<br>特点：</p>
<ul>
<li>相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。</li>
<li>部署过程自动化，一般不需要或不能人工干预</li>
</ul>
<p>缺点：</p>
<ul>
<li>部署周期长</li>
<li>发布策略较复杂：需要针对发布过程中的可用性、回滚等操作制定策略</li>
<li>不易回滚</li>
<li>影响范围较大</li>
</ul>
<h2 id="灰度发布-金丝雀发布"><a href="#灰度发布-金丝雀发布" class="headerlink" title="灰度发布/金丝雀发布"></a>灰度发布/金丝雀发布</h2><p>只升级部分服务，即让一部分用户继续用老版本，一部分用户开始用新版本，如果用户对新版本没有什么<br>意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。<br>特点：</p>
<ul>
<li>可以根据应用的可用性，不断调整新旧版本的使用比例</li>
</ul>
<p>缺点：</p>
<ul>
<li>自动化要求高，需要处理新旧版本持续的上下线及不同版本的访问权重：例如90%的用户维持使用老版本，10%的用户尝鲜新版本。</li>
<li>同时运行多个版本，需要处理多版本的兼容性</li>
</ul>
<h3 id="A-B-Test"><a href="#A-B-Test" class="headerlink" title="A/B Test"></a>A/B Test</h3><p>灰度发布的一种测试方式，主要对特定用户采样后，对收集到的反馈数据做相关对比，然后根据比对结果作出<br>决策。用来测试应用功能表现的方法，侧重应用的可用性，受欢迎程度等，最后决定是否升级</p>
<h1 id="Istio金丝雀发布思路"><a href="#Istio金丝雀发布思路" class="headerlink" title="Istio金丝雀发布思路"></a>Istio金丝雀发布思路</h1><ul>
<li>创建k8s资源<ul>
<li>创建应用的多个版本(deployment/pod)，每个版本使用不同的标签区别(例如：version: v1/v2)</li>
<li>使用service关联所有的版本</li>
</ul>
</li>
<li>使用istio部署应用：部署应用时注入Envoy sidecar</li>
<li>创建istio资源<ul>
<li>使用DestinationRule关联所有的应用版本</li>
<li>使用VirtualService定义路由策略（基于用户内容或基于百分比）</li>
<li>【可选】ingress gateway暴露应用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>servicemesh</tag>
        <tag>灰度发布</tag>
        <tag>金丝雀发布</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/blog/2019/10/23/%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%89%E5%85%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="架构设计目标"><a href="#架构设计目标" class="headerlink" title="架构设计目标"></a>架构设计目标</h1><ul>
<li>可伸缩性（Scalability），当服务的负载增长时，系统能被扩展来满足需求，且不降低服务质量。<ul>
<li>负载均衡技术是实现网站架构伸缩性的主要手段</li>
</ul>
</li>
<li>高可用性（Availability），尽管部分硬件和软件会发生故障，整个系统的服务必须是每天24小时每星期7天可用的。</li>
<li>可管理性（Manageability），整个系统可能在物理上很大，但应该容易管理。</li>
<li>价格有效性（Cost-effectiveness），整个系统实现是经济的、易支付的。</li>
</ul>
<h1 id="负载均衡技术"><a href="#负载均衡技术" class="headerlink" title="负载均衡技术"></a>负载均衡技术</h1><ul>
<li>基于客户端调度访问：客户端存储服务器集群配置信息，当有请求时，通过算法向不同服务器发送请求【redis的集群即使用此方法，redis的客户端需要存储redis集群的ip及端口列表】</li>
<li>基于DNS域名轮流解析：一个域名映射多个服务器</li>
<li>基于应用层系统负载调度：nginx、haproxy</li>
<li>基于网络及传输层的IP地址调度：lvs、haproxy</li>
</ul>
<h1 id="阿里云高可用"><a href="#阿里云高可用" class="headerlink" title="阿里云高可用"></a>阿里云高可用</h1><ul>
<li>同一个城市的多个可用区网络互通，用户无感知</li>
<li>为了保证应用的高可用，应该在不同可用区部署服务</li>
<li>rds的主库默认会在同一可用区建立备库（用户不可见，主库故障时，rds自动切换），用户可购买不同可用区的容灾备</li>
</ul>
<h1 id="架构层次设计"><a href="#架构层次设计" class="headerlink" title="架构层次设计"></a>架构层次设计</h1><ul>
<li>缓存服务【CDN】</li>
<li>负载均衡器</li>
<li>web服务</li>
<li>应用层服务</li>
<li>数据库</li>
</ul>
<h1 id="高并发实现"><a href="#高并发实现" class="headerlink" title="高并发实现"></a>高并发实现</h1><ul>
<li>应用层横向扩展<ul>
<li>负载均衡器（四层/七层实现）</li>
<li>弹性伸缩服务（动态增减服务器容量）</li>
</ul>
</li>
<li>使用应用层缓存（如memcache、redis服务等key-value服务）</li>
<li>同步转异步（消息队列）</li>
<li>提供数据库访问能力（读写分离）</li>
</ul>
<h2 id="应用层缓存"><a href="#应用层缓存" class="headerlink" title="应用层缓存"></a>应用层缓存</h2><ul>
<li>原因：数据库服务横向扩展支持高并发</li>
<li>特点<ul>
<li>key-value存储</li>
<li>内存中缓存数据</li>
<li>支持热点数据缓存</li>
<li>数据访问速度要求高</li>
<li>更新评率低，读取频率高</li>
</ul>
</li>
<li>产品<ul>
<li>memcache：数据不存盘</li>
<li>redis：数据存盘</li>
</ul>
</li>
</ul>
<h2 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h2><ul>
<li>重点：业务流程设计中拆分出同步和异步</li>
<li>两种模式：<ul>
<li>同步：支付要求实时返回信息</li>
<li>异步：消息队列</li>
</ul>
</li>
<li>消息队列：<ul>
<li>生产者</li>
<li>消息平台【存储、路由】</li>
<li>消费者</li>
</ul>
</li>
</ul>
<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><ul>
<li>读写分离原因<ul>
<li>写操作严格，并发不高</li>
<li>由于写操作加锁原因，会影响读操作，间接造成读操作并发不高</li>
<li>写操作频率一般比读操作频率低很多</li>
</ul>
</li>
<li>读写分离操作<ul>
<li>读写操作拆分到不同数据库实例上，由于磁盘io限制，一般也要求数据库实例分布在不同主机上</li>
<li>读写分离关键：复制技术（一般才去日志重做机制-redo）</li>
</ul>
</li>
<li>读写分离应用：能够接受读写操作微小的延迟和不一致</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus-altermanager告警</title>
    <url>/blog/2020/08/05/%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/prometheus-altermanager%E5%91%8A%E8%AD%A6/</url>
    <content><![CDATA[<h1 id="告警状态"><a href="#告警状态" class="headerlink" title="告警状态"></a>告警状态</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/alter-status.jpg" alt></p>
<ul>
<li>inactive：当做什么都没发生</li>
<li>pending：已触发阈值，但是未满足告警持续时间</li>
<li>firing：触发阈值且满足告警持续时间；告警发给接收者。</li>
</ul>
<h1 id="告警收敛设置"><a href="#告警收敛设置" class="headerlink" title="告警收敛设置"></a><a href="https://prometheus.io/docs/alerting/latest/alertmanager/#alertmanager" target="_blank" rel="noopener">告警收敛设置</a></h1><ul>
<li>分组(group)：将告警名称相同的多个告警合并到一个告警中发送</li>
<li>抑制(inhibit)：当告警发生后，停止发送和此类警报相关的其他警报</li>
<li>静默(silence)：是一种简单的在特定时间范围内将警报静音的机制</li>
</ul>
<h1 id="告警流程"><a href="#告警流程" class="headerlink" title="告警流程"></a>告警流程</h1><ul>
<li>prometheus根据采集的数据和告警规则进行判断；满足条件后，将告警发送到altermanager<ul>
<li>是否触发阈值</li>
<li>是否超过持续时间</li>
</ul>
</li>
<li>altermanager根据告警收敛规则，决定是否、什么时间发送告警（邮件、企业微信、钉钉等）</li>
</ul>
<h1 id="启动配置-告警方式"><a href="#启动配置-告警方式" class="headerlink" title="启动配置-告警方式"></a>启动配置-告警方式</h1><ul>
<li>启动参数<ul>
<li>配置文件：–config.file=”alertmanager.yml”</li>
<li>数据目录：–storage.path=”data/“</li>
<li>外部访问url：–web.external-url=/</li>
</ul>
</li>
<li>主配置【邮件示例】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global: </span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  smtp_smarthost: &apos;smtp.163.com:25&apos;</span><br><span class="line">  smtp_from: &apos;baojingtongzhi@163.com&apos;</span><br><span class="line">  smtp_auth_username: &apos;baojingtongzhi@163.com&apos;</span><br><span class="line">  smtp_auth_password: &apos;NCKBJTSASSXMRQBM&apos;</span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: default-receiver</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &quot;zhenliang369@163.com&quot;</span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_interval: 1m</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  receiver: default-receiver</span><br><span class="line">  repeat_interval: 1m</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>alertmanager</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus入门</title>
    <url>/blog/2020/07/30/%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/prometheus%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ul>
<li>一个多维数据模型(data model)，其中包含通过度量名称(metric name)和标签(key/value)定义的时间序列数据</li>
<li>PromQL，灵活的数据查询语言</li>
<li>不依赖分布式存储，数据保存在服务器节点上</li>
<li>通过http的pull模型拉取时间序列数据</li>
<li>可以通过推送网关(pushgateway)支持push模型获取数据</li>
<li>可以通过服务发现或静态配置发现目标节点</li>
<li>支持多种图形和仪表盘</li>
</ul>
<h1 id="核心概念-数据"><a href="#核心概念-数据" class="headerlink" title="核心概念-数据"></a>核心概念-数据</h1><h2 id="数据格式-data-model"><a href="#数据格式-data-model" class="headerlink" title="数据格式(data model)"></a>数据格式(data model)</h2><ul>
<li>语法：<code>&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...}</code></li>
<li>范例：<code>api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/messages&quot;}</code></li>
<li>数据产生流程<ul>
<li>客户端metrics接口的数据格式：【node_boot_time_seconds 1.585383507e+09】</li>
<li>prometheus接收数据后根据数据来源添加标签后进行存储【node_boot_time_seconds{instance=”localhost:9100”,job=”node_exporter”}  1585383507】</li>
</ul>
</li>
</ul>
<h2 id="数据类型-metric-types"><a href="#数据类型-metric-types" class="headerlink" title="数据类型(metric types)"></a>数据类型(metric types)</h2><ul>
<li><p>计数器类型(counter)：计数器是一个累计度量指标，</p>
<ul>
<li>代表一个单调递增的计数器(除非系统重启)</li>
<li>例如代表请求数、任务完成数、错误数</li>
</ul>
</li>
<li><p>测量类型(gauge)：反应应用的当前状态</p>
<ul>
<li>数据可增可减</li>
<li>例如服务器的内存、cpu、磁盘使用率等</li>
</ul>
</li>
<li><p>直方图类型(Histogram)：显示一段时间内值在各区间的分布情况【概率分布】</p>
<ul>
<li><p>数据类型名称：度量基础名称+不同类型统计数据</p>
<ul>
<li>bucket类型：获取值在统计区间(bucket)的个数，名称如<basename>_bucket{le=”<upper inclusive bound>“}</upper></basename></li>
<li>sum类型：所有获取数值的总和，名称如<basename>_sum</basename></li>
<li>count类型：所有获取值的个数，名称如<basename>_count【等同于<basename>_bucket{le=”+Inf”}（小于无穷大的个数）】</basename></basename></li>
</ul>
</li>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;100&quot;&#125; 0 #http响应小于1000字节的个数</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;1000&quot;&#125; 0 </span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;10000&quot;&#125; 163</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;100000&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;1e+06&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;1e+07&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;1e+08&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;1e+09&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_bucket&#123;handler=&quot;/metrics&quot;,le=&quot;+Inf&quot;&#125; 170</span><br><span class="line">prometheus_http_response_size_bytes_sum&#123;handler=&quot;/metrics&quot;&#125; 1.578861e+06 # #170次http响应的字节总和</span><br><span class="line">prometheus_http_response_size_bytes_count&#123;handler=&quot;/metrics&quot;&#125; 170 #一共抓取170次http响应数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据处理：histogram_quantile(a float, b instant-vector)函数可计算区间b中超过分数a的个体情况；例如：统计http请求超过10分钟的90%场景中的情况(剔除极端值)：histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[10m]))</p>
</li>
</ul>
</li>
<li><p>摘要类型(Summary)：和直方图数据类似，它是由客户端直接提供(histogram_quantile)的计算结果提供给prometheus</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prometheus_target_interval_length_seconds&#123;interval=&quot;15s&quot;,quantile=&quot;0.01&quot;&#125; 14.999831807</span><br><span class="line">prometheus_target_interval_length_seconds&#123;interval=&quot;15s&quot;,quantile=&quot;0.05&quot;&#125; 14.999910011</span><br><span class="line">prometheus_target_interval_length_seconds&#123;interval=&quot;15s&quot;,quantile=&quot;0.5&quot;&#125; 15.000031073</span><br><span class="line">prometheus_target_interval_length_seconds&#123;interval=&quot;15s&quot;,quantile=&quot;0.9&quot;&#125; 15.000114733</span><br><span class="line">prometheus_target_interval_length_seconds&#123;interval=&quot;15s&quot;,quantile=&quot;0.99&quot;&#125; 15.000228675</span><br><span class="line">prometheus_target_interval_length_seconds_sum&#123;interval=&quot;15s&quot;&#125; 10170.020818119998</span><br><span class="line">prometheus_target_interval_length_seconds_count&#123;interval=&quot;15s&quot;&#125; 678</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="作业和实例-jobs-and-instances"><a href="#作业和实例-jobs-and-instances" class="headerlink" title="作业和实例(jobs and instances)"></a>作业和实例(jobs and instances)</h2><ul>
<li><p>instance：可以抓取数据的目标端点</p>
</li>
<li><p>jobs：具有相同目标的实例(instance)集合【如多个mysql实例】</p>
</li>
<li><p>范例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">- job_name: &apos;prometheus&apos;</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [&apos;localhost:9090&apos;]</span><br><span class="line">- job_name: &apos;node&apos;</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [&apos;192.168.1.10:9090&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="架构与组件"><a href="#架构与组件" class="headerlink" title="架构与组件"></a>架构与组件</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/prometheus-architecture.png" alt></p>
<ul>
<li>数据采集(pull模型)：<ul>
<li>短周期任务(short-lived jobs)：通过<strong>pushgateway</strong>组件短期存储指标数据</li>
<li>持续性任务：exporter</li>
<li>服务发现(service discovery)：自动发现监控指标，例如：文件、k8s、consul</li>
</ul>
</li>
<li>数据存储(<strong>prometheus server</strong>)：node-hdd/ssd(本地存储)、influxDB</li>
<li>告警(<strong>altermanager</strong>)</li>
<li>查询&amp;展示：promQL(查询语言)、api clients、<strong>grafana</strong>、web UI</li>
</ul>
<h1 id="PromQL语法"><a href="#PromQL语法" class="headerlink" title="PromQL语法"></a>PromQL语法</h1><blockquote>
<p>学习方法：通过granfa的<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">dashboard</a>模板</p>
</blockquote>
<ul>
<li>瞬时数据：node_cpu_seconds_total</li>
<li>区间数据：node_load1[3m]<ul>
<li><code>s</code> - seconds</li>
<li><code>m</code> - minutes</li>
<li><code>h</code> - hours</li>
<li><code>d</code> - days</li>
<li><code>w</code> - weeks</li>
<li><code>y</code> - years</li>
</ul>
</li>
<li><p>标签选择指标：node_network_info{operstate=”up”,device=~”veth.*”}</p>
<ul>
<li>=：选择与字符串完全相等的标签</li>
<li>!=：选择与字符串不相等的标签</li>
<li>=~：选择与字符串正则匹配的标签</li>
<li>!~：选择与字符串正则不匹配的标签</li>
</ul>
</li>
<li><p>指标计算：(node_memory_MemAvailable_bytes/node_memory_MemTotal_bytes)*100（可用内存）</p>
<ul>
<li>加减乘除：+、-、*、/、%、^</li>
<li>比较运算(常用于报警)：==、!=、&gt;、&gt;=、&lt;、&lt;=</li>
<li>逻辑运算：and、or</li>
<li>聚合运算：sum、min、max、avg、count、topk(n,metric)<ul>
<li>sum：<ul>
<li>直接计算总和(所有节点可用内存)：sum(node_memory_MemAvailable/(1024*1024))</li>
<li>分类之后分别计算总和(计算每个pod的占用内存)：sum(container_memory_rss{image!=””}) by(pod) </li>
</ul>
</li>
</ul>
</li>
<li>内置函数：rate(区间内每秒增长量)、irate、abs、increase(区间内增长量)、sort_desc、sort</li>
</ul>
</li>
</ul>
<h1 id="pushgateway"><a href="#pushgateway" class="headerlink" title="pushgateway"></a>pushgateway</h1><ul>
<li>prometheus配置抓取目标为pushgateway时，必须设置honor_labels为true，避免收集的数据本身的job和instance被覆盖</li>
<li>配置参数【–persistence.file】和–persistence.interval=5m将收集的数据持久化</li>
</ul>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><ul>
<li><p>service discovery</p>
</li>
<li><p>自定义监控指标-API</p>
</li>
<li><p>prometheus-operator</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000022164038" target="_blank" rel="noopener">高可用prometheus：thanos 实践</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
        <tag>altermanager</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus-server设置</title>
    <url>/blog/2020/08/05/%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/prometheus-server%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h1><ul>
<li>–config.file=/etc/config/prometheus.yml：指定配置文件</li>
<li>–storage.tsdb.path=/data：指定数据目录</li>
<li>–web.enable-lifecycle：允许通过http POST方式关闭服务或重载配置</li>
<li>–storage.tsdb.retention.time：数据保留时间(默认15天)【y,w, d, h, m, s, ms】</li>
<li>–storage.tsdb.no-lockfile：不创建lockfile【如果使用k8s的deployment管理时需要开启】</li>
</ul>
<h1 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h1><ul>
<li>主配置示例：<a href="https://github.com/prometheus/prometheus/blob/release-2.20/config/testdata/conf.good.yml" target="_blank" rel="noopener">https://github.com/prometheus/prometheus/blob/release-2.20/config/testdata/conf.good.yml</a></li>
<li>抓取设置和标签设置示例：<a href="https://github.com/prometheus/prometheus/blob/release-2.20/documentation/examples/prometheus-kubernetes.yml" target="_blank" rel="noopener">https://github.com/prometheus/prometheus/blob/release-2.20/documentation/examples/prometheus-kubernetes.yml</a></li>
<li>主配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># 收集数据时间间隔(default = 1m)</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 收集数据超时(default = 10s)</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 评估规则时间间隔(default = 1m)</span></span><br><span class="line">  <span class="comment">#evaluation_interval: 30s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 和外部通信(联邦、远程存储、报警)时添加的到任意时间序列或警报的标签</span></span><br><span class="line">  <span class="comment">#external_labels:</span></span><br><span class="line">  <span class="comment">#  [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># PromQL查询日志，重载配置文件会重新打开一个文件</span></span><br><span class="line">  <span class="comment">#query_log_file: query.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报警规则文件，可以使用正则表达式进行文件匹配</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line"><span class="comment">#- "first.rules"</span></span><br><span class="line"><span class="comment">#- "my/*.rules"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取数据的配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># 默认添加标签`job=&lt;job_name&gt;`到时序数据</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="comment"># metrics_path 数据指标节点url，默认'/metrics'</span></span><br><span class="line">    <span class="comment"># scheme 使用的协议，默认'http'.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line"><span class="comment"># 指定与Alertmanager相关的配置</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将数据写入其他时序数据库【如influxDB】</span></span><br><span class="line"><span class="comment">#remote_write:</span></span><br><span class="line"><span class="comment">#  - url: "http://localhost:8086/api/v1/prom/write?db=prometheus&amp;u=username&amp;p=password"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以读取其他时序数据库【如influxDB】</span></span><br><span class="line"><span class="comment">#remote_read:</span></span><br><span class="line"><span class="comment">#  - url: "http://localhost:8086/api/v1/prom/read?db=prometheus&amp;u=username&amp;p=password"</span></span><br></pre></td></tr></table></figure>
<h1 id="抓取目标设置-scrape-configs"><a href="#抓取目标设置-scrape-configs" class="headerlink" title="抓取目标设置-scrape_configs"></a>抓取目标设置-scrape_configs</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span> <span class="comment">#抓取设置</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span> <span class="comment">#分组设置，这个分组下的所有目标会被添加job=prometheus的标签</span></span><br><span class="line">  <span class="attr">static_configs:</span>   <span class="comment"># 配置文件中设置抓取目标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['127.0.0.1:9090']</span> <span class="comment">#抓取目标，同时也会在这个目标上添加标签instance=127.0.0.1:9090</span></span><br><span class="line">    <span class="attr">labels:</span>  <span class="comment">#从此数据源获取的数据都会添加标签my=label</span></span><br><span class="line">      <span class="attr">my:</span> <span class="string">label</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">node_export</span></span><br><span class="line">  <span class="attr">file_sd_configs:</span> <span class="comment"># 加载配置文件(yaml/json)获取抓取目标</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">files:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">foo/*.slow.json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">foo/*.slow.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">single/file.yml</span></span><br><span class="line">      <span class="attr">refresh_interval:</span> <span class="string">10m</span> <span class="comment">#读取配置文件时间间隔【默认5min】</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">files:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bar/*.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">service-y</span></span><br><span class="line">  <span class="attr">consul_sd_configs:</span> <span class="comment">#通过配置中心consul获取抓取目标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">server:</span> <span class="string">'localhost:1234'</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">mysecret</span></span><br><span class="line">    <span class="attr">services:</span> <span class="string">['nginx',</span> <span class="string">'cache'</span><span class="string">,</span> <span class="string">'mysql'</span><span class="string">]</span> <span class="comment">#只抓取匹配的服务</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">["canary",</span> <span class="string">"v1"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">node_meta:</span></span><br><span class="line">      <span class="attr">rack:</span> <span class="string">"123"</span></span><br><span class="line">    <span class="attr">allow_stale:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">tls_config:</span></span><br><span class="line">      <span class="attr">ca_file:</span> <span class="string">valid_ca_file</span></span><br><span class="line">      <span class="attr">cert_file:</span> <span class="string">valid_cert_file</span></span><br><span class="line">      <span class="attr">key_file:</span>  <span class="string">valid_key_file</span></span><br><span class="line">      <span class="attr">insecure_skip_verify:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>目标配置文件(json格式)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;&lt;host&gt;&quot;, ... ],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;&lt;labelname&gt;&quot;: &quot;&lt;labelvalue&gt;&quot;, ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="目标标签处理-relabel-configs"><a href="#目标标签处理-relabel-configs" class="headerlink" title="目标标签处理-relabel_configs"></a>目标标签处理-relabel_configs</h1><blockquote>
<p>可以直接在数据抓取目标处设置label</p>
</blockquote>
<ul>
<li><p>drop、keep：删除或保留正则匹配的原标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- action: keep #只保留原标签中值为default、kubernetes、https的标签</span><br><span class="line">  regex: default;kubernetes;https</span><br><span class="line">  source_labels:</span><br><span class="line">  - __meta_kubernetes_namespace</span><br><span class="line">  - __meta_kubernetes_service_name</span><br><span class="line">  - __meta_kubernetes_endpoint_port_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>replace：替换标签key或value</p>
<ul>
<li>替换标签内容【使用replacement】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- action: replace #执行替换操作</span><br><span class="line">  regex: ([^:]+)(?::\d+)?;(\d+) #对原标签的value进行匹配(分号分隔匹配不同标签的正则)</span><br><span class="line">  replacement: $1:$2 #目标标签value(可以使用正则的分组引用原标签的value)</span><br><span class="line">  source_labels: #原标签key</span><br><span class="line">  - __address__</span><br><span class="line">  - __meta_kubernetes_service_annotation_prometheus_io_port</span><br><span class="line">  target_label: __address__ #目标标签key</span><br><span class="line"># 此例子中使用正则匹配(regex)从原标签(source_labels)</span><br><span class="line"># 的值中提取值(replacement)赋值给目标标签(target_label)</span><br></pre></td></tr></table></figure>
<ul>
<li>替换标签(重命名标签)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- action: replace</span><br><span class="line">  source_labels:</span><br><span class="line">  - __meta_kubernetes_service_name</span><br><span class="line">  target_label: kubernetes_name</span><br><span class="line"># 将原标签(source_labels)重命名为目标标签</span><br></pre></td></tr></table></figure>
</li>
<li><p>labelmap：只保留标签名称的部分内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- action: labelmap</span><br><span class="line">  regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line"># 如果标签名称为__meta_kubernetes_service_label_asdfg，则被简化为asdfg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><ul>
<li><p>记录规则【对原始的数据进行计算分类，避免使用过多数据的计算冲击prometheus的运行】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groups:</span><br><span class="line">  - name: example</span><br><span class="line">    rules:</span><br><span class="line">    - record: job:http_inprogress_requests:sum</span><br><span class="line">      expr: sum by (job) (http_inprogress_requests)</span><br></pre></td></tr></table></figure>
</li>
<li><p>报警规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: node.rules #分组名称</span><br><span class="line">  rules:</span><br><span class="line">  - alert: NodeFilesystemUsage #告警名称</span><br><span class="line">    expr: | #表达式</span><br><span class="line">      100 - (node_filesystem_free&#123;fstype=~&quot;ext4|xfs&quot;&#125; / </span><br><span class="line">      node_filesystem_size&#123;fstype=~&quot;ext4|xfs&quot;&#125; * 100) &gt; 20 </span><br><span class="line">    for: 1m #持续时间</span><br><span class="line">    labels: #标签【过滤选择资源】</span><br><span class="line">      severity: warning  #报警级别</span><br><span class="line">    annotations: #注解，告警详情</span><br><span class="line">      summary: &quot;Instance &#123;&#123; $labels.instance &#125;&#125; : &#123;&#123; $labels.mountpoint &#125;&#125; 分区使用率过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: &#123;&#123; $labels.mountpoint &#125;&#125; 分区使用大于80% (当前值: &#123;&#123; $value &#125;&#125;)&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus高可用架构</title>
    <url>/blog/2020/08/05/%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/prometheus%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="prometheus高可用"><a href="#prometheus高可用" class="headerlink" title="prometheus高可用"></a>prometheus高可用</h1><h2 id="联邦功能"><a href="#联邦功能" class="headerlink" title="联邦功能"></a>联邦功能</h2><p>prometheus原生支持联邦架构，能够实现从别的prometheus抓取符合特定条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">- job_name: &apos;federate&apos;</span><br><span class="line">    scrape_interval: 15s</span><br><span class="line">    honor_labels: true</span><br><span class="line">    metrics_path: &apos;/federate&apos;</span><br><span class="line">    params:</span><br><span class="line">      &apos;match[]&apos;:</span><br><span class="line">        - &apos;&#123;job=~&quot;kubernetes.*&quot;&#125;&apos; #抓取目标prometheus中job为kubernetes开头的监控项</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets:</span><br><span class="line">        - &apos;192.168.31.201:30090&apos;</span><br></pre></td></tr></table></figure>
<h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><ul>
<li><p>HA方案：启动多个prometheus-server，每个prometheus配置都相同，收集相同目标的数据</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/prometheus-ha.jpg" alt></p>
<ul>
<li>优点：只能保证prometheus服务的可用性问题</li>
<li>缺点：数据无法持久化、无法保证数据一致性；受制于单点性能限制(ServerA/ServerB)，无法进行动态扩展。</li>
<li>适用场景：小规模、短周期存储监控数据</li>
</ul>
</li>
<li><p>HA+远程存储：多台配置相同的prometheus(ServerA/ServerB)，都可以向远程存储写数据；使用keepalived机制，保证同一时间只启动其中的一台prometheus-server，也只有存活的prometheus可以向远程存储写数据</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/prometheus-remote-storage.jpg" alt></p>
<ul>
<li>优点：数据可以长期存储、保证了数据的一致性；保证了prometheus-server的可用性</li>
<li>缺点：单台server性能有限，无法收集更多监控数据</li>
<li>适用场景：小规模、长期数据存储</li>
</ul>
</li>
<li><p>HA+远程存储+联邦集群：将不同的采集任务划分为不同功能区(ServerA/ServerB)，再启动一台单独的prometheus(ServerC)将重要的数据从ServerA和ServerB中汇总，同时启用外部存储进行数据持久化</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/prometheus-ha-federate.jpg" alt></p>
<ul>
<li>优点：重要数据可以持久化、server可以灵活迁移；能够依据不同任务进行层级划分；ServerA/ServerB可以使用HA进行高可用</li>
</ul>
</li>
</ul>
<h2 id="监控范例"><a href="#监控范例" class="headerlink" title="监控范例"></a>监控范例</h2><ul>
<li><p>监控需求：</p>
<ul>
<li>系统监控(cpu、内存、磁盘、网络)数据量不大，但需要长期存储【需要做资源规划和分析】</li>
<li>业务监控(nginx/grpc等)和线上业务访问成正比，数据量巨大；业务监控主要做实时探测，一般需求不超过一周(主要做实时业务成功率报警，历史数据分析从ELK等日志系统操作)</li>
</ul>
</li>
<li><p>监控实现</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/prometheus-sample.jpg" alt></p>
</li>
</ul>
<h1 id="altermanager高可用"><a href="#altermanager高可用" class="headerlink" title="altermanager高可用"></a>altermanager高可用</h1><p>单点架构中，由于收敛规则中的group可以去重(repeat)，所以altermanager可以对接多个具有相同配置的prometheus-server</p>
<h2 id="高可用方案-1"><a href="#高可用方案-1" class="headerlink" title="高可用方案"></a>高可用方案</h2><ul>
<li><p>使用负载均衡，将prometheus发送的告警分流到不同的altermanager上</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/alert-ha.jpg" alt></p>
</li>
<li><p>使用altermanager的集群功能【使用gossip协议：去中心化、最终一致性】</p>
<ul>
<li>–cluster.listen-address=”127.0.0.1:8001”：当前实例集群服务监听地址</li>
<li>–cluster.peer=127.0.0.1:8001：初始化时关联的其他实例的集群服务地址【第一个启动的实例不用配置】</li>
</ul>
</li>
</ul>
<h2 id="集群实践"><a href="#集群实践" class="headerlink" title="集群实践"></a>集群实践</h2><ul>
<li><p>webhook项目编译</p>
<ul>
<li><p>webhook项目：<a href="https://github.com/prometheus/alertmanager/tree/master/examples/webhook" target="_blank" rel="noopener">https://github.com/prometheus/alertmanager/tree/master/examples/webhook</a></p>
</li>
<li><p>安装go环境：<a href="https://golang.google.cn/doc/install" target="_blank" rel="noopener">https://golang.google.cn/doc/install</a></p>
</li>
<li><p>配置go仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译webhook项目：<code>go get github.com/prometheus/alertmanager/examples/webhook</code></p>
</li>
<li><p>webhook最新二进制文件位置：$HOME/go/bin/webhook</p>
</li>
</ul>
</li>
<li><p>启动altermanager和webhook</p>
<ul>
<li><a href="https://github.com/prometheus/alertmanager/blob/master/examples/ha/alertmanager.yml" target="_blank" rel="noopener">alertmanager.yml</a>：关联本地webhook</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup ./alertmanager  --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;127.0.0.1:8001&quot; --config.file=alertmanager.yml --log.level=debug 2&gt;&amp;1 &gt; alert1.log &amp; </span><br><span class="line">nohup ./alertmanager  --web.listen-address=&quot;:9094&quot; --cluster.listen-address=&quot;127.0.0.1:8002&quot; --cluster.peer=127.0.0.1:8001 --config.file=alertmanager.yml --log.level=debug 2&gt;&amp;1 &gt; alert2.log &amp; </span><br><span class="line">nohup ./alertmanager  --web.listen-address=&quot;:9095&quot; --cluster.listen-address=&quot;127.0.0.1:8003&quot; --cluster.peer=127.0.0.1:8001 --config.file=alertmanager.yml --log.level=debug 2&gt;&amp;1 &gt; alert3.log &amp; </span><br><span class="line">nohup ./webhook --log.level=debug 2&gt;&amp;1 &gt; webhook.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用脚本测试最终收到的报警信息</p>
<ul>
<li>报警脚本：<a href="https://github.com/prometheus/alertmanager/blob/master/examples/ha/send_alerts.sh" target="_blank" rel="noopener">https://github.com/prometheus/alertmanager/blob/master/examples/ha/send_alerts.sh</a></li>
<li>查看报警信息：<code>cat webhook.log</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
        <tag>altermanager</tag>
      </tags>
  </entry>
  <entry>
    <title>windows常用命令</title>
    <url>/blog/2019/05/15/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="启停windows服务"><a href="#启停windows服务" class="headerlink" title="启停windows服务"></a>启停windows服务</h1><ul>
<li>停止：net stop gitblit</li>
<li>启动：net start gitblit</li>
</ul>
<h1 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h1><p>发起30个ping包耗时30s：ping -n 30 127.0.0.1 &gt; null</p>
<h1 id="grep实现"><a href="#grep实现" class="headerlink" title="grep实现"></a>grep实现</h1><blockquote>
<p>findstr</p>
</blockquote>
<ul>
<li>netstat -ant|findstr :80$</li>
</ul>
<h1 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h1><ul>
<li>进程列表：tasklist /?</li>
<li>关闭进程：taskkill /?<ul>
<li>关闭nginx：taskkill /F /IM nginx.exe &gt; nul</li>
</ul>
</li>
</ul>
<h1 id="变量设置"><a href="#变量设置" class="headerlink" title="变量设置"></a>变量设置</h1><ul>
<li>设置变量：set key=value</li>
<li>删除变量（空值）：set key=</li>
<li>查看变量值：set key</li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook简单使用</title>
    <url>/blog/2018/02/26/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/gitbook%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li><a href="http://gitbook.zhangjikai.com" target="_blank" rel="noopener">范例参考</a></li>
<li>可以将markdown书写的文章转换为html文档直接在网页上浏览</li>
<li>可以将markdown书写的文章导出为电子书</li>
<li>可以搭配github做文章版本管理</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">安装nodejs</a></li>
<li>使用nmp安装gitbook-cli<br><code>npm install gitbook-cli -g</code></li>
</ul>
<h1 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h1><ul>
<li>创建电子书目录[同时也是github库]</li>
<li>创建SUMMARY.md文件,此文件主要描述电子书的目录结构</li>
</ul>
<p><img src="http://simple0426-blog.oss-cn-beijing.aliyuncs.com/summary.png" alt></p>
<ul>
<li>创建book.json文件，此文件主要用于描述gitbook提供web服务时使用的插件及配置</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"-lunr"</span>,</span><br><span class="line">        <span class="string">"-search"</span>,</span><br><span class="line">        <span class="string">"-livereload"</span>,</span><br><span class="line">        <span class="string">"expandable-chapters-small"</span>,</span><br><span class="line">        <span class="string">"anchors"</span>,</span><br><span class="line">        <span class="string">"anchor-navigation-ex"</span>,</span><br><span class="line">        <span class="string">"edit-link"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"edit-link"</span>: &#123;</span><br><span class="line">            <span class="attr">"base"</span>: <span class="string">"https://github.com/simple0426/blog/edit/master"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"修改本文"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h1><ul>
<li>gitbook help 使用帮助</li>
<li>gitbook install 根据book.json中的设置安装相应插件</li>
<li>gitbook build 根据SUMMARY.md的设置在当前目录的_book目录下生产用于提供web服务的html文件</li>
<li>gitbook serve –port 80 在80端口提供浏览电子书的web服务<ul>
<li>默认4000端口</li>
<li>此命令同时也会执行build的功能</li>
</ul>
</li>
</ul>
<h1 id="导出电子书"><a href="#导出电子书" class="headerlink" title="导出电子书"></a>导出电子书</h1><ul>
<li>需要安装<a href="https://calibre-ebook.com/download" target="_blank" rel="noopener">calibre</a>【使用其中的ebook-convert这个插件】</li>
<li>导出命令<br><code>gitbook pdf . my.pdf</code></li>
</ul>
<h1 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h1><ul>
<li><a href="https://plugins.gitbook.com/" target="_blank" rel="noopener">官网地址</a></li>
<li><a href="http://gitbook.zhangjikai.com/plugins.html#search-plus" target="_blank" rel="noopener">中文参考</a></li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接</title>
    <url>/blog/2018/04/18/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/TCP%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><blockquote>
<p>三次握手</p>
</blockquote>
<p><img src="http://simple0426-blog.oss-cn-beijing.aliyuncs.com/tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt></p>
<h1 id="释放连接"><a href="#释放连接" class="headerlink" title="释放连接"></a>释放连接</h1><blockquote>
<p>四次挥手</p>
</blockquote>
<p><img src="http://simple0426-blog.oss-cn-beijing.aliyuncs.com/tcp%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt></p>
<h1 id="状态迁移"><a href="#状态迁移" class="headerlink" title="状态迁移"></a>状态迁移</h1><h2 id="客户端状态迁移"><a href="#客户端状态迁移" class="headerlink" title="客户端状态迁移"></a>客户端状态迁移</h2><ul>
<li>CLOSED   连接关闭</li>
<li>SYN_SENT   主动发送连接请求【SYN】，等待确认</li>
<li>ESTABLISHED  socket已经处于链接状态，可以进行数据交互<ul>
<li>一般认为一个established就是一个服务的并发连接</li>
</ul>
</li>
<li>FIN_WAIT1     要求关闭连接【FIN】，但请求未被确认</li>
<li>FIN_WAIT2     要求关闭连接的请求被确认【ACK】<ul>
<li>此时为半连接，可以接收数据单不能发送数据</li>
</ul>
</li>
<li>TIME_WAIT     收到关闭半连接的请求【FIN】，发送确认信息【ACK】<ul>
<li>超时【2MSL(maximum segment lifetime)数据包最大生存时间】后连接被释放</li>
</ul>
</li>
<li>CLOSED   连接关闭</li>
</ul>
<h2 id="服务端状态迁移"><a href="#服务端状态迁移" class="headerlink" title="服务端状态迁移"></a>服务端状态迁移</h2><ul>
<li>CLOSED   连接关闭</li>
<li>LISTEN        监听状态，等待连接请求</li>
<li>SYN_RECVD  被动收到连接请求后，发送确认信息【ACK】，状态改变</li>
<li>ESTABLISHED  socket已经处于链接状态，可以进行数据交互</li>
<li>CLOSE_WAIT        收到关闭连接的请求【FIN】，发送确认信息【ACK】</li>
<li>LAST_ACK      要求关闭半连接【FIN】，但请求未被确认</li>
<li>CLOSED   收到连接关闭的确认信息【ACK】，连接关闭</li>
</ul>
<h1 id="CLOSING状态"><a href="#CLOSING状态" class="headerlink" title="CLOSING状态"></a>CLOSING状态</h1><ul>
<li>原因：两端同时要求关闭连接<ul>
<li>已发出关闭请求【FIN】，但未收到对此的确认信息</li>
<li>同时，收到对端的关闭请求【FIN】，发出确认信息【ACK】</li>
</ul>
</li>
<li>邻接状态<ul>
<li>FIN_WAIT1     要求关闭连接【FIN】，但请求未被确认</li>
<li>CLOSING     同时发出关闭连接请求【ACK】，但未收到确认信息</li>
<li>TIME_WAIT     收到发送关闭连接的确认信息【ACK】</li>
</ul>
</li>
</ul>
<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p><img src="http://simple0426-blog.oss-cn-beijing.aliyuncs.com/tcp%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt></p>
<h1 id="TCP参数"><a href="#TCP参数" class="headerlink" title="TCP参数"></a>TCP参数</h1><ul>
<li>tcp_syn_retries：对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接）</li>
<li>tcp_retries1：放弃回应一个TCP连接请求前﹐需要进行多少次重试。默认值是3</li>
<li>tcp_synack_retries：对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的 tcp_syn_retries 来决定这个值)</li>
<li>tcp_syncookies：当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</li>
<li>tcp_max_syn_backlog：对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。</li>
<li>tcp_abort_on_overflow：当守护进程太忙而不能接受新的连接，就向对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</li>
<li>tcp_max_tw_buckets：系 统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐(事实上做NAT的时候最好可以适当地增加该值)</li>
<li>tcp_tw_recycle：打开快速 TIME-WAIT sockets 回收。(做NAT的时候，建议打开它)</li>
<li>tcp_tw_reuse：该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</li>
<li>tcp_timestamps：Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。</li>
<li>tcp_max_orphans：系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐</li>
<li>tcp_fin_timeout ：对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。</li>
<li>tcp_keepalive_time：当keepalive打开的情况下，TCP发送keepalive消息的频率。默认值是7200(2小时)</li>
<li>tcp_keepalive_probes：TCP发送keepalive探测以确定该连接已经断开的次数。默认值是9</li>
<li>tcp_keepalive_intvl：探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul>
<li>SYN超时或syn攻击防御<ul>
<li>tcp_syncookies</li>
<li>tcp_synack_retries</li>
<li>tcp_max_syn_backlog</li>
<li>tcp_abort_on_overflow</li>
</ul>
</li>
<li>TIME_WAIT处理<ul>
<li>TIME_WAIT快速回收<ul>
<li>tcp_tw_recycle</li>
<li>tcp_timestamps</li>
</ul>
</li>
<li>TIME_WAIT重用<ul>
<li>tcp_tw_reuse</li>
<li>tcp_timestamps</li>
</ul>
</li>
<li>tcp_max_tw_buckets：控制并发的TIME_WAIT数量</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/zhangxinrun/article/details/7621028" target="_blank" rel="noopener">tcp_syn_retries等参数详解</a></li>
<li><a href="https://blog.csdn.net/changyourmind/article/details/53127100" target="_blank" rel="noopener">浅析TCP协议中的疑难杂症</a></li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习</title>
    <url>/blog/2018/02/26/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>段落是由一个或多个的文本行组成，段落前后必须包含一个或多个空行<br>段落内的换行方式：两个空格+回车</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 级别一</span><br><span class="line">## 级别二</span><br><span class="line">###### 级别六</span><br><span class="line">末尾可以加#，但只起美观作用，且#的数量可以任意</span><br></pre></td></tr></table></figure>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><p>在段落的开始使用任意数量的&gt;符号划分缩进层级</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表展示"><a href="#无序列表展示" class="headerlink" title="无序列表展示"></a>无序列表展示</h2><ul>
<li>使用*或+或-，然后跟一个空格或制表符，最多三个空格</li>
<li>列表必须是一个单独的段落[<strong>列表前必须是标题或空行</strong>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* apple </span><br><span class="line">* banana </span><br><span class="line">* orange </span><br><span class="line">* coconut</span><br></pre></td></tr></table></figure>
<h2 id="有序列表显示"><a href="#有序列表显示" class="headerlink" title="有序列表显示:"></a>有序列表显示:</h2><blockquote>
<p>使用数字+英文句点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. Bird </span><br><span class="line">1. McHale </span><br><span class="line">8. Parish</span><br></pre></td></tr></table></figure>
<h2 id="多级列表使用缩进实现"><a href="#多级列表使用缩进实现" class="headerlink" title="多级列表使用缩进实现"></a>多级列表使用缩进实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* aa  </span><br><span class="line">    * bb  </span><br><span class="line">* cc</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><ul>
<li>在原始代码的每一行前添加4个空格或一个制表符</li>
<li>或者使用```代码```</li>
</ul>
<p>为了使语法高亮，应当提示代码类型如下所示：<br>```python<br>print(‘hello’)<br>```</p>
<h2 id="文本中的代码标记-反引号"><a href="#文本中的代码标记-反引号" class="headerlink" title="文本中的代码标记[反引号]"></a>文本中的代码标记[反引号]</h2><p>小段代码标记：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python代码:`print(&apos;hello world&apos;)`</span><br></pre></td></tr></table></figure></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;链接到[django](https://www.djangoproject.com/)站点 </span><br><span class="line">链接到[admin](/admin)站点</span><br></pre></td></tr></table></figure>
<h2 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;链接到[百度][]站点 </span><br><span class="line">链接到[腾讯][qq]站点</span><br><span class="line">[百度]: http://www.baidu.com</span><br><span class="line">[qq]: http://www.qq.com</span><br></pre></td></tr></table></figure>
<h2 id="原始链接"><a href="#原始链接" class="headerlink" title="原始链接"></a>原始链接</h2><blockquote>
<p>使用方括号包围网址或邮箱地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;http://www.163.com&gt; </span><br><span class="line">&lt;hejingqi@quxiu8.com&gt;</span><br></pre></td></tr></table></figure>
<h2 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">美女图片: </span><br><span class="line">![beauty][]</span><br><span class="line">[beauty]: http://file.youxiniao.com/uploads/allimg/160615/63-160615144538.jpg</span><br></pre></td></tr></table></figure>
<h2 id="页面内跳转"><a href="#页面内跳转" class="headerlink" title="页面内跳转"></a>页面内跳转</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[点击跳转](#jump)                   #使用Markdown跳转</span><br><span class="line">&lt;span id=&quot;jump&quot;&gt;跳转到这&lt;/span&gt;     #设置跳转的锚点[id]</span><br></pre></td></tr></table></figure>
<h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><ul>
<li>使用*或下划线来强调,单个为斜体，2个为加粗<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体* </span><br><span class="line">__加粗__</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h1><p>[在文本中使用*-等字符的原始含义]</p>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><ul>
<li>显示：<del>删除</del></li>
<li>源码：<code>~~删除~~</code></li>
</ul>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>可以使用连续3个以上星号或减号做分割线【星号或减号之间可以有空格】，但是行内不能有其他字符</p>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础知识</title>
    <url>/blog/2019/06/11/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="http浏览过程"><a href="#http浏览过程" class="headerlink" title="http浏览过程"></a>http浏览过程</h1><ol>
<li>用户提交域名</li>
<li>浏览器进行域名解析<ol>
<li>浏览器使用本地缓存进行域名解析【刷新dns缓存：ipconfig/flushdns】</li>
<li>本地无缓存时使用本地dns服务器</li>
<li>本地dns无缓存时向授权dns服务器请求解析</li>
</ol>
</li>
<li>有使用CDN时，进入CDN解析循环</li>
</ol>
<h1 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h1><h2 id="BS模式"><a href="#BS模式" class="headerlink" title="BS模式"></a>BS模式</h2><p>即browser/server浏览器/服务器模式，是一种三层架构【页面显示、逻辑处理、数据库访问】， B/S架构中显示逻辑交给了web浏览器，事务处理放在webapp上，这样就避免了庞大的客户端，减少了客户端的压力，因为客户端包含的逻辑较少，因此也被称为瘦客户端</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无需安装客户端，有web浏览器就够了</li>
<li>BS架构无需升级多个客户端，升级服务器就行了</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在跨浏览器上，需要测试人员进行各种测试</li>
<li>在速度和安全上需要花费巨大的设计成本，这是BS架构的最大问题</li>
<li>客户端服务器的交互式请求-相应模式，通常需要刷新页面，这并是不客户乐意做的（在Ajax实用化后此问题得到一定程度的缓解）</li>
</ul>
<h2 id="CS模式"><a href="#CS模式" class="headerlink" title="CS模式"></a>CS模式</h2><p>C/S系统是一种典型的两层架构，期全称为Client/server，客户端服务端架构，客户端包含一个或多个在用户电脑上运行的程序，而服务端有两种，一种为数据库服务端，客户端通过数据库连接访问服务端的数据；另一种是socket服务器端，服务器程序通过socket与客户端程序通信。<br>C/S架构为胖客户端，因为客户端需要实现绝大部分的业务逻辑和页面展示。这种架构中，通过与数据库交互（通常是sql或存储过程的实现）来达到持久化数据。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>C/S架构的页面和操作可以很丰富</li>
<li>服务器端和客户端可以更好的兼容</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要安装客户端，不利于向未知用户推广</li>
<li>维护成本高，发生一次升级，则所有客户端的程序都需要改变</li>
</ul>
<h1 id="网页技术"><a href="#网页技术" class="headerlink" title="网页技术"></a>网页技术</h1><h2 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h2><p>程序在客户端浏览器解析，它是相对于动态网页而言，是指没有后台数据库、不含程序和可交互的网页。通俗来说就是编辑什么显示什么不会有任何变化。<br>常见扩展名为：htm、html、xml、shtml、jpg(gif、png、bmp等所有图片)、js、css（样式），swf，avi，wmv，flv视频格式</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>静态网页的每个页面都有一个固定的url，且网页url一般以.html、.htm、.shtml常见后缀，而且地址中不含有问号“？”或“&amp;”等特殊符号；</li>
<li>静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件</li>
<li>静态网页内容相对稳定，因此更容易被搜索引擎收录</li>
<li>静态网页没有数据库支持，维护更新不便</li>
<li>静态网页交互性差</li>
<li>网页程序在浏览器端解析，服务器直接返回数据，能够接受更多的并发</li>
</ul>
<h3 id="静态网页语言"><a href="#静态网页语言" class="headerlink" title="静态网页语言"></a>静态网页语言</h3><p>html，js，css，xml</p>
<h2 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a>动态网页</h2><p>以asp、aspx、php、jsp、do、cgi、perl为后缀，并且一般动态网页中含有标志性的“？”、“&amp;”等</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>以数据库技术为基础</li>
<li>可以实现更多的功能，如用户登录、用户注册、在线调查、用户管理、订单管理等</li>
<li>动态网页大多并不是独立存在于服务器的网页文件，只有当用户请求时服务器才返回一个完整页面</li>
<li>动态网页中的“？”对搜索引擎的收录存在一定问题，搜索引擎一般不可能从一个网站的数据库中访问全部的网页，或者出于技术方面的考虑，所有蜘蛛一般不会去抓取网址中“？”后面的内容，一般采用动态网页的网站在进行搜索引擎推广时需要做一定的技术处理（伪静态）才能适应搜索引擎的抓取要求。</li>
<li>程序在服务端解析，服务端：php引擎，java容器（tomcat，resin，jboss、weblogic）</li>
<li>由于程序在服务端解析，因此会消耗大量的cpu和内存等资源，因此效率不如静态网页</li>
</ul>
<h2 id="伪静态网页"><a href="#伪静态网页" class="headerlink" title="伪静态网页"></a>伪静态网页</h2><ul>
<li>由于搜索引擎无法正确读取带参数的动态网页内容，多数网站采用动态生成静态页面的技术，消除动态网页中的参数，使搜索引擎收录更多的网页，达到优化的效果，伪静态实质依然是动态页面。</li>
<li>伪静态技术：通过某些技术（如rewrite规则），把网页的url重写，同时消除了动态网页中的参数，但是并不生成任何的页面，仅改变了地址路径，以达到搜索引擎收录的目的。</li>
</ul>
<h1 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/http-header.png" alt></p>
<ul>
<li>请求行<ul>
<li>范例：GET /index.html HTTP/1.1</li>
<li>请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT<ul>
<li>GET：当客户端从服务端读取文档时使用GET方法，使用GET方法时，请求参数和对应的值附加到URL后，利用一个问号（“？”）代表URL的结束与请求参数的开始，传递参数的最长为1024个字节</li>
<li>POST：当客户端向服务端提交的信息较多时使用POST方法，POST方法将参数和值封装在请求的数据中，以键值对的形式出现</li>
</ul>
</li>
</ul>
</li>
<li>请求头<ul>
<li>请求头部由关键字/值对组成，每行一对。关键字与值使用英文冒号分割。请求头部通知服务器关于客户端请求的信息。</li>
<li>典型的请求头有：<ul>
<li>User-agent：产生请求的浏览器类型</li>
<li>Accept：客户端可识别的内容类型列表</li>
<li>Host：请求的主机名，允许多个域名同处一个ip地址，即为虚拟主机。</li>
</ul>
</li>
</ul>
</li>
<li>空行<ul>
<li>最后一个请求头之后是一个空行，发送回车和换行符，通知服务器一下不再有请求头</li>
<li>对于一个完整的http请求来说，空行是必须的，否则服务器会认为本次请求的数据尚未完全发送到服务器，服务器会一直处于等待状态。</li>
</ul>
</li>
<li><p>请求数据</p>
<ul>
<li>请求数据不在GET方法中，而是在POST方法中</li>
<li>POST方法适用于需要客户填写表单的场合</li>
<li>与请求数据相关的最常用的请求头有Content-Type和Content-Length</li>
</ul>
</li>
<li><p>GET与POST</p>
<ul>
<li>GET是从服务器上获取数据，POST是向服务器传送数据</li>
<li>对于GET方式，服务端使用Request.QueryString获取变量的值；POST方式服务端使用Request.Form获取提交的数据</li>
<li>GET方式通过URL提交数据，数据在URL中可以看到，所以不安全；POST方式，数据放在html header中，较为安全。</li>
<li>GET方式提交的数据最多为1024字节，POST方式则没有限制。</li>
</ul>
</li>
</ul>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><table>
<thead>
<tr>
<th>群组</th>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>2系列【成功】</td>
<td>200</td>
<td>OK,服务器成功返回网页</td>
</tr>
<tr>
<td>3系列【重定向】</td>
<td>301</td>
<td>Moved Permanently（永久跳转）请求的网页已永久跳转到新位置</td>
</tr>
<tr>
<td>4系列【请求错误】</td>
<td>403</td>
<td>Forbidden（禁止访问）服务器拒绝请求</td>
</tr>
<tr>
<td>4系列</td>
<td>404</td>
<td>Not Found，服务器找不到请求的页面</td>
</tr>
<tr>
<td>5系列【服务器错误】</td>
<td>500</td>
<td>Internal Server Error(内部服务器错误)</td>
</tr>
<tr>
<td>5系列</td>
<td>502</td>
<td>Bad Gateway（坏的网关），一般是网关服务器请求后端服务时，后端服务没有按照http协议正确返回结果</td>
</tr>
<tr>
<td>5系列</td>
<td>503</td>
<td>Service Unavailable（服务不可用），可能因为超载或停机维护</td>
</tr>
<tr>
<td>5系列</td>
<td>504</td>
<td>Gateway Timeout（网关超时），一般是因为网关服务器请求后端服务时，后端服务没有在特定的时间内完成服务</td>
</tr>
</tbody>
</table>
<h1 id="名词注解"><a href="#名词注解" class="headerlink" title="名词注解"></a>名词注解</h1><ul>
<li>IP：独立的ip数，是网站流量分析的重要指标，0:00-24:00内相同ip被计算一次</li>
<li>PV【page view 访问量】：用户刷新一次被计算1次</li>
<li>UV【unique vistor独立访客】：访问网站的一个电脑客户端为一个访客<ul>
<li>通过IP地址+其他特征信息定义</li>
<li>通过cookies分辨</li>
</ul>
</li>
<li>URI标记一个网络资源</li>
<li>URL用地址标记一个网络资源<ul>
<li>格式：scheme://host.domain:port/path/filename</li>
<li>范例：<a href="http://www.w3school.com.cn/html/html_url.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html/html_url.asp</a></li>
</ul>
</li>
</ul>
<h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><ul>
<li>IIS：windows下常用web服务器</li>
<li>apache</li>
<li>nginx</li>
<li>tomcat</li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>状态码</tag>
        <tag>http报文</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法学习</title>
    <url>/blog/2018/02/27/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/yaml%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时只允许使用空格，不允许使用tab</li>
<li>缩进时的空格数量不重要，重要的是同一层级的元素左侧对齐</li>
<li>#表示注释</li>
<li>yaml文件应当以’—‘【三横杠】开头，以’…’【三点】结尾</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>语法：以key: value形式表示字典（冒号后必须跟着一个空格）</p>
<h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><p><code>dict: {a: &#39;test1&#39;, b: &#39;test2&#39;}</code></p>
<h2 id="复合式"><a href="#复合式" class="headerlink" title="复合式"></a>复合式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict:</span><br><span class="line"> a: &apos;test3&apos;</span><br><span class="line"> b: &apos;test4&apos;</span><br></pre></td></tr></table></figure>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>语法：列表的所有成员都是从同一缩进级别开始的行，以“ - ”开头（短划线和空格）</p>
<h2 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h2><p><code>list: [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]</code></p>
<h2 id="复合式-1"><a href="#复合式-1" class="headerlink" title="复合式"></a>复合式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list:</span><br><span class="line"> - one</span><br><span class="line"> - two</span><br><span class="line"> - three</span><br></pre></td></tr></table></figure>
<h1 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>字符串有多行内容时，使用<code>|</code>或<code>&gt;</code>表示</li>
<li>字符串内容默认可以直接表示，不用添加引号</li>
<li>当字符串内容以<code>[] {} &gt; | * &amp; ! % # \</code> @ ,`开头时，应当对字符串整体使用双引号</li>
<li>字符串中包含单引号、双引号、反斜线，应当对字符串整体使用双引号，同时也要使用转义字符进行转义</li>
<li>由于”: “【冒号后接空格】表示一个映射【字典、列表】，“ #”【空格后接井号】表示注释，因此字符串中包含这些时需要整体使用引号</li>
<li>单引号和双引号的区别就是，双引号可以使用转义字符【比如<code>\n</code>】</li>
</ul>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>数字</li>
<li>字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str: |</span><br><span class="line"> line 1</span><br><span class="line"> line 2</span><br><span class="line"> line 3</span><br><span class="line">str: &gt;</span><br><span class="line"> line 1</span><br><span class="line"> line 2</span><br><span class="line"> line 3</span><br></pre></td></tr></table></figure>
<ul>
<li>布尔值</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><code>&amp;</code>定义锚点，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>引用锚点</li>
<li>范例1-字典</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据结构</span><br><span class="line">dict1: &amp;defaults &#123;a: &apos;test1&apos;, b: &apos;test2&apos;&#125;</span><br><span class="line">dict2:</span><br><span class="line"> c: &apos;test3&apos;</span><br><span class="line"> d: &apos;test4&apos;</span><br><span class="line"> &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">print(dict1, dict2)</span><br><span class="line">&#123;&apos;a&apos;: &apos;test1&apos;, &apos;b&apos;: &apos;test2&apos;&#125; </span><br><span class="line">&#123;&apos;c&apos;: &apos;test3&apos;, &apos;a&apos;: &apos;test1&apos;, &apos;d&apos;: &apos;test4&apos;, &apos;b&apos;: &apos;test2&apos;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>范例2-列表</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ceshi:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&amp;var</span> <span class="string">a</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">d</span></span><br><span class="line"> <span class="bullet">-</span> <span class="meta">*var</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>windows常用工具</title>
    <url>/blog/2019/05/11/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/windows%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h1><h2 id="办公类"><a href="#办公类" class="headerlink" title="办公类"></a>办公类</h2><ul>
<li>beyondCompare：文本比较工具</li>
<li><a href="#git">git</a>：windows下git工具（一般作为windows下的linux命令行使用）</li>
<li><a href="#pycharm">pycharm</a>：python集成开发工具</li>
<li><a href="#sublimetext3">sublimeText3</a>：文本编辑工具</li>
<li>xmind8：思维导图工具</li>
<li>secureCRT：linux系统远程连接工具</li>
<li>Postman：接口调试工具</li>
<li>navicat：数据库连接工具</li>
<li>DockerToolbox：windows下docker使用环境<ul>
<li>（默认安装）Oracle VM VirtualBox：虚拟化工具</li>
<li>（默认安装）Git MSYS-git UNIX tools：windows下linux命令行工具</li>
</ul>
</li>
<li>shadowsocks：FQ工具</li>
<li>wireshark：网络包分析工具</li>
</ul>
<h2 id="生活类"><a href="#生活类" class="headerlink" title="生活类"></a>生活类</h2><ul>
<li>快播/QQ影音</li>
<li>印象笔记</li>
<li>windows便签</li>
<li>迅雷下载极速版</li>
<li>uiso：镜像制作工具</li>
<li>驱动精灵万能网卡版</li>
<li>teamviewer：远程协作工具</li>
<li>office</li>
<li>DiskGenius：硬盘分区工具</li>
<li>DriverStoreExplorer：驱动卸载工具</li>
<li>百度网盘</li>
<li>firefox/chrome</li>
<li>QQ浏览器：<ul>
<li>qq登录</li>
<li>书签同步</li>
<li>网站账号云同步</li>
</ul>
</li>
</ul>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在环境变量PATH中添加路径【C:\Git\bin；C:\Git\usr\bin】以方便适用其中的linux命令</p>
<h1 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h1><p>设置py文件默认头部信息【file and code templates】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author  : simple0426</span><br><span class="line"># @Email   : istyle.simple@gmail.com</span><br><span class="line"># @File    : $&#123;NAME&#125;.py</span><br><span class="line"># @Software: $&#123;PRODUCT_NAME&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sublimetext3"><a href="#sublimetext3" class="headerlink" title="sublimetext3"></a>sublimetext3</h1><h2 id="安装packagecontrol"><a href="#安装packagecontrol" class="headerlink" title="安装packagecontrol"></a>安装packagecontrol</h2><ul>
<li>安装地址：<a href="http://packagecontrol.cn/installation#st3" target="_blank" rel="noopener">http://packagecontrol.cn/installation#st3</a></li>
<li>执行命令：通过 ctrl+` 或 View &gt; Show Console打开控制台，将Python代码粘贴到控制台，回车。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.cn/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure>
<ul>
<li>添加或修改PackageControl的channels【PackageControl-SettingsUser】：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;channels&quot;: [ &quot;http://packagecontrol.cn/channel_v3.json&quot; ]</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>ctrl+shift+p &gt;&gt; install package &gt;&gt; xxxx</p>
</blockquote>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/sublimeText3-plugins.jpg" alt></p>
<h3 id="Pretty-JSON"><a href="#Pretty-JSON" class="headerlink" title="Pretty JSON"></a>Pretty JSON</h3><p>按Ctrl+Alt+J就可格式化json数据</p>
<h3 id="Table-Editor"><a href="#Table-Editor" class="headerlink" title="Table Editor"></a>Table Editor</h3><ul>
<li>通过<code>Ctrl+Shift+P-&gt;Table Editor: Enable for current view</code>开启  </li>
<li>先输入标题行,如<code>|id|name|age|</code>，回车后在第二行输入<code>|-</code>后，<br>按tab键就将进入table编辑模式  </li>
<li>表格必须与前面输入的文字之间有空行，否则表格会被当成普通文字渲染 </li>
</ul>
<h3 id="Markdown-Editing"><a href="#Markdown-Editing" class="headerlink" title="Markdown Editing"></a>Markdown Editing</h3><ul>
<li>设置：package setting–&gt;markdown editing–&gt;GFM setings User  </li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"draw_centered"</span>: <span class="literal">false</span>, <span class="comment">//去除文字整体居中</span></span><br><span class="line">    <span class="attr">"color_scheme"</span>: <span class="string">"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme"</span>, <span class="comment">//主题与sublime保持一致</span></span><br><span class="line">    <span class="attr">"line_numbers"</span>: <span class="literal">true</span>, <span class="comment">//显示行号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在全局设置中忽略默认的markdown</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"ignored_packages":</span><br><span class="line">[</span><br><span class="line">    <span class="string">"Markdown"</span>,</span><br><span class="line">    <span class="string">"Vintage"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h3 id="Markdown-preview"><a href="#Markdown-preview" class="headerlink" title="Markdown preview"></a>Markdown preview</h3><ul>
<li>按键绑定的设置：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; &quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.tmTheme&quot;,</span><br><span class="line">    &quot;expand_tabs_on_save&quot;: true,</span><br><span class="line">    &quot;font_face&quot;: &quot;微软雅黑&quot;,</span><br><span class="line">    &quot;font_size&quot;: 12,</span><br><span class="line">    &quot;ignored_packages&quot;:</span><br><span class="line">    [</span><br><span class="line">        &quot;Vintage&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;pep8_ignore&quot;:</span><br><span class="line">    [</span><br><span class="line">        &quot;E123&quot;,</span><br><span class="line">        &quot;E128&quot;,</span><br><span class="line">        &quot;E301&quot;,</span><br><span class="line">        &quot;E302&quot;,</span><br><span class="line">        &quot;E309&quot;,</span><br><span class="line">        &quot;E401&quot;,</span><br><span class="line">        &quot;E305&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;tab_size&quot;: 4,</span><br><span class="line">    &quot;theme&quot;: &quot;Default.sublime-theme&quot;,</span><br><span class="line">    &quot;translate_tabs_to_spaces&quot;: true,</span><br><span class="line">    &quot;update_check&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>beyondCompare</tag>
        <tag>pycharm</tag>
        <tag>sublimeText</tag>
        <tag>xmind</tag>
      </tags>
  </entry>
  <entry>
    <title>博客应用hexo</title>
    <url>/blog/2018/02/26/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8hexo/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">参考</a></p>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><p><code>npm install -g hexo-cli</code></p>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="hexo建站"><a href="#hexo建站" class="headerlink" title="hexo建站"></a>hexo建站</h2><ul>
<li>hexo init blog</li>
<li>cd blog</li>
<li>npm install</li>
</ul>
<h2 id="使用git版本控制"><a href="#使用git版本控制" class="headerlink" title="使用git版本控制"></a>使用git版本控制</h2><ul>
<li>目录切换：cd blog</li>
<li>初始化：git init</li>
<li>关联远程：git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:simple0426/blog.git</li>
<li>保持同步：git pull origin master</li>
</ul>
<h1 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h1><ul>
<li>scaffolds：模版文件夹。Hexo的模板是指在新建的markdown文件中默认填充的内容。</li>
<li>source：资源文件夹是存放用户资源的地方。<ul>
<li>除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。</li>
<li>Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li>
</ul>
</li>
<li>themes：主题 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul>
<h1 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h1><p>相当于在markdown文件中使用非markdown语法，<br>它是的hexo私有语法，不能被markdown解析，但可以被hexo解析  </p>
<h2 id="引入其他文章"><a href="#引入其他文章" class="headerlink" title="引入其他文章"></a>引入其他文章</h2><p>语法：{% post_link path/to/file [title] %}<br>范例：{% post_link 系统管理/系统基础/shell编程 shell %}<br>注意：post_link使用的路径为相对于source/posts的路径  </p>
<h2 id="引入代码"><a href="#引入代码" class="headerlink" title="引入代码"></a>引入代码</h2><p>语法：{% include [title] [lang:language] path/to/file %}<br>范例：{% include_code python登录 lang:python login.py %}<br>目录设置：  </p>
<ul>
<li>代码目录【code_dir】在主站config.yml中设置</li>
<li>【code_dir：code】表示路径为source/code</li>
<li>上述login.py表示的实际路径为source/code/login.py</li>
</ul>
<h1 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li>cd blog</li>
<li>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><ul>
<li>theme: next【主题】</li>
<li>language: zh-Hans【语言】</li>
<li>order_by: -updated【以文章修改时间排序】</li>
</ul>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><ul>
<li>scheme: Mist【主题风格】</li>
<li>文章缩略显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<ul>
<li>菜单配置【主题配置】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: / || home</span><br><span class="line"> tags: /tags/ || tags</span><br><span class="line"> categories: /categories/ || th</span><br><span class="line"> archives: /archives/ || archive</span><br></pre></td></tr></table></figure>
<h2 id="分类与标签"><a href="#分类与标签" class="headerlink" title="分类与标签"></a>分类与标签</h2><ul>
<li>创建categories和tags目录</li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">分类页</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE%E4%BA%91%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">标签页</a></li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>npm install hexo-generator-searchdb</code></p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p>主题配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="加入代码块复制功能"><a href="#加入代码块复制功能" class="headerlink" title="加入代码块复制功能"></a>加入代码块复制功能</h2><p>在NexT主题的v6.3版本里已经加入了代码复制这个功能，所以如果你刚开始使用NexT，直接升级主题，并在主题配置文件中打开代码复制的开关就好了。</p>
<p>在Next5.1.4版本中添加此功能：<a href="https://qiming.info/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">https://qiming.info/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/</a></p>
<p>悬疑步骤：themes/next/_config.yml中增加codeblock配置选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result</span><br><span class="line">    show_result: true</span><br></pre></td></tr></table></figure>
<h1 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h1><ul>
<li>hexo init：新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</li>
<li>hexo new 文章标题：新建一篇文章</li>
<li>hexo new draft 文章标题：新建一篇草稿【或私密文章】<ul>
<li>在source/<code>_</code>drafts目录下建立相应文件</li>
</ul>
</li>
<li>hexo generate|g：生成静态文件。</li>
<li>hexo server|s <ul>
<li>-p, –port    重设端口【默认4000】</li>
<li>-s, –static  只使用静态文件</li>
<li>-l, –log 启动日记记录，使用覆盖记录格式</li>
<li>–drafts 将草稿也显示【默认不显示草稿】</li>
</ul>
</li>
<li>hexo deploy|d：部署网站。<ul>
<li>-g, –generate    部署之前预先生成静态文件</li>
</ul>
</li>
<li>hexo clean：清除缓存文件 (db.json) 和已生成的静态文件 (public)。</li>
<li>hexo publish 文章标题：将草稿发布为文章</li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="文章插入图片"><a href="#文章插入图片" class="headerlink" title="文章插入图片"></a>文章插入图片</h2><ul>
<li>主站配置：post_asset_folder:这个选项设置为true</li>
<li>安装插件：npm install hexo-asset-image</li>
<li>使用：<ul>
<li>运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 </li>
<li>把图片复制进入文件夹内</li>
<li>markdown文章内引入<code>![](xxxx目录/图片)</code></li>
</ul>
</li>
</ul>
<h2 id="github-pages配置"><a href="#github-pages配置" class="headerlink" title="github-pages配置"></a>github-pages配置</h2><blockquote>
<p>使用gh-pages分支方式部署</p>
</blockquote>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>npm install hexo-deployer-git</p>
<h3 id="主站配置"><a href="#主站配置" class="headerlink" title="主站配置"></a>主站配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http://blog.unlazy.cn/</span><br><span class="line">root: /</span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@github.com:simple0426/blog.git</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>
<h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><ul>
<li>在source文件夹下建立CNAME文件</li>
<li>CNAME文件内容：blog.unlazy.cn</li>
</ul>
<h3 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h3><p><code>hexo d -g</code></p>
<h2 id="public的压缩bug"><a href="#public的压缩bug" class="headerlink" title="public的压缩bug"></a>public的压缩bug</h2><ul>
<li>现象：将windows下的public文件夹使用zip压缩后，传输至linux系统，文章标题为中文的的文件或目录名乱码</li>
<li>原因：这是zip格式的缺陷，所以目前并没有很完美的解决办法。<a href="http://blog.csdn.net/u012260238/article/details/52718416" target="_blank" rel="noopener">参考</a></li>
<li>解决：使用tar方式传输public文件夹</li>
</ul>
<h2 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h2><blockquote>
<p>特别注意的是小括号 ( ) 大括号 { } ,如果不小心写了,你执行hexo s –debug可能报一些莫名其妙的错误! </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! &amp;#33; — 惊叹号Exclamation mark </span><br><span class="line">” &amp;#34; &amp;quot; 双引号Quotation mark </span><br><span class="line"># &amp;#35; — 数字标志Number sign </span><br><span class="line">$ &amp;#36; — 美元标志Dollar sign </span><br><span class="line">% &amp;#37; — 百分号Percent sign </span><br><span class="line">&amp; &amp;#38; &amp;amp; Ampersand </span><br><span class="line">‘ &amp;#39; — 单引号Apostrophe </span><br><span class="line">( &amp;#40; — 小括号左边部分Left parenthesis </span><br><span class="line">) &amp;#41; — 小括号右边部分Right parenthesis </span><br><span class="line">* &amp;#42; — 星号Asterisk </span><br><span class="line">+ &amp;#43; — 加号Plus sign </span><br><span class="line">&lt; &amp;#60; &amp;lt; 小于号Less than </span><br><span class="line">= &amp;#61; — 等于符号Equals sign </span><br><span class="line">&gt; &amp;#62; &amp;gt; 大于号Greater than </span><br><span class="line">? &amp;#63; — 问号Question mark </span><br><span class="line">@ &amp;#64; — Commercial at </span><br><span class="line">[ &amp;#91; --- 中括号左边部分Left square bracket </span><br><span class="line">\ &amp;#92; --- 反斜杠Reverse solidus (backslash) </span><br><span class="line">] &amp;#93; — 中括号右边部分Right square bracket </span><br><span class="line">&#123; &amp;#123; — 大括号左边部分Left curly brace </span><br><span class="line">| &amp;#124; — 竖线Vertical bar </span><br><span class="line">&#125; &amp;#125; — 大括号右边部分Right curly brace</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>时间格式</title>
    <url>/blog/2019/08/07/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>格式符</th>
<th>含义</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>缩写的星期几</td>
<td>Sun</td>
</tr>
<tr>
<td>%A</td>
<td>完整的星期几</td>
<td>Sunday</td>
</tr>
<tr>
<td>%b/%h</td>
<td>缩写的月份</td>
<td>Mar</td>
</tr>
<tr>
<td>%B</td>
<td>完整的月份</td>
<td>March</td>
</tr>
<tr>
<td>%c</td>
<td>日期和时间表示法</td>
<td>Sun Aug 19 02:56:02 2012</td>
</tr>
<tr>
<td>%d</td>
<td>一月中的第几天（01-31）</td>
<td>19</td>
</tr>
<tr>
<td>%D</td>
<td>年月日格式%m/%d/%Y</td>
<td>08/07/19</td>
</tr>
<tr>
<td>%F</td>
<td>全格式年月日：%Y-%m-%d</td>
<td>2019-08-07</td>
</tr>
<tr>
<td>%H</td>
<td>24小时制的小时（00-23）</td>
<td>14</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制的小时（01-12）</td>
<td>05</td>
</tr>
<tr>
<td>%j</td>
<td>一年中的第几天（001-366）</td>
<td>231</td>
</tr>
<tr>
<td>%m</td>
<td>十进制表示的月份（01-12）</td>
<td>08</td>
</tr>
<tr>
<td>%M</td>
<td>分（00-59）</td>
<td>55</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM名称</td>
<td>PM</td>
</tr>
<tr>
<td>%P</td>
<td>和%p一样，小写形式</td>
<td>am</td>
</tr>
<tr>
<td>%s</td>
<td>timestamp时间戳</td>
<td>-</td>
</tr>
<tr>
<td>%S</td>
<td>秒 （00-59）</td>
<td>02</td>
</tr>
<tr>
<td>%T</td>
<td>时分秒格式%H:%M:%S</td>
<td>10:03:24</td>
</tr>
<tr>
<td>%U</td>
<td>一年中的第几周，以第一个星期日为第一周的第一天（00-53）</td>
<td>33</td>
</tr>
<tr>
<td>%w</td>
<td>十进制表示的星期几，星期日表示为0（0-6）</td>
<td>4</td>
</tr>
<tr>
<td>%W</td>
<td>一年中的第几周，以第一个星期一作为第一周的第一天（00-53）</td>
<td>34</td>
</tr>
<tr>
<td>%x</td>
<td>日期表示法</td>
<td>08/19/12</td>
</tr>
<tr>
<td>%X</td>
<td>时间表示法</td>
<td>02:50:06</td>
</tr>
<tr>
<td>%y</td>
<td>年份的最后两个数字（00-99）</td>
<td>01</td>
</tr>
<tr>
<td>%Y</td>
<td>年份</td>
<td>2012</td>
</tr>
<tr>
<td>%Z</td>
<td>时区的名称或缩写</td>
<td>CST</td>
</tr>
<tr>
<td>%%</td>
<td>一个%符号</td>
<td>%</td>
</tr>
<tr>
<td>%n</td>
<td>换行</td>
<td>-</td>
</tr>
<tr>
<td>%t</td>
<td>制表符</td>
<td>-</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>时间格式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/blog/2019/08/05/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="POSIX正则表达式"><a href="#POSIX正则表达式" class="headerlink" title="POSIX正则表达式"></a>POSIX正则表达式</h1><ul>
<li>常见的正则表达式记法，其实都源于Perl。实际上，正则表达式从Perl衍生出一个显赫的流派，叫做PCRE（Perl Compatible Regular Expression），\d、\w、\s 之类的记法，就是这个流派的特征。但是在PCRE之外，正则表达式还有其它流派，比如下面要介绍的POSIX规范的正则表达式。</li>
<li>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），主要定义了unix系统的接口规范；相应的，POSIX正则表达式定义了类unix系统下的正则表达式规范</li>
<li>POSIX定义了两种类型的正则表达式：<ul>
<li>BRE(Basic Regular Expression)：基本正则表达式<ul>
<li>包含的特殊字符：<code>. \ [ ^ $ *</code></li>
<li>grep/vim/sed使用的即是基本正则</li>
</ul>
</li>
<li>ERE(Extended Regular Expressions)：扩展正则表达式<ul>
<li>ERE相对于BRE多了7个特殊字符：<code>? + { } | ( )</code>；在BRE中要实现相应的功能，则需要使用转义符。</li>
<li>egrep/awk使用的即是扩展正则，同时也兼容PCRE</li>
<li>BRE和ERE(PCRE与ERE基本相同)区别</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能含义</th>
<th>BRE</th>
<th>ERE</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义子表达式的开始</td>
<td><code>\(</code></td>
<td>(</td>
</tr>
<tr>
<td>定义子表达式的结束</td>
<td><code>\)</code></td>
<td>)</td>
</tr>
<tr>
<td>匹配前一个字符(子表达式)的一次或多次</td>
<td><code>\+</code></td>
<td>+</td>
</tr>
<tr>
<td>匹配前一个字符(子表达式)的零次或一次</td>
<td><code>\?</code></td>
<td>?</td>
</tr>
<tr>
<td>大括号开始</td>
<td><code>\{</code></td>
<td><code>{</code></td>
</tr>
<tr>
<td>大括号结束</td>
<td><code>\}</code></td>
<td><code>}</code></td>
</tr>
<tr>
<td>交替匹配</td>
<td><code>\</code>&#124;</td>
<td>&#124;</td>
</tr>
</tbody>
</table>
<ul>
<li>POSIX与PCRE的区别<ul>
<li>POSIX字符组中，反斜线\不是用来转义的。所以POSIX方括号表示法<code>[\d]</code>只能匹配<code>\</code>和d两个字符，而不是<code>[0-9]</code>对应的数字字符。</li>
<li>POSIX与PCRE的预定义字符不同</li>
</ul>
</li>
</ul>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><ul>
<li><code>.</code>：匹配任何字符，包含换行符</li>
<li><code>\</code>：转义字符</li>
<li>方括号表达式<ul>
<li><code>[012asdf89]</code>：匹配任意单个字符</li>
<li><code>[^01asdf67]</code>：字符列表取反</li>
<li><code>[a-d]</code>：范围表达式，等同于<code>[abcd]</code>【和地区字典排序有关】</li>
<li>包含<code>]</code>时必须放在方括号的第一个位置</li>
<li>包含<code>^</code>不能放在第一个位置</li>
<li>包含<code>-</code>必须放在括号内的最后一个位置</li>
</ul>
</li>
</ul>
<h1 id="预定义字符"><a href="#预定义字符" class="headerlink" title="预定义字符"></a>预定义字符</h1><blockquote>
<p>即POSIX标准字符类【和地区字典无关的设置】<br>主要用于补充POSIX标准不存在单词、数字等基本预定义字符【如：PCRE中存在\s \w \d等预定义字符】</p>
</blockquote>
<ul>
<li><code>[:alnum:]</code>：字母和数字</li>
<li><code>[:alpha:]</code>：字母</li>
<li><code>[:blank:]</code>：空格或tab</li>
<li><code>[:cntrl:]</code>：控制字符</li>
<li><code>[:digit:]</code>：数字</li>
<li><code>[:graph:]</code>：任何可看到且可打印的字符</li>
<li><code>[:lower:]</code>：小写字母</li>
<li><code>[:print:]</code>：非控制字符</li>
<li><code>[:space:]</code>：产生空白的字符</li>
<li><code>[:upper:]</code>：大写字母</li>
<li><code>[:xdigit:]</code>：十六进制数字</li>
<li><code>[:punct:]</code>：标点符号</li>
</ul>
<h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><ul>
<li>^：匹配字符串开始</li>
<li>$：匹配字符串结束</li>
</ul>
<h1 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h1><ul>
<li><code>*</code> 匹配前一个字符0或多次</li>
<li><code>?</code> 匹配前一个字符0或1次      【扩展正则示例,基本正则形式参见BRE与ERE区别】</li>
<li><code>+</code> 匹配前一个字符1或多次   【扩展正则示例】</li>
<li><code>{n}</code>  匹配前置条目n次            【扩展正则示例】</li>
<li><code>{n,}</code> 匹配前置条目至少n次   【扩展正则示例】</li>
<li><code>{,m}</code> 匹配前置条目至多m次   【扩展正则示例】</li>
<li><code>{n,m}</code> 匹配前置条目n到m次   【扩展正则示例】</li>
</ul>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><ul>
<li><code>|</code>：交替匹配符号两边的内容    【扩展正则示例】</li>
<li><code>()</code>：分组                                        【扩展正则示例】</li>
<li><code>\n</code>：分组后的后向引用功能</li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>证书生成工具cfssl</title>
    <url>/blog/2020/07/15/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cfssl/</url>
    <content><![CDATA[<h1 id="下载cfssl工具"><a href="#下载cfssl工具" class="headerlink" title="下载cfssl工具"></a>下载cfssl工具</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl*</span><br><span class="line">mv cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line">mv cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<h1 id="创建CA"><a href="#创建CA" class="headerlink" title="创建CA"></a>创建CA</h1><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># config</span><br><span class="line">cfssl print-defaults config &gt; ca-config.json</span><br><span class="line"># csr</span><br><span class="line">cfssl print-defaults csr &gt; ca-csr.json</span><br></pre></td></tr></table></figure>
<h2 id="CA配置文件-范例"><a href="#CA配置文件-范例" class="headerlink" title="CA配置文件-范例"></a>CA配置文件-范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">         &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>ca-config.json：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时需要使用某个profile</li>
<li>signing：表示该证书可用于签名其他证书</li>
<li>server auth：表示client可以用该CA对server提供的证书进行验证</li>
<li>client auth：表示server可以用该CA对client提供的证书进行验证</li>
</ul>
<h2 id="CA证书签名请求-范例"><a href="#CA证书签名请求-范例" class="headerlink" title="CA证书签名请求-范例"></a>CA证书签名请求-范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; ca-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>CN-Common Name：kube-apiserver从证书中提取该字段作为请求的用户名(User Name)；浏览器使用该字段验证网站是否合法</li>
<li>C-countryName：国家名</li>
<li>ST-stateOrProvinceName：省份</li>
<li>L-localityName：城市名</li>
<li>O-Organization：组织机构名，kube-apiserver从证书中提取该字段作为请求用户所属的组(Group)</li>
<li>OU-OrganizationUnitName：组织下的部门名称</li>
<li>hosts：如果hosts字段不为空，则需要指定使用该证书的IP或域名列表</li>
</ul>
<h2 id="生成CA证书和私钥"><a href="#生成CA证书和私钥" class="headerlink" title="生成CA证书和私钥"></a>生成CA证书和私钥</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line">ls ca*.pem</span><br><span class="line"># 证书信息查看</span><br><span class="line">cfssl-certinfo -cert ca.pem</span><br></pre></td></tr></table></figure>
<h1 id="CA签发普通证书"><a href="#CA签发普通证书" class="headerlink" title="CA签发普通证书"></a>CA签发普通证书</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; nginx.myapp.com-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;nginx.myapp.com&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes nginx.myapp.com-csr.json | cfssljson -bare nginx.myapp.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>cfssl</tag>
      </tags>
  </entry>
  <entry>
    <title>编程基础</title>
    <url>/blog/2019/11/12/%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><ul>
<li>同步和异步的区别就在于是否等待IO执行的结果</li>
<li>好比你去麦当劳餐厅点餐，你说“来个汉堡”，服务员告诉你，对不起汉堡要现做，需要等待5分钟，于是你就站在收银台前等了5分钟，拿着汉堡取逛商场，这是同步IO</li>
<li>你说“来个汉堡”，服务员告诉你，汉堡需要等待5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立即去干别的事（逛商场），这就是异步IO</li>
<li>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</li>
</ul>
<h1 id="队列与堆栈"><a href="#队列与堆栈" class="headerlink" title="队列与堆栈"></a>队列与堆栈</h1><ul>
<li>堆栈：后进先出</li>
<li>队列：先进先出</li>
</ul>
<h1 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h1><ul>
<li>变量本身类型不固定的语言称之为动态语言</li>
<li>静态语言在定义变量时在定义变量时必须指定变量类型，如果赋值的时候类型不匹配就会报错</li>
</ul>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="服务特点"><a href="#服务特点" class="headerlink" title="服务特点"></a>服务特点</h2><ul>
<li>先天分布式【每个服务都有多个实例进行负载均衡】</li>
<li>无状态</li>
</ul>
<h2 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h2><blockquote>
<p><a href="http://kyfxbl.iteye.com/blog/1831869" target="_blank" rel="noopener">http://kyfxbl.iteye.com/blog/1831869</a></p>
</blockquote>
<ul>
<li>有状态【stateful】:对单次请求的处理依赖保存的数据【比如商城购物，放入购物车、确认订单、支付等步骤需要session来实现有状态的服务】；容易实现事务；但不利于水平扩展。</li>
<li>无状态【stateless】:对单次请求的处理不依赖其他请求；容易水平扩展；为了实现事务机制，需要额外的动作【隐藏表单、sessionstorage、cookie】剥离session来实现服务从有状态到无状态转变。</li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab之ci-runner使用</title>
    <url>/blog/2020/01/18/CICD/gitlab/gitlab%E4%B9%8Bci-runner%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="ci-runner安装与配置"><a href="#ci-runner安装与配置" class="headerlink" title="ci-runner安装与配置"></a>ci-runner安装与配置</h1><p>gitlab CI服务最好不要部署于gitlab服务器上【因为CI(持续集成)任务会很消耗资源】</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>docker是CI(持续集成)任务的基础环境，当然CI(持续集成)任务也可以直接利用CI服务器的shell环境</p>
<h2 id="安装gitlab-runner"><a href="#安装gitlab-runner" class="headerlink" title="安装gitlab-runner"></a><a href="https://docs.gitlab.com/runner/install/linux-repository.html" target="_blank" rel="noopener">安装gitlab-runner</a></h2><blockquote>
<p>gitlab-runner是部署于gitlab CI服务器上的代理服务，用于接收gitlab服务器上发送的构建指令并执行构建操作</p>
</blockquote>
<ul>
<li>curl -L <a href="https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" target="_blank" rel="noopener">https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh</a> | sudo bash</li>
<li>sudo apt-get install gitlab-runner</li>
<li>gitlab-runner status</li>
</ul>
<h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>使gitlab-runner运行的用户可以执行docker命令</p>
<h2 id="将ci-runner注册到gitlab"><a href="#将ci-runner注册到gitlab" class="headerlink" title="将ci-runner注册到gitlab"></a>将ci-runner注册到gitlab</h2><ul>
<li>执行命令：gitlab-runner register</li>
<li>注册输入内容<ul>
<li>gitlab服务器地址【管理员界面–》runners】</li>
<li>注册秘钥【管理员界面–》runners】</li>
<li>描述信息：说明这个runner用途</li>
<li>标签信息：标识这个runner，可以让.gitlab-ci.yml中的job使用指定的runner运行任务</li>
<li>执行环境：命令执行的环境，可以是docker【python27、python34、maven等环境】、shell等</li>
</ul>
</li>
</ul>
<h1 id="CICD入门范例"><a href="#CICD入门范例" class="headerlink" title="CICD入门范例"></a>CICD入门范例</h1><ul>
<li><p>项目源代码的根目录下创建.gitlab-ci.yml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义构建的步骤</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line"># 定义执行的任务</span><br><span class="line">job1:</span><br><span class="line">  stage: test   # 任务和构建步骤绑定</span><br><span class="line">  tags:             # 定义构建的基础环境(即runner的标签信息)</span><br><span class="line">    - shell </span><br><span class="line">  script:           # 定义构建执行的命令</span><br><span class="line">    - echo &quot;I am job1&quot;</span><br><span class="line">    - echo &quot;I am in test stage&quot;</span><br><span class="line"></span><br><span class="line">job2:</span><br><span class="line">  stage: build</span><br><span class="line">  tags:</span><br><span class="line">    - shell</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;I am job2&quot;</span><br><span class="line">    - echo &quot;I am in build stage&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认，项目代码库有变动，CICD–》pipeline就会执行</p>
</li>
</ul>
<h1 id="CICD综合范例"><a href="#CICD综合范例" class="headerlink" title="CICD综合范例"></a>CICD综合范例</h1><ul>
<li><a href="https://github.com/imooc-course/docker-cloud-flask-demo" target="_blank" rel="noopener">学习示例代码</a></li>
<li>gitlab-ci.yml示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - style</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line">  - release</span><br><span class="line"></span><br><span class="line">pep8:</span><br><span class="line">  stage: style</span><br><span class="line">  script:</span><br><span class="line">    - pip install tox</span><br><span class="line">    - tox -e pep8               #执行python pep8代码检查</span><br><span class="line">  tags:</span><br><span class="line">    - python2.7</span><br><span class="line">  except:                            #代码库有版本(tag)变动时不执行</span><br><span class="line">    - tags</span><br><span class="line"></span><br><span class="line">unittest-py27:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - pip install tox</span><br><span class="line">    - tox -e py27               #执行python2.7环境下的单元测试</span><br><span class="line">  tags:</span><br><span class="line">    - python2.7</span><br><span class="line">  except:</span><br><span class="line">    - tags</span><br><span class="line"></span><br><span class="line">unittest-py34:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - pip install tox</span><br><span class="line">    - tox -e py34               #执行python3.4环境下的单元测试</span><br><span class="line">  tags:</span><br><span class="line">    - python3.4</span><br><span class="line">  except:</span><br><span class="line">    - tags</span><br><span class="line"></span><br><span class="line">docker-deploy:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - docker build -t flask-demo .</span><br><span class="line">    - if [ $(docker ps -qf &quot;name=web&quot;) ];then docker rm -f web;fi</span><br><span class="line">    - docker run -id -p 5000:5000 --name web flask-demo </span><br><span class="line">  tags:</span><br><span class="line">    - shell</span><br><span class="line">  only:                             #仅当master分支有变动时才执行此任务</span><br><span class="line">    - master</span><br><span class="line"></span><br><span class="line">docker-build:</span><br><span class="line">  stage: release</span><br><span class="line">  script:</span><br><span class="line">    - docker build -t registry.cn-hangzhou.aliyuncs.com/simple00426/flask-demo:$CI_COMMIT_TAG . </span><br><span class="line">    - docker push registry.cn-hangzhou.aliyuncs.com/simple00426/flask-demo:$CI_COMMIT_TAG</span><br><span class="line">  tags:</span><br><span class="line">    - shell</span><br><span class="line">  only:                         #仅当代码库有版本(tag)变动时才执行此任务</span><br><span class="line">    - tags</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="CICD使用建议"><a href="#CICD使用建议" class="headerlink" title="CICD使用建议"></a>CICD使用建议</h1><ul>
<li>保护master分支，只允许其他分支merge，不允许直接push【settings–》repository–》Protected Branches–》allow to push(no one)】</li>
<li>分支合并到master时，必须通过pipeline检测【settings–》general–》merge request–》pipeline must succeed】</li>
<li>在项目的readme文件中添加项目的pipeline实时状态信息【settings-》CICD–》General pipelines–》Pipeline status】</li>
</ul>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>runner</tag>
      </tags>
  </entry>
  <entry>
    <title>源代码管理-gitlab</title>
    <url>/blog/2020/07/06/CICD/gitlab/%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-gitlab/</url>
    <content><![CDATA[<h1 id="gitlab服务"><a href="#gitlab服务" class="headerlink" title="gitlab服务"></a>gitlab服务</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a><a href="https://mirrors.tuna.tsinghua.edu.cn/help/gitlab-ce/" target="_blank" rel="noopener">软件安装</a></h2><blockquote>
<p>初始密码（用户root）：cat /etc/<em>gitlab</em>/initial_root_password</p>
</blockquote>
<h3 id="docker方式"><a href="#docker方式" class="headerlink" title="docker方式"></a><a href="https://docs.gitlab.com/omnibus/docker/" target="_blank" rel="noopener">docker方式</a></h3><blockquote>
<p>由于gitlab的访问端口由external_url中决定，如下配置中<br>容器中的gitlab服务暴露在80端口，宿主机以外通过<a href="http://172.17.8.53:9999/" target="_blank" rel="noopener">http://172.17.8.53:9999/</a> 【172.17.8.53为宿主机ip】访问gitlab的web服务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  -p 8443:443 \</span><br><span class="line">  -p 9999:80 \</span><br><span class="line">  -p 9998:22 \</span><br><span class="line">  -v $PWD/config:/etc/gitlab \</span><br><span class="line">  -v $PWD/logs:/var/log/gitlab \</span><br><span class="line">  -v $PWD/data:/var/opt/gitlab \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -e GITLAB_OMNIBUS_CONFIG=&quot;external_url &apos;http://172.17.8.53/&apos;;gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 9998&quot; \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu16-04"><a href="#ubuntu16-04" class="headerlink" title="ubuntu16.04"></a>ubuntu16.04</h3><ul>
<li>软件源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br><span class="line">echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main&quot; &gt; /etc/apt/sources.list.d/gitlab-ce.list</span><br></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure>
<h3 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h3><ul>
<li>软件源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache</span><br><span class="line">sudo yum install gitlab-ce</span><br></pre></td></tr></table></figure>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><blockquote>
<p>/etc/gitlab/gitlab.rb</p>
</blockquote>
<ul>
<li>服务器地址配置【在邮件通知中会使用此地址】<br><code>external_url &#39;http://10.10.10.164&#39;</code></li>
<li>备份保留时间配置[以s为单位]<br><code>gitlab_rails[&#39;backup_keep_time&#39;] = 86400</code></li>
<li>邮箱配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;smtp_enable&apos;] = true</span><br><span class="line">gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.exmail.qq.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_port&apos;] = 465</span><br><span class="line">gitlab_rails[&apos;smtp_user_name&apos;] = &quot;gitlab@abc.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_password&apos;] = &quot;Git@abc123&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_domain&apos;] = &quot;exmail.qq.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true</span><br><span class="line">gitlab_rails[&apos;smtp_tls&apos;] = true</span><br><span class="line">gitlab_rails[&apos;gitlab_email_from&apos;] = &quot;gitlab@abc.com&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://docs.gitlab.com/omnibus/settings/smtp.html#testing-the-smtp-configuration" target="_blank" rel="noopener">邮箱功能测试</a><ul>
<li>进入控制台：<code>gitlab-rails console</code></li>
<li>测试：<code>Notify.test_email(&#39;destination_email@address.com&#39;, &#39;Message Subject&#39;, &#39;Message Body&#39;).deliver_now</code></li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看gitlab版本：<code>cat /opt/gitlab/version-manifest.json</code> </li>
<li>变更配置：<code>sudo gitlab-ctl reconfigure</code></li>
<li>创建备份：<code>gitlab-rake gitlab:backup:create</code></li>
<li>恢复备份(BACKUP后为在备份目录【默认/var/opt/gitlab/backups/】产生文件名中数字)：<br><code>gitlab-rake gitlab:backup:restore BACKUP=1507879010_2017_10_13</code></li>
<li>服务状态操作(查/起/停)：<code>gitlab-ctl status|start|stop</code></li>
</ul>
<h1 id="git客户端配置"><a href="#git客户端配置" class="headerlink" title="git客户端配置"></a>git客户端配置</h1><ul>
<li>web界面注册账号</li>
<li>本地配置账号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global   user.name=simple0426</span><br><span class="line">git config --global   user.email=perfect_0426@qq.com</span><br></pre></td></tr></table></figure>
<ul>
<li>生产秘钥并上传至gitlab<br><code>ssh-keygen -t rsa -C &quot;perfect_0426@qq.com</code></li>
<li>测试连通性<br><code>ssh -T git@github.com</code></li>
<li>根据gitlab范例创建项目  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog-comments</span><br><span class="line">cd blog-comments</span><br><span class="line">git init</span><br><span class="line">echo &quot;# blog-comments&quot; &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"># 本地库关联远程库</span><br><span class="line">git remote add origin git@github.com:simple0426/blog-comments.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="多仓库设置"><a href="#多仓库设置" class="headerlink" title="多仓库设置"></a>多仓库设置</h1><h2 id="产生密钥对"><a href="#产生密钥对" class="headerlink" title="产生密钥对"></a>产生密钥对</h2><ul>
<li>ssh-keygen.exe -t rsa -P “” -f “C:\Users\simple\.ssh\gitee”</li>
<li>ssh-keygen.exe -t rsa -P “” -f “C:\Users\simple\.ssh\github”</li>
</ul>
<h2 id="在两个平台添加公钥"><a href="#在两个平台添加公钥" class="headerlink" title="在两个平台添加公钥"></a>在两个平台添加公钥</h2><h2 id="配置ssh的config文件"><a href="#配置ssh的config文件" class="headerlink" title="配置ssh的config文件"></a>配置ssh的config文件</h2><blockquote>
<p>windows下：C:\Users\simple\.ssh\config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host gitee.com</span><br><span class="line">  ProxyCommand none</span><br><span class="line">  IdentityFile C:\Users\simple\\.ssh\gitee</span><br><span class="line">  ServerAliveInterval 60</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line">Host github.com</span><br><span class="line">  ProxyCommand none</span><br><span class="line">  IdentityFile C:\Users\simple\\.ssh\github</span><br><span class="line">  ServerAliveInterval 60</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  TCPKeepAlive yes</span><br></pre></td></tr></table></figure>
<h2 id="ssh登录测试"><a href="#ssh登录测试" class="headerlink" title="ssh登录测试"></a>ssh登录测试</h2><ul>
<li>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></li>
<li>ssh -T <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a></li>
</ul>
<h2 id="配置项目config文件"><a href="#配置项目config文件" class="headerlink" title="配置项目config文件"></a>配置项目config文件</h2><blockquote>
<p>.git\config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;github&quot;]</span><br><span class="line">        url = git@github.com:simple0426/blog.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[remote &quot;gitee&quot;]</span><br><span class="line">        url = git@gitee.com:simple0426/simple0426.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>
<h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><ul>
<li>git pull github master</li>
<li>git push github master</li>
</ul>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible之playbook学习</title>
    <url>/blog/2019/05/25/CICD/ansible/ansible%E4%B9%8Bplaybook%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="playbook简介"><a href="#playbook简介" class="headerlink" title="playbook简介"></a>playbook简介</h1><p>playbook是以目录文件结构的形式组织ansible语法，用以实现复杂功能，它的主要概念如下：</p>
<ul>
<li>module：实现功能的基本组成单元，类似程序代码<ul>
<li>它应该是幂等效果，即多次执行和一次执行具有同样的效果</li>
</ul>
</li>
<li>task：执行module，用以实现特定功能，类似运行代码后的进程</li>
<li>role：是由task、handler、var等组成以实现特定功能，它还可能包含模块、插件等其他功能组件</li>
<li>play：是将一些主机(inventory)和一些role或task进行映射、绑定，以达到在这些主机上实现特定功能</li>
<li>playbook：playbook是多个play的集合，以达到在多主机进行多功能的部署</li>
<li>block：一般用于task的逻辑分组以及在play中进行错误处理</li>
<li>handlers：事件触发器，当远程系统发生变化时执行的触发器【即特定task】</li>
</ul>
<h2 id="playbook功能"><a href="#playbook功能" class="headerlink" title="playbook功能"></a>playbook功能</h2><ul>
<li>管理配置文件</li>
<li>远程部署服务</li>
<li>多层架构下的滚动更新</li>
<li>将操作委派给其他主机</li>
<li>在部署等操作过程中和监控系统、负载均衡系统交互</li>
</ul>
<h1 id="block范例"><a href="#block范例" class="headerlink" title="block范例"></a>block范例</h1><h2 id="task逻辑分组"><a href="#task逻辑分组" class="headerlink" title="task逻辑分组"></a>task逻辑分组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: 127.0.0.1</span><br><span class="line">  debugger: on_skipped</span><br><span class="line">  tasks:</span><br><span class="line">    - name: display memory and cpu load</span><br><span class="line">      block:</span><br><span class="line">      - name: display memory</span><br><span class="line">        shell: free -m</span><br><span class="line">        register: mem</span><br><span class="line">      - debug: msg=&quot;&#123;&#123; mem.stdout &#125;&#125;&quot;</span><br><span class="line">      - name: display cpu load</span><br><span class="line">        shell: uptime</span><br><span class="line">        register: uptime</span><br><span class="line">      - debug: msg=&quot;&#123;&#123; uptime.stdout &#125;&#125;&quot;</span><br><span class="line">      when: ansible_facts[&apos;distribution&apos;] == &apos;Ubuntu&apos;</span><br><span class="line">      become: yes</span><br><span class="line">    - name: touch file</span><br><span class="line">      command: touch /tmp/test</span><br></pre></td></tr></table></figure>
<h2 id="play中错误处理"><a href="#play中错误处理" class="headerlink" title="play中错误处理"></a>play中错误处理</h2><p>类似python中的try/expect/finally<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: 127.0.0.1</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Handler the error</span><br><span class="line">      block:                          # 标记可能出现异常的区块</span><br><span class="line">        - debug: msg=&apos;I execute normally&apos;</span><br><span class="line">        - name: I force a failure</span><br><span class="line">          command: /bin/false</span><br><span class="line">        - debug: msg=&quot;I never execute&quot;</span><br><span class="line">#      ignore_errors: yes     # ignore与rescue功能互斥</span><br><span class="line">      rescue:                       # 出现异常时的处理</span><br><span class="line">        - debug: msg=&apos;I caught an error&apos;</span><br><span class="line">        - name: &apos;force an error in rescue&apos;</span><br><span class="line">          command: /bin/false</span><br><span class="line">        - debug: msg=&apos;I alse never executes&apos;</span><br><span class="line">      always:                       # 无论是否出现异常都执行的任务</span><br><span class="line">        - name: other tasks</span><br><span class="line">          command: uptime</span><br></pre></td></tr></table></figure></p>
<h1 id="handlers语法"><a href="#handlers语法" class="headerlink" title="handlers语法"></a>handlers语法</h1><ul>
<li>不支持在notify和handlers的name中使用变量</li>
<li>在handers中定义listen选项，既可以作为handler的名称被notify使用，也可以将多个handler分组以便notify使用</li>
<li>一个触发器仅被执行一次，即使在一个play中声明多次</li>
<li>在一个play中，多个触发器共同在task列表执行完成后执行</li>
<li>触发器的运行顺序根据handlers中的定义顺序执行，和notify的使用顺序无关</li>
<li>pre_tasks/tasks/post_tasks中的触发器在相应部分的末尾被触发</li>
<li>不能触发位于include中触发器，但可以使用import中包含的触发器</li>
</ul>
<h1 id="task语法"><a href="#task语法" class="headerlink" title="task语法"></a>task语法</h1><ul>
<li>name：task名称，以描述这个task的具体任务；可以在name中使用已经定义过的变量</li>
<li>action：task定义旧形式<ul>
<li>task定义新形式：【module：options】</li>
<li>task定义旧形式：【action：module options】</li>
</ul>
</li>
<li>module：执行的模块；如果模块中的参数过长，可以在末尾留出空格并以缩进形式开启新行</li>
<li>notify：在任务执行完成后激活触发器的执行；</li>
<li>run_once：在一组主机中仅执行一次【即仅在一组主机的第一个主机上执行，但是执行结果可以应用到所有主机】</li>
<li>delegate_facts：True 从主机或主机组之外的其他主机收集facts信息【一般和delegate_to搭配使用】</li>
<li>delegate_to：在主机或主机组的task中定义其他主机要执行的任务 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本地操作实现</span><br><span class="line">shell：free -m</span><br><span class="line">run_once：true</span><br><span class="line">delegate_to:localhost</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="play语法"><a href="#play语法" class="headerlink" title="play语法"></a>play语法</h1><ul>
<li>name：play名称</li>
<li>hosts：将要执行任务的主机，以逗号分隔多个主机或多个组</li>
<li>remote_user：远程连接用户<ul>
<li>remote_user、ansible_user【ansible_ssh_user】、命令行下的-u参数 三者具有相同功能都是用于ssh远程连接时设置用户</li>
<li>remote_user主要在ansible.cfg、play中设置</li>
<li>ansible_user主要在inventory中设置</li>
</ul>
</li>
<li>order：设置执行任务的主机顺序<ul>
<li>默认inventory，即以inventory中定义的顺序执行任务</li>
</ul>
</li>
<li>gather_facts：是否收集操作系统信息</li>
<li>vars：定义的变量</li>
<li>tasks：执行任务列表</li>
<li>pre_tasks/post_tasks：tasks之前或之后执行的任务列表</li>
<li>roles：角色列表</li>
<li>handlers：触发器列表；实际也是任务列表，和普通的任务没什么不同</li>
<li>any_errors_fatal: True：对于一个任务，只有所有主机都执行成功才认为是成功，才能执行下一个任务；否则认定为失败，失败则playbook立即停止运行并退出</li>
<li>serial：指定在主机组或主机列表中执行任务时，同时有几台主机在执行任务，此功能主要用于灰度发布<ul>
<li>可以是数字或数字列表</li>
<li>可以是百分比或百分比列表</li>
<li>也可以是数字和百分比的混合<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- hosts: 172.17.134.58,172.17.134.63</span><br><span class="line">  gather_facts: no</span><br><span class="line">  vars: &#123; haproxy: 172.17.134.53, end_sec: 10 &#125;</span><br><span class="line">  serial: 1</span><br><span class="line">  tasks:</span><br><span class="line">    - include: files/deploy/double_srv.yml</span><br><span class="line">      tags: [&apos;service_user&apos;]</span><br><span class="line">      vars:  &#123; project: service_user, project_port: 8050, start_sec: 30 &#125;</span><br><span class="line"># 由于serial为1，同时只有一台主机在执行任务，循环2次执行完此任务；</span><br><span class="line"># 若serial为2，则同时会有2台主机执行任务，一次循环即可执行完</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="公共语法"><a href="#公共语法" class="headerlink" title="公共语法"></a>公共语法</h1><p>play或task中都可以使用的语法</p>
<ul>
<li>environment：在task和play中设置环境变量<ul>
<li>environment: PATH: /home//open_api:</li>
</ul>
</li>
<li><p>tags：在play、roles、task级别设置标签，以便只执行特定标签任务</p>
<ul>
<li><p>play级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: deploy java</span><br><span class="line">  hosts: 172.17.12.14</span><br><span class="line">  tags: [&apos;java&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>role级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roles:</span><br><span class="line">    - &#123; role: interface_app, tags: [&apos;interface_app&apos;]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>task级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: debug info</span><br><span class="line">  debug: &quot;msg=&#123;&#123; ansible_env.PATH &#125;&#125;&quot;</span><br><span class="line">  tags: [&apos;path&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>include：包含另一个play或task</p>
<ul>
<li>此功能已被拆分为include_xxx和import_xxx两类模块，未来可能被遗弃：<a href="https://docs.ansible.com/ansible/latest/modules/include_module.html#include-module" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/modules/include_module.html#include-module</a></li>
<li>包含play：与hosts同级的另一个play</li>
<li><p>包含task：task列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: ops</span><br><span class="line">  vars:</span><br><span class="line">    - key: 8</span><br><span class="line">  tasks:</span><br><span class="line">    - name: debug info</span><br><span class="line">      debug: msg=&quot;The &#123;&#123; inventory_hostname &#125;&#125; Value is &#123;&#123; key &#125;&#125;&quot;</span><br><span class="line">    - include: task.yml</span><br><span class="line">- include: play2.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>与when搭配使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- include: service_base.yml</span><br><span class="line">  when: change|changed and project == &apos;service_base&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>动态导入与静态导入</p>
<ul>
<li>include_x：为动态导入，即在运行时遇到该任务点时才执行导入操作<ul>
<li>include_role：加载并执行一个role</li>
<li>include_tasks：动态包含任务列表</li>
</ul>
</li>
<li>import_x：为静态导入，即在ansible整体解析时执行导入操作<ul>
<li>import_playbook：导入playbook</li>
<li>import_role：导入role到一个play中</li>
<li>import_tasks：导入task列表</li>
</ul>
</li>
<li>当使用tags或when时<ul>
<li>对于import，task选项(options)将会被复制进子task中</li>
<li>对于include，task选项(options)只会影响自身，不会影响子task</li>
</ul>
</li>
<li>include_x使用限制<ul>
<li>被包含的tags或tasks不会出现在命令行下–list-tags或–list-tasks中</li>
<li>主play中的notify不会触发include包含的handler</li>
<li>不能使用–start-at-task从include包含的task处执行</li>
</ul>
</li>
<li>import_x使用限制<ul>
<li>循环时只能使用include而不是import</li>
<li>inventory中的变量不能用于目标文件名或角色名</li>
</ul>
</li>
</ul>
</li>
<li><p>wait_for：在继续其他任务时，等待一个状态成立</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定的时间后【delay】，检测某台主机的某个端口是否还有tcp连接【drained】，最多等待300s，在300s内，  </span><br><span class="line"># 如果为drained状态则继续执行其他任务，但是exclude_hosts中包含的主机【列表】与所操作的主机连接排除在外</span><br><span class="line">- name: wait &#123;&#123; project &#125;&#125; port drain</span><br><span class="line">  wait_for: </span><br><span class="line">    host: &apos;&#123;&#123; inventory_hostname &#125;&#125;&apos; </span><br><span class="line">    port: &apos;&#123;&#123; project_port &#125;&#125;&apos; </span><br><span class="line">    state: drained </span><br><span class="line">    timeout: 300 </span><br><span class="line">    delay: &apos;&#123;&#123; end_sec &#125;&#125;&apos; </span><br><span class="line">    exclude_hosts: &apos;&#123;&#123; micro_srv &#125;&#125;&apos;</span><br><span class="line"># 在指定时间后检测端口是否开启</span><br><span class="line">- name: wait &#123;&#123; project &#125;&#125; port up</span><br><span class="line">  wait_for: host=&apos;&#123;&#123; inventory_hostname &#125;&#125;&apos; port=&apos;&#123;&#123; project_port &#125;&#125;&apos; state=started delay=&apos;&#123;&#123; start_sec &#125;&#125;&apos;</span><br></pre></td></tr></table></figure>
<h1 id="roles目录"><a href="#roles目录" class="headerlink" title="roles目录"></a>roles目录</h1><ul>
<li>roles以包含规定目录名的语法来构成</li>
<li>每个规定的目录名下必须包含main.yml文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roles/                          角色主目录</span><br><span class="line">   common/                 common角色目录</span><br><span class="line">     files/                      文件目录</span><br><span class="line">     templates/              模板目录</span><br><span class="line">     tasks/                    任务列表目录</span><br><span class="line">     handlers/                handler目录</span><br><span class="line">     vars/                      不可被inventory定义覆盖的变量目录</span><br><span class="line">     defaults/                 可被inventory定义覆盖的变量目录</span><br><span class="line">     meta/                      meta中定义角色依赖关系</span><br></pre></td></tr></table></figure>
<h1 id="playbook目录"><a href="#playbook目录" class="headerlink" title="playbook目录"></a>playbook目录</h1><h2 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site.yml                      主playbook入口</span><br><span class="line">webservers.yml           特殊任务playbook入口</span><br><span class="line">hosts                         自定义inventory</span><br><span class="line">group_vars/                组变量</span><br><span class="line">   all</span><br><span class="line">   dbservers</span><br><span class="line">host_vars/                  主机变量</span><br><span class="line">   host1</span><br><span class="line">   host2</span><br><span class="line">roles</span><br></pre></td></tr></table></figure>
<h2 id="多环境设置"><a href="#多环境设置" class="headerlink" title="多环境设置"></a>多环境设置</h2><ul>
<li>在区分环境时【比如开发、测试、生产、预上线、生产】，只需将jinventory及相关变量放置到同级目录即可</li>
<li>执行范例：ansible-playbook -i environments/pre/hosts site-pre.yml -t interface_campaign</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主目录结构</span><br><span class="line">├── ansible.cfg</span><br><span class="line">├── environments</span><br><span class="line">│   ├── pre</span><br><span class="line">│   └── prod</span><br><span class="line">├── files</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── keyfile</span><br><span class="line">│   ├── pre</span><br><span class="line">│   └── prod</span><br><span class="line">├── readme.md</span><br><span class="line">├── roles</span><br><span class="line">│   ├── common</span><br><span class="line">│   ├── project_java</span><br><span class="line">│   ├── project_python</span><br><span class="line">│   ├── python_web</span><br><span class="line">├── site-pre.yml</span><br><span class="line">├── site-prod.yml</span><br><span class="line">└── tasks</span><br><span class="line">    ├── ChPass_DenyRoot_AddKey.yml</span><br><span class="line">    └── UseRoot_AddUser.yml</span><br><span class="line"></span><br><span class="line"># environment目录结构</span><br><span class="line">├── pre</span><br><span class="line">│   ├── group_vars</span><br><span class="line">│   │   └── all</span><br><span class="line">│   ├── hosts</span><br><span class="line">│   └── host_vars</span><br><span class="line">│       ├── 172.17.134.53</span><br><span class="line">│       └── 172.17.134.63</span><br><span class="line">└── prod</span><br><span class="line">    ├── group_vars</span><br><span class="line">    │   └── all</span><br><span class="line">    ├── hosts</span><br><span class="line">    └── host_vars</span><br><span class="line">        ├── 172.17.12.10</span><br><span class="line">        └── 172.17.8.18</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>playbook</tag>
        <tag>include</tag>
        <tag>多环境</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible之命令行</title>
    <url>/blog/2019/05/29/CICD/ansible/ansible%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h1><p>在一个或一组主机下运行单个任务</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>语法：ansible 《pattern》 -m 《module_name》 -a 《arguments》 other_options  <ul>
<li>默认的模块名为command</li>
</ul>
</li>
<li>示例：ansible 10.150.20.209 -u db -m apt -a “pkg=dos2unix state=latest” -b –become-method sudo -k -K  </li>
<li>注意：在执行任务时，应该特别注意shell引用规则(即单双引号的使用规则)，避免变量在被传递给ansible前被本地shell捕获</li>
</ul>
<h2 id="主机资源匹配"><a href="#主机资源匹配" class="headerlink" title="主机资源匹配"></a>主机资源匹配</h2><ul>
<li>all或<code>*</code>匹配所有主机</li>
<li>以逗号分隔多个主机或组：ansible bigdata,crm -m ping</li>
<li>使用<code>*</code>也可以进行主机或组名的部分匹配：ansible test<code>*</code> -m ping </li>
<li>使用切片功能，在组内从上往下进行主机匹配：webservers[0:2]</li>
<li>使用正则进行匹配(必须以~开头)：~(web|db).*.example.com</li>
<li>使用-l/–limit参数【ansible/ansible-playbook】进一步说明需要执行任务的主机</li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>–ask-vault-pass：       提示输入加密面</li>
<li>–become-method：    权限变更的方式【su或sudo】</li>
<li>–become-user：        权限变更时使用的用户</li>
<li>–list-hosts：               输出符合要求的主机列表</li>
<li>–playbook-dir             指定playbok的根目录，这样就可以在命令行下使用playbook的roles、group_vars等特性</li>
<li>–private-key，–key-file</li>
<li>–scp-extra-args：      scp选项参数</li>
<li>–sftp-extra-args ：     sftp选项参数</li>
<li>–ssh-common-args：指定传给scp/sftp/ssh的一般参数</li>
<li>–ssh-extra-args：     只传给ssh的参数</li>
<li>–syntax-check：       检测语法</li>
<li>–vault-id</li>
<li>–vault-password-file：加密密码的文本文件</li>
<li>–version：               显示程序版本、配置文件位置、模块搜索路径、模块文件位置、可执行文件位置</li>
<li>-B/–background ：   异步运行模式，运行超过X秒后失败</li>
<li>-C/–check：            不实际执行任务，但是显示执行后可能发生的变化</li>
<li>-D/–diff：                与-C搭配使用，显示当使用files和templates模块时，变化前后的区别</li>
<li>-K/–ask-become-pass：权限变更时交互式输入密码</li>
<li>-M/–module-path：  以冒号分隔的自定义模块路径【默认~/.ansible/plugins/modules:/usr/share/ansible/plugins/modules】</li>
<li>-P/–poll：               和-B搭配使用，设置轮询时间间隔【默认15，0为永不轮询】</li>
<li>-t/–timeout：           设置连接超时时间【默认10】</li>
<li>-a/–args：              模块参数</li>
<li>-b/–become：         设置将要进行权限变更</li>
<li>-c/–connection         连接类型，比如：ssh/local/docker等</li>
<li>-e/–extra-vars :       设置自定义变量【key=value形式或yaml、json文件（文件名称前添加@）】</li>
<li>-f/–forks：             设置并行进程数【默认为5】</li>
<li>-h/–help：              帮助信息</li>
<li>-i/–inventory：       设置资源文件位置或以逗号分隔的主机列表</li>
<li>-k/–ask-pass：       远程连接时交互式输入密码</li>
<li>-l/–limit                    限定执行任务的主机资源【以逗号分隔或以@开头引用文件】</li>
<li>-m/–module-name：将要执行的模块名称</li>
<li>-o/–one-line：         简化输出为一行</li>
<li>-t/–tree：                将输出记录到此目录</li>
<li>-u/–user：              远程连接用户</li>
<li>-v/–verbose：         详细输出模式（-vvv输出更多，-vvvv将开启连接调试）</li>
</ul>
<h2 id="范例1：异步模式"><a href="#范例1：异步模式" class="headerlink" title="范例1：异步模式"></a>范例1：异步模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hjq@localhost ~]$ ansible python -B 300 -P 0 -m yum -a &quot;name=libselinux-python state=latest&quot; </span><br><span class="line">python | CHANGED =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;pkg_mgr&quot;: &quot;yum&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;ansible_job_id&quot;: &quot;759078551843.27281&quot;, </span><br><span class="line">    &quot;changed&quot;: true, </span><br><span class="line">    &quot;finished&quot;: 0, </span><br><span class="line">    &quot;results_file&quot;: &quot;/root/.ansible_async/759078551843.27281&quot;, </span><br><span class="line">    &quot;started&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line">[hjq@localhost ~]$ ansible python -m async_status -a &quot;jid=759078551843.27281&quot;</span><br></pre></td></tr></table></figure>
<h2 id="范例2：新建用户"><a href="#范例2：新建用户" class="headerlink" title="范例2：新建用户"></a>范例2：新建用户</h2><ul>
<li>产生随机密码<ul>
<li>使用openssl：<code>echo pass|openssl passwd -1 -stdin</code></li>
<li>ubuntu下mkpasswd：<code>echo pass|mkpasswd --method=sha-512 --stdin</code></li>
</ul>
</li>
<li>新建用户<ul>
<li>密码必须hash：<code>ansible python -m user -e &quot;pass=Muke#123&quot; -a &#39;name=muker password=&quot;{\{ pass|password_hash(&quot;sha512&quot;) }\}&quot;&#39; -b</code></li>
</ul>
</li>
<li>用户sudo配置<ul>
<li><code>ansible python -m lineinfile -a &quot;dest=/etc/sudoers state=present line=&#39;muker ALL=(ALL) NOPASSWD: ALL&#39; validate=&#39;visudo -cf %s&#39;&quot;</code></li>
<li><code>ansible python -m lineinfile -a &#39;dest=/etc/sudoers state=present line=&quot;Defaults:muker !requiretty&quot; validate=&quot;visudo -cf %s&quot;&#39;</code></li>
</ul>
</li>
<li>秘钥登录<ul>
<li><code>ansible python -m authorized_key -a &quot;user=muker key=&#39;{\{ lookup(&#39;file&#39;, lookup(&#39;env&#39;, &#39;HOME&#39;) + &#39;/.ssh/id_rsa.pub&#39;) }\}&#39; state=present&quot; -u muker -K</code></li>
</ul>
</li>
</ul>
<h1 id="ansible-console"><a href="#ansible-console" class="headerlink" title="ansible-console"></a>ansible-console</h1><blockquote>
<p>交互式使用ansible</p>
</blockquote>
<h2 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>cd 切换主机或组</li>
<li>list 显示当前的主机或组</li>
<li>forks 设置临时并发数</li>
<li>module XXX 使用模块</li>
<li>help module 查看模块用法</li>
<li>become yes/no 进入/离开sudo模式</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hjq@all (2)[f:5]$ cd ops</span><br><span class="line">hjq@ops (1)[f:5]$ copy src=ansible.cfg dest=~/</span><br></pre></td></tr></table></figure>
<h1 id="ansible-doc"><a href="#ansible-doc" class="headerlink" title="ansible-doc"></a>ansible-doc</h1><p>插件文档工具<br>语法：ansible-doc [-l|-F|-s] [options] [-t <plugin type> ] [plugin]  </plugin></p>
<ul>
<li>-l 查看插件列表及相关简单描述信息</li>
<li>-F 查看插件列表及相关的源码位置【隐含-l参数】</li>
<li>-s 查看插件的参数信息<ul>
<li>ansible-doc -s -t lookup csvfile</li>
</ul>
</li>
<li>-t 设置插件类型，默认为模块，可选插件如下<ul>
<li>cache</li>
<li>callback</li>
<li>connection</li>
<li>inventory</li>
<li>lookup</li>
<li>shell</li>
<li>module</li>
<li>strategy</li>
<li>vars</li>
</ul>
</li>
</ul>
<h1 id="ansible-config"><a href="#ansible-config" class="headerlink" title="ansible-config"></a>ansible-config</h1><p>配置查看工具</p>
<ul>
<li>ansible-config dump –only-changed：查看ansible.cfg中的自定义配置【非默认配置】</li>
<li>ansible-config view：查看当前配置文件ansible.cfg</li>
</ul>
<h1 id="ansible-inventory"><a href="#ansible-inventory" class="headerlink" title="ansible-inventory"></a>ansible-inventory</h1><p>资源查看工具<br>语法：–list [–export] [–yaml]|–graph [–vars]|–host[–yaml]</p>
<ul>
<li>–list：显示所有主机信息<ul>
<li>–export ：与–list搭配使用，优化显示信息</li>
</ul>
</li>
<li>–host：显示特定主机信息</li>
<li>-y/–yaml：以yaml显示输出【默认json格式】<ul>
<li>与list和host搭配使用</li>
</ul>
</li>
<li>–graph：以图表形式显示所有主机信息<ul>
<li>–vars：在图表中显示变量信息</li>
</ul>
</li>
</ul>
<h1 id="ansible-vault"><a href="#ansible-vault" class="headerlink" title="ansible-vault"></a>ansible-vault</h1><ul>
<li>是用于加密结构化数据[json或yaml格式]文件的命令</li>
<li>可以通过include_vars或vars_files加载group_vars或host_vars下的资源变量文件</li>
<li>也可以是ansible-playbook命令下使用-e参数加载的变量文件</li>
<li>语法：ansible-vault [create|decrypt|edit|encrypt|rekey|view] [options] [vaultfile.yml]</li>
</ul>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>create 创建加密文件</li>
<li>edit 编辑加密文件</li>
<li>encrypt 加密文件</li>
<li>decrypt 解密文件</li>
<li>view 查看加密文件内容</li>
<li>rekey 变更加密密码</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>–ask-vault-pass：【默认选项】要求输入加密密码</li>
<li>–vault-password-file：提供密码文件</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><blockquote>
<p>命令ansible或ansible-playbook</p>
</blockquote>
<ul>
<li>–ask-vault-pass 交互式出入加密密码</li>
<li>–vault-password-file=xx 提供加密密码文件</li>
<li>范例：<ul>
<li>ansible 127.0.0.1 -e “@vars.yml” -m debug  -a “msg=“ –ask-vault-pass</li>
<li>ansible-playbook test.yml –vault-password-file=password.txt</li>
</ul>
</li>
</ul>
<h1 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h1><p>运行playbook的工具</p>
<ul>
<li>–flush-cache：清除每一台主机的facts缓存信息</li>
<li>–force-handlers：即使任务失败也执行handlers</li>
<li>–syntax-check：对playbook进行语法检查</li>
<li>–start-at-task：从指定任务处继续执行playbook</li>
<li>-t/–tags xxx：执行指定标签任务</li>
<li>–step：每执行一个任务都要进行确认</li>
<li>–list-hosts：查看所有主机</li>
<li>–list-tags：查看所有标签</li>
<li>–list-tasks：查看所有任务</li>
<li>–skip-tags：跳过标签执行其他任务</li>
<li>-C/–check： 不实际执行任务，但是显示执行后可能发生的变化<ul>
<li>playbook关键词用法：check_mode：yes</li>
</ul>
</li>
<li>-D/–diff：与-C搭配使用，显示当使用files和templates模块时，变化前后的区别</li>
</ul>
<h1 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h1><p>管理共享仓库中的ansible角色，默认的共享仓库是<a href="https://galaxy.ansible.com." target="_blank" rel="noopener">https://galaxy.ansible.com.</a></p>
<ul>
<li>info：查询已经安装的或在共享仓库中的角色详细信息</li>
<li>search：从共享仓库搜索角色【全名搜索】</li>
<li>list：查看本地已经安装的角色【全名搜索】</li>
<li>remove：移除本地角色</li>
<li>install：安装一个角色<ul>
<li>-f 强制覆盖已存在的角色</li>
<li>–force-with-deps：强制覆盖已存在的角色和依赖信息</li>
</ul>
</li>
</ul>
<h1 id="ansible-pull"><a href="#ansible-pull" class="headerlink" title="ansible-pull"></a>ansible-pull</h1><p>从版本库中拉取playbook并在本地执行</p>
<h2 id="命令参数-1"><a href="#命令参数-1" class="headerlink" title="命令参数"></a>命令参数</h2><p>ansible-pull -o -C master -U <a href="https://github.com/simple0426/ansible_test.git" target="_blank" rel="noopener">https://github.com/simple0426/ansible_test.git</a> -i hosts –purge</p>
<ul>
<li>-o 只有代码库有变更时拉取代码并执行</li>
<li>–purge 执行ansible完成后删除代码<ul>
<li>与-o参数有冲突</li>
<li>默认会将playbook项目拉取至~/.ansible/pull/《hostname》|local目录下</li>
</ul>
</li>
<li>-C 使用指定分支代码</li>
<li>-i 强制使用项目中的hosts</li>
<li>-U 指定playbook的仓库地址【必选项】</li>
</ul>
<h2 id="仓库目录"><a href="#仓库目录" class="headerlink" title="仓库目录"></a>仓库目录</h2><p>ansible_test/<br>├── hosts<br>├── local.yml<br>├── ops.yml<br>└── simple.yml</p>
<h3 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[localhost]</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li>hosts中只能定义本机，即127.0.0.1</li>
<li>当系统没hosts或未设置时默认使用项目中的hosts</li>
<li>当系统有hosts设置时，只会读取127.0.0.1设置，此时需要在命令行使用【-i hosts】参数强制读取项目中的hosts</li>
</ul>
<h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: localhost</span><br><span class="line">  gather_facts: no</span><br><span class="line">  tasks:</span><br><span class="line">    - name: touch file</span><br><span class="line">      command: touch /tmp/ceshi3</span><br></pre></td></tr></table></figure>
<ol>
<li>playbook中的hosts只能为本机，即127.0.0.1或其别名</li>
<li>程序会通过python接口读取系统的主机名或其缩略形式</li>
<li>ansible-pull会在项目中查找与主机名同名的playbook执行【如ops.yml、simple.yml】</li>
<li>如果未找到主机名相关的playbook，则会在项目中找local.yml这个playbook后执行</li>
<li>最后，如果找不到local.yml则报错退出</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>可以在项目中的local.yml中定义每个主机都要执行的操作</li>
<li>在项目的《hostname》.yml中定义个别主机需要执行的操作</li>
<li>也可以使用不同分支控制不同主机执行不同操作</li>
<li>可以使用crontab来定义每个主机定期执行的playbook</li>
</ul>
<h2 id="番外：FQDN"><a href="#番外：FQDN" class="headerlink" title="番外：FQDN"></a>番外：FQDN</h2><ul>
<li>FQDN=主机名+域名</li>
<li>设置主机名<ul>
<li>命令行：hostname xxxx</li>
<li>文件/etc/hostname：xxx</li>
<li>文件/etc/hosts：127.0.0.1 xxx</li>
</ul>
</li>
<li>设置FQDN【以便于python等程序通过接口获取】<ol>
<li>删除hosts中默认的”127.0.0.1   localhost localhost.localdomain”等选项</li>
<li>hosts中添加”127.0.0.1       xxx localhost”</li>
</ol>
</li>
<li>如果hosts的127.0.0.1行内存在诸如”localhost.localdomain”以逗号分隔的选项，则FQDN依然为”localhost.localdomain”</li>
</ul>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>ansible-config</tag>
        <tag>ansible-console</tag>
        <tag>ansible-doc</tag>
        <tag>ansible-inventory</tag>
        <tag>ansible-playbook</tag>
        <tag>ansible-galaxy</tag>
        <tag>ansible-vault</tag>
        <tag>ansible-pull</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible之变量与模板</title>
    <url>/blog/2019/06/20/CICD/ansible/ansible%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量使用注意"><a href="#变量使用注意" class="headerlink" title="变量使用注意"></a>变量使用注意</h2><ul>
<li>变量名，应该以字母开头，并且变量名中不含空格、逗点、中横线</li>
<li>变量内容，如果只包含字母、数字、下划线、中横线等普通字符，可以直接书写，无需使用引号</li>
<li>使用jinja2模块系统进行变量引用</li>
<li>对于字典变量，可以使用方括号或点方式引用，但是点方式可能会和python字典的属性或方法冲突</li>
<li>变量作用域<ul>
<li>全局：由config、环境变量【environment】、命令行设置</li>
<li>play级别：每个play和包含的结构，变量条目【vars，vars_files，vars_prompt】，roles的defaults和vars</li>
<li>host级别：直接关联主机的变量，比如inventory，include_vars，facts信息，任务执行产生的注册变量</li>
</ul>
</li>
</ul>
<h2 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h2><blockquote>
<p>模板语法（双大括号和大括号百分号）已插入转移符<code>\</code>特殊处理</p>
</blockquote>
<ul>
<li>当变量内容包含特殊字符（如&amp;#）时，需使用双引号包围变量内容；</li>
<li>当变量内容含有<code>{\{</code>等字符时，则需要使用“!unsafe“标志避免语法错误：<code>un_safevar:  !unsafe &#39;{\{in12var&#39;</code></li>
<li>避免模板变量被渲染（无论变量是否存在，都不对变量进行渲染）：<code>{\% raw %\}{\{ test1 }\}{\% endraw %\}</code></li>
</ul>
<h2 id="锚点和引用"><a href="#锚点和引用" class="headerlink" title="锚点和引用"></a>锚点和引用</h2><blockquote>
<p>这是yaml语法特性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">  test1: &amp;defaults &apos;he&apos; #定义锚点</span><br><span class="line">  test2:</span><br><span class="line">    - &apos;jing&apos;</span><br><span class="line">    - &apos;qi&apos;</span><br><span class="line">    - *defaults # 在列表中引用锚点</span><br><span class="line">  test3: &amp;pro</span><br><span class="line">    name: &apos;yaning&apos;</span><br><span class="line">    age: 30</span><br><span class="line">  test4:</span><br><span class="line">    &lt;&lt;: *pro # 将test3的变量内容合并到test4中</span><br><span class="line">    age: 31  # 重新定义age变量</span><br></pre></td></tr></table></figure>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a><a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#special-variables" target="_blank" rel="noopener">内置变量</a></h2><ul>
<li>保留变量<ul>
<li>hostvars：主机变量<ul>
<li>可以在当前主机访问其他主机变量</li>
<li><code>hostvars[&#39;bigdata&#39;][&#39;ansible_facts&#39;][&#39;eth0&#39;][&#39;ipv4&#39;][&#39;address&#39;]</code></li>
</ul>
</li>
<li>groups：所有组信息</li>
<li>group_names：当前主机所在组信息</li>
<li>inventory_hostname：inventory中定义的主机名</li>
<li>playbook_dir：playbook根目录</li>
<li>inventory_dir：inventory所在目录</li>
</ul>
</li>
<li>facts变量：ansible_facts</li>
<li>连接类型变量<ul>
<li>ansible_user：远程连接用户</li>
<li>ansible_ssh_pass：ssh连接密码</li>
</ul>
</li>
</ul>
<h2 id="inventory中定义的变量"><a href="#inventory中定义的变量" class="headerlink" title="inventory中定义的变量"></a>inventory中定义的变量</h2><h3 id="inventory文件"><a href="#inventory文件" class="headerlink" title="inventory文件"></a>inventory文件</h3><ul>
<li>主机变量： <code>crm ansible_user=&#39;root&#39; ansible_ssh_pass=&#39;123456&#39;</code></li>
<li>组变量：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nginx:vars]</span><br><span class="line">key=9</span><br></pre></td></tr></table></figure>
<h3 id="inventory目录"><a href="#inventory目录" class="headerlink" title="inventory目录"></a>inventory目录</h3><blockquote>
<p>与inventory同级或在其下的group_vars/host_vars目录</p>
</blockquote>
<ul>
<li>可以包含在playbook根目录下，也可以包含在inventory目录下，当两者同时存在时，playbook下的覆盖inventory下的</li>
<li>变量目录包含的变量文件是yaml格式的，且文件名没有后缀或是以’.yml’、’.yaml’、’.json’为后缀</li>
<li>ansible-playbook命令默认寻找当前playbook目录下的变量文件，但是其他ansible命令（比如ansible/ansible-console）则只查找inventory目录下的变量文件，除非使用–playbook-dir参数后才会查找playbook下的变量文件</li>
<li>多个地方定义的变量，优先级如下：host》childgroup》parentgroup》allgroup</li>
<li>group_vars目录下定义组变量<ul>
<li>组名文件表示组变量</li>
<li>all文件表示所有组的公共变量</li>
</ul>
</li>
<li>host_vars目录下定义主机变量<ul>
<li>主机名或ip名文件表示主机变量</li>
</ul>
</li>
</ul>
<h2 id="playbook中定义的变量"><a href="#playbook中定义的变量" class="headerlink" title="playbook中定义的变量"></a>playbook中定义的变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars: #直接定义变量</span><br><span class="line">  - key1: 8</span><br><span class="line">  # 定义长字符变量</span><br><span class="line">  - key5: |</span><br><span class="line">      123000</span><br><span class="line">      234111</span><br><span class="line">      345222</span><br><span class="line">vars_files: #使用变量文件</span><br><span class="line">  - var.yml</span><br><span class="line">vars_prompt: #交互式输入变量</span><br><span class="line">  - name: &quot;key3&quot; #变量名</span><br><span class="line">    prompt: &quot;pls input key3 value:&quot; #交互式信息</span><br><span class="line">    default: &apos;None&apos; #默认值</span><br><span class="line">    private: yes #是否显示输入</span><br><span class="line">tasks:</span><br><span class="line">  - name: debug info</span><br><span class="line">    debug: msg=&quot;key1 is &#123;&#123; key1 &#125;&#125; key2 is &#123;&#123; key2 &#125;&#125; key3 is &#123;&#123; key3 &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="roles中的变量"><a href="#roles中的变量" class="headerlink" title="roles中的变量"></a>roles中的变量</h2><ul>
<li>vars目录定义的变量不可被inventory级别定义的变量覆盖，但是play、命令行级别的可以覆盖</li>
<li>defaults目录定义的变量可以被inventory级别定义的变量覆盖</li>
</ul>
<h2 id="命令行下的变量"><a href="#命令行下的变量" class="headerlink" title="命令行下的变量"></a>命令行下的变量</h2><ul>
<li>命令行下使用key=value传递的变量都是字符串形式，如果要传递其他类型变量【如：布尔、整数、浮点型、列表等】则需要使用json格式</li>
<li>范例：ansible-playbook -e “key1=7 key2=foo” -e “@var.yml @var1.json” test.yml</li>
</ul>
<h2 id="facts中的变量"><a href="#facts中的变量" class="headerlink" title="facts中的变量"></a>facts中的变量</h2><p>facts是从远程操作系统收集的信息</p>
<h3 id="facts变量获取"><a href="#facts变量获取" class="headerlink" title="facts变量获取"></a>facts变量获取</h3><ul>
<li>可以在playbook中使用变量ansible_facts获取<ul>
<li>debug: var=ansible_facts</li>
</ul>
</li>
<li>也可以使用setup模块获取</li>
<li>ansible执行过程中默认收集facts信息<ul>
<li>ansible.cfg中配置项gathering设置默认行为</li>
<li>play中设置gather_facts改变默认行为</li>
</ul>
</li>
<li>默认没有开启facts缓存【可以在ansible.cfg设置如下参数开启文件形式缓存】<ul>
<li>fact_caching = jsonfile</li>
<li>fact_caching_connection = /tmp</li>
<li>fact_caching_timeout = 86400</li>
</ul>
</li>
</ul>
<h3 id="facts变量引用"><a href="#facts变量引用" class="headerlink" title="facts变量引用"></a>facts变量引用</h3><ul>
<li>facts变量可以从缓存或开启收集功能后实时获取</li>
<li>可以在当前执行任务的主机中获取其他主机或组的facts变量信息，但是<ul>
<li>需要在同一个play中已经和其他主机或组进行过通信，获取过facts信息</li>
<li>或者，在更高级别的play中有收集过其他主机或组的facts信息</li>
<li>也可以，开启facts缓存，当本地缓存有其他主机或组的facts信息时，则需受上述规则限制</li>
</ul>
</li>
</ul>
<h2 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h2><ul>
<li>执行一个任务，并将任务返回值保留为一个变量以用于后续任务，此时的变量即是注册变量</li>
<li>注册变量只在产生之后、play运行结束之前有效，并且它只保留在内存中【而不像facts可以自定义保存位置】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: register variable</span><br><span class="line">  shell: hostname</span><br><span class="line">  register: info</span><br><span class="line">- name: use register</span><br><span class="line">  debug: msg=&quot;This is &#123;&#123; info.stdout_lines[0] &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="变量冲突"><a href="#变量冲突" class="headerlink" title="变量冲突"></a>变量冲突</h2><ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#how-we-merge" target="_blank" rel="noopener">变量合并</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable" target="_blank" rel="noopener">变量优先级</a><ul>
<li>连接类型变量优先级【特定类型的链接设置优先于通用设置】：ansible_ssh_user》ansible_user》remote_user</li>
<li>主机与组的变量优先级：主机变量》组变量》父组变量</li>
</ul>
</li>
<li>优先级简单表示【优先级从高到低】<ol>
<li>命令行自定义变量</li>
<li>task 【tasks列表中定义的变量】</li>
<li>role 【roles列表中定义的变量】</li>
<li>play </li>
<li>playbook </li>
<li>inventory</li>
</ol>
</li>
</ul>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><ul>
<li><a href="http://jinja.pocoo.org/docs/templates/#builtin-filters" target="_blank" rel="noopener">jinja2内置过滤器</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">ansible支持的过滤器</a></li>
</ul>
<h2 id="常用过滤器"><a href="#常用过滤器" class="headerlink" title="常用过滤器"></a>常用过滤器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>字符串转整形</td>
</tr>
<tr>
<td>capitalize</td>
<td>首字母大写</td>
</tr>
<tr>
<td>default</td>
<td>设置默认值</td>
</tr>
<tr>
<td>random</td>
<td>取随机值</td>
</tr>
<tr>
<td>min/max</td>
<td>取最大最小值</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
</tr>
<tr>
<td>regu_replace</td>
<td>正则替换</td>
</tr>
<tr>
<td>join</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>json_query</td>
<td>从复杂json结构中获取值</td>
</tr>
<tr>
<td>from_json</td>
<td>从json文件获取变量</td>
</tr>
<tr>
<td>from_yaml</td>
<td>从yaml文件中获取变量</td>
</tr>
</tbody>
</table>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: 127.0.0.1</span><br><span class="line">  gather_facts: False</span><br><span class="line">  vars:</span><br><span class="line">    filename: /etc/profile</span><br><span class="line">    list: [1, 2, 3, 4, 5]</span><br><span class="line">    one: &quot;1&quot;</span><br><span class="line">    str: &quot;string&quot;</span><br><span class="line">    domain_definition:</span><br><span class="line">        domain:</span><br><span class="line">            cluster:</span><br><span class="line">                - name: &quot;cluster1&quot;</span><br><span class="line">                - name: &quot;cluster2&quot;</span><br><span class="line">            server:</span><br><span class="line">                - name: &quot;server11&quot;</span><br><span class="line">                  cluster: &quot;cluster1&quot;</span><br><span class="line">                  port: &quot;8080&quot;</span><br><span class="line">                - name: &quot;server12&quot;</span><br><span class="line">                  cluster: &quot;cluster1&quot;</span><br><span class="line">                  port: &quot;8090&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    # 使用jmespath从复杂json结构中获取变量</span><br><span class="line">    - debug:</span><br><span class="line">        var: item</span><br><span class="line">      loop: &quot;&#123;&#123; domain_definition|json_query(&apos;domain.cluster[*].name&apos;)&#125;&#125;&quot;</span><br><span class="line">    - name: use filter basename</span><br><span class="line">      shell: echo &#123;&#123; filename|basename &#125;&#125; &gt;&gt; /tmp/shell11</span><br><span class="line">    - name: debug int capitalize filter</span><br><span class="line">      debug: msg=&quot;The int value &#123;&#123; one|int &#125;&#125; the lower value is &#123;&#123; str|capitalize &#125;&#125;&quot;</span><br><span class="line">    - name: debug default value filter</span><br><span class="line">      debug: msg=&quot;The variable is &#123;&#123; ansible|default(&apos;ansible is not defined&apos;)&#125;&#125;&quot;</span><br><span class="line">    # 当default第二个值为true，则会在变量计算出来为空或false时使用默认值</span><br><span class="line">    - debug:</span><br><span class="line">        msg: &quot;var is &#123;&#123; lookup(&apos;env&apos;, &apos;USER1&apos;)|default(&apos;admin&apos;, true)&#125;&#125;&quot;</span><br><span class="line">    - name: debug list max and min filter</span><br><span class="line">      debug: msg=&quot;The list max value is &#123;&#123; list|max &#125;&#125; the min is &#123;&#123; list|min &#125;&#125;&quot;</span><br><span class="line">    - name: debug join filter</span><br><span class="line">      debug: msg=&quot;The join filter value is &#123;&#123; list|join(&apos;+&apos;) &#125;&#125;&quot;</span><br><span class="line">    - name: debug random filter</span><br><span class="line">    # 从1开始步长为10取随机值</span><br><span class="line">      debug: msg=&quot;the list random value is &#123;&#123; list|random &#125;&#125; generate a random value &#123;&#123; 1000|random(1, 10)&#125;&#125;&quot;</span><br><span class="line">    - name: debug replace and regex_replace filter</span><br><span class="line">      debug: msg=&quot;The replace value is &#123;&#123; str|replace(&apos;t&apos;, &apos;T&apos;)&#125;&#125;,\</span><br><span class="line">                The regex_replace value is &#123;&#123; str|regex_replace(&apos;.*str(.*)$&apos;, &apos;\\1&apos;)&#125;&#125;&quot;</span><br><span class="line">    # 从json或yaml文件中读取变量</span><br><span class="line">    - name: cat test.json</span><br><span class="line">      shell: cat test.json</span><br><span class="line">      register: result_json</span><br><span class="line">    - name: debug json info</span><br><span class="line">      debug:</span><br><span class="line">        msg: &quot;test2 var is &#123;&#123; (result_json.stdout|from_json)[&apos;test2&apos;]&#125;&#125;&quot;</span><br><span class="line">    - name: cat test1.yml</span><br><span class="line">      shell: cat test1.yml</span><br><span class="line">      register: result_yml</span><br><span class="line">    - name: debug yml info</span><br><span class="line">      debug:</span><br><span class="line">        msg: &quot;test1 var is &#123;&#123; (result_yml.stdout|from_yaml)[&apos;test1&apos;] &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h1 id="lookup插件"><a href="#lookup插件" class="headerlink" title="lookup插件"></a><a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html" target="_blank" rel="noopener">lookup插件</a></h1><ul>
<li>lookup插件允许访问外部数据源</li>
<li>解析过程在控制端完成，和模板系统类似</li>
</ul>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>从文件中解析内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">- contents: &quot;&#123;&#123; lookup(&apos;file&apos;, &apos;/etc/hosts&apos;)&#125;&#125;&quot;</span><br><span class="line">tasks:</span><br><span class="line">- name: display network content</span><br><span class="line">  debug: msg=&quot;network content is &#123;% for i in contents.split(&apos;\n&apos;) %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>主要用于解析模板中的facts信息【被控主机】<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lookup.j2：</span><br><span class="line">worker_processes &#123;&#123; ansible_processor_cores &#125;&#125;</span><br><span class="line">IPaddress &#123;&#123; ansible_eth0.ipv4.address &#125;&#125;</span><br><span class="line">test.yml：</span><br><span class="line">vars:</span><br><span class="line">- temp: &quot;&#123;&#123; lookup(&apos;template&apos;, &apos;lookup.j2&apos;)&#125;&#125;&quot;</span><br><span class="line">tasks:</span><br><span class="line">- name: display lookup content</span><br><span class="line">  debug: msg=&quot;network content is &#123;% for i in temp.split(&apos;\n&apos;) %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>解析命令行输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">- cmd: &quot;&#123;&#123; lookup(&apos;pipe&apos;, &apos;date +%s&apos;)&#125;&#125;&quot;</span><br><span class="line">tasks:</span><br><span class="line">- name: display lookup content</span><br><span class="line">  debug: msg=&quot;&#123;&#123; cmd &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>从redis中解析key值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">- key: &quot;&#123;&#123; lookup(&apos;redis&apos;, &apos;he&apos;, host=&apos;127.0.0.1&apos;, port=6379)&#125;&#125;&quot;</span><br><span class="line">tasks:</span><br><span class="line">- name: display lookup content</span><br><span class="line">  debug: msg=&quot;&#123;&#123; key &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="csvfile"><a href="#csvfile" class="headerlink" title="csvfile"></a>csvfile</h2><p>从csv文件中解析内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># java1是第0列的值，同时作为key，去取第4列的值【从0开始索引】</span><br><span class="line"># 此时逗号作为分隔符【默认为tab（TAB或t）】</span><br><span class="line">- name: get value from csv</span><br><span class="line">  debug: msg=&quot;java1 password is &#123;&#123; lookup(&apos;csvfile&apos;, &apos;java1 file=b.csv delimiter=, col=4&apos;)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="lookup与loop"><a href="#lookup与loop" class="headerlink" title="lookup与loop"></a>lookup与loop</h2><ul>
<li>lookup一次解析的多个结果默认用逗号连接；loop循环默认用列表作为输入。</li>
<li>为了让lookup解析的结果可以使用loop循环输出，需要如下操作，以便将解析结果转为列表<ul>
<li>在lookup中添加wantlist=True，</li>
<li>或使用query代替lookup</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    - debug: </span><br><span class="line">#        msg: &quot;&#123;&#123; lookup(&apos;inventory_hostnames&apos;, &apos;all&apos;, wantlist=True)&#125;&#125;&quot;</span><br><span class="line">        msg: &quot;&#123;&#123; query(&apos;inventory_hostnames&apos;, &apos;all&apos;)&#125;&#125;&quot;</span><br><span class="line">#        msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class="line">#      loop: &quot;&#123;&#123; lookup(&apos;inventory_hostnames&apos;, &apos;all&apos;, wantlist=True) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><blockquote>
<p>loop可以部分替代with_xxx功能  </p>
</blockquote>
<h2 id="普通列表"><a href="#普通列表" class="headerlink" title="普通列表"></a>普通列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">  - numbers: [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">- debug: msg=&apos;&#123;&#123; item &#125;&#125;&apos;</span><br><span class="line">  # with_flattened: &apos;&#123;&#123; numbers &#125;&#125;&apos;</span><br><span class="line">  loop: &apos;&#123;&#123; numbers|flatten &#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">- debug: msg=&quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class="line">  # with_items: </span><br><span class="line">  loop:</span><br><span class="line">    - &apos;one&apos;</span><br><span class="line">    - &apos;two&apos;</span><br><span class="line">    - &apos;three&apos;</span><br></pre></td></tr></table></figure>
<h2 id="hash列表"><a href="#hash列表" class="headerlink" title="hash列表"></a>hash列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- debug: msg=&quot;&#123;&#123; item.key &#125;&#125; is &#123;&#123; item.value &#125;&#125;&quot;</span><br><span class="line">  # with_items:</span><br><span class="line">  loop:</span><br><span class="line">    - &#123;&apos;key&apos;: &apos;name&apos;, &apos;value&apos;: 1&#125;</span><br><span class="line">    - &#123;&apos;key&apos;: &apos;nam2&apos;, &apos;value&apos;: 2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars:</span><br><span class="line">  - user:</span><br><span class="line">      shencan:</span><br><span class="line">        name: shencan</span><br><span class="line">        shell: bash</span><br><span class="line">      ruifengyun:</span><br><span class="line">        name: ruifengyun</span><br><span class="line">        shell: zsh</span><br><span class="line"></span><br><span class="line">- debug: msg=&apos;&#123;&#123; item.key &#125;&#125; value=&#123;&#123; item.value.name &#125;&#125;</span><br><span class="line">              shell=&#123;&#123; item.value.shell&#125;&#125;&apos;</span><br><span class="line">  #loop: &quot;&#123;&#123; user|dict2items &#125;&#125;&quot;</span><br><span class="line">  with_dict: &quot;&#123;&#123; user &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="双循环"><a href="#双循环" class="headerlink" title="双循环"></a>双循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- shell: &quot;echo &#123;&#123; item[0] &#125;&#125;*&#123;&#123; item[1] &#125;&#125;|bc&quot;</span><br><span class="line">  with_nested:</span><br><span class="line">    - [2, 3]</span><br><span class="line">    - [3, 5, 7]</span><br></pre></td></tr></table></figure>
<h2 id="匹配文件"><a href="#匹配文件" class="headerlink" title="匹配文件"></a>匹配文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- shell: echo 12 &gt; &#123;&#123; item &#125;&#125;</span><br><span class="line">  with_fileglob:</span><br><span class="line">    - &apos;./*.1&apos;</span><br><span class="line">    - &apos;./*.2&apos;</span><br></pre></td></tr></table></figure>
<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><ul>
<li>一次性判断  </li>
<li>when中直接使用变量名，不需要使用双大括号</li>
<li>多条件复杂逻辑关系可使用括号分组，如：【project_alias == “tomcat-crm” and (flag is changed or exe is defined)】</li>
<li>多个条件为and关系时可以使用列表形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: touch file when os is ubuntu</span><br><span class="line">  command: touch /tmp/ceshi</span><br><span class="line">  when:</span><br><span class="line">    - ansible_facts[&quot;os_family&quot;] == &quot;Debian&quot;</span><br><span class="line">    - ansible_memory_mb.real.total &gt; 900</span><br></pre></td></tr></table></figure>
<h3 id="执行结果判断"><a href="#执行结果判断" class="headerlink" title="执行结果判断"></a>执行结果判断</h3><ul>
<li>successed</li>
<li>failed</li>
<li>changed</li>
<li>skipped</li>
<li>undefined【变量未定义】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: test result</span><br><span class="line">  git:</span><br><span class="line">    repo: https://github.com/simple0426/gitbook.git</span><br><span class="line">    dest: /home/python/gitbook</span><br><span class="line">    version: master</span><br><span class="line">  run_once: true</span><br><span class="line">  register: result</span><br><span class="line">- name: debug change</span><br><span class="line">  debug: msg=&quot;change&quot;</span><br><span class="line">  when: result is changed</span><br><span class="line">- name: debug undefined</span><br><span class="line">  debug: msg=&quot;key12 is undefined&quot;</span><br><span class="line">  when: key12 is undefined</span><br></pre></td></tr></table></figure>
<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><p>多次尝试性判断  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每隔15s执行一次，共尝试3次；条件依然不满足时，task失败</span><br><span class="line">- name: ensure time is 201905241750</span><br><span class="line">  shell: date +%Y%m%d%H%M</span><br><span class="line">  register: date</span><br><span class="line">  until: date.stdout == &apos;201905241750&apos;</span><br><span class="line">  retries: 3</span><br><span class="line">  delay: 15</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>变量</tag>
        <tag>lookup</tag>
        <tag>loop</tag>
        <tag>condition</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible之基础学习</title>
    <url>/blog/2019/05/17/CICD/ansible/ansible%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ansible是用于远程系统管理、软件部署的工具，类似工具有fabric、puppet</p>
<h2 id="软件特性"><a href="#软件特性" class="headerlink" title="软件特性"></a>软件特性</h2><ul>
<li>基于当前的架构理解，使用简单的语言描述操作过程（playbook编写）</li>
<li>操作的可重用性及操作过程的可追溯性（playbook的可读性、roles的可重用性）</li>
<li>任何操作都是基于状态的描述（模块的幂等特性），只需保证目标对象最终要达到的状态，而不管目标对象的当前状态</li>
<li>基于openssh进行安全通信，无需额外的端口，无需客户端</li>
<li>管理各种基础设置，比如裸机(cobbler)、操作系统、虚拟化(vagrant)、容器(docker)、云、网络、存储等</li>
<li>内置功能丰富的模块，同时拥有强大的社区（galaxy）</li>
<li>管理软件迭代过程中使用的多个阶段环境（比如dev/test/stage/prod，通过多inventory实现）</li>
<li>可以实现服务的滚动更新（percentage）和不停机更新</li>
</ul>
<h2 id="实现操作"><a href="#实现操作" class="headerlink" title="实现操作"></a>实现操作</h2><ul>
<li>安装软件【yum、apt】</li>
<li>服务启停控制【service】</li>
<li>文件修改【lineinfile】</li>
<li>文件上传与下载【copy、fetch】</li>
<li>执行命令【command】</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><h3 id="控制端"><a href="#控制端" class="headerlink" title="控制端"></a>控制端</h3><ul>
<li>当前版本(2.8)要求控制端的python版本<ul>
<li>python2（2.7）</li>
<li>python3（3.5以上）</li>
</ul>
</li>
<li>控制端不支持在windows上安装</li>
<li>可以在RHEL/CentOS/Debian/Ubuntu/macOS/BSDs等linux主机安装</li>
</ul>
<h3 id="被控端"><a href="#被控端" class="headerlink" title="被控端"></a>被控端</h3><ul>
<li>python版本要求<ul>
<li>python2（2.6或以上）</li>
<li>python3（3.5或以上）</li>
</ul>
</li>
</ul>
<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><ul>
<li>yum：yum install ansible</li>
<li><p>apt：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo apt-add-repository --yes --update ppa:ansible/ansible</span><br><span class="line">sudo apt install ansible</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip：pip install ansible</p>
</li>
<li><a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" target="_blank" rel="noopener">其他安装参考</a></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>假如远端主机开启selinux，如果需要使用copy/file/template模块，则需要先安装libselinux-python软件</li>
<li>被控端，ansible默认使用的python解释器位置为/usr/bin/python，可以使用ansible_python_interpreter设置</li>
<li>ansible有个原生模块“raw”不需要使用python解释器，可以使用它初始化安装python：ansible myhost –become -m raw -a “yum install -y python2”</li>
<li>pip或源码安装的ansilbe默认没有配置文件<a href="https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg" target="_blank" rel="noopener">ansible.cfg</a></li>
</ul>
<h1 id="设置ansible"><a href="#设置ansible" class="headerlink" title="设置ansible"></a>设置ansible</h1><blockquote>
<p>主要为设置ansible.cfg文件</p>
</blockquote>
<ul>
<li>配置文件ansible.cfg中定义了ansible执行时的参数配置</li>
<li>可以使用环境变量或命令行参数进行部分选项设置，多种选项的优先级是：命令行》环境变量》配置文件</li>
<li>配置文件默认加载顺序：<ul>
<li>环境变量ANSIBLE_CONFIG</li>
<li>当前目录下的ansible.cfg【但是当前目录权限为其他人可写时，则拒绝加载】</li>
<li>用户主目录下的.ansible.cfg</li>
<li>系统目录/etc/ansible/ansible.cfg</li>
</ul>
</li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a><a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings" target="_blank" rel="noopener">常用参数</a></h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>inventory</td>
<td>资源清单</td>
</tr>
<tr>
<td>library</td>
<td>模块位置【冒号分隔多个位置】</td>
</tr>
<tr>
<td>forks</td>
<td>几个进程在工作【默认5个】</td>
</tr>
<tr>
<td>host_key_checking</td>
<td>如果远端主机第一次被链接是否执行秘钥检查【设置为False】</td>
</tr>
<tr>
<td>timeout</td>
<td>ssh连接超时</td>
</tr>
<tr>
<td>log_path</td>
<td>日志路径</td>
</tr>
<tr>
<td>sudo_user</td>
<td>sudo用户</td>
</tr>
<tr>
<td>remote_port</td>
<td>ssh连接端口</td>
</tr>
<tr>
<td>ssh_args</td>
<td>额外的ssh连接参数【可用于跳板机配置】</td>
</tr>
<tr>
<td>scp_if_ssh</td>
<td>如果有跳板机，则需设置为True</td>
</tr>
<tr>
<td>retry_files_enabled</td>
<td>关闭因playbook无法执行而产生的retry文件</td>
</tr>
<tr>
<td>deprecation_warnings = False</td>
<td>关闭警告信息</td>
</tr>
<tr>
<td>stdout_callback</td>
<td>定义屏幕输出格式为yaml(json格式输出遇到换行时不直观)</td>
</tr>
</tbody>
</table>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">inventory      = ./hosts</span><br><span class="line">remote_port    = 22</span><br><span class="line">host_key_checking = False</span><br><span class="line">stdout_callback = yaml</span><br><span class="line">callback_whitelist = timer</span><br><span class="line">command_warnings = False</span><br><span class="line">fact_caching = jsonfile</span><br><span class="line">fact_caching_connection=/tmp</span><br><span class="line">fact_caching_timeout = 86400</span><br><span class="line">retry_files_enabled = False</span><br></pre></td></tr></table></figure>
<h1 id="设置inventory"><a href="#设置inventory" class="headerlink" title="设置inventory"></a>设置inventory</h1><p>inventory即执行任务的主机资源列表，默认指的是/etc/ansible/hosts文件</p>
<h2 id="引用inventory"><a href="#引用inventory" class="headerlink" title="引用inventory"></a>引用inventory</h2><ul>
<li>默认使用/etc/ansible/hosts或ansible.cfg中定义的hosts</li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html" target="_blank" rel="noopener">动态的获取主机资源</a>，比如<ul>
<li>使用脚本，动态获取主机资源</li>
<li>通过插件，从云上获取主机资源</li>
</ul>
</li>
<li>主机资源文件可以是多种格式的，默认是ini，也可以是yaml<ul>
<li>查看ansible支持的主机资源类型：ansible-doc -t inventory –list</li>
</ul>
</li>
<li>多种主机资源聚合时<ul>
<li>可以在命令行中多次使用-i参数指定</li>
<li>也可以建立一个目录，在目录下定义多个主机资源文件</li>
</ul>
</li>
</ul>
<h2 id="定义inventory"><a href="#定义inventory" class="headerlink" title="定义inventory"></a>定义inventory</h2><ul>
<li>可以在inventory中定义主机变量和组变量【一般只设置<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#list-of-behavioral-inventory-parameters" target="_blank" rel="noopener">连接类型的内置变量</a>，常用参数如下：】<ul>
<li>ansible_user：ansible连接远程主机使用的ssh用户</li>
<li>ansible_host：远程连接主机</li>
<li>ansible_port：远程连接使用的端口</li>
<li>ansible_password：远程连接面</li>
<li>ansible_connecttion：定义hosts的连接方式【值为local时为执行本地操作】</li>
</ul>
</li>
<li>一个主机可以被包含在多个组中，一个组也可以包含另一个组</li>
<li>当主机名或ip中包含连续的字母或数字时，可以使用正则形式，比如<ul>
<li>www[a-f].example.com</li>
<li>192.168.0.1[0-9]</li>
</ul>
</li>
<li>默认的组是all【包含所有主机】和ungrouped【包含未分组的主机】</li>
<li>当控制端与远程主机没有使用标准的22端口通信时，<ul>
<li>如果使用的是paramiko进行连接【比如centos6/RHEL6】,则不会读取ssh配置文件中的端口信息</li>
<li>当使用openssh进行连接时，则会使用ssh配置文件中的端口信息</li>
<li>所以当使用非标准端口进行通信时，应该在inventory中明确指明使用的端口，例如：<ul>
<li>后缀形式：<code>badwolf.example.com:5309</code></li>
<li>变量形式：<code>jumper ansible_port=5555 ansible_host=192.0.2.50</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crm ansible_user=&apos;root&apos; ansible_ssh_pass=&apos;123456&apos;     定义主机和主机变量</span><br><span class="line">[docker]      定义docker组</span><br><span class="line">192.168.99.10[2:9]</span><br><span class="line">[docker:vars]      定义docker组变量</span><br><span class="line">ansible_ssh_pass=&quot;123&quot;</span><br><span class="line">[newserver:children]      newserver组包含webservers组</span><br><span class="line">webservers</span><br></pre></td></tr></table></figure>
<h1 id="远程连接设置"><a href="#远程连接设置" class="headerlink" title="远程连接设置"></a>远程连接设置</h1><ul>
<li>ansible默认使用原生openssh用于远程连接，并将开启ControlPersist 功能  </li>
<li>由于RHEL6和centos6的openssh版本过老无法使用ControlPersist 功能，在这些系统上将会使用paramiko来替代openssh用于远程连接  </li>
<li>有时会出现个别设备不支持sftp，这时候就需要使用scp来替代【比如使用跳板机】  </li>
</ul>
<h2 id="密码方式登录"><a href="#密码方式登录" class="headerlink" title="密码方式登录"></a>密码方式登录</h2><p>在inventory文件中设置ansible_user和ansible_password参数</p>
<h2 id="秘钥方式登录"><a href="#秘钥方式登录" class="headerlink" title="秘钥方式登录"></a>秘钥方式登录</h2><blockquote>
<p>先使用密码方式，建立秘钥后取消密码选项</p>
</blockquote>
<ul>
<li>产生秘钥：ssh-keygen -t rsa -P “” -f ./bastion</li>
<li>传送公钥：ansible ops -m copy -a “src=keyfiles/bastion.pub dest=~/.ssh/authorized_keys mode=0600”</li>
</ul>
<h1 id="跳板机设置"><a href="#跳板机设置" class="headerlink" title="跳板机设置"></a>跳板机设置</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>ansible可以通过跳板机管理远程内网服务器</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>通过ssh的代理转发功能实现本地使用远程主机内网ip登录远程服务器，</li>
<li>本案例中使用证书登录，即ansible主机与跳板机(bastion)、跳板机与目标服务器(internal)之间均使用证书登录</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="产生秘钥"><a href="#产生秘钥" class="headerlink" title="产生秘钥"></a>产生秘钥</h3><ul>
<li>ssh-keygen -t rsa -P “” -f ./bastion</li>
<li>ssh-keygen -t rsa -P “” -f ./internal</li>
</ul>
<h3 id="传送公钥"><a href="#传送公钥" class="headerlink" title="传送公钥"></a>传送公钥</h3><blockquote>
<p>公钥放置在某用户主目录下，则以后必须使用相应的用户登录，此例中<br>ansible主机使用muker登录跳板机，跳板机使用muker登录目标主机</p>
</blockquote>
<ul>
<li>ansible ops -m copy -a “src=keyfiles/bastion.pub dest=~/.ssh/authorized_keys mode=0600”</li>
<li>ansible 1.1.1.1【下例中172.16.0.205主机的公网ip】 -m copy -a “src=keyfiles/internal.pub dest=~/.ssh/authorized_keys mode=0600”</li>
</ul>
<h3 id="设置sshd-可选"><a href="#设置sshd-可选" class="headerlink" title="设置sshd(可选)"></a>设置sshd(可选)</h3><blockquote>
<p>设置ssh服务只允许证书登录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/ssh/sshd_conf</span><br><span class="line">PermitRootLogin no</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<h3 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h3><ul>
<li>ssh发起连接时，默认使用~/.ssh/config配置，可使用-F参数强制使用指定配置文件</li>
<li>本地私钥权限必须为0600</li>
<li>config文件配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host ops</span><br><span class="line">  User muker #连接跳板机使用的用户名</span><br><span class="line">  HostName 47.99.78.151 #跳板机ip</span><br><span class="line">  ProxyCommand none</span><br><span class="line">  BatchMode yes #跳板机模式</span><br><span class="line">  IdentityFile ~/keyfiles/bastion #本地连跳板机时使用的私钥</span><br><span class="line">  StrictHostKeyChecking no #首次登录时禁止秘钥检查</span><br><span class="line">Host 172.16.0.*  # 目标主机网络</span><br><span class="line">  ServerAliveInterval 60 </span><br><span class="line">  TCPKeepAlive        yes</span><br><span class="line">  ProxyCommand ssh -qaY -i ~/keyfiles/bastion muker@ops &apos;nc -w 14400 %h %p&apos; # ssh代理转发</span><br><span class="line">  IdentityFile    ~/keyfiles/internal #跳板机使用私钥internal连接目标主机</span><br><span class="line">  StrictHostKeyChecking no</span><br></pre></td></tr></table></figure>
<h3 id="ssh登录测试"><a href="#ssh登录测试" class="headerlink" title="ssh登录测试"></a>ssh登录测试</h3><ul>
<li>登录跳板机： ssh -F keyfiles/config ops</li>
<li>登录目标内网主机：ssh -F keyfiles/config <a href="mailto:muker@172.16.0.205" target="_blank" rel="noopener">muker@172.16.0.205</a></li>
</ul>
<h3 id="ansible配置"><a href="#ansible配置" class="headerlink" title="ansible配置"></a>ansible配置</h3><ul>
<li><p>ansible.cfg</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ssh_connection]</span><br><span class="line">ssh_args = -C -o ControlMaster=auto -F keyfiles/config</span><br><span class="line">scp_if_ssh = True #文件复制操作强制使用scp模式</span><br></pre></td></tr></table></figure>
</li>
<li><p>hosts</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ops ansible_user=&apos;muker&apos;</span><br><span class="line">172.16.0.205 ansible_user=&apos;muker&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ansible测试"><a href="#ansible测试" class="headerlink" title="ansible测试"></a>ansible测试</h3><blockquote>
<p>ping测试</p>
</blockquote>
<ul>
<li>ansible ops -m ping</li>
<li>ansible 172.16.0.205 -m ping</li>
</ul>
<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ul>
<li>ping：测试主机连通性</li>
<li>setup：用于获取操作系统信息<ul>
<li>ansible 127.0.0.1 -m setup -a “filter=ansible_os*”</li>
</ul>
</li>
<li>command/shell：执行命令【command为命令行下默认模块】<ul>
<li>creates：当文件存在时，module所在task不执行【可用于实现幂等性】</li>
</ul>
</li>
<li><p>template：模板系统，可以复制包含变量名的文件</p>
<ul>
<li>validate：检查由实参渲染的模板文件语法是否正常，如nginx配置文件、sudo文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: write the nginx config file</span><br><span class="line">  template: src=nginx2.conf dest=/etc/nginx/nginx.conf validate=&apos;nginx -t -c %s&apos;</span><br><span class="line">  notify:</span><br><span class="line">  - restart nginx</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>file：创建、删除文件或目录</p>
<ul>
<li>state：directory、absent</li>
</ul>
</li>
<li>yum/apt：软件包管理</li>
<li>service：服务管理</li>
<li>user：用户管理</li>
<li>git：git操作</li>
<li>copy：复制文件和目录<ul>
<li>缺点：当复制的目录有多级或目录内的文件数据过多时，传输效率异常低下</li>
<li>优点：可以备份（backup），可以检测配置文件的有效性（validate）</li>
</ul>
</li>
<li>archive：打包文件和目录<ul>
<li>缺点：不会复制空目录或空文件【比如python包文件<code>__init__.py</code>即可以是空文件】</li>
</ul>
</li>
<li>synchronize：使用rsync模块同步文件和目录<ul>
<li>优点：传输效率高</li>
<li>缺点：<ul>
<li>必须使用ansible.cfg中的ssh配置选项</li>
<li>不能备份、不能检测配置文件有效性</li>
<li>不能解析hosts文件中的变量</li>
</ul>
</li>
</ul>
</li>
<li><p>haproxy：控制haproxy服务</p>
<ul>
<li>haproxy版本：1.5【增加后端服务器drain状态（软下线）】</li>
<li>haproxy依赖：安装socat，并在haproxy.cnf中配置：stats socket /var/run/haproxy.sock mode 600 level admin<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此配置主要将后端的某台服务器软下线【不接受新连接，已经建立的连接正常处理并关闭】</span><br><span class="line">- name: disable &#123;&#123; project &#125;&#125; in haproxy</span><br><span class="line">  haproxy: state=drain backend=&apos;&#123;&#123; project &#125;&#125;&apos; host=&apos;&#123;&#123; inventory_hostname &#125;&#125;&apos; socket=/var/run/haproxy.sock </span><br><span class="line"># 上线某个后端的某台主机并等待，保障此后端主机可用</span><br><span class="line">- name: enable &#123;&#123; project &#125;&#125; in haproxy</span><br><span class="line">  haproxy: state=enabled backend=&apos;&#123;&#123; project &#125;&#125;&apos; host=&apos;&#123;&#123; inventory_hostname &#125;&#125;&apos; socket=/var/run/haproxy.sock wait=yes</span><br><span class="line">  delegate_to: &apos;&#123;&#123; haproxy &#125;&#125;&apos;</span><br><span class="line">  become: yes</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>fetch：从远程主机拉取文件到本地</p>
<ul>
<li>dest：保存为本地文件或保存在本地目录【必须以斜线结尾】</li>
<li>flat：设置为yes时，和copy一样的行为；当为no时，则保存在本地的dest/&lt;remote_hostname&gt;/&lt;absolute_path&gt;下</li>
<li>src：远程主机上的文件</li>
<li>validate_checksum：是否在传输完成后进行校验</li>
<li>范例：ansible test1 -m fetch -a “src=~/vendor/redis-4.0.14.tar.gz dest=files/ flat=yes”</li>
</ul>
</li>
<li>blockinfile：插入、更新、删除多行文本内容<ul>
<li>group/owner/mode：属主属组权限等</li>
<li>backup：备份文件</li>
<li>block：在标记处将要插入的文本；如果选项缺失或是空字符串，则和state=present一样都是删除内容</li>
<li>path：文件路径</li>
<li>create：文件不存在则新创建</li>
<li>validate：文件语法检查</li>
<li>state：present为添加或更新，absent为删除</li>
<li>marker：替换内容的前后注释信息，默认：”# {mark} ANSIBLE MANAGED BLOCK”</li>
<li>insertafter：在指定标记后插入内容<ul>
<li>‘EOF’表示文件末尾</li>
<li>regex表示一般正则表达式，如果匹配不到则使用EOF</li>
</ul>
</li>
<li>insertbefore：在指定标记钱插入内容<ul>
<li>‘BOF’表示文件开始</li>
<li>regex表示一般正则表达式，如果匹配不到则使用EOF</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改mavne仓库为阿里云</span><br><span class="line">- name: add aliyun repo</span><br><span class="line">  blockinfile:</span><br><span class="line">    path: /usr/local/apache-maven-3.6.0/conf/settings.xml</span><br><span class="line">    marker: &quot;&lt;!-- &#123;mark&#125; ANSIBLE MANAGED BLOCK --&gt;&quot;</span><br><span class="line">    backup: yes</span><br><span class="line">    insertafter: &quot;&lt;mirrors&gt;&quot;</span><br><span class="line">    block: |</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">         &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">         &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">         &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">         &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible.cfg</tag>
        <tag>ssh</tag>
        <tag>inventory</tag>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins安装与配置</title>
    <url>/blog/2020/02/10/CICD/jenkins/jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>需要提前配置java8运行环境</p>
</blockquote>
<h2 id="虚拟机方式"><a href="#虚拟机方式" class="headerlink" title="虚拟机方式"></a>虚拟机方式</h2><ul>
<li><p>centos安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo</span><br><span class="line">rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br><span class="line">yum install jenkins -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>ubuntu安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -</span><br><span class="line">sudo sh -c &apos;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码包安装</p>
<ul>
<li>软件源：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/</code> <code>debian-stable|redhat-stable</code></li>
<li>deb包安装失败<ul>
<li>sudo apt-get update # 更新</li>
<li>sudo apt-get -f install # 解决依赖关系</li>
<li>sudo dpkg -i xxx.deb # 重新安装</li>
</ul>
</li>
<li>安装错误<ul>
<li>错误：ERROR: No Java executable found in current PATH: /bin:/usr/bin:/sbin:/usr/sbin</li>
<li>解决：ln -s /usr/local/jdk1.8.0_241/bin/java /usr/bin/</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="docker方式"><a href="#docker方式" class="headerlink" title="docker方式"></a>docker方式</h2><ul>
<li><p>启动参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name jenkins \</span><br><span class="line">  -u root -d \</span><br><span class="line">  -p 80:8080 -p 50000:50000 \</span><br><span class="line">  -v /data/jenkins/:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v /usr/bin/docker:/usr/bin/docker \</span><br><span class="line">  -v /usr/local/maven:/usr/local/maven \</span><br><span class="line">  -v /usr/local/jdk:/usr/local/jdk \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e JAVA_OPTS=&quot;-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true&quot; \</span><br><span class="line">  --restart=always \</span><br><span class="line">  jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数详解：</p>
<ul>
<li>–name：设置容器名称</li>
<li>-u：以root启动，防止出现权限问题</li>
<li>-d：后台运行</li>
<li>-p 80:8080：映射服务端口【宿主机80-》容器8080】</li>
<li>-p 50000:50000：agent连接master的端口</li>
<li>-v /data/jenkins/:/var/jenkins_home：jenkins主目录持久化存储</li>
<li>-v /var/run/docker.sock:/var/run/docker.sock：确保jenkins容器内可以操作宿主机的docker</li>
<li>-v /usr/local/maven:/usr/local/maven：挂载宿主机maven到jenkins容器</li>
<li>-v /usr/local/jdk:/usr/local/jdk：挂载宿主机jdk到容器</li>
<li>-v /etc/localtime:/etc/localtime：设置容器时间</li>
<li>-e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true”：关闭csrf保护</li>
</ul>
</li>
<li>csrf设置：由于jenkins2.0版本默认开启CSRF且不能关闭，所以需要在启动jenkins服务时关闭csrf<ul>
<li><a href="https://www.jenkins.io/doc/upgrade-guide/2.222/#always-enabled-csrf-protection" target="_blank" rel="noopener">官方说明</a></li>
<li><a href="https://www.cnblogs.com/kazihuo/p/12937071.html" target="_blank" rel="noopener">网友设置</a></li>
</ul>
</li>
</ul>
<h1 id="访问和认证"><a href="#访问和认证" class="headerlink" title="访问和认证"></a>访问和认证</h1><ul>
<li>访问地址：<a href="http://JENKINS_URL:8080" target="_blank" rel="noopener">http://JENKINS_URL:8080</a><ul>
<li>初始化密码：/var/jenkins_home/secrets/initialAdminPassword</li>
</ul>
</li>
</ul>
<h1 id="使用国内镜像"><a href="#使用国内镜像" class="headerlink" title="使用国内镜像"></a>使用国内镜像</h1><ul>
<li><p>修改插件更新中心URL：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></p>
</li>
<li><p>修改json配置【/var/jenkins_home/updates/default.json】</p>
<blockquote>
<p>每次插件信息(default.json)更新都会覆盖为官方地址，所以每次default.json更新都需要做如下修改</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/https:\/\/updates.jenkins.io\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&apos; default.json &amp;&amp; \</span><br><span class="line"> sed -i &apos;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&apos; default.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启jenkins：<code>docker restart jenkins</code></p>
</li>
</ul>
<h1 id="邮件设置"><a href="#邮件设置" class="headerlink" title="邮件设置"></a>邮件设置</h1><blockquote>
<p>Mailer插件</p>
</blockquote>
<ul>
<li>系统管理员帐户</li>
<li>SMTP服务器户</li>
<li>SMTP认证</li>
<li>用户名</li>
<li>密码</li>
<li>发送测试【如果设置的邮件为163，则收件人和发件人一样；否则会显示为垃圾邮件不能发送】</li>
<li>测试用户邮箱地址</li>
</ul>
<h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><blockquote>
<p>一般使用ssh连接并控制slave节点，需要<a href="https://plugins.jenkins.io/ssh-slaves" target="_blank" rel="noopener">SSH Build Agents</a>插件</p>
</blockquote>
<ul>
<li>远程工作目录</li>
<li>设置启动方式（ssh）</li>
<li>节点属性<ul>
<li>环境变量：如JAVA_HOME、MAVEN_HOME</li>
<li>tools位置：参见工具<a href="#使用注意">使用注意</a></li>
</ul>
</li>
</ul>
<h1 id="全局工具"><a href="#全局工具" class="headerlink" title="全局工具"></a>全局工具</h1><p>使用工具后，jenkins可以自动下载【可选】并安装maven、jdk等工具，并把相关的环境变量MAVEN_HOME、JAVA_HOME放在执行环境的PATH变量下，这样就可以直接使用相关的命令java、mvn</p>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><blockquote>
<p>Maven Configuration处本意为设置全局的maven settings.xml文件，经过多次试验均无效；所以Maven Configuration保持默认设置；</p>
</blockquote>
<p>maven有多种安装方式</p>
<ul>
<li>在宿主机安装maven后，在Maven installations处指定MAVEN_HOME</li>
<li>指定install automatically，从Apache官方自动安装maven</li>
<li>指定install automatically，从指定的url处下载*.zip/*.tar.gz文件；<strong>注意</strong>：必须指定解压子目录，且子目录名称为解压的原始目录，如<ul>
<li>URL:<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</a></li>
<li>子目录：apache-maven-3.6.3</li>
</ul>
</li>
</ul>
<h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><blockquote>
<p>与maven安装类似</p>
</blockquote>
<p>jdk也有多种安装方式</p>
<ul>
<li>在宿主机安装jdk后，在JDK installations处指定JAVA_HOME</li>
<li>指定install automatically，从java.sun.com安装【需要oracle账号】</li>
<li>指定install automatically，从指定的url处下载*.zip/*.tar.gz文件；<strong>注意</strong>：必须指定解压子目录，且子目录名称为解压的原始目录，如<ul>
<li>URL：<a href="https://d6.injdk.cn/oracle/8/jdk-8u251-linux-x64.tar.gz" target="_blank" rel="noopener">https://d6.injdk.cn/oracle/8/jdk-8u251-linux-x64.tar.gz</a> </li>
<li>子目录：jdk1.8.0_251</li>
</ul>
</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li><p>node节点tools使用：</p>
<blockquote>
<p>全局工具设置只在master节点有效，node节点需要相关工具时需要在node节点单独安装；node节点工具使用设置如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节点管理==》节点属性==》工具位置：</span><br><span class="line">* 名称：master和node都可以使用的工具名称</span><br><span class="line">* Home：maven、jdk等工具的根目录，和JAVA_HOME、MAVEN_HOME类似</span><br><span class="line">  - jdk设置：如/usr/local/jdk【JAVA_HOME】</span><br><span class="line">  - maven设置：如/usr/local/maven【MAVEN_HOME】</span><br><span class="line"></span><br><span class="line">由于tools设置的工具，尤其是自动化安装操作只在master上有效，所以为了统一管理，建议master和node上统一</span><br><span class="line">使用本地安装方式，并保持目录位置一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>maven仓库设置：直接修改安装目录下的conf/settings.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器方式挂载的jdk、maven</p>
<ul>
<li>可以在tools中设置JAVA_HOME/MAVEN_HOME，然后以tools方式使用maven、jdk</li>
<li>也可以在pipeline中以shell方式设置JAVA_HOME/MAVEN_HOME，然后直接使用maven、jdk</li>
</ul>
</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">      jdk &apos;jdk-251&apos;</span><br><span class="line">      maven &apos;mvn-3.5&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;java&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &apos;java -version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;maven&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &apos;mvn -version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集成docker"><a href="#集成docker" class="headerlink" title="集成docker"></a>集成docker</h1><ul>
<li>插件<ul>
<li>Docker Commons Plugin：给各种docker插件提供基础的API</li>
<li>docker-build-step：在job中执行docker命令</li>
</ul>
</li>
<li>配置(docker-build-step插件)：系统配置–》Docker Builder–》unix:///var/run/docker.sock【确保jenkinis用户对此socket有读权限】</li>
<li><p>使用方式-tools：通过在全局工具配置中定义特定版本的docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">  agent any</span><br><span class="line">  tools &#123;</span><br><span class="line">    &apos;org.jenkinsci.plugins.docker.commons.tools.DockerTool&apos; &apos;docker1903&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  stages &#123;</span><br><span class="line">    stage(&apos;foo&apos;) &#123;</span><br><span class="line">      steps &#123;</span><br><span class="line">        sh &quot;docker version&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方式-agent：加载PATH变量下默认的docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent&#123;</span><br><span class="line">        docker&#123;</span><br><span class="line">            image &apos;maven:3.6.3-jdk-8&apos;</span><br><span class="line">            label &apos;agent01&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&apos;Build&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo jdk version...&apos;</span><br><span class="line">                sh &apos;java -version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Test&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo maven version...&apos;</span><br><span class="line">                sh &apos;mvn --version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Deploy&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo Deploy stage...&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并行使用多个docker镜像(parallel)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stage(&apos;Build&apos;)&#123;</span><br><span class="line">    parallel&#123;</span><br><span class="line">        stage(&apos;Front End Build: Angular&apos;)&#123;</span><br><span class="line">            agent&#123;</span><br><span class="line">                docker&#123;</span><br><span class="line">                    image &apos;liumiaocn/angular:8.3.8&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo Front End Build stage...&apos;</span><br><span class="line">                sh &apos;ng --version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Back End build: Marven&apos;)&#123;</span><br><span class="line">            agent&#123;</span><br><span class="line">                docker&#123;</span><br><span class="line">                    image &apos;maven:3.6.3-jdk-8&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo Back End Build stage ...&apos;</span><br><span class="line">                sh &apos;mvn --version&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dockerfile中定义构建环境</p>
<ul>
<li>默认，需要在多分支pipeline或SCM-pipeline中使用</li>
<li>为了手动测试，可以在jenkins宿主机的绝对目录定义dockerfile<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agent&#123;</span><br><span class="line">    dockerfile&#123;</span><br><span class="line">        filename &apos;Dockerfile&apos;</span><br><span class="line">        dir &apos;/tmp&apos;</span><br><span class="line">        label &apos;agent01&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible之应用实践</title>
    <url>/blog/2019/07/02/CICD/ansible/ansible%E4%B9%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h1><h2 id="异步等待模式"><a href="#异步等待模式" class="headerlink" title="异步等待模式"></a>异步等待模式</h2><ul>
<li>ansible在客户端异步执行，在任务执行过程中，无论ssh连接是否中断都不影响任务执行  </li>
<li>async：任务执行超时时间，如无此关键词，则任务以同步模式执行【ansible默认模式】</li>
<li>poll：任务轮询时间，大于0的正值，任务异步执行，但在任务出结果之前ansible在前台阻塞挂起</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: test sleep</span><br><span class="line">  command: /bin/sleep &#123;&#123; 41 | random(35, 1)&#125;&#125;</span><br><span class="line">  async: 100</span><br><span class="line">  poll: 20</span><br></pre></td></tr></table></figure>
<h2 id="异步非等待模式"><a href="#异步非等待模式" class="headerlink" title="异步非等待模式"></a>异步非等待模式</h2><ul>
<li>poll等于0，则任务不轮询结果</li>
<li>ansible在执行任务的过程中，把任务交给节点后即刻切换到下一个节点，不等待任务的执行结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: test sleep</span><br><span class="line">  command: /bin/sleep &#123;&#123; 41 | random(35, 1)&#125;&#125;</span><br><span class="line">  async: 100</span><br><span class="line">  poll: 0</span><br></pre></td></tr></table></figure>
<h2 id="查询非等待模式结果"><a href="#查询非等待模式结果" class="headerlink" title="查询非等待模式结果"></a>查询非等待模式结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: test sleep</span><br><span class="line">  command: /bin/sleep &#123;&#123; 41 | random(35, 1)&#125;&#125;</span><br><span class="line">  async: 100</span><br><span class="line">  poll: 0</span><br><span class="line">  register: sleep_status</span><br><span class="line">- name: check status</span><br><span class="line">  async_status:</span><br><span class="line">    jid: &quot;&#123;&#123; sleep_status.ansible_job_id &#125;&#125;&quot;</span><br><span class="line">  register: job_result</span><br><span class="line">  until: job_result.finished</span><br><span class="line">  retries: 10</span><br><span class="line">  delay: 10</span><br></pre></td></tr></table></figure>
<h1 id="debugger调试"><a href="#debugger调试" class="headerlink" title="debugger调试"></a>debugger调试</h1><ul>
<li>可以在任意具有name属性的区块设置，比如play、role、block、task</li>
<li>debugger值：<ul>
<li>always：总是调用调试模块</li>
<li>never：从不调用</li>
<li>on_failed：仅在任务失败时调用调试模块</li>
<li>on_unreachable：当主机不可达时调用模块</li>
<li>on_skipped：任务跳过时调用模块</li>
</ul>
</li>
<li>可用命令：<ul>
<li>p task：显示任务名称</li>
<li>p task.args：显示任务参数</li>
<li>p task_vars：显示任务变量</li>
<li>p host：显示任务操作主机</li>
<li>p result._result：显示任务执行结果</li>
<li>task_vars[key] = value：设置变量</li>
<li>task.args[key] = value：设置参数</li>
<li>r（edo）：重新运行任务</li>
<li>c（continue）：继续执行</li>
<li>q（uit） ：从debugger模式退出</li>
</ul>
</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="忽略错误继续执行"><a href="#忽略错误继续执行" class="headerlink" title="忽略错误继续执行"></a>忽略错误继续执行</h2><ul>
<li>默认行为：遇到错误会终止错误处以后task的执行</li>
<li>语法：ignore_errors：yes</li>
<li>定义位置：task</li>
</ul>
<h2 id="重置主机不可达错误"><a href="#重置主机不可达错误" class="headerlink" title="重置主机不可达错误"></a>重置主机不可达错误</h2><ul>
<li>默认行为：当执行某任务时，主机不可达，会退出正在执行的任务进而退出整个play</li>
<li>设置后：重置主机不可达错误时，某个task的主机不可达不影响其他task的连接尝试</li>
<li>语法：ignore_unreachable: yes</li>
<li>定义位置：play</li>
</ul>
<h2 id="强制handler执行"><a href="#强制handler执行" class="headerlink" title="强制handler执行"></a>强制handler执行</h2><ul>
<li>默认行为：一个play中某个task的失败，会引起已经触发的handler不再执行</li>
<li>语法：force_handlers: True</li>
<li>定义位置：play、ansible.cfg或命令行（–force-handlers）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">force_handlers: true</span><br><span class="line">handlers:</span><br><span class="line">  - name: touch file</span><br><span class="line">    command: touch /tmp/file</span><br><span class="line">tasks:</span><br><span class="line">  - name: exe handlers</span><br><span class="line">    command: touch /tmp/file1</span><br><span class="line">    notify:</span><br><span class="line">      - touch file</span><br><span class="line">  - name: touch failed</span><br><span class="line">    command: touch /home/muk/ceshi</span><br></pre></td></tr></table></figure>
<h2 id="任何错误都退出"><a href="#任何错误都退出" class="headerlink" title="任何错误都退出"></a>任何错误都退出</h2><ul>
<li>默认情况下：在多个主机执行任务时，在一个主机上遇到错误只造成此主机剩余任务不执行，不影响其他主机任务的执行【多个主机间的错误互不干扰】</li>
<li>设置后：任何主机的任何错误都会造成整个play的退出，不再执行。</li>
<li>语法：any_errors_fatal: true</li>
<li>定义位置：play</li>
</ul>
<h2 id="重定义失败状态"><a href="#重定义失败状态" class="headerlink" title="重定义失败状态"></a>重定义失败状态</h2><ul>
<li>定义位置：task</li>
<li>语法：failed_when</li>
<li>含义：只有满足自定义的条件才算是失败状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: test fail when</span><br><span class="line">  command: touch /home/ceshi/12</span><br><span class="line">  register: result</span><br><span class="line">  failed_when: &quot;&apos;No such&apos; in result.stderr&quot;</span><br></pre></td></tr></table></figure>
<h2 id="重定义变更状态"><a href="#重定义变更状态" class="headerlink" title="重定义变更状态"></a>重定义变更状态</h2><ul>
<li>定义位置：task</li>
<li>语法：changed_when</li>
<li>含义只有满足自定义的条件才算是“变更”状态</li>
</ul>
<h2 id="使用block处理错误"><a href="#使用block处理错误" class="headerlink" title="使用block处理错误"></a>使用block处理错误</h2>]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>debug</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡器-lvs</title>
    <url>/blog/2019/09/15/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%90%86%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8-LVS/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">LVS</a>的全称是Linux virtual server，即Linux虚拟服务器。之所以是虚拟服务器，是因为LVS自身是个负载均衡器(director)，不直接处理请求，而是将请求转发至位于它后端真正的服务器realserver上。</p>
<h2 id="lvs技术实现"><a href="#lvs技术实现" class="headerlink" title="lvs技术实现"></a>lvs技术实现</h2><ul>
<li>四层负载均衡：网络及传输层实现的IP虚拟服务器软件IPVS；ipvs是集成在内核中的框架，可以通过用户空间的程序ipvsadm工具来管理，该工具可以定义一些规则来管理内核中的ipvs，就像iptables和netfilter的关系一样。这也是本文介绍的功能。</li>
<li>七层负载均衡：基于内容请求分发的内核Layer-7交换机KTCPVS【功能尚不完善，使用的人不多】</li>
<li>集群管理软件：redhat公司从其6.1发行版起已包含LVS代码，他们开发了一个LVS集群管理工具叫Piranha，用于控制LVS集群，并提供了一个图形化的配置界面。【但此工具已被Redhat官方废弃，相应功能已使用<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/7.0_release_notes/sect-red_hat_enterprise_linux-7.0_release_notes-clustering-keepalived_and_haproxy_replace_piranha_as_load_balancer" target="_blank" rel="noopener">haproxy和keepalived</a>代替】</li>
</ul>
<h2 id="ipvs技术术语"><a href="#ipvs技术术语" class="headerlink" title="ipvs技术术语"></a>ipvs技术术语</h2><ul>
<li>LB：负载均衡器所在服务器</li>
<li>RS：提供真实服务的服务器</li>
<li>CIP（client IP）：客户端ip地址</li>
<li>RIP（realserver IP）：真实提供服务的服务器ip地址</li>
<li>DIP（director IP）：负载均衡器（director）上转发数据包到realserver的网卡地址</li>
<li>VIP（virtual IP）：负载均衡器（director）上用于向客户端提供服务的ip地址</li>
</ul>
<h2 id="ipvs的工作模式"><a href="#ipvs的工作模式" class="headerlink" title="ipvs的工作模式"></a>ipvs的工作模式</h2><p>当用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的Real Server节点，而Real Server节点如何返回数据给用户，这正是IPVS实现的重点技术，IPVS实现负载均衡的机制有三种:</p>
<ul>
<li>VS/NAT（virtual server via network address translation）：通过网络地址转换将一组服务器构成一个高性能、高可用的虚拟服务器</li>
<li>VS/TUN（vertual server via tunneling）：在分析VS/NAT的缺点和网络服务的非对称性的基础上提出的通过ip隧道实现虚拟服务器</li>
<li>VS/DR（vertual server via director routing）：通过直接路由实现虚拟服务器</li>
<li>FULLNAT：淘宝开源实现的模式，数据包进入LB时，同时对源地址和目标地址进行转换，从而实现RS可以跨VLAN通信，RS只需要连接内网，这样可以保证安全性。进站和出站的LB不一定是同一台机器。</li>
</ul>
<h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><ul>
<li>原理：通过网络地址转换，调度器LB重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器，真实服务器的响应报文处理之后，返回时必须通过调度器（节点服务器的网关为负载均衡服务器），经过调度器时报文的源地址被重写，再返回给客户端，完成整个负载调度过程。</li>
<li>实现要点<ul>
<li>节点服务器需要将网关配置为LB的ip地址，这样才能保证报文经过LB，报文才能被改写</li>
<li>LB节点配置VIP和内核转发功能</li>
<li>nat模式支持对ip及端口的转换</li>
</ul>
</li>
<li>优缺点：由于请求和响应的报文都经过LB【也就是像7层负载的处理方式一样，但却没有7层负载那么”多功能”】，而响应数据一般比请求数据大得多，LB的负载压力过大，调度器Director容易出现瓶颈</li>
</ul>
<h3 id="TUN模式"><a href="#TUN模式" class="headerlink" title="TUN模式"></a>TUN模式</h3><ul>
<li>原理：调度器把请求的报文通过ip隧道（将请求的报文封装在另一个ip报文中）转发至真实服务器，而真实服务器将处理后的响应报文直接返回给客户端。</li>
<li>实现要点：<ul>
<li>LB和RS节点都需要配置ip隧道功能</li>
<li>LB和RS服务器lo网卡都要绑定VIP【防止真实网卡绑定vip造成ip冲突】，同时在RS上配置不对vip的arp广播请求响应，这样可以保证目标地址为vip的数据包只被director接受。</li>
</ul>
</li>
<li>优缺点：<ul>
<li>调度器就只处理请求的入站报文。由于一般网络服务应答数据比请求报文大很多，采用此模式后，系统吞吐量可以提高10倍。</li>
<li>TUN模式的LAN环境转发不如DR模式效率高，而且还要考虑系统对ip隧道的支持问题</li>
<li>LAN环境一般多采用DR模式，WAN环境可以用TUN模式，但在当前WAN环境下，请求转发更多被haproxy、nginx、dns调度取代，因此应用不多。</li>
</ul>
</li>
</ul>
<h3 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h3><ul>
<li>原理：DR模式通过改写请求报文的目标MAC地址【请求地址仍为VIP】，将请求转发给真实的服务器，而真实服务器将响应后的处理结果直接返回给客户端。</li>
<li>实现要点<ul>
<li>要求调度器LB与真实服务器RS都有一块网卡连接在同一物理网段上。</li>
<li>在LB和RS节点都需要配置VIP，并在RS配置抑制对vip的arp广播响应</li>
<li>调度器不需要开启内核转发功能</li>
<li>RS与director的监听端口必须一致</li>
</ul>
</li>
<li>优缺点：<ul>
<li>这种模式没有IP隧道的开销，对集群中的真实服务器也没有必须支持ip隧道协议的要求</li>
</ul>
</li>
</ul>
<h3 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h3><table>
<thead>
<tr>
<th>项目</th>
<th>vs/nat</th>
<th>vs/tun</th>
<th>vs/dr</th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>any</td>
<td>Tnuneling</td>
<td>Non-arp device</td>
</tr>
<tr>
<td>server network</td>
<td>private</td>
<td>LAN/WAN</td>
<td>LAN</td>
</tr>
<tr>
<td>server number</td>
<td>low</td>
<td>High</td>
<td>High</td>
</tr>
<tr>
<td>server gateway</td>
<td>load balancer</td>
<td>own router</td>
<td>own router</td>
</tr>
</tbody>
</table>
<ul>
<li>在性能上，VS/DR和VS/TUN远高于VS/NAT，因为调度器只处于从客户到服务器的半连接中，按照半连接的TCP有限状态机进行状态迁移，极大程度上减轻了调度器的压力(真正建立TCP连接的是RS和Client)。VS/DR性能又稍高于VS/TUN，因为少了隧道的开销</li>
<li>VS/DR和VS/TUN的主要区别是VS/TUN可以跨网络实现后端服务器负载均衡(也可以局域网内)，而VS/DR只能和director在局域网内进行负载均衡。</li>
</ul>
<h2 id="ipvs调度算法"><a href="#ipvs调度算法" class="headerlink" title="ipvs调度算法"></a>ipvs调度算法</h2><p>IPVS在内核中的负载均衡调度是以连接为粒度的。在HTTP协议（非持久）中，每个对象从WEB服务器上获取都需要建立一个TCP连接，同一用户 的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不平衡。在内核中的连接调度算法上，IPVS已实现了八种调度算法，其中，又根据运行方式不同，分为两大类：静态调度和动态反馈调度</p>
<h3 id="静态调度"><a href="#静态调度" class="headerlink" title="静态调度"></a>静态调度</h3><blockquote>
<p>不管RS的繁忙程度，根据调度算法计算后轮到谁就调度谁。</p>
</blockquote>
<ul>
<li>轮叫调度（Round-Robin Scheduling，rr）</li>
<li>加权轮叫调度（Weighted Round-Robin Scheduling，wrr），按照权重比例作为轮询标准</li>
<li>目标地址散列调度（Destination Hashing Scheduling，dh），目标地址哈希，对于同一目标IP的请求总是发往同一服务器；</li>
<li>源地址散列调度（Source Hashing Scheduling，sh），源地址哈希，在一定时间内，只要是来自同一个客户端的请求，就发送至同一个realserver。源地址散列调度和目标地址散列调度可以结合使用在防火墙集群中，它们可以保证整个系统的唯一出入口。</li>
</ul>
<h3 id="动态反馈调度"><a href="#动态反馈调度" class="headerlink" title="动态反馈调度"></a>动态反馈调度</h3><blockquote>
<p>根据RS的繁忙程度反馈，计算出下一个连接应该调度谁(动态反馈负载均衡算法考虑服务器的实时负载和响应情况，不断调整服务器间处理请求的比例，来避免有些服务器超载时依然收到大量请求，从而提高整个系统的吞吐率)。</p>
</blockquote>
<ul>
<li>最小连接调度（Least-Connection Scheduling，lc），调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某服务器，其连接数加1；当连接中止或超时，其连接数减1。当各个服务器的处理能力不同时，该算法不理想。</li>
<li>加权最小连接调度（Weighted Least-Connection Scheduling，wlc）：ipvs默认调度算法</li>
<li>基于本地的最少连接（Locality-Based Least Connections Scheduling，lblc）</li>
<li>带复制的基于局部性最少连接（Locality-Based Least Connections with Replication Scheduling，lblcr）：目前主要用于Cache集群系统；因为在Cache集群中客户请求报文的目标IP地址是变化的。</li>
</ul>
<h3 id="综合负载"><a href="#综合负载" class="headerlink" title="综合负载"></a>综合负载</h3><p>计算算综合负载时，我们主要使用两大类负载信息：输入指标和服务器指标<br>输入指标：主要是在单位时间内服务器收到新连接数与平均连接数的比例，它是在调度器上收集到的。<br>服务器指标：  </p>
<ul>
<li>主要记录服务器各种负载信息，如服务器当前CPU负载LOADi、服务器当前磁盘使用情况Di、当前内存利用情况Mi和当前进程数目 Pi。【有两种方法可以获得这些信息；一是在所有的服务器上运行着SNMP（Simple Network Management Protocol）服务进程，而在调度器上的Monitor Daemon通过SNMP向各个服务器查询获得这些信息；二是在服务器上实现和运行收集信息的Agent，由Agent定时地向Monitor Daemon报告负载信息。】</li>
<li>一个重要的服务器指标是服务器所提供服务的响应时间，它能比较好地反映服务器上请求等待队列的长度和请求的处理时间。调度器上的Monitor Daemon作为客户访问服务器所提供的服务，测得其响应时间。</li>
</ul>
<h3 id="权重计算"><a href="#权重计算" class="headerlink" title="权重计算"></a>权重计算</h3><ul>
<li>在实际使用中，若发现所有服务器的权值都小于他们的DEFAULT_WEIGHT，则说明整个服务器集群处于超载状态，这时需要加入新的服务器结点 到集群中来处理部分负载；</li>
<li>反之，若所有服务器的权值都接近于SCALE*DEFAULT_WEIGHT，则说明当前系统的负载都比较轻。</li>
</ul>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><blockquote>
<p>由于官方文档及网络均无ubuntu下源码安装参考，所以此处源码安装特指centos下的源码安装</p>
</blockquote>
<ul>
<li><a href="http://www.linuxvirtualserver.org/software/ipvs.html" target="_blank" rel="noopener">lvs官方下载地址</a></li>
<li><a href="https://mirrors.edge.kernel.org/pub/linux/utils/kernel/ipvsadm/" target="_blank" rel="noopener">最新版本ipvsadm</a></li>
</ul>
<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><ul>
<li>依赖安装：<code>yum install gcc* make kernel-devel libnl* popt* -y</code><ul>
<li><a href="http://kb.linuxvirtualserver.org/wiki/Compiling_ipvsadm_on_different_Linux_distributions#Red_Hat_Enterprise_Linux_6" target="_blank" rel="noopener">编译安装参考</a></li>
</ul>
</li>
<li>设置内核软链接：ln -s /usr/src/kernels/$(uname -r) /usr/src/linux</li>
</ul>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul>
<li>tar xzf ipvsadm.tar.gz</li>
<li>make </li>
<li>make install</li>
</ul>
<h2 id="安装结果测试"><a href="#安装结果测试" class="headerlink" title="安装结果测试"></a>安装结果测试</h2><ul>
<li>命令是否存在：ipvsadm</li>
<li>模块是否存在：lsmod |grep ip_vs</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>准备1台LB和2台RS服务器；节点关闭防火墙和selinux</p>
<h2 id="LB节点设置"><a href="#LB节点设置" class="headerlink" title="LB节点设置"></a>LB节点设置</h2><ul>
<li>LB主机添加vip地址：ifconfig eth0:0 192.168.100.10/24 up</li>
<li>设置tcp超时参数：ipvsadm –set 30 5 60</li>
<li>LB添加vip及设置调度算法：ipvsadm -A -t 192.168.100.10:80 -s rr</li>
<li>LB添加RS节点：<ul>
<li>ipvsadm -a -t 192.168.100.10:80 -r 192.168.100.1:80 -g</li>
<li>ipvsadm -a -t 192.168.100.10:80 -r 192.168.100.2:80 -g</li>
</ul>
</li>
</ul>
<h2 id="RS节点设置"><a href="#RS节点设置" class="headerlink" title="RS节点设置"></a>RS节点设置</h2><ul>
<li>lo网卡配置vip：ifconfig lo:1 192.168.100.10/32 up</li>
<li>添加路由【多网卡环境】：route add -host 192.168.100.10 eth0</li>
<li>设置节点抑制arp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore </span><br><span class="line">echo 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignore </span><br><span class="line">echo 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br></pre></td></tr></table></figure>
<h2 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h2><p>watch –interval=2 ipvsadm -Ln【watch持续监控LB状态】</p>
<h2 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h2><ul>
<li>ipvsadm -L                查看LB-director信息</li>
<li>ipvsadm -C                  清空配置信息</li>
<li>ipvsadm -d                   删除配置条目</li>
</ul>
<h2 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h2><ul>
<li><a href="https://github.com/simple0426/sysadm/blob/master/shell/lvs/dr-lb.sh" target="_blank" rel="noopener">DR模式-LB节点控制脚本</a></li>
<li><a href="https://github.com/simple0426/sysadm/blob/master/shell/lvs/dr-rs.sh" target="_blank" rel="noopener">DR模式-RS节点控制脚本</a></li>
<li><a href="https://github.com/simple0426/sysadm/blob/master/shell/lvs/tun-rs.sh" target="_blank" rel="noopener">TUN模式-RS节点控制脚本</a></li>
<li><a href="https://github.com/simple0426/sysadm/blob/master/shell/lvs/MasterLb-chk-rs.sh" target="_blank" rel="noopener">主LB对RS节点执行健康检查</a></li>
<li><a href="https://github.com/simple0426/sysadm/blob/master/shell/lvs/SlaveLb-chk-MasterLb.sh" target="_blank" rel="noopener">在备LB上实现对主LB的健康检查和接管</a>【类似keepalived】</li>
</ul>
<h1 id="故障与排查"><a href="#故障与排查" class="headerlink" title="故障与排查"></a>故障与排查</h1><ul>
<li>负载不均<ul>
<li>访问量较少，不均衡现象更加明显</li>
<li>会话保持【lvs或后端服务】</li>
<li>调度算法及用户请求的类型【时间长短、资源大小】</li>
</ul>
</li>
<li>故障<ul>
<li>调度器上lvs调度规则及ip地址的正确性</li>
<li>要在RS进行服务检查</li>
<li>RS节点绑定vip和抑制arp检查【对绑定的vip做实时监控并报警】</li>
</ul>
</li>
<li>辅助排查工具tcpdump、ping</li>
</ul>
<hr>
<p>本文参考：<a href="https://www.cnblogs.com/wyzhou/p/9741790.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyzhou/p/9741790.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>lvs</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins自动化-gitlab</title>
    <url>/blog/2020/02/11/CICD/jenkins/jenkins%E8%87%AA%E5%8A%A8%E5%8C%96-gitlab/</url>
    <content><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><ul>
<li>类型：pipeline</li>
<li>名称：spring-hello-demo</li>
</ul>
<h1 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h1><ul>
<li>以webhook方式</li>
<li>设置token信息，如：123456</li>
<li>webhook触发的URL(gitlab中设置)：JENKINS_URL/job/spring-hello-demo/build?token=TOKEN_NAME<ul>
<li>如：<a href="http://192.168.2.162:7005/job/spring-hello/build?token=123456" target="_blank" rel="noopener">http://192.168.2.162:7005/job/spring-hello/build?token=123456</a></li>
</ul>
</li>
</ul>
<h1 id="pipeline设置"><a href="#pipeline设置" class="headerlink" title="pipeline设置"></a>pipeline设置</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/pipeline-scm.jpg" alt></p>
<ul>
<li>方式：pipeline script from SCM</li>
<li>SCM：git</li>
<li>Repository URL：包含项目源码、Jenkinsfile的源码库地址，<a href="https://github.com/simple0426/spring-hello-demo.git" target="_blank" rel="noopener">示例代码</a></li>
<li>Credentials：jenkins连接gitlab的认证信息，可使用【用户名+密码】形式</li>
<li>Branches to build：构建的分支</li>
<li>脚本路径：Jenkinsfile文件位置</li>
</ul>
<h1 id="jenkins设置"><a href="#jenkins设置" class="headerlink" title="jenkins设置"></a>jenkins设置</h1><ul>
<li>在用户(如root)中创建API Token，此token用于：gitlab连接jenkins</li>
<li>全局安全设置：<ul>
<li>访问控制-》授权策略-》【启用】匿名用户具有读权限</li>
<li>跨站请求伪造保护：【禁用】防止跨站点请求伪造</li>
</ul>
</li>
</ul>
<h1 id="gitlab设置"><a href="#gitlab设置" class="headerlink" title="gitlab设置"></a>gitlab设置</h1><ul>
<li>设置：settings-》integrations<ul>
<li>URL：jenkins中的hook地址，如：<a href="http://192.168.2.162:7005/job/spring-hello-demo/build?token=123456" target="_blank" rel="noopener">http://192.168.2.162:7005/job/spring-hello-demo/build?token=123456</a></li>
<li>Secret Token：jenkins中创建的API Token</li>
<li>【启用】Push events</li>
<li>【禁用】Enable SSL verification</li>
<li>点击【add webhook】按钮</li>
</ul>
</li>
<li>测试：Project Hooks-》test-》push events</li>
<li>错误处理<ul>
<li>错误：Url is blocked: Requests to the local network are not allowed</li>
<li>解决【admin area】<ul>
<li>位置：settings-》network-》Outbound requests</li>
<li>设置：【启用】Allow requests to the local network from web hooks and services</li>
<li>设置：允许哪些局域网的webhook请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&apos;build&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                    echo &quot;WORKSPACE: $&#123;env.WORKSPACE&#125;&quot; //工作目录</span><br><span class="line">                    echo &quot;NODE_NAME: $&#123;env.NODE_NAME&#125;&quot; //节点名称</span><br><span class="line">                    if (&quot;$&#123;env.NODE_NAME&#125;&quot; == &quot;master&quot;)&#123; //如果是在master上，则执行脚本</span><br><span class="line">                       sh &quot;sh build-prod.sh&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="build-prod-sh"><a href="#build-prod-sh" class="headerlink" title="build-prod.sh"></a>build-prod.sh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># 服务端口</span><br><span class="line">targetPort=8080</span><br><span class="line"># 镜像版本号</span><br><span class="line">vendor=1.0.0</span><br><span class="line"># 项目名称</span><br><span class="line">projectName=spring-hello-demo</span><br><span class="line"></span><br><span class="line"># 软件打包</span><br><span class="line">cd $WORKSPACE</span><br><span class="line">mvn clean package -D skipTests</span><br><span class="line"></span><br><span class="line"># 删除基于镜像的所有容器</span><br><span class="line">if [ $(docker ps -aqf &quot;name=$projectName&quot;) ];then </span><br><span class="line">    docker rm -f $projectName</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 删除旧镜像</span><br><span class="line">if [ $(docker images -qf &quot;reference=$projectName:$vendor&quot;) ];then </span><br><span class="line">    docker rmi -f $projectName:$vendor</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line"># 创建镜像</span><br><span class="line">docker build -t $projectName:$vendor .</span><br><span class="line"> </span><br><span class="line"># 基于镜像启动容器</span><br><span class="line">docker run --name $projectName -d -p $targetPort:$targetPort $projectName:$vendor</span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">COPY target/*.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡器-haproxy</title>
    <url>/blog/2019/09/10/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%90%86%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8-haproxy/</url>
    <content><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul>
<li>yum或apt方式安装</li>
<li>源码安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h2><p>haproxy.cfg详细配置，请<a href="https://github.com/simple0426/sysadm/blob/master/config/web/haproxy.cfg" target="_blank" rel="noopener">查看</a> ！！！</p>
<ul>
<li>global：全局设置，通常和操作系统相关，如进程</li>
<li>defaults：默认配置，可以被frontend、backend、listen部分继承</li>
<li>fontend：用来接收客户端请求，根据域名、uri等定义不同的匹配规则，并将请求转发给不同的backend</li>
<li>backend：定义后端服务器集群，并设置后端服务器的权重、连接超时、调度、健康检查等</li>
<li>listen：可以理解为backend和fontend的组合体</li>
</ul>
<h2 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h2><blockquote>
<p>haproxy使用系统syslog的方式写日志【udp协议，514端口】</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line">local0.*                                           /usr/local/haproxy/logs/haproxy.log</span><br></pre></td></tr></table></figure>
<h1 id="服务控制"><a href="#服务控制" class="headerlink" title="服务控制"></a>服务控制</h1><h2 id="服务控制-1"><a href="#服务控制-1" class="headerlink" title="服务控制"></a>服务控制</h2><ul>
<li>重载配置：service haproxy reload</li>
<li>启动、停止、重启：start/stop/restart</li>
</ul>
<h2 id="haproxy命令选项"><a href="#haproxy命令选项" class="headerlink" title="haproxy命令选项"></a>haproxy命令选项</h2><ul>
<li>-f：指定配置文件</li>
<li>-c：检测配置文件语法</li>
<li>-D：守护进程模式</li>
<li>-p pid：指定启动后的pid文件</li>
<li><code>-sf/-st [pid ]*</code>：终止旧的pid【hard、soft】</li>
</ul>
<h2 id="socket命令"><a href="#socket命令" class="headerlink" title="socket命令"></a>socket命令</h2><ul>
<li>前置要求：在配置文件haproxy.cfg的global区段配置【stats socket /var/run/haproxy.sock mode 600 level admin】</li>
<li>作用：连接socket后，管理负载均衡器代理的前后端服务器【fontend、backend】</li>
<li>工具：socat是类似于netcat的工具，名字来由是Socket CAT，可以看作是netcat的N倍加强版，主要特点就是在两个数据流之间建立通道</li>
<li>socat用法：<ul>
<li>help信息：echo “”|sudo socat stdio /var/run/haproxy.sock</li>
<li>状态查看：echo “show stat”|sudo socat stdio /var/run/haproxy.sock</li>
<li>启停server：echo “enable server service_marketinfo/172.17.134.60”|sudo socat stdio /var/run/haproxy.sock</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用服务-keepalived</title>
    <url>/blog/2019/09/16/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%90%86%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1-keepalived/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>keepalived起初是专门为lvs设计的，专门用来监控lvs集群系统中各个服务节点的状态，后来又加入了VRRP（Virtual Router Redundancy Protocol）虚拟路由冗余协议。VRRP的出现是为解决静态路由出现的单点故障问题，他能保证网络的不间断、稳定的运行。所以keepalived有两个功能：</p>
<ul>
<li>对lvs集群节点的健康检查【healthcheck】</li>
<li>对lvs集群LB节点的故障转移【failover】</li>
</ul>
<h2 id="VRRP"><a href="#VRRP" class="headerlink" title="VRRP"></a>VRRP</h2><blockquote>
<p>keepalived directors 之间故障转移时通过VRRP协议实现的。  </p>
</blockquote>
<ul>
<li>原理：在keepalived directors正常工作时，主director会不断的向备节点广播心跳消息，用以告诉备节点自己还活着；当主节点发生故障时，备节点就无法继续检测到主节点的心跳，进而调用自身的接管程序，接管主节点的ip资源和服务。而当主节点恢复故障时，备节点会释放自身接管的ip资源和服务，恢复到原来的备用角色</li>
<li>vrrp协议要点<ul>
<li>通过竞选机制从backup中选出优先级最高的为master</li>
<li>只有master有发送vrrp广播的权利</li>
<li>vrrp广播可以告诉节点更新arp表信息</li>
</ul>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><a href="https://www.keepalived.org/download.html" target="_blank" rel="noopener">下载</a></li>
<li>依赖安装：yum install openssl openssl-devel -y</li>
<li>安装<ul>
<li>tar xzvf keepalived-1.1.17.tar.gz</li>
<li>./configure –sysconf=/etc</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li>规范化：ln -s /usr/local/sbin/keepalived /usr/sbin</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h2><blockquote>
<p>即：keepalived.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;  # 全局定义部分</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id lvs_master #运行keepalived服务的服务器标识，主要用于发送邮件时显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123; # vrrp实例定义部分</span><br><span class="line">    state MASTER # 定义keepalived的角色：MASTER表示主服务器，BACKUP表示备用服务器</span><br><span class="line">    interface eth0 # 定义HA集群检测的服务接口</span><br><span class="line">    lvs_sync_daemon_interface eth1 # 定义HA集群检测的心跳接口【默认使用服务接口】</span><br><span class="line">    virtual_router_id 60 # 虚拟路由器标识，一个vrrp实例下的主备必须相同，不同vrrp实例的标识不同</span><br><span class="line">    priority 100 # 一个实例中主服务器优先级高于备用服务器</span><br><span class="line">    advert_int 1 # 心跳间隔</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS # 主备之间的认证类型</span><br><span class="line">        auth_pass 1234 # 主备之间的认证密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.100.120 #vip地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.100.120 80 &#123; # 虚拟服务器部分，虚拟服务器的ip和端口</span><br><span class="line">    delay_loop 6 # director的健康检查间隔</span><br><span class="line">    lb_algo wrr # 负载调度算法</span><br><span class="line">    lb_kind DR # 实现负载均衡的方式</span><br><span class="line">    persistence_timeout 50 # 会话保持时间</span><br><span class="line">    protocol TCP # director向RS转发的协议类型</span><br><span class="line">    real_server 192.168.100.111 80 &#123; # 真实服务器的ip和端口</span><br><span class="line">    weight 1 # 服务器在被调度时的权重</span><br><span class="line">    TCP_CHECK &#123; # director对real-server的检测类型</span><br><span class="line">         connect_timeout 3 # 连接超时时间</span><br><span class="line">         nb_get_retry 3  # 重试次数</span><br><span class="line">         delay_before_retry 3  # 重试间隔</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.100.112 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    TCP_CHECK &#123; </span><br><span class="line">         connect_timeout 3</span><br><span class="line">         nb_get_retry 3  </span><br><span class="line">         delay_before_retry 3  </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务启动参数"><a href="#服务启动参数" class="headerlink" title="服务启动参数"></a>服务启动参数</h2><blockquote>
<p>/etc/sysconfig/keepalived【centos】或/etc/default/keepalived【ubuntu】</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Options for keepalived. See `keepalived --help&apos; output and keepalived(8) and</span><br><span class="line"># keepalived.conf(5) man pages for a list of all options. Here are the most</span><br><span class="line"># common ones :</span><br><span class="line">#</span><br><span class="line"># --vrrp               -P    Only run with VRRP subsystem.</span><br><span class="line"># --check              -C    Only run with Health-checker subsystem.</span><br><span class="line"># --dont-release-vrrp  -V    Dont remove VRRP VIPs &amp; VROUTEs on daemon stop.</span><br><span class="line"># --dont-release-ipvs  -I    Dont remove IPVS topology on daemon stop.</span><br><span class="line"># --dump-conf          -d    Dump the configuration data.</span><br><span class="line"># --log-detail         -D    Detailed log messages.</span><br><span class="line"># --log-facility       -S    0-7 Set local syslog facility (default=LOG_DAEMON)</span><br><span class="line"></span><br><span class="line">KEEPALIVED_OPTIONS=&quot;-D -d -S 0&quot;</span><br></pre></td></tr></table></figure>
<h2 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h2><blockquote>
<p>设置系统syslog</p>
</blockquote>
<ul>
<li>配置设置：echo “local0.*   /var/log/keepalived.log” &gt;&gt; /etc/rsyslog.conf</li>
<li>重启syslog服务：/etc/init.d/rsyslog restart</li>
</ul>
<h1 id="服务控制"><a href="#服务控制" class="headerlink" title="服务控制"></a>服务控制</h1><ul>
<li>启动服务：/etc/init.d/keepalived start</li>
<li>开机自启：chkconfig keepalived on</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>angular运行环境</title>
    <url>/blog/2019/05/15/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/web%E6%9C%8D%E5%8A%A1/angular%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="使用淘宝npm库"><a href="#使用淘宝npm库" class="headerlink" title="使用淘宝npm库"></a>使用淘宝npm库</h1><p>npm install -registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<h1 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h1><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<p>node为免安装，解压后bin目录有node和npm，只需将bin目录添加到系统PATH下即可</p>
<h1 id="安装Angularjs"><a href="#安装Angularjs" class="headerlink" title="安装Angularjs"></a>安装Angularjs</h1><p>angular是用typescript编写的，所以先安装typescript，再安装angularjs-cli</p>
<ul>
<li>npm install -g typescript typings</li>
<li>npm install -g @angular/cli</li>
</ul>
<h1 id="build项目"><a href="#build项目" class="headerlink" title="build项目"></a>build项目</h1><ul>
<li>首先进入项目目录：npm install</li>
<li>ng build –prod –output-hashing=none</li>
</ul>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><ul>
<li>npm install报错：Error: EACCES: permission denied, mkdir ‘/root/web/CRM-Website-ABKE/node_modules/wd/build’<ul>
<li>原因：如果npm是在root账户下执行的话，它会将uid改成当前账户，或者uid的值从user配置文件中获取，而默认情况下uid的值为nobody。所以在root账户下运行npm install时需要将unsafe-perm选项加上。</li>
<li>解决npm install -registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> –unsafe-perm=true</li>
</ul>
</li>
<li>ng build报错:  JavaScript heap out of memory<ul>
<li>原因：项目build时需要的内存不足</li>
<li>解决：export NODE_OPTIONS=–max_old_space_size=4096</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>apache下rewrite使用</title>
    <url>/blog/2019/05/07/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/web%E6%9C%8D%E5%8A%A1/apache%E4%B8%8Brewrite%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>rewrite url实现URL的跳转和隐藏真实地址，基于perl语言的正则表达式规范</li>
<li>主要用途：拟静态、拟目录、域名跳转、防盗链</li>
<li>开启功能<ul>
<li>去除httpd.conf文件中”#LoadModule rewrite_module modules/mod_rewrite.so”前面的”#”号; </li>
<li>RewriteEngine on </li>
</ul>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>基于整个apache的配置，即httpd.conf</li>
<li>基于虚拟主机的配置，即virtual host指令</li>
<li>基于目录的配置，即directory指令和 目录下的.htaccess文件</li>
</ul>
<h2 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title="htaccess文件"></a>htaccess文件</h2><ul>
<li>.htaccess只有在用户访问目录时加载</li>
<li>子目录和父目录的htaccess文件处于同等地位，默认不会继承父作用域规则</li>
<li>默认情况下，mod_rewrite在合并属于同一上下文内容时会覆盖规则。</li>
<li>htaccess开启rewrite功能<ul>
<li>RewriteEngine On</li>
<li>Options FollowSymLinks</li>
<li>RewriteBase / 【从根开始改写url】</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>设定符合条件的url：RewriteCond TestString CondPattern  </li>
<li>该写符合条件的url：RewriteRule Pattern Substitution [flags]  </li>
</ul>
<h1 id="RewriteCond"><a href="#RewriteCond" class="headerlink" title="RewriteCond"></a>RewriteCond</h1><h2 id="TestString"><a href="#TestString" class="headerlink" title="TestString"></a>TestString</h2><p>&lt;要匹配的<a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond" target="_blank" rel="noopener">服务器变量</a>&gt; + &lt;正则匹配条件&gt;</p>
<h2 id="CondPattern"><a href="#CondPattern" class="headerlink" title="CondPattern"></a>CondPattern</h2><blockquote>
<p>额外的标志位</p>
</blockquote>
<ol>
<li>‘nocase|NC’ (no case) 忽略大小写</li>
<li>‘ornext|OR’ (or next condition) 更改多个RewriteCond为逻辑“或”(默认为“与”)</li>
<li>‘novary|NV’ (no vary)</li>
</ol>
<h1 id="RewriteRule"><a href="#RewriteRule" class="headerlink" title="RewriteRule"></a>RewriteRule</h1><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><blockquote>
<p>request_uri(不包含hostname、port、query_string的部分)</p>
</blockquote>
<ol>
<li>pattern在( VirtualHost)中指代request_uri</li>
<li>pattern在(Directory and .htaccess)中则指request_uri排除当前目录后的部分</li>
</ol>
<h2 id="Substitution"><a href="#Substitution" class="headerlink" title="Substitution"></a>Substitution</h2><ol>
<li>file-system-path：在virtualhost中配置的规则被当做文件系统路径</li>
<li>URL-path：request_uri</li>
<li>absolute URL：使用R标志重定向到一个新的url</li>
<li>-(dash)：保持url不变</li>
</ol>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><ol>
<li>NC：忽略大小写</li>
<li>R[=code]：url重定向</li>
<li>C：如果本条rule匹配则传递给下一条规则，如果本条不匹配则以后的rule都跳过</li>
<li>L：本条rule为最后一条规则，之后的rule都不再应用</li>
<li>QSA：在原始URL后追加查询字符串</li>
<li>F：返回403给客户端</li>
</ol>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><h2 id="虚拟主机建立多个网站"><a href="#虚拟主机建立多个网站" class="headerlink" title="虚拟主机建立多个网站"></a>虚拟主机建立多个网站</h2><ul>
<li>只添加根目录htaccess文件，既能子域名访问网站，也可以通过首域名+同名目录访问网站</li>
<li>每添加一个域名及相应的同名目录，都需要在根目录和同名目录添加相关配置</li>
<li>阿里云虚拟主机页面上的301配置只能实现首页【域名级别】的301跳转，要实现域名间的全站跳转必须使用下方的配置</li>
</ul>
<h2 id="根目录htaccess"><a href="#根目录htaccess" class="headerlink" title="根目录htaccess"></a>根目录htaccess</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line"># auroraabrasive.com全站301跳转www.auroraabrasive.com</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; ^auroraabrasive.com$ [NC] </span><br><span class="line">RewriteRule ^(.*)$ http://www.auroraabrasive.com/$1 [R=301,L]</span><br><span class="line"># 首域名+目录访问 或 子域名访问网站</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; ^www\.auroraabrasive\.com$ [NC]  </span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; !^/auroraabrasive/            </span><br><span class="line">RewriteRule ^(.*)$ auroraabrasive/$1?Rewrite [L,QSA]</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># 部分注解</span><br><span class="line">1. 如果请求的header信息中host为www.auroraabrasive.com</span><br><span class="line">2. 如果请求的request_uri中不是以auroraabrasive开头的(斜杠为分界符)</span><br><span class="line">3. 重写url-path为 auroraabrasive/%&#123;URI&#125;?Rewrite</span><br></pre></td></tr></table></figure>
<h2 id="子目录htaccess"><a href="#子目录htaccess" class="headerlink" title="子目录htaccess"></a>子目录htaccess</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line"># 只允许指定的域名访问</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; !^www\.auroraabrasive\.com$ [NC] </span><br><span class="line">RewriteRule (.*) http://www.auroraabrasive.com/$1 [L,R=301]</span><br><span class="line"># 同名目录访问</span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; ^\/auroraabrasive\/ [NC]</span><br><span class="line">RewriteCond %&#123;QUERY_STRING&#125; !^(.*)?Rewrite </span><br><span class="line">RewriteRule ^(.*)$ /%&#123;REQUEST_URI&#125;/%&#123;REQUEST_URI&#125;/$1?Rewrite [L,QSA]  </span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># 部分注解</span><br><span class="line">1. 如果请求的header信息中host不是www.auroraabrasive.com</span><br><span class="line">2. 重定向url为http://www.auroraabrasive.com/%&#123;URI&#125;，并且不再匹配其他规则</span><br><span class="line">3. 如果请求的%&#123;REQUEST_URI&#125;是以auroraabrasive开头的</span><br><span class="line">4. 如果请求的query_string不是以任意字符串开头后紧跟Rewrite</span><br><span class="line">5. 改写url-path为/%&#123;REQUEST_URI&#125;/%&#123;REQUEST_URI&#125;/%&#123;URI&#125;?Rewrite</span><br><span class="line">(由于rewritecond中使用了REQUEST_URI变量，此时url-path为全路径匹配，包含了本级目录auroraabrasive)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb入门与管理</title>
    <url>/blog/2019/11/21/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E5%85%A5%E9%97%A8%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul>
<li>3.2之后增加存储引擎WiredTiger</li>
<li>4.2之后移除对MMAPv1引擎的支持</li>
<li>若要将数据从MMAPv1迁移到WiredTiger，参考官方文档</li>
<li>数据目录下包含的文件必须和存储引擎匹配，否则无法启动</li>
<li>WiredTiger存储引擎默认支持document级别锁（类似关系型数据库的行级锁）</li>
</ul>
<h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><p>由于mongodb的不同版本的区别较大，需要确认不同操作系统版本支持的软件版本</p>
<h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h2><ul>
<li>Journal：使用Journal，即预写式日志保证数据可靠性</li>
<li>副本集：在4.0之后的版本，使用WiredTiger引擎、开启主从复制时不能关闭日志功能（storage.journal.enabled: false）</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><ul>
<li>时钟同步<ul>
<li>目的：为了保证mongodb组件或集群成员之间保证正常工作，应该开启ntp服务以同步主机时间</li>
<li>错误示例：【waited 189s for distributed lock configUpgrade for upgrading config database to new format v5】</li>
</ul>
</li>
<li>设置文件描述符：ulimit</li>
<li>禁用Transparent Huge Pages</li>
<li>禁用NUMA选项</li>
<li>关闭selinux</li>
</ul>
<h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>主要是安装mongodb-org，它包含如下的组件：</p>
<ul>
<li>mongodb-org-server：mongodb的服务端主进程<strong>mongod</strong></li>
<li>mongodb-org-mongos：mongodb的分片功能主进程<strong>mongos</strong></li>
<li>mongodb-org-shell：mongodb的客户端程序<strong>mongo</strong></li>
<li>mongodb-org-tools：mongodb的工具软件，比如mongodump,mongorestore, mongostat等</li>
</ul>
<h2 id="centos安装"><a href="#centos安装" class="headerlink" title="centos安装"></a>centos安装</h2><ul>
<li><p>设置yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.2]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum源更新：yum makecache</p>
</li>
<li>软件安装：sudo yum install -y mongodb-org</li>
</ul>
<h2 id="ubuntu安装"><a href="#ubuntu安装" class="headerlink" title="ubuntu安装"></a>ubuntu安装</h2><ul>
<li><p>设置软件源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br><span class="line">echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>软件安装：sudo apt-get install -y mongodb-org</p>
</li>
<li>避免自动升级<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="tar包安装"><a href="#tar包安装" class="headerlink" title="tar包安装"></a>tar包安装</h2><ul>
<li>依赖安装：sudo yum install libcurl openssl</li>
<li><a href="https://www.mongodb.com/download-center/community?jmp=docs" target="_blank" rel="noopener">软件下载及解压</a></li>
<li>编译安装（根据内置的参考文档）</li>
<li>将二进制文件路径添加到PATH</li>
<li>建立用户、日志目录、数据目录(对目录授权：mongod程序必须 有dbPath目录的读写权限)</li>
<li>编辑配置文件mongod.conf</li>
<li>启动服务：/usr/bin/mongod –config /etc/mongod.conf</li>
</ul>
<h1 id="服务控制"><a href="#服务控制" class="headerlink" title="服务控制"></a>服务控制</h1><ul>
<li>目录设置(mongod.conf)：<ul>
<li>数据目录：storage.dbPath</li>
<li>日志目录：systemLog.path</li>
</ul>
</li>
<li>启停：service mongod start/stop/restart</li>
<li>客户端连接：mongo</li>
</ul>
<h1 id="结构操作"><a href="#结构操作" class="headerlink" title="结构操作"></a>结构操作</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><ul>
<li>db：显示当前数据库</li>
<li>show dbs：查看所有数据库</li>
<li>use db：切换数据库（不存在则创建）</li>
<li>db.dropDatabase()：删除当前库</li>
</ul>
<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><ul>
<li>查看库的所有集合： show collections</li>
<li>创建集合：<ul>
<li>单独创建一个资源受限的空集合，超过限制则删除最早的数据</li>
<li>语法范例：db.createCollection(“profile”,{size: 1024, capped: true, max: 5})<ul>
<li>size：使用空间大小限制</li>
<li>capped：是否开显示</li>
<li>max：最多保存多少条数据</li>
</ul>
</li>
</ul>
</li>
<li>删除集合：db.collection.drop()</li>
<li>重命名集合：db.collection.renameCollection(“new_name”)</li>
</ul>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><blockquote>
<p>集合不存在则自动创建</p>
</blockquote>
<ul>
<li><p>插入数据：db.collection.insert()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insert(&#123;&quot;item&quot;: &quot;test&quot;, &quot;qty&quot;: 11, &quot;status&quot;: &quot;B&quot;, &quot;size&quot;: &#123;&quot;h&quot;: 12, &quot;w&quot;: 2, &quot;uom&quot;: &quot;cm&quot;&#125;, &quot;tags&quot;: [&quot;orange&quot;]&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量插入数据：db.collection.insertMany()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: &quot;journal&quot;, qty: 25, status: &quot;A&quot;, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">   &#123; item: &quot;notebook&quot;, qty: 50, status: &quot;A&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot; ] &#125;,</span><br><span class="line">   &#123; item: &quot;paper&quot;, qty: 10, status: &quot;D&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot;, &quot;plain&quot; ] &#125;,</span><br><span class="line">   &#123; item: &quot;planner&quot;, qty: 0, status: &quot;D&quot;, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">   &#123; item: &quot;postcard&quot;, qty: 45, status: &quot;A&quot;, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, tags: [ &quot;blue&quot; ] &#125;</span><br><span class="line">]);</span><br><span class="line">// MongoDB adds an _id field with an ObjectId value if the field is not present in the document</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>语法：db.collection.remove()</li>
<li>db.inventory.remove({“item”: “test”})</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>语法：db.collection.update( [查询条件]，[更新内容]，[不存在时是否添加(默认false)]，[是否更新多行(默认false,只更新第一行)])</li>
<li>范例：<ul>
<li>内容变更：$set：db.inventory.update({“status”: “A”}, {$set: {“qty”: 35}},false,true)</li>
<li>数值增减：$inc：db.inventory.update({“status”: “A”}, {$inc: {“qty”: -34}})</li>
</ul>
</li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul>
<li>查询所有内容： db.collection.find() <ul>
<li>格式化输出(pretty)：db.inventory.find({}).pretty()</li>
</ul>
</li>
<li>精确查询：db.inventory.find( { “size.uom”: “in” } )</li>
<li>指定返回字段(默认返回id)<ul>
<li>语法：db.collection.find([查询字段]， [返回字段(1：包含，0：排除)])</li>
<li>范例：db.inventory.find({},{_id:0, item:1, status:1})【不返回id，返回status】</li>
</ul>
</li>
</ul>
<h1 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a><a href="https://www.cnblogs.com/dbabd/p/10811523.html" target="_blank" rel="noopener">用户和权限</a></h1><ul>
<li>mongodb默认没有启用用户访问控制，可以无限制的访问数据库</li>
<li>权限由指定的数据库资源(resource)和指定资源上的操作(action)组成<ul>
<li>资源：数据库、集合、集群</li>
<li>操作：增、删、改、查（CRUD）</li>
</ul>
</li>
<li>mongodb通过角色对用户授予相应数据库资源的操作权限，每个角色中的权限可以显式指定，也可以继承其他角色的权限，也可以两者兼有<pre><code>+ 在同一个数据库中，新建的用户可以继承其他用户的角色
+ 在admin库中，创建的角色可以继承其他任意数据库中角色的权限
</code></pre></li>
<li>mongodb中的角色分类<ul>
<li>系统内置角色</li>
<li>用户自定义角色</li>
</ul>
</li>
</ul>
<h2 id="系统内置角色"><a href="#系统内置角色" class="headerlink" title="系统内置角色"></a>系统内置角色</h2><ul>
<li>数据库用户角色<ul>
<li>read：读取非系统集合数据</li>
<li>readWrite：读写非系统集合数据</li>
</ul>
</li>
<li>数据库管理角色<ul>
<li>dbAdmin：执行某些管理任务(与schema相关、索引、收集统计信息)的权限，但不包含用户管理</li>
<li>userAdmin：创建、修改角色、用户的权限</li>
<li>dbOwner：对数据库的所有的权限：readWrite、userAdmin、userAdmin</li>
</ul>
</li>
<li>集群管理角色<ul>
<li>clusterMonitor：监控工具（MongoDB Cloud Manager、Ops Manager）有只读权限</li>
<li>hostManager：包含针对数据库服务器的监控和管理操作</li>
<li>clusterManager：包含针对集群的监控和管理操作</li>
<li>clusterAdmin：拥有集群的最高权限：clusterManager、clusterMonitor、hostManager、dropDatabase</li>
</ul>
</li>
<li>备份恢复角色<ul>
<li>backup：拥有备份mongodb数据的最小权限</li>
<li>restore：含有从数据文件恢复数据的权限</li>
</ul>
</li>
<li>全体数据库级别角色：只存在于admin库，适用于除了config和local之外的所有库<ul>
<li>readAnyDatabase：对所有库的只读权限</li>
<li>readWriteAnyDatabase：对所有库的读写权限</li>
<li>userAdminAnyDatabase：类似于userAdmin对所有库的用户管理权限</li>
<li>dbAdminAnyDatabase：类似于dbAdmin对所有库的管理权限</li>
</ul>
</li>
<li>超级用户角色<ul>
<li>用户拥有以下角色时，可以对任意用户授予任意数据库任意权限<ul>
<li>admin库的dbOwner的角色</li>
<li>admin库的userAdmin的角色</li>
<li>userAdminAnyDatabase</li>
</ul>
</li>
<li>root角色拥有的权限：readWriteAnyDatabase、dbAdminAnyDatabase、userAdminAnyDatabase、clusterAdmin、restore和backup</li>
</ul>
</li>
<li>内部角色：__system</li>
</ul>
<h2 id="用户管理和访问控制"><a href="#用户管理和访问控制" class="headerlink" title="用户管理和访问控制"></a>用户管理和访问控制</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ul>
<li>创建管理用户：<code>db.createUser({user: &quot;user_admin&quot;, pwd: &quot;user_admin&quot;, roles: [{role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;}]})</code></li>
<li>开启访问控制(重启服务)：security.authorization：enabled</li>
<li>授权登录<ul>
<li>交互终端内：use admin；db.auth(‘user_admin’,’user_admin’)</li>
<li>命令行模式：mongo –host 172.16.0.201 –port 27017 -u user_admin -p user_admin –authenticationDatabase admin</li>
</ul>
</li>
</ul>
<h3 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h3><ul>
<li>查询数据库所有用户：db.getUsers()、show users</li>
<li><p>创建用户并添加角色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: &quot;user_dba&quot;,</span><br><span class="line">    pwd: &quot;user_dba&quot;,</span><br><span class="line">    roles: [&quot;read&quot;],</span><br><span class="line">    customData: &#123;info: &quot;user for dba&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新用户角色：db.updateUser(“user_dba”, {roles:[{role: “read”, db: “admin”},{role: “readWrite”,db: “examples”}]})</p>
</li>
<li>查询用户角色信息：db.getUser(“user_dba”,{showPrivileges: true})</li>
<li>添加用户角色：db.grantRolesToUser(“user_dba”,[{role: “readWrite”, db: “admin”}])</li>
<li>回收用户角色：db.revokeRolesFromUser(“user_dba”, [{role: “read”, db: “admin”}])</li>
<li>变更用户密码：db.changeUserPassword(“user_dba”,”new_passwd”)</li>
<li>删除用户：db.dropUser(“user_dba”)</li>
</ul>
<h1 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h1><ul>
<li>用户授权：<code>db.grantRolesToUser(&quot;user_admin&quot;,[{role: &quot;backup&quot;, db: &quot;admin&quot;},{role: &quot;restore&quot;, db: &quot;admin&quot;}])</code></li>
<li>备份数据：<code>mongodump --port 30001 -u user_admin -p user_admin --authenticationDatabase=admin -d test -o ./backup/</code></li>
<li>导出数据：mongoexport<ul>
<li>命令参数<ul>
<li>-f：指定要导出的字段</li>
<li>–type：指定导出格式，默认json格式，也可指定csv</li>
<li>-d：数据库  -c：集合</li>
</ul>
</li>
<li>mongoexport –host=host.com –port=3717 -u root -p passwd –authenticationDatabase=admin -d fubu -c fubu_forum -f username,phone,qq,email,homepage,recently_posted,last_reply_time –type=csv -o ./fubu_forum.csv</li>
</ul>
</li>
<li>恢复数据：<code>mongorestore --port 30001 -u user_admin -p user_admin --authenticationDatabase=admin -d test --dir=./backup/test</code></li>
</ul>
<h1 id="操作日志"><a href="#操作日志" class="headerlink" title="操作日志"></a>操作日志</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MongoDB Profile  记录是直接存在系统 db 里的，记录位置 system.profile ，<br>所以，我们只要查询这个 Collection 的记录就可以获取到我们的 Profile  记录了  </p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li>日志设置状态查询：db.getProfilingStatus();</li>
<li>命令行设置<ul>
<li>只能在非mongos的主设置</li>
<li>设置：db.setProfilingLevel(1,500); </li>
<li>设置解读：0代表关闭，1代表只记录slowlog，2代表记录所有操作，这里设置成了500，即500ms。</li>
</ul>
</li>
<li>配置文件设置<ul>
<li>开关：operationProfiling.mode: [off/slowOp/all]</li>
<li>阈值：operationProfiling.slowOpThresholdMs: N</li>
</ul>
</li>
</ul>
<h2 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h2><ul>
<li>交互式命令行：db.system.profile.find({millis:{$gt:500}})</li>
<li>shell命令行：echo “db.system.profile.find({millis:{\$gt:500}})”|mongo 10.86.0.150:27017</li>
</ul>
<h1 id="服务性能优化"><a href="#服务性能优化" class="headerlink" title="服务性能优化"></a>服务性能优化</h1><ul>
<li>连接池【客户端设置】</li>
<li>内存：默认使用50% of (RAM - 1 GB)或256 MB中的大的数值</li>
<li>cpu：默认的线城池数量和cpu核心数相关</li>
<li>swap：系统设置swap分区，并设置swap【低度使用swap】<ul>
<li>cat /proc/sys/vm/swappiness</li>
<li>sysctl vm.swappiness=1</li>
</ul>
</li>
<li>文件系统<ul>
<li>尽量使用xfs文件系统</li>
<li>不建议使用NFS等远程文件系统</li>
<li>使用的文件系统支持目录级别fsync()【HGFS、virtualbox的共享目录不支持此操作】</li>
</ul>
</li>
<li>磁盘：建议使用RAID-10. RAID-5</li>
<li>存储方式：将数据、预写日志、日志、索引存放在不同磁盘以改善性能</li>
<li>数据压缩存储<ul>
<li>snappy：默认压缩方式，压缩率较低，cpu使用也低</li>
<li>zlib：压缩率较高，cpu使用也高</li>
<li>zstd：4.2版本出现的压缩选项，在压缩率和cpu中折中选择</li>
</ul>
</li>
</ul>
<hr>
<h1 id="NUMA使用"><a href="#NUMA使用" class="headerlink" title="NUMA使用"></a>NUMA使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在的机器上都是有多个CPU和多个内存块的。以前我们都是将内存块看成是一大块内存，所有CPU到这个共享内存的访问消息是一样的。这就是之前普 遍使用的SMP模型。<br>但是随着处理器的增加，共享内存可能会导致内存访问冲突越来越厉害，且如果内存访问达到瓶颈的时候，性能就不能随之增加。NUMA（Non-Uniform Memory Access）就是这样的环境下引入的一个模型。<br> 比如一台机器是有2个处理器，有4个内存块。我们将1个处理器和两个内存块合起来，称为一个NUMA node，这样这个机器就会有两个NUMA node。在物理分布上，NUMA node的处理器和内存块的物理距离更小，因此访问也更快。<br> 比如这台机器会分左右两个处理器（cpu1, cpu2），在每个处理器两边放两个内存块(memory1.1, memory1.2, memory2.1,memory2.2)，这样NUMA node1的cpu1访问memory1.1和memory1.2就比访问memory2.1和memory2.2更快。所以使用NUMA的模式如果能尽量保证本node内的CPU只访问本node内的内存块，那这样的效率就是最高的。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>当你的服务器还有内存的时候，发现它已经在开始使用swap了，甚至已经导致机器出现停滞的现象。这个就有可 能是由于numa的限制，如果一个进程限制它只能使用自己的numa节点的内存，那么当自身numa node内存使用光之后，就不会去使用其他numa node的内存了，会开始使用swap，甚至更糟的情况，机器没有设置swap的时候，可能会直接死机！所以你可以使用numactl –interleave=all来取消numa node的限制。</p>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul>
<li>如果你的程序是会占用大规模内存的，你大多应该选择关闭numa node的限制。因为这个时候你的程序很有几率会碰到numa陷阱。  </li>
<li>如果你的程序并不占用大内存，而是要求更快的程序运行时间。你大多应该选择限制只访问本numa node的方法来进行处理  </li>
</ul>
<h2 id="mongodb使用"><a href="#mongodb使用" class="headerlink" title="mongodb使用"></a>mongodb使用</h2><p>mongod=”numactl –interleave=all /usr/local/mongod/bin/mongod”</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>用户权限</tag>
        <tag>管理</tag>
        <tag>numa</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins之声明式pipeline</title>
    <url>/blog/2020/02/10/CICD/jenkins/jenkins%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8Fpipeline/</url>
    <content><![CDATA[<h1 id="基本结构-stages"><a href="#基本结构-stages" class="headerlink" title="基本结构-stages"></a>基本结构-stages</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">   agent any    //指定构建环境【例如什么类型(物理机、虚拟机、docker)的哪个节点】</span><br><span class="line"></span><br><span class="line">   stages &#123;     //构建步骤，至少包含一个stage</span><br><span class="line">      stage(&apos;build&apos;) &#123;</span><br><span class="line">        parallel&#123;   //指定多个stage并行构建</span><br><span class="line">            stage(&apos;build-1&apos;)&#123; </span><br><span class="line">                steps&#123;    //在一个stage构建中的详细步骤，有且只有一个steps</span><br><span class="line">                    echo &apos;build stage 1&apos;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">            stage(&apos;build-2&apos;)&#123;</span><br><span class="line">                steps&#123;</span><br><span class="line">                    echo &apos;build stage 2&apos;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      stage(&apos;test&apos;) &#123;</span><br><span class="line">         steps &#123;</span><br><span class="line">            echo &apos;test stage&apos;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="steps内部指令"><a href="#steps内部指令" class="headerlink" title="steps内部指令"></a>steps内部指令</h1><ul>
<li><p>sh：执行shell命令</p>
</li>
<li><p>echo：执行echo命令</p>
</li>
<li><p>script：执行groovy语法</p>
</li>
<li><p>bat、powershel：执行windows批处理</p>
</li>
<li><p>error：主动报错并终止pipeline执行</p>
</li>
<li><p>timeout：代码块执行超时，默认单位min</p>
<ul>
<li>time：超时时间</li>
<li>unit：时间单位，NANOSECONDS 、MICROSECONDS、MILLISECONDS、SECONDS、MINUTES(默认)、HOURS、DAYS</li>
</ul>
</li>
<li><p>waitUntil：不断重复waitUntil块内代码直到条件为true。waitUntil步骤最好与timeout步骤共同使用避免死循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout(time: 10,unit: &apos;SECONDS&apos;)&#123;</span><br><span class="line">  waitUntil&#123;</span><br><span class="line">    sleep(11)</span><br><span class="line">    sh &apos;ok&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>retry：重复执行代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retry(20)&#123;</span><br><span class="line">  script&#123;</span><br><span class="line">    sh script &apos;curl http://example&apos;, returnStatus: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sleep：休眠时间。默认seconds，其他同timeout</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sleep(120)</span><br><span class="line">sleep(time: 2,unit: &quot;MINUTES&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="其他重要指令"><a href="#其他重要指令" class="headerlink" title="其他重要指令"></a>其他重要指令</h1><ul>
<li>environment：用于设置环境变量，可以定义在pipeline或stage部分</li>
<li>tools：定义可以使用的工具，可以定义在pipeline或stage部分</li>
<li>input：定义在stage部分会暂停pipeline提示用户输入</li>
<li>parallel：并行执行多个stage</li>
<li>triggers：定义执行pipeline的触发器</li>
<li>cron：用法同crontab，一般用于trigger【范例：分/时/日/月/周】</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>printenv：执行shell命令，显示所有的变量名称</p>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul>
<li>BUILD_URL:本次构建的访问地址</li>
<li>JOB_BASE_NAME：创建的构建任务名称</li>
<li>BUILD_NUMBER：构建序列号</li>
<li>WORKSPACE：本次构建工作目录</li>
</ul>
<h2 id="自定义局部变量"><a href="#自定义局部变量" class="headerlink" title="自定义局部变量"></a>自定义局部变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment &#123;</span><br><span class="line">  name = &quot;hejq&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>Manage Jenkins→Configure System→Global properties 页勾选“Environment variables”</p>
<h1 id="pipeline设置-options"><a href="#pipeline设置-options" class="headerlink" title="pipeline设置-options"></a>pipeline设置-options</h1><ul>
<li><p>buildDiscarder：保存的历史构建数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; buildDiscarder(logRotator(numToKeepStr: &apos;1&apos;)) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkoutToSubdirectory：从版本库拉取代码到子目录中【默认：工作目录的根目录】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; checkoutToSubdirectory(&apos;foo&apos;) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>disableConcurrentBuilds：禁止pipeline并行执行，防止出现抢占资源或调度冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; disableConcurrentBuilds() &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newContainerPerStage：使用docker构建时，每个stage都使用新的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; newContainerPerStage() &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>retry：发生失败时执行重试的次数（包含第一次失败）；可以在pipeline或stage块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; retry(3) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timeout：执行超时时间，超过此时间pipeline被终止；可以设置在pipeline或stage块</p>
<p>单位：HOURS、MINUTES、SECONDS</p>
<p>实践：一般设置10分钟即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#123; timeout(time: 1, unit: &apos;HOURS&apos;) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="参数化构建-parameters"><a href="#参数化构建-parameters" class="headerlink" title="参数化构建-parameters"></a><a href="https://jenkins.io/doc/book/pipeline/syntax/#parameters" target="_blank" rel="noopener">参数化构建-parameters</a></h1><table>
<thead>
<tr>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>text</td>
<td>文本，容纳多于字符串的信息</td>
</tr>
<tr>
<td>booleanParam</td>
<td>布尔类型</td>
</tr>
<tr>
<td>choice</td>
<td>下拉框多选</td>
</tr>
<tr>
<td>file</td>
<td>添加构建过程需要的文件</td>
</tr>
<tr>
<td>password</td>
<td>密码类型</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    parameters&#123;</span><br><span class="line">        choice(</span><br><span class="line">            description: &apos;你需要选择哪个模块进行构建？&apos;,</span><br><span class="line">            name: &apos;modulename&apos;,</span><br><span class="line">            choices: [&apos;Module1&apos;, &apos;Module2&apos;, &apos;Module3&apos;]</span><br><span class="line">            )</span><br><span class="line">        string(</span><br><span class="line">            description: &apos;你需要在哪台机器上进行部署？&apos;,</span><br><span class="line">            name: &apos;deploy_hostname&apos;,</span><br><span class="line">            defaultValue: &apos;host131&apos;,</span><br><span class="line">            )</span><br><span class="line">        text(</span><br><span class="line">            name: &apos;release_note&apos;,</span><br><span class="line">            defaultValue: &apos;Release Note 信息如下所示:\n \</span><br><span class="line">            bug-Fixed: \n \</span><br><span class="line">            Feature-Added: &apos;,</span><br><span class="line">            description: &apos;Release Note的详细信息是什么？&apos;</span><br><span class="line">            )</span><br><span class="line">        booleanParam(</span><br><span class="line">            name: &apos;test_skip_flag&apos;,</span><br><span class="line">            defaultValue: true,</span><br><span class="line">            description: &apos;你需要在部署之前执行自动化测试么？&apos;</span><br><span class="line">            )</span><br><span class="line">        password(</span><br><span class="line">            name: &apos;deploy_password&apos;,</span><br><span class="line">            defaultValue: &apos;hejingqi&apos;,</span><br><span class="line">            description: &apos;部署机器连接时需要用到的密码信息是多少？&apos;</span><br><span class="line">            )</span><br><span class="line">        file(</span><br><span class="line">            name: &apos;deploy_property_file&apos;,</span><br><span class="line">            description: &quot;你需要输入的部署环境的设定文件是什么？&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&apos;Build&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &quot;Build stage:选中的构建Module为：$&#123;params.modulename&#125;...&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Test&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &quot;Test stage:是否执行自动化测试：$&#123;params.test_skip_flag&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Deploy&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &quot;Deploy stage:部署机器的名称：$&#123;params.deploy_hostname&#125;...&quot;</span><br><span class="line">                echo &quot;Deploy stage:部署连接的密码：$&#123;params.deploy_password&#125;...&quot;</span><br><span class="line">                echo &quot;Deploy stage:Release Note的新的：$&#123;params.release_note&#125;...&quot;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="条件-when【pre处理】"><a href="#条件-when【pre处理】" class="headerlink" title="条件-when【pre处理】"></a><a href="https://jenkins.io/doc/book/pipeline/syntax/#when" target="_blank" rel="noopener">条件-when</a>【pre处理】</h1><table>
<thead>
<tr>
<th>条件类型</th>
<th>使用说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>branch</td>
<td>指定分支构建时触发</td>
<td>只支持多分支pipeline</td>
</tr>
<tr>
<td>buildingTag</td>
<td>构建tag时触发</td>
<td>-</td>
</tr>
<tr>
<td>changelog</td>
<td>SCM的变更日志包含指定内容时触发</td>
<td>常与正则表达式结合使用</td>
</tr>
<tr>
<td>changeset</td>
<td>SCM的changeset包含指定文件时触发</td>
<td>常与*等表达式结合使用，缺省不区分大小写，可通过caseSensitive为true实现区分大小写</td>
</tr>
<tr>
<td>changeRequest</td>
<td>变更请求发生时触发（比如Github的Pull Request、Gitlab的Merge Request以及Gerrit的变更等）</td>
<td>如未指定参数，每次请求都会触发；也可以指定【分支信息/标题/author/邮件地址】等信息作为参数触发</td>
</tr>
<tr>
<td>environment</td>
<td>环境变量被设为某值时触发</td>
<td>-</td>
</tr>
<tr>
<td>equals</td>
<td>变量设为某值时触发</td>
<td>-</td>
</tr>
<tr>
<td>expression</td>
<td>表达式为true时触发</td>
<td>返回的字符串必须转换为布尔类型才能操作</td>
</tr>
<tr>
<td>tag</td>
<td>TAG_NAME变量满足匹配模式时被触发</td>
<td>-</td>
</tr>
<tr>
<td>not</td>
<td>当条件为false时触发</td>
<td>-</td>
</tr>
<tr>
<td>allOf</td>
<td>当所有条件都为true才会被触发</td>
<td>-</td>
</tr>
<tr>
<td>anyOf</td>
<td>当所有嵌套条件至少一个为true时会被触发</td>
<td>-</td>
</tr>
<tr>
<td>triggeredBy</td>
<td>当前构建为指定方式时触发【触发条件：SCMTrigger/TimerTrigger/UpstreamCause】</td>
<td>-</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment&#123; //设置环境变量</span><br><span class="line">        ENVIRONMENT_TEST_FLAG = &apos;NO&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&apos;Init&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                script&#123; //可以写grovy脚本，此处只定义变量</span><br><span class="line">                    BUILD_EXPRESSION = true</span><br><span class="line">                    DEPLOY_USER = &apos;liumiaocn&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Build&apos;)&#123;</span><br><span class="line">            when&#123;</span><br><span class="line">                expression &#123;BUILD_EXPRESSION&#125; //表达式为真则执行</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo Build stage ...&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Test&apos;)&#123;</span><br><span class="line">                when&#123;</span><br><span class="line">                    environment name: &apos;ENVIRONMENT_TEST_FLAG&apos;, //环境变量是指定值则执行</span><br><span class="line">                    value: &apos;YES&apos;</span><br><span class="line">                &#125;</span><br><span class="line">                steps&#123;</span><br><span class="line">                    sh &apos;echo Test stage ...&apos;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Deploy&apos;)&#123;</span><br><span class="line">            when&#123;</span><br><span class="line">                equals expected: &apos;liumiaocn&apos;, //变量是指定值则执行</span><br><span class="line">                actual: DEPLOY_USER</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &apos;echo Deploy stage ...&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="post处理"><a href="#post处理" class="headerlink" title="post处理"></a>post处理</h1><blockquote>
<p>根据pipeline或stage执行结果进行后续处理</p>
</blockquote>
<h2 id="内置条件"><a href="#内置条件" class="headerlink" title="内置条件"></a>内置条件</h2><ul>
<li>always：无论pipeline或stage执行结果如何，都会执行下面的操作</li>
<li>changed：只有pipeline或stage执行结果与之前相比，状态发生变化，才会执行下边的操作</li>
<li>fixed：前一次执行结果为不稳定或失败状态，本次执行成功，才会执行下边的操作</li>
<li>regression：本次执行结果为不稳定、失败或中止状态，上次为成功状态</li>
<li>aborted：本次执行操作被手动中止，UI显示为灰色</li>
<li>failure：本次执行为failed状态，UI显示为红色</li>
<li>success：本次执行成功，UI显示为绿色</li>
<li>unstable：由于测试失败或代码规范性检查失败产生的状态，UI显示为黄色</li>
<li>unsuccessful：执行结果不是success</li>
<li>cleanup：在其他post条件后，无论执行结果如何都会执行</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&apos;Example&apos;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &apos;Hello World&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    post&#123;</span><br><span class="line">        always&#123;</span><br><span class="line">            echo &apos;I will always say Hello World&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx基础学习</title>
    <url>/blog/2019/06/11/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/web%E6%9C%8D%E5%8A%A1/nginx%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://tengine.taobao.org/nginx_docs/cn/docs/" target="_blank" rel="noopener">淘宝nginx文档</a></p>
<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">官方nginx文档</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>占用资源少</li>
<li>支持高并发</li>
<li>可以做代理服务器【类似squid、haproxy】</li>
<li>可以做缓存服务器【类似varnish】</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><ul>
<li>ubuntu： apt-get install zlib1g-dev libpcre3 libpcre3-dev openssl libssl-dev -y </li>
<li>centos：yum install pcre pcre-devel zlib zlib-devel openssl openssl-devel -y</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-pcre --with-http_ssl_module \</span><br><span class="line">--with-http_gzip_static_module --with-http_flv_module --with-http_realip_module --with-debug</span><br></pre></td></tr></table></figure>
<ul>
<li>支持查看nginx连接状态</li>
<li>支持正则表达式【比如map功能即为使用正则】</li>
<li>支持ssl功能</li>
<li>支持gzip压缩</li>
<li>支持flv视频流</li>
<li>支持通过realip模块定位最终客户端地址【客户端走多层代理访问最终服务时需要】</li>
<li>开启debug功能</li>
</ul>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>make &amp;&amp; make install </p>
<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><ul>
<li>-?,-h         : this help</li>
<li>-v            : show version and exit</li>
<li>-V            : show version and configure options then exit</li>
<li>-t            : test configuration and exit</li>
<li>-T            : test configuration, dump it and exit【显示配置文件详情】</li>
<li>-q            : suppress non-error messages during configuration testing【检查配置文件语法时屏蔽非错误提示信息】</li>
<li>-s signal     : send signal to a master process: stop, quit, reopen, reload<ul>
<li>stop：强制关闭主进程</li>
<li>quit：优雅关闭煮即成</li>
<li>reopen：打开新的日志文件写入</li>
<li>reload：重新加载配置文件</li>
</ul>
</li>
<li>-p prefix     : set prefix path (default: /usr/local/nginx/)</li>
<li>-c filename   : set configuration file (default: conf/nginx.conf)</li>
<li>-g directives : set global directives out of configuration file【配置文件外设置全局命令，如：-g daemon on】</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/nginx-conf.png" alt></p>
<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user nginx nginx</span><br><span class="line">worker_processes  4;</span><br><span class="line">worker_cpu_affinity 01 10 01 10;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">    指明了nginx要开启的进程数，据官方说法，一般开一个就够了，多开几个，可以减少机器io带来的影响。 一般为当前机器总cpu核心数的1到2倍</span><br><span class="line">worker_cpu_affinity 01 10 01 10; </span><br><span class="line">    nginx默认是没有开启利用多核cpu的配置的。需要通过增加worker_cpu_affinity配置参数来充分利用多核cpu。</span><br><span class="line">    为每个进程开启一个cpu，1表示开启核心，0为关闭</span><br><span class="line">    2核2进程写法：</span><br><span class="line">    worker_processes 2；</span><br><span class="line">    worker_cpu_affinity 01 10;</span><br><span class="line">    2核4进程写法：</span><br><span class="line">    worker_processes  4;</span><br><span class="line">    worker_cpu_affinity 01 10 01 10;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">    指定一个nginx进程可以打开的最多文件描述符数目，（需要使用命令“ulimit -n 65535”来设置。）</span><br><span class="line">worker_connections  65535;</span><br><span class="line">    用于定义Nginx每个进程的最大连接数</span><br></pre></td></tr></table></figure>
<h2 id="http设置"><a href="#http设置" class="headerlink" title="http设置"></a>http设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">#    map $http_x_forwarded_for  $clientRealIp &#123;</span><br><span class="line">#            &quot;&quot;      $remote_addr;</span><br><span class="line">#            ~^(?P&lt;firstAddr&gt;[0-9\.]+),?.*$  $firstAddr;</span><br><span class="line">#    &#125;</span><br><span class="line">    lua_shared_dict limit 50m;  #防cc使用字典，大小50M</span><br><span class="line">    lua_package_path &quot;/home/zj-web/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">    init_by_lua_file &quot;/home/zj-web/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">    access_by_lua_file &quot;/home/zj-web/nginx/conf/waf/access.lua&quot;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    error_log   logs/error.log  error;</span><br><span class="line">    # tcp conf</span><br><span class="line">    include tcp.conf;</span><br><span class="line">    # gzip conf</span><br><span class="line">    include gzip.conf;</span><br><span class="line">    # site conf</span><br><span class="line">    include site-available/*.conf;</span><br><span class="line">    # realip conf</span><br><span class="line">    include realip.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_type  application/octet-stream;</span><br><span class="line">    默认类型为二进制流，也就是当文件类型未定义时使用这种方式，例如：在没有配置PHP环境时，Nginx是不予解析的，此时，用浏览器访问PHP文件就会出现下载窗口。</span><br><span class="line">log_format:</span><br><span class="line">    日志格式</span><br><span class="line">access_log/error_log:</span><br><span class="line">    主日志信息【当location未定义时使用】</span><br><span class="line">lua*：</span><br><span class="line">    与lua脚本搭配构建WAF</span><br></pre></td></tr></table></figure>
<h2 id="tcp设置"><a href="#tcp设置" class="headerlink" title="tcp设置"></a>tcp设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client_max_body_size  20m;</span><br><span class="line">client_header_buffer_size    32K;</span><br><span class="line">client_body_buffer_size 128k;</span><br><span class="line">large_client_header_buffers  4 32k;</span><br><span class="line">Sendfile  on;</span><br><span class="line">tcp_nopush     on;</span><br><span class="line">tcp_nodelay    on;</span><br><span class="line">keepalive_timeout 60;</span><br><span class="line">client_header_timeout  10;</span><br><span class="line">client_body_timeout    10;</span><br><span class="line">send_timeout          10;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client_max_body_size  20m;</span><br><span class="line">    用来设置允许客户端请求的最大的单个文件字节数</span><br><span class="line">client_header_buffer_size    32K;</span><br><span class="line">    用于指定来自客户端请求头的header buffer大小</span><br><span class="line">client_body_buffer_size   128k;</span><br><span class="line">    指定客户端请求主体缓冲区大小</span><br><span class="line">large_client_header_buffers  4 32k;</span><br><span class="line">    用来指定客户端请求中较大的消息头的缓存最大数量和大小</span><br><span class="line">sendfile  on;</span><br><span class="line">    用于开启高效文件传输模式</span><br><span class="line">tcp_nopush     on;</span><br><span class="line">tcp_nodelay    on;</span><br><span class="line">    将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span><br><span class="line">keepalive_timeout 60;</span><br><span class="line">    设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接</span><br><span class="line">client_header_timeout  10;</span><br><span class="line">    设置客户端请求头读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回Request time out（408）错误</span><br><span class="line">client_body_timeout    10;</span><br><span class="line">    设置客户端请求主体读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回Request time out（408）错误，默认值是60</span><br><span class="line">send_timeout          10;</span><br><span class="line">    指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。</span><br></pre></td></tr></table></figure>
<h2 id="gzip设置"><a href="#gzip设置" class="headerlink" title="gzip设置"></a>gzip设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编译参数--with-http_gzip_static_module</span><br><span class="line">gzip  on;</span><br><span class="line">gzip_min_length  1k;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_buffers    16 64k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_disable &quot;MSIE [1-6].&quot;;</span><br><span class="line">gzip_comp_level 5;</span><br><span class="line">gzip_types       text/plain application/x-javascript text/css application/xml application/json application/javascript image/jpeg image/gif image/png;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip on;                   #开启gzip模块，实时压缩输出数据流</span><br><span class="line">gzip_min_length 1k;         #设置允许压缩的下限阀值【大于1k的文件才进行压缩】</span><br><span class="line">gzip_buffers 4 16k;          #申请4个大小16K的内存作为压缩结果流缓存</span><br><span class="line">gzip_http_version 1.1;       #支持的http协议</span><br><span class="line">gzip_comp_level 5;          #压缩级别</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml;   #支持的压缩类型</span><br><span class="line">gzip_vary on;               #可以根据客户端是否支持压缩自动调整压缩功能</span><br></pre></td></tr></table></figure>
<h2 id="ssl设置"><a href="#ssl设置" class="headerlink" title="ssl设置"></a>ssl设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编译参数--with-http_ssl_module</span><br><span class="line"># 文件路径为相对于nginx.conf的路径</span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate   cert/214135355250268.pem;</span><br><span class="line">ssl_certificate_key  cert/214135355250268.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl自定义证书设置</span><br><span class="line">1.系统安装openssl及开发库</span><br><span class="line">2.使用openssl产生证书【pem格式】和私钥【pem格式】</span><br><span class="line">openssl req -x509 -nodes -newkey rsa:2048 -keyout nginx.key -out nginx.crt</span><br></pre></td></tr></table></figure>
<h2 id="php配置"><a href="#php配置" class="headerlink" title="php配置"></a>php配置</h2><blockquote>
<p>nginx默认没有配置SCRIPT_FILENAME</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root  /var/www/html;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>root定义php文件的根目录</li>
<li>SCRIPT_FILENAME，定义web访问时php文件路径【/var/www/html/index.php】<ul>
<li>document_root即为本区域或父区域定义的文件根目录【/var/www/html】</li>
<li>fastcgi_script_name即为文件在根目录下的位置【/index.php】</li>
</ul>
</li>
</ul>
<h2 id="auth与status"><a href="#auth与status" class="headerlink" title="auth与status"></a>auth与status</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编译参数：--with-http_stub_status_module</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  0.0.0.0;</span><br><span class="line">    location /status &#123;</span><br><span class="line">        stub_status on;              #开启模块功能</span><br><span class="line">        access_log off;               #关闭访问日志</span><br><span class="line">        allow 127.0.0.1;        #只允许127 访问</span><br><span class="line">        deny all;</span><br><span class="line">        auth_basic &quot;status for nginx&quot;;                #验证登陆时的标题</span><br><span class="line">        auth_basic_user_file htpasswd;   #使用授权文件htpasswd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth_basic是Nginx的一种认证机制。auth_basic_user_file用来指定认证的密码文件，</span><br><span class="line">由于Nginx的auth_basic认证采用的是与Apache兼容的密码文件，</span><br><span class="line">因此需要用Apache的htpasswd命令来生成密码文件，例如要添加一个webadmin用户，可以使用下面方式生成密码文件：</span><br><span class="line">yum install httpd-tools -y</span><br><span class="line">htpasswd -c htpasswd webadmin</span><br><span class="line">此命令会在当前目录生产一个文件htpasswd，其中用户名webadmin</span><br></pre></td></tr></table></figure>
<h2 id="websocket支持"><a href="#websocket支持" class="headerlink" title="websocket支持"></a><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">websocket支持</a></h2><blockquote>
<p>nginx1.3.13之后，nginx内置支持websocket代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /chat/ &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">    proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name pre-zj-static.zj-hf.cn;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  pre-zj-static.zj-hf.cn;</span><br><span class="line">    include ssl.conf;</span><br><span class="line">    error_page  403 /error/403.jpg;</span><br><span class="line">    error_page  404 /error/4041.html;</span><br><span class="line">    error_page  500 502 503 504  /error/50x.jpg;</span><br><span class="line">    location  /error/ &#123;</span><br><span class="line">        internal;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        error_log  logs/vue-html.error.log  info;</span><br><span class="line">        root wechat/vue;</span><br><span class="line">        add_header Cache-Control &apos;no-store&apos;;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ /index.html =404;</span><br><span class="line">      &#125;</span><br><span class="line">     location ~\.html &#123;</span><br><span class="line">        error_log  logs/jq-html.error.log  info;</span><br><span class="line">        root  wechat/jq;</span><br><span class="line">        add_header Cache-Control &apos;no-store&apos;;</span><br><span class="line">        allow all;</span><br><span class="line">      &#125;</span><br><span class="line">     location ~* ^.+pdf.+\.(bcmap|css|json|js|properties|txt|html|swf|wav|png|jpg|woff|ttf)$ &#123;</span><br><span class="line">                error_log  logs/vue-assetst.error.log  info;</span><br><span class="line">                root  wechat/jq;</span><br><span class="line">                access_log   off;</span><br><span class="line">                expires      30d;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><ul>
<li>listen 80 default_server;<br>  用于指定虚拟主机的服务端口，default_server可以在多个虚拟主机之间设置默认的虚拟主机。</li>
<li>server_name <a href="http://www.abc.org" target="_blank" rel="noopener">www.abc.org</a> abc.com;<br>  用来指定IP地址或者域名，多个域名之间用空格分开,不含www的域名也可直接设置，如abc.com</li>
<li>return 301 https://$server_name$request_uri;<br>  向客户端返回相应的状态码以及url</li>
<li>root<ul>
<li>虚拟主机根目录，【定义的根目录与conf、sbin同级】</li>
<li>示例：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">    root /local_path/image/;</span><br><span class="line">&#125;</span><br><span class="line">当客户端请求 /request_path/image/cat.png 的时候， </span><br><span class="line">Nginx把请求映射为/local_path/image/request_path/image/cat.png</span><br></pre></td></tr></table></figure>
<ul>
<li>alias：<ul>
<li>对请求的路径做替换转换</li>
<li>示例</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">    alias /local_path/image/;</span><br><span class="line">&#125;</span><br><span class="line">当客户端请求 /request_path/image/cat.png 的时候， </span><br><span class="line">Nginx把请求映射为/local_path/image/cat.png</span><br></pre></td></tr></table></figure>
<ul>
<li><p>add_header</p>
<ul>
<li>重写发送给客户端的响应头【response】</li>
</ul>
</li>
<li><p>allow all</p>
<ul>
<li>对匹配的location作访问限制【allow或deny】</li>
<li>可使用的匹配规则为：允许部分，拒绝所有；拒绝部分，允许所有。</li>
</ul>
</li>
<li>access_log   off;<ul>
<li>关闭访问日志</li>
</ul>
</li>
<li>expires      30d;<ul>
<li>设置静态文件缓存时间</li>
</ul>
</li>
<li>try_files $uri $uri/ /index.html =404;<ul>
<li>当location的程序不能处理请求时的处理方式【可以处理404等异常】</li>
<li>按照指定的顺序检查文件或目录【名字末尾加反斜线】是否存在</li>
<li>如果找不到任何文件，将按最后一个参数指定的uri进行内部跳转。</li>
<li>最后一个参数可以是一个命名的location或状态码【404】等</li>
</ul>
</li>
<li>internal 只能由内部url调用，外部访问则404</li>
<li>error_page  403 /error/403.jpg; <ul>
<li>定义错误页面，位于server内</li>
<li>错误页面大小必须大于512字节，否则会被浏览器的默认错误页面替代</li>
</ul>
</li>
</ul>
<h1 id="location优先级"><a href="#location优先级" class="headerlink" title="location优先级"></a>location优先级</h1><h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>=</code> 精确匹配，如果找到匹配=好的内容，立即停止搜索，并立即处理请求（优先级最高）</li>
<li><code>~</code> 表示执行一个正则匹配，区分大小写</li>
<li><code>~*</code> 表示执行一个正则匹配，不区分大小写</li>
<li><code>^~</code> 只匹配字符串，不匹配正则表达式,一般用来匹配目录</li>
<li><code>@</code> 指定一个命名的location，一般只用于内部重定向请求【try_files、error_page】</li>
</ul>
<h2 id="location示例"><a href="#location示例" class="headerlink" title="location示例"></a>location示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location指令：</span><br><span class="line">#NO.1</span><br><span class="line">        location / &#123;</span><br><span class="line">        return 500;</span><br><span class="line">        &#125;</span><br><span class="line">#NO.2</span><br><span class="line">        location /a/ &#123;</span><br><span class="line">        return 403;</span><br><span class="line">        &#125;</span><br><span class="line">#NO.3</span><br><span class="line">        location ^~ /a/ &#123;</span><br><span class="line">        return 403;</span><br><span class="line">        &#125;</span><br><span class="line">#NO.4</span><br><span class="line">        location /a/1.jpg &#123;</span><br><span class="line">        return 402;</span><br><span class="line">        &#125;</span><br><span class="line">#NO.5</span><br><span class="line">        location ~* \.jpg$ &#123;</span><br><span class="line">        return 401;</span><br><span class="line">        &#125;</span><br><span class="line">#NO.6</span><br><span class="line">        location = /a/1.jpg &#123;</span><br><span class="line">        return 400;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先级：</span><br><span class="line">1）优先匹配#NO.6  “=”优先级最高</span><br><span class="line">2）再次匹配#NO.5  正则表达式匹配</span><br><span class="line">3）再次匹配#NO.4  完整匹配</span><br><span class="line">4）再次匹配#NO.3  部分包含的被匹配【NO.2与NO.3效果相同】</span><br><span class="line">5）最后匹配#NO.1  所有的访问都被匹配</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>htpasswd</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx进阶学习</title>
    <url>/blog/2019/06/11/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/web%E6%9C%8D%E5%8A%A1/nginx%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://tengine.taobao.org/nginx_docs/cn/docs/" target="_blank" rel="noopener">淘宝nginx文档</a></p>
<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">官方nginx文档</a></p>
<h1 id="proxy设置"><a href="#proxy设置" class="headerlink" title="proxy设置"></a>proxy设置</h1><h2 id="proxy相关变量"><a href="#proxy相关变量" class="headerlink" title="proxy相关变量"></a>proxy相关变量</h2><ul>
<li>$remote_addr：客户端地址【距离服务器最近的客户端ip，有代理时为代理的ip】</li>
<li>$http_x_real_ip：<ul>
<li>在没有特殊配置情况下，X-Real-IP请求头不会自动添加到请求头中；</li>
<li>这个请求头一般为代理服务器设置，形如：proxy_set_header X-Real-IP $remote_addr;</li>
<li>如果经过两次代理【客户端-》cdn-》waf-》nginx】，且都设置proxy_set_header X-Real-IP $remote_addr，则在nginx服务层获取的http_x_real_ip为cdn的ip地址</li>
</ul>
</li>
<li>$http_x_forwarded_for：<ul>
<li>在没有特殊配置情况下，X-Forwarded-For请求头不会自动添加到请求头中；</li>
<li>代理服务器中的设置：proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</li>
</ul>
</li>
<li>$proxy_add_x_forwarded_for：<ul>
<li>如果请求头中没有X-Forwarded-For则$proxy_add_x_forwarded_for为$remote_addr</li>
<li>代理服务器中的设置：proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</li>
<li>此变量是把请求头中的X-Forwarded-For与$remote_addr用逗号合起来，每经过一个反向代理就在请求头X-Forwarded-For后追加反向代理IP，形如：real client ip, proxy ip 1。。。proxy ip N</li>
</ul>
</li>
</ul>
<h2 id="upstream参数"><a href="#upstream参数" class="headerlink" title="upstream参数"></a>upstream参数</h2><blockquote>
<p>upstream用于nginx代理多个相同功能的后端服务器，在nginx层实现对后端服务器的高可用和负载均衡</p>
</blockquote>
<ul>
<li>upstream在http区块下，与server同级</li>
<li>server语法：<ul>
<li>weight：服务器的权重，默认为1</li>
<li>max_fails：失败重试次数，默认为1，0为不重试</li>
<li>fail_timeout：与服务器通信的超时时间【此时认为服务器不可达】。默认为10s。</li>
<li>backup：标记作为备份服务器，当主服务器不可达时被启用</li>
<li>down：标记服务器永久不可用；可以和ip_hash指令一起用；当服务器被标记为down状态时，nginx和后端服务器已经建立的连接并不会被移除，只会阻止建立新的连接，因此可以用于nginx后端的软下线。</li>
</ul>
</li>
<li>负载均衡算法<ul>
<li>默认情况，请求通过权重轮询算法被分配给服务器</li>
<li>ip_hash用于将客户端请求基于客户端ip地址分发给后端服务器【一个客户端的所有请求只会发给一个后端服务器】；在ip_hash模式下，当一台服务器需要被临时移除，为了保持客户端ip地址的hash值，应当为此服务器标记down参数。</li>
</ul>
</li>
<li>范例：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream  server &#123;</span><br><span class="line">    server   192.168.100.1 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server   192.168.100.3 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="proxy参数设置"><a href="#proxy参数设置" class="headerlink" title="proxy参数设置"></a>proxy参数设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># http, server, location</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_connect_timeout 60;</span><br><span class="line">proxy_send_timeout 60;</span><br><span class="line">proxy_read_timeout 60;</span><br><span class="line">proxy_buffering on;</span><br><span class="line">proxy_buffer_size 4k;</span><br><span class="line">proxy_buffers 4 32k;</span><br><span class="line">proxy_busy_buffers_size 64k;</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_redirect</span><br><span class="line">    是否对后端服务器的“Location”响应头和“Refresh”响应头进行该写,默认为default，即使用代理服务器的location替换后端服务器的location；off为关闭替换</span><br><span class="line">proxy_set_header             设置后，可以向后端服务器传递指定的header信息，默认的只有下面的header被定义</span><br><span class="line">    proxy_set_header Host $proxy_host;</span><br><span class="line">    proxy_set_header Connection close;</span><br><span class="line">proxy_connect_timeout</span><br><span class="line">    表示与后端服务器连接的超时时间，即发起握手等候响应的超时时间；这个超时一般不可能大于75秒</span><br><span class="line">proxy_send_timeout</span><br><span class="line">    定义向后端服务器传输请求的超时。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。 </span><br><span class="line">proxy_read_timeout</span><br><span class="line">    定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。 </span><br><span class="line">proxy_buffering on;</span><br><span class="line">    代理的时候，开启或关闭缓冲后端服务器的响应。默认为on；</span><br><span class="line">    当开启缓冲时，nginx尽可能快地从被代理的服务器接收响应，再将它存入proxy_buffer_size和proxy_buffers指令设置的缓冲区中。如果响应无法整个纳入内存，那么其中一部分将存入磁盘上的临时文件。proxy_max_temp_file_size和proxy_temp_file_write_size指令可以控制临时文件的写入。 </span><br><span class="line">    当关闭缓冲时，收到响应后，nginx立即将其同步传给客户端。nginx不会尝试从被代理的服务器读取整个请求，而是将proxy_buffer_size指令设定的大小作为一次读取的最大长度。 </span><br><span class="line">proxy_buffer_size  【该缓冲区大小默认等于proxy_buffers指令设置的一块缓冲区的大小，但它也可以被设置得更小】</span><br><span class="line">    nginx从被代理的服务器读取响应时，使用该缓冲区保存响应的开始部分，即header信息。</span><br><span class="line">proxy_buffers  【每块缓冲区默认等于一个内存页的大小。这个值是4K还是8K，取决于平台】</span><br><span class="line">    为每个连接设置缓冲区的数量为number，每块缓冲区的大小为size。这些缓冲区用于保存从被代理的服务器读取的响应。</span><br><span class="line">proxy_busy_buffers_size     【默认是proxy_buffer_size和proxy_buffers指令设置单块缓冲大小的两倍】</span><br><span class="line">    当开启缓冲响应的功能以后，在没有读到全部响应的情况下，写缓冲到达一定大小时，nginx一定会向客户端发送响应，直到缓冲小于此值。这条指令用来设置此值。 同时，剩余的缓冲区可以用于接收响应，如果需要，一部分内容将缓冲到临时文件。该大小</span><br><span class="line">proxy_temp_file_write_size   【默认值是proxy_buffer_size指令和proxy_buffers指令定义的每块缓冲区大小的两倍】</span><br><span class="line">    在开启缓冲后端服务器响应到临时文件的功能后，设置nginx每次写数据到临时文件的size(大小)限制。   </span><br><span class="line">proxy_max_temp_file_size  【默认值1024m，设置0时禁止响应写入临时文件】</span><br><span class="line">    打开响应缓冲以后，如果整个响应不能存放在proxy_buffer_size和proxy_buffers指令设置的缓冲区内，部分响应可以存放在临时文件中。 这条指令可以设置临时文件的最大容量。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>proxy_set_header Host $host解析</p>
<ul>
<li>Host的含义是表明请求的主机名</li>
<li>$http_host为请求头中的Host信息，可能为空</li>
<li>$host可以在多个地方取值，但主要为代理服务器端接受请求的域名【如外网域名】</li>
<li>$proxy_host主要为被代理的主机ip或域名【一般为内网域名或ip】</li>
</ul>
</li>
<li><p>使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># location</span><br><span class="line">proxy_pass http://server;</span><br></pre></td></tr></table></figure>
<h2 id="realip设置"><a href="#realip设置" class="headerlink" title="realip设置"></a>realip设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编译参数--with-http_realip_module</span><br><span class="line"># 参数位置：http, server, location</span><br><span class="line"># waf：</span><br><span class="line">set_real_ip_from 121.43.18.0/24;</span><br><span class="line">set_real_ip_from 120.25.115.0/24;</span><br><span class="line">set_real_ip_from 101.200.106.0/24;</span><br><span class="line">set_real_ip_from 120.55.177.0/24;</span><br><span class="line">set_real_ip_from 120.27.173.0/24;</span><br><span class="line">set_real_ip_from 120.55.107.0/24;</span><br><span class="line">set_real_ip_from 118.178.15.0/24;</span><br><span class="line">set_real_ip_from 123.57.117.0/24;</span><br><span class="line">set_real_ip_from 120.76.16.0/24;</span><br><span class="line">set_real_ip_from 182.92.253.32/27;</span><br><span class="line">set_real_ip_from 60.205.193.64/27;</span><br><span class="line">set_real_ip_from 60.205.193.96/27;</span><br><span class="line">set_real_ip_from 120.78.44.128/26;</span><br><span class="line">set_real_ip_from 118.178.15.224/27;</span><br><span class="line"># cdn：</span><br><span class="line">set_real_ip_from 140.205.127.0/25;</span><br><span class="line">set_real_ip_from 140.205.253.128/25;</span><br><span class="line">set_real_ip_from 139.196.128.128/25;</span><br><span class="line">set_real_ip_from 101.200.101.0/25;</span><br><span class="line">real_ip_header    X-Forwarded-For;</span><br><span class="line">real_ip_recursive on;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_real_ip_from 121.43.18.0/24; </span><br><span class="line">    设置代理服务器地址</span><br><span class="line">real_ip_header X-Forwarded-For; </span><br><span class="line">    设置读取真实ip的地址源header</span><br><span class="line">real_ip_recursive   on; </span><br><span class="line">    使用realip算法递归获取真实ip</span><br></pre></td></tr></table></figure>
<h2 id="proxy实验数据"><a href="#proxy实验数据" class="headerlink" title="proxy实验数据"></a>proxy实验数据</h2><h3 id="无代理模式"><a href="#无代理模式" class="headerlink" title="无代理模式"></a>无代理模式</h3><ul>
<li>$remote_addr：114.242.249.63</li>
<li>$http_x_real_ip：-</li>
<li>$http_x_forwarded_for：-</li>
<li>$proxy_add_x_forwarded_for：114.242.249.63</li>
</ul>
<h3 id="cdn-waf模式"><a href="#cdn-waf模式" class="headerlink" title="cdn+waf模式"></a>cdn+waf模式</h3><p>客户端-》cdn-》waf-》nginx</p>
<ul>
<li>$proxy_add_x_forwarded_for：210.12.208.226; 101.200.101.36; 123.57.117.131</li>
<li>$http_x_forwarded_for：210.12.208.226; 101.200.101.36</li>
<li>$http_x_real_ip：101.200.101.36</li>
<li>$remote_addr：123.57.117.131</li>
</ul>
<h3 id="waf模式"><a href="#waf模式" class="headerlink" title="waf模式"></a>waf模式</h3><p>客户端-》waf-》nginx</p>
<ul>
<li>$proxy_add_x_forwarded_for：114.242.249.63; 123.57.117.131</li>
<li>$http_x_forwarded_for：114.242.249.63</li>
<li>$http_x_real_ip：114.242.249.63</li>
<li>$remote_addr：123.57.117.131</li>
</ul>
<h3 id="cdn模式"><a href="#cdn模式" class="headerlink" title="cdn模式"></a>cdn模式</h3><p>客户端-》cdn-》nginx</p>
<ul>
<li>$proxy_add_x_forwarded_for：114.242.249.63; 101.200.101.42</li>
<li>$http_x_forwarded_for：114.242.249.63</li>
<li>$http_x_real_ip：- </li>
<li>$remote_addr：101.200.101.42</li>
</ul>
<h1 id="在线升级"><a href="#在线升级" class="headerlink" title="在线升级"></a>在线升级</h1><h2 id="nginx相关信号"><a href="#nginx相关信号" class="headerlink" title="nginx相关信号"></a>nginx相关信号</h2><blockquote>
<p>可以通过向nginx主进程发送相关信号控制nginx</p>
</blockquote>
<ul>
<li>TERM、INT：快速关闭nginx</li>
<li>QUIT：优雅关闭nginx【待处理完请求才关闭】</li>
<li>HUP：变更配置文件时，新的worker进程使用新配置文件，老的worker使用旧配置文件</li>
<li>USR1：打开一个新的日志文件</li>
<li>USR2：升级nginx二进制文件【使用新的二进制文件启动进程】</li>
<li>WINCH：优雅关闭worker进程</li>
</ul>
<h2 id="编译新的二进制文件"><a href="#编译新的二进制文件" class="headerlink" title="编译新的二进制文件"></a>编译新的二进制文件</h2><p>只需configure和make，不需要make install</p>
<h2 id="二进制文件替换"><a href="#二进制文件替换" class="headerlink" title="二进制文件替换"></a>二进制文件替换</h2><ul>
<li>备份旧的nginx二进制文件</li>
<li>复制新的nginx二进制文件：cp objs/nginx /usr/local/nginx/sbin/nginx<ul>
<li>异常(提示文件被占用)：cp: cannot create regular file ‘/usr/local/nginx/sbin/nginx’: Text file busy</li>
<li>处理(强制覆盖)：cp -rfp objs/nginx /usr/local/nginx/sbin/nginx</li>
</ul>
</li>
</ul>
<h2 id="配置文件语法检测"><a href="#配置文件语法检测" class="headerlink" title="配置文件语法检测"></a>配置文件语法检测</h2><p>nginx -t</p>
<h2 id="给nginx发送信号"><a href="#给nginx发送信号" class="headerlink" title="给nginx发送信号"></a>给nginx发送信号</h2><ul>
<li>发送USR2信号使用新的二进制文件启动进程：sudo kill -USR2 4563</li>
<li>发送WINCH信号逐步停止旧的实例，让旧二进制文件启动的进程从容关闭：sudo kill -WINCH 4563</li>
</ul>
<blockquote>
<p>一段时间后，旧的工作进程处理了所有已连接的请求后退出，就仅由新的工作进程来处理输入的请求了</p>
</blockquote>
<h2 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h2><h3 id="当新进程有问题时"><a href="#当新进程有问题时" class="headerlink" title="当新进程有问题时"></a>当新进程有问题时</h3><ul>
<li>发送 HUP 信号给旧的主进程 - 它将在不重载配置文件的情况下启动它的工作进程</li>
<li>发送 QUIT 信号给新的主进程，要求其从容关闭其工作进程</li>
<li>如果新主进程还没退出，发送 TERM 信号给新的主进程，迫使其退出</li>
<li>如果因为某些原因新的工作进程不能退出，向其发送 KILL 信号（9）</li>
</ul>
<h3 id="如果升级成功时"><a href="#如果升级成功时" class="headerlink" title="如果升级成功时"></a>如果升级成功时</h3><p>发送 QUIT 信号给旧的主进程使其退出而只留下新的服务器运行</p>
<h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><ul>
<li>$arg_PARAMETER： 这个变量值为GET请求中变量名PARAMETER参数的值。</li>
<li>$args：这个变量等于GET请求中的参数。例如，foo=123&amp;bar=blahblah;这个变量只可以被修改<ul>
<li>$query_string 与$args相同</li>
<li>范例：foo=123&amp;bar=blahblah</li>
</ul>
</li>
<li>$uri：指的是请求的文件和路径，不包含”?”或者”#”之类的东西<ul>
<li>范例：/docs/2.2/zh-cn/mod/mod_rewrite.html</li>
</ul>
</li>
<li>$request_uri：则指的是请求的整个字符串，包含了后面请求的东西<ul>
<li>范例：/search?q=apache+rewrite</li>
</ul>
</li>
<li>$request：请求行信息【请求方法  请求url  使用的http协议】</li>
<li>$remote_user：通过基本授权【auth_basic】进行登录时的用户名</li>
<li>$time_local：处理请求时的系统时间</li>
<li>$status：返回给客户端的状态码</li>
<li>$body_bytes_sent：返回给客户端的数据大小</li>
<li>$http_referer：这个请求的referer信息【由哪个url跳转进来的请求】</li>
<li>$http_user_agent：客户端浏览器信息</li>
<li>$host 取用顺序：<ul>
<li>请求行中的主机名</li>
<li>来自请求头中【Host】信息</li>
<li>与该请求所匹配的server name【nginx配置】。</li>
</ul>
</li>
</ul>
<h2 id="apache变量"><a href="#apache变量" class="headerlink" title="apache变量"></a>apache变量</h2><ul>
<li>QUERY_STRING：get请求中的参数<ul>
<li>范例：foo=123&amp;bar=blahblah</li>
</ul>
</li>
<li>REQUEST_URI：请求的资源信息【请求的文件和路径，不含查询字符串】<ul>
<li>范例：/docs/2.2/zh-cn/mod/mod_rewrite.html</li>
</ul>
</li>
</ul>
<h1 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a><a href="http://tengine.taobao.org/nginx_docs/cn/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a>指令</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>语法：rewrite regex replacement [flag]；</li>
<li>上下文：server，location，if</li>
<li>含义<ul>
<li>如果指定的正则表达式能匹配URI，此URI将被replacement参数定义的字符串改写。</li>
<li>rewrite指令按其在配置文件中出现的顺序执行。</li>
<li>flag可以终止后续指令的执行。</li>
<li>如果replacement的字符串以“http://”或“https://”开头，nginx将结束执行过程，并返回给客户端一个重定向。 </li>
</ul>
</li>
</ul>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><ul>
<li>last 停止这一轮的rewrite指令，然后查找匹配改变后URI的新location</li>
<li>break 停止这一轮的rewrite指令</li>
<li>redirect 在replacement字符串中为出现http://或https://开头时，返回302临时重定向</li>
<li>permanent 返回301永久重定向</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><h3 id="网站改版"><a href="#网站改版" class="headerlink" title="网站改版"></a>网站改版</h3><blockquote>
<p>由于旧的url被搜索引擎收录，所以要实现：旧的url经过301跳转到新的url后，依然可以访问同一资源内容【网页内容一致】</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    if ($uri = &quot;/overviewSystem.html&quot;)&#123;</span><br><span class="line">            rewrite .* &quot;/winTheTustomer.html&quot; permanent;</span><br><span class="line">    &#125;</span><br><span class="line">    root /data/font/www;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location /dynamic/ &#123;</span><br><span class="line">    if ($uri = &quot;/dynamic/list/1.html&quot;)&#123;</span><br><span class="line">        rewrite .* &quot;/articleList/dynamic.html&quot; permanent;</span><br><span class="line">    &#125;</span><br><span class="line">    rewrite ^/dynamic(.*)$ $1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 访问www.abc.com/overviewSystem.html重定向到www.abc.com/winTheTustomer.html</span><br><span class="line">2. 访问www.abc.com/dynamic/list/1.html重定向到www.abc.com/articleList/dynamic.html</span><br><span class="line">3. 访问www.abc.com/dynamic[url]重定向到www.abc.com[url]</span><br></pre></td></tr></table></figure>
<h3 id="user-agent判断"><a href="#user-agent判断" class="headerlink" title="user_agent判断"></a>user_agent判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">rewrite ^(.*)$ /images/$1 break;&#125;</span><br><span class="line">if ($http_user_agent ~* &quot;android|iphone&quot;)</span><br><span class="line">&#123; proxy_pass http://192.168.100.3;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~* \.(jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar)$ &#123;  </span><br><span class="line">valid_referers none blocked *.ixdba1.net ixdba1.net;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">rewrite ^/ http://www.ixdba.net/img/error.gif;</span><br><span class="line">&#125;  </span><br><span class="line">valid_referers 定义需要处理防盗链的文件(如jpg等)，ixdba1.net表示这个请求可以正常访问上面指定的文件资源。</span><br><span class="line">if&#123;&#125;中的内容的意思是：如果地址不是上面指定的地址就跳转到通过rewrite指定的地址</span><br></pre></td></tr></table></figure>
<h3 id="首页301跳转"><a href="#首页301跳转" class="headerlink" title="首页301跳转"></a>首页301跳转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rewrite ^(.*)$  https://$host$1 permanent;【与下面return301效果相同】</span><br><span class="line"># return 301 https://$server_name$request_uri;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>如果replacement字符串包括新的请求参数，以往的请求参数会添加到新参数后面。如果不希望这样，在replacement字符串末尾加一个问号“？”，就可以避免，比如：<code>rewrite ^/users/(.*)$ /show?user=$1? last;</code></li>
<li>如果正则表达式中包含字符“}”或者“;”，整个表达式应该被包含在单引号或双引号的引用中。</li>
<li>apache的rewrite转换为nginx的rewrite：<a href="https://stackoverflow.com/questions/20870220/whats-0-in-nginx-mod-rewrite" target="_blank" rel="noopener">Try use $uri or $request_uri instead $0</a></li>
</ul>
<h1 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header Access-Control-Allow-Methods &apos;*&apos;;  # 指定允许跨域的方法，*代表所有</span><br><span class="line">add_header Access-Control-Max-Age 3600;   # 预检命令的缓存，如果不缓存每次会发送两次请求</span><br><span class="line">add_header Access-Control-Allow-Credentials &apos;true&apos;;   # 带cookie请求需要加上这个字段，并设置为true</span><br><span class="line">add_header Access-Control-Allow-Origin $http_origin;  # 表示允许这个域跨域调用（客户端发送请求的域名和端口）  $http_origin动态获取请求客户端请求的域 不用*的原因是带cookie的请求不支持*号</span><br><span class="line">add_header Access-Control-Allow-Headers $http_access_control_request_headers;  # 表示请求头的字段动态获取</span><br><span class="line">if ($request_method = &apos;OPTIONS&apos;)&#123;  # OPTIONS预检命令，预检命令通过时才发送请求，检查请求的类型是不是预检命令【因为是判断url变量，所以此选项位于location下】</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="与lua集成设置"><a href="#与lua集成设置" class="headerlink" title="与lua集成设置"></a>与lua集成设置</h1><h2 id="依赖软件下载"><a href="#依赖软件下载" class="headerlink" title="依赖软件下载"></a>依赖软件下载</h2><ul>
<li><a href="http://nginx.org/download/nginx-1.12.0.tar.gz" target="_blank" rel="noopener">nginx</a></li>
<li><a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz" target="_blank" rel="noopener">luajit</a>：Lua即时编译器</li>
<li><a href="https://www.kyne.com.au/~mark/software/download/lua-cjson-2.1.0.tar.gz" target="_blank" rel="noopener">lua-cjson</a>：lua语言cjson库</li>
<li><a href="https://github.com/simpl/ngx_devel_kit.git" target="_blank" rel="noopener">ngx_devel_kit</a>：是一个拓展nginx服务器核心功能的模块，第三方模块开发可以基于它来快速实现。</li>
<li><a href="https://github.com/openresty/lua-nginx-module.git" target="_blank" rel="noopener">lua-nginx-module</a>：可在 Nginx 中嵌入 Lua 语言，让 Nginx 可以支持 Lua 强大的语法。</li>
<li><a href="https://github.com/openresty/redis2-nginx-module.git" target="_blank" rel="noopener">redis2-nginx-module</a>：是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。</li>
<li><a href="https://github.com/openresty/set-misc-nginx-module.git" target="_blank" rel="noopener">set-misc-nginx-module</a>：是标准的HttpRewriteModule指令的扩展，提供更多的功能，如URI转义与非转义、JSON引述，Hexadecimal、MD5、SHA1、Base32、Base64编码与解码、随机数等等</li>
<li><a href="https://github.com/openresty/echo-nginx-module.git" target="_blank" rel="noopener">echo-nginx-module</a>：是一个 Nginx 模块，提供直接在 Nginx 配置使用包括 “echo”, “sleep”, “time” 等指令。</li>
</ul>
<h2 id="lua语言环境安装"><a href="#lua语言环境安装" class="headerlink" title="lua语言环境安装"></a>lua语言环境安装</h2><ol>
<li>lujit安装：<ul>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li>cjson安装：<ul>
<li>修改Makefile【LUA_INCLUDE_DIR =   $(PREFIX)/include/luajit-2.0】</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li>链接库文件<ul>
<li>sudo ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2</li>
<li>sudo ldconfig</li>
</ul>
</li>
</ol>
<h2 id="nginx编译参数"><a href="#nginx编译参数" class="headerlink" title="nginx编译参数"></a>nginx编译参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--with-http_addition_module --add-module=../ngx_devel_kit --add-module=../lua-nginx-module \</span><br><span class="line">--add-module=../echo-nginx-module --add-module=../redis2-nginx-module \</span><br><span class="line">--add-module=../set-misc-nginx-module</span><br></pre></td></tr></table></figure>
<h2 id="lua使用"><a href="#lua使用" class="headerlink" title="lua使用"></a>lua使用</h2><h3 id="waf功能简介-config-lua"><a href="#waf功能简介-config-lua" class="headerlink" title="waf功能简介(config.lua)"></a><a href="https://github.com/unixhot/waf.git" target="_blank" rel="noopener">waf</a>功能简介(<a href="https://github.com/simple0426/sysadm/blob/master/config/web/nginx/conf/waf/config.lua" target="_blank" rel="noopener">config.lua</a>)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config_waf_enable = &quot;on&quot;   #是否开启配置</span><br><span class="line">config_log_dir = &quot;/tmp/waf_logs&quot;    #日志记录地址</span><br><span class="line">config_rule_dir = &quot;/usr/local/nginx/conf/waf/rule-config&quot;         #匹配规则所放地址</span><br><span class="line">config_white_url_check = &quot;on&quot;  #是否开启url检测</span><br><span class="line">config_white_ip_check = &quot;on&quot;   #是否开启IP白名单检测</span><br><span class="line">config_black_ip_check = &quot;on&quot;   #是否开启ip黑名单检测</span><br><span class="line">config_url_check = &quot;on&quot;      #是否开启url过滤</span><br><span class="line">config_url_args_check = &quot;on&quot;   #是否开启参数检测</span><br><span class="line">config_user_agent_check = &quot;on&quot;  #是否开启ua检测</span><br><span class="line">config_cookie_check = &quot;on&quot;    #是否开启cookie检测</span><br><span class="line">config_cc_check = &quot;on&quot;   #是否开启防cc攻击</span><br><span class="line">config_cc_rate = &quot;10/60&quot;   #允许一个ip60秒内只能访问10次</span><br><span class="line">config_post_check = &quot;on&quot;   #是否开启post检测</span><br><span class="line">config_waf_output = &quot;html&quot;  #action一个html页面，也可以选择跳转</span><br><span class="line">config_waf_redirect_url = &quot;http://www.baidu.com&quot; </span><br><span class="line">config_output_html=[[  #下面是html的内容</span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot; /&gt; </span><br><span class="line">&lt;title&gt;网站防火墙&lt;/title&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;h1 align=&quot;center&quot;&gt; # 您的行为已违反本网站相关规定，注意操作规范。详情请联微信公众号：chuck-blog。 </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt; </span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<h3 id="nginx设置"><a href="#nginx设置" class="headerlink" title="nginx设置"></a>nginx设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    map $http_x_forwarded_for  $clientRealIp &#123;</span><br><span class="line">            &quot;&quot;      $remote_addr;</span><br><span class="line">            ~^(?P&lt;firstAddr&gt;[0-9\.]+),?.*$  $firstAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_shared_dict limit 50m;  #防cc使用字典，大小50M</span><br><span class="line">    lua_package_path &quot;/home/zj-ops/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">    init_by_lua_file &quot;/home/zj-ops/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">    access_by_lua_file &quot;/home/zj-ops/nginx/conf/waf/access.lua&quot;;</span><br><span class="line">    server &#123;</span><br><span class="line">        location /lua &#123;</span><br><span class="line">            echo &quot;Hello lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        location /lua_test &#123;</span><br><span class="line">            content_by_lua &apos;ngx.say(&quot;Hello Lua! Simple.&quot;)&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><ul>
<li>防sql注入测试：curl <a href="http://127.0.0.1/q.sql" target="_blank" rel="noopener">http://127.0.0.1/q.sql</a></li>
<li>cc防护测试：ab -c 100 -n 100  <a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a></li>
</ul>
<h2 id="lua集成redis"><a href="#lua集成redis" class="headerlink" title="lua集成redis"></a>lua集成redis</h2><p><a href="https://github.com/openresty/lua-resty-redis.git" target="_blank" rel="noopener">lua-resty-redis</a>提供一个lua语言版的redis API，使用socket（lua sock）和redis通信。</p>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua_package_path &quot;/home/zj-ops/nginx/conf/lua-resty-redis/lib/?.lua;&quot;;</span><br><span class="line">        location =/content_by_lua_block &#123;</span><br><span class="line">        default_type &apos;text/plain&apos;;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            ngx.say(&apos;Hello: content_by_lua_block&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    location /lua_redis_basic&#123;</span><br><span class="line">        default_type &apos;text/html&apos;;</span><br><span class="line">        lua_code_cache off;</span><br><span class="line">        content_by_lua_file /home/zj-ops/nginx/conf/self_lua/test_redis_basic.lua;</span><br><span class="line">        #access_by_lua_file /home/zj-ops/nginx/conf/self_lua/access_flow_control.lua;</span><br><span class="line">        content_by_lua &apos;ngx.say(&quot;Hello Lua! Simple.&quot;)&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="redis功能测试"><a href="#redis功能测试" class="headerlink" title="redis功能测试"></a>redis功能测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local function close_redis(redis_instance)</span><br><span class="line">    if not redis_instance then</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    local ok,err = redis_instance:close();</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.say(&quot;close redis error : &quot;,err);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local redis = require(&quot;resty.redis&quot;);</span><br><span class="line">--local redis = require &quot;redis&quot;</span><br><span class="line">-- 创建一个redis对象实例。在失败，返回nil和描述错误的字符串的情况下</span><br><span class="line">local redis_instance = redis:new();</span><br><span class="line">--设置后续操作的超时（以毫秒为单位）保护，包括connect方法</span><br><span class="line">redis_instance:set_timeout(1000)</span><br><span class="line">--建立连接</span><br><span class="line">local ip = &apos;127.0.0.1&apos;</span><br><span class="line">local port = 6379</span><br><span class="line">--尝试连接到redis服务器正在侦听的远程主机和端口</span><br><span class="line">local ok,err = redis_instance:connect(ip,port)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;connect redis error : &quot;,err)</span><br><span class="line">    return close_redis(redis_instance);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--Redis身份验证</span><br><span class="line">local auth,err = redis_instance:auth(&quot;foobared&quot;);</span><br><span class="line">if not auth then</span><br><span class="line">    ngx.say(&quot;failed to authenticate : &quot;,err)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--调用API进行处理</span><br><span class="line">local resp,err = redis_instance:set(&quot;msg&quot;,&quot;hello world&quot;)</span><br><span class="line">if not resp then</span><br><span class="line">    ngx.say(&quot;set msg error : &quot;,err)</span><br><span class="line">    return close_redis(redis_instance)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--调用API获取数据  </span><br><span class="line">local resp, err = redis_instance:get(&quot;msg&quot;)  </span><br><span class="line">if not resp then  </span><br><span class="line">    ngx.say(&quot;get msg error : &quot;, err)  </span><br><span class="line">    return close_redis(redis_instance)  </span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">--得到的数据为空处理  </span><br><span class="line">if resp == ngx.null then  </span><br><span class="line">    resp = &apos;this is not redis_data&apos;  --比如默认值  </span><br><span class="line">end  </span><br><span class="line">ngx.say(&quot;msg : &quot;, resp)  </span><br><span class="line">  </span><br><span class="line">close_redis(redis_instance)</span><br><span class="line"></span><br><span class="line"># 测试：http://127.0.0.1/lua_redis_basic </span><br><span class="line">返回：【msg : hello world】说明redis可用</span><br></pre></td></tr></table></figure>
<h3 id="实现cc防护"><a href="#实现cc防护" class="headerlink" title="实现cc防护"></a>实现cc防护</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- access_by_lua_file &apos;/opt/ops/lua/access_limit.lua&apos;</span><br><span class="line">local function close_redis(red)</span><br><span class="line">    if not red then</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    --释放连接(连接池实现)</span><br><span class="line">    local pool_max_idle_time = 10000 --毫秒</span><br><span class="line">    local pool_size = 100 --连接池大小</span><br><span class="line">    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line"></span><br><span class="line">    if not ok then</span><br><span class="line">        ngx_log(ngx_ERR, &quot;set redis keepalive error : &quot;, err)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local redis = require &quot;resty.redis&quot;</span><br><span class="line">local red = redis:new()</span><br><span class="line">red:set_timeout(1000)</span><br><span class="line">local ip = &quot;127.0.0.1&quot;</span><br><span class="line">local port = 6379</span><br><span class="line">local ok, err = red:connect(ip,port)</span><br><span class="line">local auth, err = red:auth(&quot;foobared&quot;)</span><br><span class="line">if not ok or not auth then</span><br><span class="line">    return close_redis(red)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local clientIP = ngx.req.get_headers()[&quot;X-Real-IP&quot;]</span><br><span class="line">if clientIP == nil then</span><br><span class="line">   clientIP = ngx.req.get_headers()[&quot;x_forwarded_for&quot;]</span><br><span class="line">end</span><br><span class="line">if clientIP == nil then</span><br><span class="line">   clientIP = ngx.var.remote_addr</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local incrKey = &quot;user:&quot;..clientIP..&quot;:freq&quot;</span><br><span class="line">local blockKey = &quot;user:&quot;..clientIP..&quot;:block&quot;</span><br><span class="line"></span><br><span class="line">local is_block,err = red:get(blockKey) -- check if ip is blocked</span><br><span class="line">if tonumber(is_block) == 1 then</span><br><span class="line">   ngx.exit(ngx.HTTP_FORBIDDEN)</span><br><span class="line">   return close_redis(red)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">res, err = red:incr(incrKey)</span><br><span class="line"></span><br><span class="line">if res == 1 then</span><br><span class="line">   res, err = red:expire(incrKey,1)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 1秒超过10次视为非法ip，进入黑名单</span><br><span class="line">if res &gt; 10 then</span><br><span class="line">    res, err = red:set(blockKey,1)</span><br><span class="line">    -- 每个黑名单ip封禁60秒</span><br><span class="line">    res, err = red:expire(blockKey,60)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">close_redis(red)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="其他功能与参考"><a href="#其他功能与参考" class="headerlink" title="其他功能与参考"></a>其他功能与参考</h1><ul>
<li><a href="https://blog.51cto.com/storysky/642970" target="_blank" rel="noopener">nginx限制连接模块-limit</a></li>
<li><a href="https://blog.csdn.net/force_eagle/article/details/51966333" target="_blank" rel="noopener">NGINX 结合 lua 动态修改upstream</a><ul>
<li>模块代码：<a href="https://github.com/openresty/lua-upstream-nginx-module#set_peer_down" target="_blank" rel="noopener">https://github.com/openresty/lua-upstream-nginx-module#set_peer_down</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/woshizhangliang999/article/details/51861998" target="_blank" rel="noopener">Nginx+Tomcat+SSL 识别 https还是http</a></li>
<li><a href="https://blog.csdn.net/lzw_2006/article/details/51768935" target="_blank" rel="noopener">高并发之系统限流</a></li>
<li><a href="http://www.cnblogs.com/tinywan/p/6534151.html" target="_blank" rel="noopener">Nginx + Lua + Redis 已安装成功(非openresty 方式安装)</a></li>
<li><a href="http://blog.csdn.net/fenglvming/article/details/51996406" target="_blank" rel="noopener">nginx + lua + redis 防刷和限流</a></li>
<li><a href="http://blog.csdn.net/u011085172/article/details/71515745" target="_blank" rel="noopener">nginx 不中断服务 平滑升级</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>rewrite</tag>
        <tag>nginx</tag>
        <tag>proxy</tag>
        <tag>lua</tag>
        <tag>waf</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat配置与优化</title>
    <url>/blog/2019/06/06/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/web%E6%9C%8D%E5%8A%A1/tomcat%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="JAVA程序"><a href="#JAVA程序" class="headerlink" title="JAVA程序"></a>JAVA程序</h1><h2 id="java程序"><a href="#java程序" class="headerlink" title="java程序"></a>java程序</h2><ul>
<li>java程序设计语言</li>
<li>java api【库函数】</li>
<li>java class文件</li>
<li>jvm：java虚拟机【字节码运行环境】<ul>
<li>JRE：java运行时环境，只能运行class文件；</li>
<li>JDK：java开发环境，可将java程序编译为class文件；</li>
</ul>
</li>
</ul>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/java-1.png" alt></p>
<h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><blockquote>
<p>Servlet类文件放到WEB-INF\classes目录下。</p>
</blockquote>
<p>Servlet（小服务程序）是一个与协议无关的、跨平台的Web组件，它基于Java技术开发，由Servlet容器所管理。和运行在客户端浏览器中的Applet（小应用程序）相似，Servlet运行在服务器端。Servlet采用“请求—响应”模式提供Web服务，交互式地浏览和修改数据，生成动态Web内容。<br>Servlet是平台独立的Java类，即按照Servlet规范编写的Java类，所以具有Java语言的所有优点，如良好的可移植性及安全性等。Servlet被编译为平台中立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行，就如同Applet对客户端一样，区别在于Servlet运行并不需要图形用户界面。<br>Java Servlet具有如下优点：  </p>
<ul>
<li>Servlet可以和其他资源（数据库、文件、Applet和Java应用程序等）交互，把生成的响应内容返回给客户端。如果需要，还可以保存“请求—响应”过程中的信息。</li>
<li>服务器采用Servlet可以完全授权对本地资源的访问，Servlet自身也会控制外部  用户的访问数量及访问性质。</li>
<li>Servlet可以从本地硬盘，或者通过网络从远端硬盘来激活。</li>
<li>通过Servlet Tag技术（注：即HTML中标签），可以在HTML页面中动态调用Servlet。</li>
<li>Servlet可以是其他服务的客户端程序。</li>
<li>通过链接技术，一个Servlet可以调用另一个或一系列Servlet来成为它的客户端。</li>
<li>Servlet API与协议无关。</li>
</ul>
<h2 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h2><p>是由Sun Microsystems公司倡导，在传统的网页HTML文件(<em>.htm,</em>.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。<br>相应的ASP是微软公司倡导的。ASP是Active Server Page的缩写，意为“动态服务器页面”。ASP是微软公司开发的代替CGI脚本程序的一种应用，它可以与数据库和其它程序进行交互，是一种简单、方便的编程工具。ASP的网页文件的格式是 .asp。<br> jsp 要先翻译成servlet才能执行。JSP文件第一次执行时，要先由Tomcat将其转化为Servlet文件，然后编译，所以速度会慢一些，但后继执行时速度会很快；比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class。而 test_jsp.java 本身就是一个servlet。所以 jsp只是servlet的一个变种，方便书写html内容才出现的。  </p>
<h2 id="war"><a href="#war" class="headerlink" title="war"></a>war</h2><p>在建立WAR文件之前，需要建立正确的Web应用程序的目录层次结构：</p>
<ol>
<li>建立WEB-INF子目录，并在该目录下建立classes与lib两个子目录。</li>
<li>将Servlet类文件放到WEB-INF\classes目录下，将Web应用程序所使用Java类库文件（即JAR文件）放到WEB-INF\lib目录下。</li>
<li>建立web.xml文件，放到WEB-INF目录下。</li>
<li>根据Web应用程序的需求，将JSP页面或静态HTML页面放到上下文根路径下或其子目录下。</li>
<li>如果有需要，建立META-INF目录</li>
</ol>
<p>要注意的是，虽然WAR文件和JAR文件的文件格式是一样的，并且都是使用jar命令来创建，但就其应用来说，WAR文件和JAR文件是有根本区别的。JAR文件的目的是把类和相关的资源封装到压缩的归档文件中，而对于WAR文件来说，一个WAR文件代表了一个Web应用程序，它可以包含Servlet、HTML页面、Java类、图像文件，以及组成Web应用程序的其他资源，而不仅仅是类的归档文件。</p>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/index.html" target="_blank" rel="noopener">tomcat</a></h1><p>与传统桌面应用程序不同，Tomcat中的应用程序是一个WAR（Web Archive）文件，它是许多文件构成的一个压缩包，包中的文件按照一定目录结构来组织，不同目录中的文件也具有不同的功能。部署应用程序时，只需要把WAR文件放到Tomcat的webapp目录下，Tomcat会自动检测和解压该文件。<br>Tomcat既是一个Servlet容器，又是一个独立运行的服务器，像IIS、Apache等Web服务器一样，具有处理HTML页面的功能。但它处理静态HTML文件的能力并不是太强，所以一般都是把它当作JSP/Servlet引擎，通过适配器（Adapter）与其他Web服务器软件（如Apache）配合使用。此外，Tomcat还可与其他一些软件集成起来实现更多功能，例如，与JBoss集成起来开发EJB、与OpenJMS集成起来开发JMS应用、与Cocoon（Apache的另外一个项目）集成起来开发基于XML的应用等。  </p>
<h2 id="tomcat目录"><a href="#tomcat目录" class="headerlink" title="tomcat目录"></a>tomcat目录</h2><h3 id="主要目录"><a href="#主要目录" class="headerlink" title="主要目录"></a>主要目录</h3><ul>
<li>bin：存放启动和关闭tomcat脚本</li>
<li>conf：存放配置文件【server.xml、web.xml、logging.properties】</li>
<li>lib：存放tomcat运行所需的库文件【jar】</li>
<li>logs：存放tomcat运行时产生的日志</li>
<li>webapps：tomcat的主要web程序发布目录</li>
<li>work：存放jsp编译后产生的class文件</li>
</ul>
<h3 id="脚本设置"><a href="#脚本设置" class="headerlink" title="脚本设置"></a>脚本设置</h3><blockquote>
<p>catalina.sh变量设置；官方建议在bin目录下单独建立setenv.sh文件设置变量</p>
</blockquote>
<ul>
<li>CATALINA_OUT：设置标准输出和错误输出，默认$CATALINA_BASE/logs/catalina.out</li>
<li>CATALINA_OPTS：运行start、run、debug命令时的选项，但不被stop进程使用</li>
<li>JAVA_HOME：设置jdk路径</li>
<li>JAVA_OPTS：java运行时的选项，包含所有命令，当然也包含stop进程</li>
<li>CATALINA_PID：设置进程pid，pid在强制停止【kill】进程时使用</li>
</ul>
<h3 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h3><ul>
<li>catalina.sh是控制tomcat启停的核心脚本</li>
<li>startup/shutdown脚本都是调用catalina.sh的</li>
<li>catalina.sh可选参数<ul>
<li>run：控制台运行tomcat</li>
<li>start：后台运行tomcat【在另一个窗口运行tomcat】</li>
<li>stop [n]：关闭tomcat<ul>
<li>-force：强制关闭tomcat【无法正常关闭时使用kill命令杀死进程】</li>
</ul>
</li>
<li>configtest：对server.xml进行语法检查</li>
</ul>
</li>
</ul>
<h2 id="server-xml配置"><a href="#server-xml配置" class="headerlink" title="server.xml配置"></a>server.xml配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Server&gt;</span><br><span class="line">    &lt;Service&gt;</span><br><span class="line">        &lt;Connector/&gt;</span><br><span class="line">        &lt;Engine&gt;</span><br><span class="line">            &lt;Host&gt;</span><br><span class="line">                &lt;Context&gt;</span><br><span class="line">                &lt;/Context&gt;</span><br><span class="line">            &lt;/Host&gt;</span><br><span class="line">         &lt;/Engine&gt;</span><br><span class="line">    &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>一个server代表整个catalina servlet容器：</p>
<ul>
<li>port：指定Tomcat服务器监听shutdown命令的端口</li>
<li>shutdown：指定终止tomcat服务器运行时，发给tomcat服务器shutdown监听端口的字符串</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>service是一个集合，它包含一个engine以及一个或多个connector组成</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>一个connector将在某个端口监听客户请求，并把请求交给engine处理，同时从engine获取响应返回给客户端</p>
<ul>
<li>http连接器：监听来自客户端的http请求；<ul>
<li>port：接受http请求的端口</li>
<li>redirectPort：如果端口不支持ssl时，将请求转发</li>
<li>connectionTimeout：请求超时时间【以毫秒计，默认20s，设置-1关闭超时】</li>
<li>maxHttpHeaderSize：请求和响应的http头部大小，以字节计数，【默认8192即8KB】</li>
<li>acceptCount：指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理【默认100】</li>
<li>maxConnections：任何时间都可以接收和处理的请求总数，超过此阈值但不超过acceptCount的请求依然可以接收【默认值10000】</li>
<li>minSpareThreads：tomcat保持的最小线程数【默认为10】</li>
<li>maxThreads：tomcat可以创建的最大线程数【默认200】</li>
<li>SSLEnabled：是否开启ssl【默认False】</li>
</ul>
</li>
<li>ajp连接器： 监听来自Webserver(apache)的servlet/jsp代理请求；<connector port="8009" protocol="AJP/1.3" redirectport="8443"></connector></li>
</ul>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>是一个service下的请求处理功能组件，可以包含多个虚拟主机(Host)</p>
<ul>
<li>defaultHost指定缺省的请求处理主机名，它至少与其中一个host元素的name属性值是一样</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>一个虚拟主机匹配一个域名，它可以包含多个应用(Context)</p>
<ul>
<li>name：主机名</li>
<li>appBase：应用程序基本目录，可以指定绝对路径，也可以指定相对于CATALINA_HOME的相对路径<ul>
<li>这个目录下面的子目录自动被当成应用被部署</li>
<li>这个目录下边的war文件自动被解压并作为应用部署</li>
</ul>
</li>
<li>unpackWARs：如果设置为true，则tomcat会自动解压war文件，否则直接运行war文件</li>
<li>autoDeploy：设置为true时，当tomcat处于运行状态时，能够监测appBase下的文件，如果有新的wweb加入的话，会自动发布这个web应用</li>
</ul>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>一个应用程序对应一个Context，一个web程序由一个或多个servlet组成</p>
<ul>
<li>docBase：【只有在应用不在appBase下才需要设置】应用程序的路径或者是war文件的路径</li>
<li>path：表示此web应用的url前缀</li>
<li>reloadable：如果设置为true，则tomcat会自动检测应用程序的WEB-INF/lib和WEB-INF/classes目录下class文件变化，自动重载新的应用程序，这样可以在不重启tomcat情况下改变应用程序</li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p>可以在（Engine, Host, or Context）级别设置不同功能的阈值，以下以设定访问日志为例</p>
<ul>
<li>className=”org.apache.catalina.valves.AccessLogValve”：访问日志类名</li>
<li>directory=”logs”：日志存储目录</li>
<li>prefix=”localhost_access_log” ：日志文件前缀</li>
<li>suffix=”.txt”：日志文件后缀</li>
<li>pattern=”[%{yyyy-MM-dd HH:mm:ss}t] &quot;%r&quot; %S &quot;%{postdata}r&quot; %s %{Referer}i [%{User-Agent}i] %T %b”：日志格式</li>
</ul>
<h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><ul>
<li>server.xml：配置访问日志【Value属性】<ul>
<li>需要在logrotate中配置日志轮询</li>
</ul>
</li>
<li>logging.properties：配置tomcat自身日志、console输出<ul>
<li>可以将1catalina、2localhost、3manager、4host-manager内容全部注释或将其prefix设置为同一个文件</li>
</ul>
</li>
<li>log4j.properties：项目自定义日志<ul>
<li>位置：项目WEB-INF/classes下</li>
</ul>
</li>
</ul>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><p>按照存储数据的内容，将内存分配为堆区(heap)和非堆区(non-heap)</p>
<ul>
<li>堆区：通过new的方式创建的对象(类实例)占用的内存空间，mv的垃圾回收机制可以回收堆区占用的内存，调优参数如下<ul>
<li><a href="https://segmentfault.com/q/1010000007235579?_ea=1280245" target="_blank" rel="noopener">-Xms n</a>：设置初始java堆【JVM】大小<ul>
<li>默认，JVM初始大小是物理内存的1/64，</li>
<li>最小是8MB</li>
</ul>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size" target="_blank" rel="noopener">-Xmx n</a>：设置最大java堆【JVM】大小<ul>
<li>默认，JVM最大大小是物理内存的1/4</li>
<li>【server模式下】最大值是32GB【此时内存大于等于128GB】</li>
<li>【client模式下】最大值是256MB【大于等于1GB都被当做1GB处理】</li>
</ul>
</li>
</ul>
</li>
<li>非堆区：代码、常量、外部访问(文件访问占用的资源流)等，调优参数如下<pre><code>+ -XX:MaxMetaspaceSize=n：设置metaspace的最大大小
+ 【-XX:PermSize和-XX:MaxPermSize】在java8中已被遗弃
</code></pre></li>
</ul>
<h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul>
<li>java性能调优书籍：《Java Performance: The Definitive Guide》</li>
<li><a href="https://blog.csdn.net/losetowin/article/details/78569001" target="_blank" rel="noopener">jvm设置</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb副本集与分片</title>
    <url>/blog/2019/12/01/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E4%B8%8E%E5%88%86%E7%89%87/</url>
    <content><![CDATA[<h1 id="副本集部署"><a href="#副本集部署" class="headerlink" title="副本集部署"></a>副本集部署</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>主机：172.16.0.201、172.16.0.215、172.16.0.205</li>
<li>201已建立用户及其权限<ul>
<li>readWriteAnyDatabase</li>
<li>clusterAdmin</li>
<li>userAdminAnyDatabase</li>
<li>dbAdminAnyDatabase</li>
</ul>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net: # 网络设置</span><br><span class="line">  port: 27017</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">security: </span><br><span class="line">  authorization: enabled # 开启用户认证</span><br><span class="line">  keyFile: /etc/mongo_key.txt #集群认证秘钥</span><br><span class="line">replication:</span><br><span class="line">  replSetName: &quot;rs0&quot; # 副本集名称设置</span><br></pre></td></tr></table></figure>
<h2 id="集群认证秘钥"><a href="#集群认证秘钥" class="headerlink" title="集群认证秘钥"></a>集群认证秘钥</h2><ul>
<li>产生：openssl rand -base64 32 -out mongo_key.txt</li>
<li>变更用户和权限<ul>
<li>chmod 0600 mongo_key.txt</li>
<li>chown mongodb mongo_key.txt</li>
</ul>
</li>
</ul>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><blockquote>
<p>登录其中一个节点(201)配置，配置后此节点即为主节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs.initiate( &#123;</span><br><span class="line">   _id : &quot;rs0&quot;,</span><br><span class="line">   members: [</span><br><span class="line">      &#123; _id: 0, host: &quot;172.16.0.201:27017&quot; &#125;,</span><br><span class="line">      &#123; _id: 1, host: &quot;172.16.0.215:27017&quot; &#125;,</span><br><span class="line">      &#123; _id: 2, host: &quot;172.16.0.205:27017&quot; &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="集群操作命令"><a href="#集群操作命令" class="headerlink" title="集群操作命令"></a>集群操作命令</h2><ul>
<li>查看状态：rs.status()</li>
<li>查看配置：rs.conf()</li>
<li>查看从机状态：db.printSlaveReplicationInfo();</li>
<li>查看复制状态：db.printReplicationInfo();</li>
</ul>
<h2 id="从机读设置"><a href="#从机读设置" class="headerlink" title="从机读设置"></a>从机读设置</h2><ul>
<li>默认，读写都在primary节点操作，如果在从机操作，则会报错：”not master and slaveOk=false”</li>
<li>从机客户端连接中设置可读：rs.slaveOk()</li>
<li>主机客户端设置读取策略：<ul>
<li>mongo连接级别：db.getMongo().setReadPref(‘secondary’)</li>
<li>连接内的指针级别：db.inventories.find().readPref(‘secondary’)</li>
</ul>
</li>
</ul>
<h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>此部署文档适用于MongoDB 4.2</li>
<li>由于从3.6开始，所有分片集群必须是副本集；所有低于3.6版本的分片想要升级，必须<ul>
<li>先将独立的分片集群转换为副本集</li>
<li>后将副本集升级为分片副本集集群</li>
</ul>
</li>
</ul>
<h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><ul>
<li>3节点数据副本集rs0【rs0/172.16.0.201:27017,172.16.0.215:27017,172.16.0.205:27017】</li>
<li>3节点数据副本集rs1【rs1/172.16.0.201:27027,172.16.0.215:27027,172.16.0.205:27027】</li>
<li>3节点配置副本集【configReplSet/172.16.0.201:29017,172.16.0.215:29017,172.16.0.205:29017】</li>
<li>单节点路由服务【172.16.0.201:30001】</li>
</ul>
<h2 id="架构部署预览"><a href="#架构部署预览" class="headerlink" title="架构部署预览"></a>架构部署预览</h2><ul>
<li><a href="#创建数据副本集">创建3节点数据副本集rs0，批量插入测试数据</a></li>
<li><a href="#创建配置副本集">创建配置副本集(configsrv)</a></li>
<li><a href="#创建路由服务">创建路由服务(mongos)</a></li>
<li><a href="#将数据副本集添加为分片节点">将数据副本集添加为分片节点</a></li>
<li>创建第二个分片节点，即副本集rs1</li>
<li><a href="#将期望的集合分片">将期望的集合分片</a></li>
</ul>
<h1 id="创建数据副本集"><a href="#创建数据副本集" class="headerlink" title="创建数据副本集"></a>创建数据副本集</h1><ul>
<li>参靠<a href="#副本集部署">mongodb副本集部署</a></li>
<li>使用自定义目录方式启动服务<ul>
<li>创建目录：mkdir -p /data/mongodb/rs0/{data,conf,log}</li>
<li>创建用户：useradd mongodb</li>
<li>对目录授权：chown -R mongodb.mongodb /data/mongodb/rs0</li>
</ul>
</li>
<li>设置副本集名称：replication.replSetName: “rs0”</li>
<li>命令行以指定用户启动服务：<code>chroot --userspec &quot;mongodb:mongodb&quot; &quot;/&quot; sh -c &quot;/usr/bin/mongod -f /data/mongodb/rs0/conf/mongod.conf&quot;</code></li>
<li><p>批量插入测试数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">var bulk = db.test_collection.initializeUnorderedBulkOp();</span><br><span class="line">people = [&quot;Marc&quot;, &quot;Bill&quot;, &quot;George&quot;, &quot;Eliot&quot;, &quot;Matt&quot;, &quot;Trey&quot;, &quot;Tracy&quot;, &quot;Greg&quot;, &quot;Steve&quot;, &quot;Kristina&quot;, &quot;Katie&quot;, &quot;Jeff&quot;];</span><br><span class="line">for(var i=0; i&lt;1000000; i++)&#123;</span><br><span class="line">   user_id = i;</span><br><span class="line">   name = people[Math.floor(Math.random()*people.length)];</span><br><span class="line">   number = Math.floor(Math.random()*10001);</span><br><span class="line">   bulk.insert( &#123; &quot;user_id&quot;:user_id, &quot;name&quot;:name, &quot;number&quot;:number &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bulk.execute();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将副本集转换为可分片模式</p>
<ul>
<li>连接集群从节点：关闭服务后、添加配置【sharding.clusterRole: shardsvr】、重启服务</li>
<li>连接集群主节点：主节点置为从【rs.stepDown()】、添加配置【sharding.clusterRole: shardsvr】、重启服务</li>
</ul>
</li>
</ul>
<h1 id="创建配置副本集"><a href="#创建配置副本集" class="headerlink" title="创建配置副本集"></a>创建配置副本集</h1><ul>
<li>参靠<a href="#副本集部署">mongodb副本集部署</a></li>
<li>设置配置集群选项<ul>
<li>replication.replSetName: “configReplSet”</li>
<li>sharding.clusterRole: configsvr</li>
</ul>
</li>
<li>初始化配置集群<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs.reconfig( &#123;</span><br><span class="line">   _id : &quot;configReplSet&quot;,</span><br><span class="line">  configsvr: true,</span><br><span class="line">   members: [</span><br><span class="line">      &#123; _id: 0, host: &quot;172.16.0.201:29017&quot; &#125;,</span><br><span class="line">      &#123; _id: 1, host: &quot;172.16.0.215:29017&quot; &#125;,</span><br><span class="line">      &#123; _id: 2, host: &quot;172.16.0.205:29017&quot; &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="创建路由服务"><a href="#创建路由服务" class="headerlink" title="创建路由服务"></a>创建路由服务</h1><ul>
<li>配置选项：<ul>
<li>sharding.configDB: configReplSet/172.16.0.201:29017,172.16.0.215:29017,172.16.0.205:29017</li>
<li>security.keyFile: /etc/mongo_key.txt</li>
</ul>
</li>
<li>启动服务：<code>chroot --userspec &quot;mongodb:mongodb&quot; &quot;/&quot; sh -c &quot;/usr/bin/mongos -f /data/mongodb/mongos/conf/mongos.conf&quot;</code></li>
</ul>
<h1 id="将数据副本集添加为分片节点"><a href="#将数据副本集添加为分片节点" class="headerlink" title="将数据副本集添加为分片节点"></a>将数据副本集添加为分片节点</h1><ul>
<li>连接到mongos并授权登录</li>
<li>添加副本集为分片节点：sh.addShard( “rs0/172.16.0.201:27017,172.16.0.215:27017,172.16.0.205:27017” )</li>
<li>查看集群分片状态：sh.status()</li>
</ul>
<h1 id="将期望的集合分片"><a href="#将期望的集合分片" class="headerlink" title="将期望的集合分片"></a>将期望的集合分片</h1><ul>
<li>连接到mongos并授权登录</li>
<li>数据库开启分片：sh.enableSharding( “test” )</li>
<li>在非空集合上添加索引：use test; db.test_collection.createIndex( { number : 1 } )</li>
<li>对集合分片：use test; sh.shardCollection( “test.test_collection”, { “number” : 1 } )</li>
<li>确认分片处于平衡状态<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">db.stats()</span><br><span class="line">db.printShardingStatus()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="数据节点mongod-conf"><a href="#数据节点mongod-conf" class="headerlink" title="数据节点mongod.conf"></a>数据节点mongod.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongodb/rs0/data</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/mongodb/rs0/log/mongod.log</span><br><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">processManagement:</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line">  fork: true</span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br><span class="line">  keyFile: /etc/mongo_key.txt</span><br><span class="line">replication:</span><br><span class="line">  replSetName: &quot;rs0&quot;</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br></pre></td></tr></table></figure>
<h2 id="配置节点configsrv-conf"><a href="#配置节点configsrv-conf" class="headerlink" title="配置节点configsrv.conf"></a>配置节点configsrv.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongodb/configdb/data</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/mongodb/configdb/log/config.log</span><br><span class="line">net:</span><br><span class="line">  port: 29017</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">processManagement:</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line">  fork: true</span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br><span class="line">  keyFile: /etc/mongo_key.txt</span><br><span class="line">replication:</span><br><span class="line">  replSetName: &quot;configReplSet&quot;</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr</span><br></pre></td></tr></table></figure>
<h2 id="路由服务mongos-conf"><a href="#路由服务mongos-conf" class="headerlink" title="路由服务mongos.conf"></a>路由服务mongos.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/mongodb/mongos/log/mongos.log</span><br><span class="line">net:</span><br><span class="line">  port: 30001</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">processManagement:</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line">  fork: true</span><br><span class="line">sharding:</span><br><span class="line">  configDB: configReplSet/172.16.0.201:29017,172.16.0.215:29017,172.16.0.205:29017</span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo_key.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>副本集</tag>
        <tag>分片</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从同步</title>
    <url>/blog/2019/09/29/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="复制简介"><a href="#复制简介" class="headerlink" title="复制简介"></a>复制简介</h1><h2 id="复制功能优势"><a href="#复制功能优势" class="headerlink" title="复制功能优势"></a>复制功能优势</h2><ul>
<li>横向扩展解决方案：更新和写操作在主库，读操作在从库</li>
<li>数据安全性：从库可以停止同步、延迟同步、执行数据备份</li>
<li>离线数据分析</li>
<li>远距离数据分发</li>
</ul>
<h2 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h2><ul>
<li><p>异步复制</p>
<ul>
<li>一般结构【默认】<ul>
<li>特点：单层结构、所有slave直接连接master</li>
</ul>
</li>
<li>级联复制【操作如下】<ul>
<li>主：开启binlog</li>
<li>主的从：开启binlog、log_slave_updates</li>
<li>从的从：正常配置</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-delayed.html" target="_blank" rel="noopener">延迟复制</a>【操作如下】<ul>
<li>STOP SLAVE</li>
<li>CHANGE MASTER TO MASTER_DELAY = N;【seconds】</li>
<li>START SLAVE</li>
</ul>
</li>
<li><p><a href="https://dinfratechsource.com/2018/11/11/configure-master-master-mysql-database-replication/" target="_blank" rel="noopener">双向复制</a>【官方无此说明】：正向、反向各做一次主从同步操作，配置文件如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># server-A</span><br><span class="line">server-id=1</span><br><span class="line">log-bin=&quot;mysql-bin&quot;</span><br><span class="line">log_slave_updates   = 1</span><br><span class="line">binlog-ignore-db=test</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">replicate-ignore-db=test</span><br><span class="line">replicate-ignore-db=information_schema</span><br><span class="line">relay-log=&quot;mysql-relay-log&quot;</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line">expire_logs_days    = 10</span><br><span class="line">max_binlog_size     = 100M</span><br><span class="line"></span><br><span class="line"># server-B</span><br><span class="line">server-id=2</span><br><span class="line">log-bin=&quot;mysql-bin&quot;</span><br><span class="line">log_slave_updates   = 1</span><br><span class="line">binlog-ignore-db=test</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">replicate-ignore-db=test</span><br><span class="line">replicate-ignore-db=information_schema</span><br><span class="line">relay-log=&quot;mysql-relay-log&quot;</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br><span class="line">expire_logs_days    = 10</span><br><span class="line">max_binlog_size     = 100M</span><br></pre></td></tr></table></figure>
<ul>
<li>问题<ul>
<li>需要避免在两主上同时对一个表数据进行修改</li>
<li>不能解决磁盘io压力</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同步复制：<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html" target="_blank" rel="noopener">NDB集群</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-semisync.html" target="_blank" rel="noopener">半同步</a>：主库事务的提交必须保证至少有一个从库也执行了相应操作【阿里云rds高可用即采用此种方式】</li>
</ul>
<h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><ul>
<li>SBR（Statement Based Replication）：复制全部的sql语句，默认方式<ul>
<li>复制存储过程和触发器时，可能会有问题</li>
<li>binlog文件记录的内容少，备份和还原也更快</li>
<li>记录原始的sql语句，可以用于安全审计</li>
</ul>
</li>
<li>RBR（Row Based Replication）：复制变更的字段内容<ul>
<li>可以精确记录表和字段是如何更改的，因此binlog文件记录的内容较多</li>
<li>不能直观的看到sql执行历史，解析binlog时：【mysqlbinlog –base64-output=DECODE-ROWS –verbose】</li>
</ul>
</li>
<li>MBR（Mixed Based Replication）：前两种方式的变种组合</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-gtids.html" target="_blank" rel="noopener">GUIDs</a> ：基于GUID的复制方式，不必直接基于binlog文件和文件中的position</li>
</ul>
<h2 id="主从复制的角色定位"><a href="#主从复制的角色定位" class="headerlink" title="主从复制的角色定位"></a>主从复制的角色定位</h2><ul>
<li>主：只能开启binlog功能，并将全部事件（不能指定事件类型）记录在binlog中</li>
<li>从：<ul>
<li>记录已经在从库上读取并执行的binlog文件名和文件内的偏移信息（position）</li>
<li>可以决定只执行binlog的部分内容【只同步部分库表，或不同步部分库表】</li>
<li>可以决定：断开、重连、恢复同步动作</li>
</ul>
</li>
</ul>
<h2 id="复制原理和细节"><a href="#复制原理和细节" class="headerlink" title="复制原理和细节"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-implementation-details.html" target="_blank" rel="noopener">复制原理和细节</a></h2><ul>
<li>主库配置log-bin后等待从机连接</li>
<li>从机使用change master命令配置连接和复制状态信息【存储在master.info文件】，使用start slave开启复制</li>
<li>从机的io线程和主机的binlog dump线程通信，传输binlog</li>
<li>从机的io线程将收到的binlog存入relay-log文件中</li>
<li>从机的sql线程读取relay-log中的日志，并在数据库中执行相应的sql操作【状态信息保存在relay-log.info】</li>
</ul>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-howto.html" target="_blank" rel="noopener">操作步骤</a></h1><h2 id="主配置【主】"><a href="#主配置【主】" class="headerlink" title="主配置【主】"></a>主配置【主】</h2><blockquote>
<p>配置后需要重启server</p>
</blockquote>
<ul>
<li>server-id=1</li>
<li>log-bin=mysql-bin</li>
<li>以下为保持innodb事务一致性的设置：<ul>
<li>innodb_flush_log_at_trx_commit=1</li>
<li>sync_binlog=1</li>
</ul>
</li>
</ul>
<h2 id="从配置【从】"><a href="#从配置【从】" class="headerlink" title="从配置【从】"></a>从配置【从】</h2><blockquote>
<p>配置后需要重启server</p>
</blockquote>
<ul>
<li>server-id=2</li>
</ul>
<h2 id="建立复制账号【主】"><a href="#建立复制账号【主】" class="headerlink" title="建立复制账号【主】"></a>建立复制账号【主】</h2><p><code>grant replication slave on *.* to &#39;repl&#39;@&#39;172.16.0.215&#39; identified by &#39;repl20190926&#39;;</code></p>
<h2 id="导出数据【主】"><a href="#导出数据【主】" class="headerlink" title="导出数据【主】"></a>导出数据【主】</h2><ul>
<li>为了保证数据一致性，在导出过程中需要锁表</li>
<li>在mysql的终端会话中锁表，退出该会话会导致锁表失效；因此需要，在一个会话终端中锁表，在另一个会话终端中导出数据</li>
</ul>
<h3 id="逻辑导出-手动方式"><a href="#逻辑导出-手动方式" class="headerlink" title="逻辑导出-手动方式"></a>逻辑导出-手动方式</h3><ul>
<li>锁表【会话终端1】： FLUSH TABLES WITH READ LOCK；</li>
<li>导出数据【会话终端2】：mysqldump</li>
<li>查看同步信息【会话终端1】：SHOW MASTER STATUS;</li>
<li>解锁【会话终端1中unlock tables或直接退出会话终端1】</li>
</ul>
<h3 id="逻辑导出-一键方式"><a href="#逻辑导出-一键方式" class="headerlink" title="逻辑导出-一键方式"></a>逻辑导出-一键方式</h3><blockquote>
<p>mysqldump使用–master-data参数时，会自动处理锁表解锁、显示同步信息（导出的sql文件中）等</p>
</blockquote>
<p><code>mysqldump --all-databases --master-data &gt; dbdump.db</code></p>
<h3 id="物理导出"><a href="#物理导出" class="headerlink" title="物理导出"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-howto-rawdata.html" target="_blank" rel="noopener">物理导出</a></h3><p>适用于数据量较多的数据库</p>
<h2 id="导入数据【从】"><a href="#导入数据【从】" class="headerlink" title="导入数据【从】"></a>导入数据【从】</h2><blockquote>
<p>从库已有同步时，则使用<code>--skip-slave-start</code>启动server，或stop slave停止同步</p>
</blockquote>
<ul>
<li>将导出的数据传送到从库所在主机</li>
<li>从库导入数据：mysql &lt; all.sql </li>
</ul>
<h2 id="使用命令同步【从】"><a href="#使用命令同步【从】" class="headerlink" title="使用命令同步【从】"></a>使用命令同步【从】</h2><ul>
<li>连接主库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">-&gt;     MASTER_HOST=&apos;master_host_name&apos;,</span><br><span class="line">-&gt;     MASTER_USER=&apos;replication_user_name&apos;,</span><br><span class="line">-&gt;     MASTER_PASSWORD=&apos;replication_password&apos;,</span><br><span class="line">-&gt;     MASTER_LOG_FILE=&apos;recorded_log_file_name&apos;,</span><br><span class="line">-&gt;     MASTER_LOG_POS=recorded_log_position;</span><br></pre></td></tr></table></figure>
<ul>
<li>开启同步：START SLAVE;</li>
</ul>
<h2 id="查看同步状态【从】"><a href="#查看同步状态【从】" class="headerlink" title="查看同步状态【从】"></a>查看同步状态【从】</h2><ul>
<li>SHOW SLAVE STATUS\G;<ul>
<li>Slave_IO_State：io线程状态</li>
<li>Slave_IO_Running：io线程是否在运行</li>
<li>Slave_SQL_Running：sql线程是否在运行</li>
<li>Seconds_Behind_Maste：主从延迟</li>
</ul>
</li>
</ul>
<h1 id="其他复制选项"><a href="#其他复制选项" class="headerlink" title="其他复制选项"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/replication-solutions.html" target="_blank" rel="noopener">其他复制选项</a></h1><h2 id="防止从库写操作"><a href="#防止从库写操作" class="headerlink" title="防止从库写操作"></a>防止从库写操作</h2><ul>
<li>从库配置read-only=yes参数【此时只允许从服务器线程或super权限用户执行更新操作】</li>
<li>复制忽略mysql、information_schema库，主从建立单独的应用连接用户，从库建立的用户只授予读权限（select）</li>
</ul>
<h2 id="过滤库表"><a href="#过滤库表" class="headerlink" title="过滤库表"></a>过滤库表</h2><ul>
<li>数据库级别的设置(do-db、ignore-db)：会由于binlog格式SBR和RBR的不同产生不同效果<ul>
<li>–replicate-do-db</li>
<li>–replicate-ignore-db</li>
</ul>
</li>
<li>表级别的设置：不会因binlog格式不同产生不同效果，因此要尽量使用table级别设置<ul>
<li>–replicate-do-table</li>
<li>–replicate-ignore-table</li>
<li>–replicate-wild-ignore-table</li>
<li>–replicate-wild-do-table</li>
</ul>
</li>
</ul>
<h2 id="提升复制性能"><a href="#提升复制性能" class="headerlink" title="提升复制性能"></a>提升复制性能</h2><ul>
<li>级联复制</li>
<li>其他提升复制性能操作<ul>
<li>数据文件、binlog文件、relay-log文件放到不同物理磁盘</li>
<li>将实例的不同数据库同步到不同从机</li>
<li>如果从机不作为其他从机的主，可以注释log_slave_updates，避免从机写binlog文件</li>
</ul>
</li>
</ul>
<h2 id="主故障切换"><a href="#主故障切换" class="headerlink" title="主故障切换"></a>主故障切换</h2><ul>
<li>从提升为主的配置：配置log-bin，禁止log_slave_updates<ul>
<li>从机开启log-bin参数不会写binlog，同时配置log_slave_updates则会写binlog</li>
<li>禁止log_slave_updates：当从机【slave-1】配置log_slave_updates，如果主故障，需要切换此从机【slave-1】为主机时，其他从机【slave-2】会在已接收过原master的binlog更新的同时，也接收新master【slave-1】的binlog更新，此时会出现重复操作</li>
</ul>
</li>
<li>所有从机停止io线程【STOP SLAVE IO_THREAD】，并确认sql线程已经完全读取并执行relay-log中的信息【show proceslist】</li>
<li>slave1【提升为master】<ul>
<li>STOP SLAVE</li>
<li>RESET MASTER</li>
</ul>
</li>
<li>slave2、slave3【其他从机】<ul>
<li>STOP SLAVE</li>
<li><code>CHANGE MASTER TO MASTER_HOST=&#39;Slave1&#39;</code>【user, password, port】</li>
<li>START SLAVE </li>
</ul>
</li>
</ul>
<h1 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h1><ul>
<li>确认master开启binlog【show master status】</li>
<li>确认master和slave的server-id不一样</li>
<li>确认slave的 Slave_IO_Running和Slave_SQL_Running状态正常【show slave status】</li>
<li>确认slave没有手动写入数据，造成数据不一致</li>
<li>跳过来自主服务器的下一个语句【事件：事务类的一条事务，非事务类的一条sql语句】<ul>
<li>语法：SET GLOBAL sql_slave_skip_counter = N;</li>
<li>N=1的情况：来自主服务器的下一个语句不使用AUTO_INCREMENT或LAST_INSERT_ID()</li>
<li>N=2的情况：使用AUTO_INCREMENT或LAST_INSERT_ID()时，此时它们从主服务器的二进制日志中取两个事件</li>
</ul>
</li>
<li>配置跳过指定的错误号【比如：由于重复造成的不能入库】<ul>
<li>语法：slave-skip-errors=1032,1062,1007</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装与配置</title>
    <url>/blog/2019/09/24/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="官方参考"><a href="#官方参考" class="headerlink" title="官方参考"></a>官方参考</h1><p>参考手册：<a href="https://dev.mysql.com/doc/refman/5.6/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/</a></p>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/source-installation-prerequisites.html" target="_blank" rel="noopener">依赖安装</a></h2><ul>
<li>cmake</li>
<li>make OR gmake</li>
<li>GCC 4.2.1 or later<ul>
<li>centos系列使用gcc*</li>
</ul>
</li>
<li>SSL library</li>
<li>ncurses<ul>
<li>ubuntu16：libncurses5-dev、libncurses5</li>
</ul>
</li>
</ul>
<h2 id="预配置"><a href="#预配置" class="headerlink" title="预配置"></a><a href="https://dev.mysql.com/doc/refman/5.6/en/installing-source-distribution.html" target="_blank" rel="noopener">预配置</a></h2><ul>
<li>groupadd mysql</li>
<li>useradd -r -g mysql -s /bin/false mysql</li>
<li>mkdir /application</li>
</ul>
<h2 id="软件解压"><a href="#软件解压" class="headerlink" title="软件解压"></a>软件解压</h2><p>tar zxvf mysql-VERSION.tar.gz</p>
<h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><ul>
<li>cd mysql-VERSION</li>
<li>保持源码位置干净<ul>
<li>mkdir bld</li>
<li>cd bld</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/source-configuration-options.html" target="_blank" rel="noopener">编译配置</a>：<ul>
<li>安装基础目录：-DCMAKE_INSTALL_PREFIX=/application/mysql</li>
<li>数据存储目录：-DMYSQL_DATADIR=/application/mysql/data</li>
<li>建立mysql库文件libmysqld ：-DWITH_EMBEDDED_SERVER=ON</li>
<li>添加ssl支持：-DWITH_SSL=yes</li>
<li>默认字符集：-DDEFAULT_CHARSET=utf8</li>
<li>默认字符序：-DDEFAULT_COLLATION=utf8_general_ci</li>
<li>开启debug支持：-DWITH_DEBUG=1</li>
<li>显示当前编译变量列表及对应帮助信息：-LH</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=/application/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/application/mysql/data \</span><br><span class="line">-DWITH_EMBEDDED_SERVER=ON \</span><br><span class="line">-DWITH_SSL=yes \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line">-DWITH_DEBUG=1 \</span><br><span class="line">-LH</span><br></pre></td></tr></table></figure>
<h2 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h2><ul>
<li>make</li>
<li>make install</li>
</ul>
<h2 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h2><ul>
<li>初始化数据：/application/mysql/scripts/mysql_install_db –basedir=/application/mysql –datadir=/application/mysql/data/ –user=mysql</li>
<li>变更目录权限：chown -R mysql.mysql /application/mysql</li>
</ul>
<h2 id="变更为系统服务"><a href="#变更为系统服务" class="headerlink" title="变更为系统服务"></a>变更为系统服务</h2><ul>
<li>cp /application/mysql/support-files/mysql.server /etc/init.d/mysqld</li>
<li>chmod +x /etc/init.d/mysqld</li>
<li>sed -i ‘/^basedir=/s#=#&amp;/application/mysql#’ /etc/init.d/mysqld</li>
<li>sed -i ‘/^datadir=/s#=#&amp;/application/mysql/data#’ /etc/init.d/mysqld </li>
<li>添加为系统服务：systemctl daemon-reload</li>
<li>设置开机启动<ul>
<li>systemctl enable mysqld</li>
<li>systemctl is-enabled mysqld</li>
</ul>
</li>
<li>变更pid文件位置（/etc/init.d/mysqld）<ul>
<li>示例：mysqld_pid_file_path=/application/mysql/mysqld.pid</li>
<li>用法：sed -i ‘/^mysqld_pid_file_path/s#=#&amp;/application/mysql/mysqld.pid#’ /etc/init.d/mysqld</li>
<li>系统重载配置：systemctl daemon-reload</li>
<li>正常启停控制：systemctl start mysql</li>
</ul>
</li>
</ul>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul>
<li>echo “export PATH=/application/mysql/bin:\$PATH” &gt;&gt; /etc/profile</li>
<li>source /etc/profile</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="读取顺序"><a href="#读取顺序" class="headerlink" title="读取顺序"></a>读取顺序</h2><blockquote>
<p>mysql不会读取其他人有写权限的配置文件【o+w】<br>读取顺序如下，但是后读取的文件有高优先级</p>
</blockquote>
<ul>
<li>/etc/my.cnf、/etc/mysql/my.cnf</li>
<li>SYSCONFDIR/my.cnf：默认是安装目录的etc子目录</li>
<li>$MYSQL_HOME/my.cnf【服务端】：MYSQL_HOME为用户自定义设置，或BASEDIR、DATADIR</li>
<li>defaults-extra-file： 命令行选项–defaults-extra-file</li>
<li>~/.my.cnf：用户自定义</li>
<li>~/.mylogin.cnf【客户端，较少使用】：用户登录类型配置定义</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>配置文件和命令行语法类似【mysqld –verbose –help】，但是不包含命令行选项前导的双横向</li>
<li>井号#或分号<code>;</code>开始的行是注释，井号也可以出现在行中间</li>
<li><code>[group]</code>：选项分组，分组名称和程序名称相同，如：<ul>
<li><code>[mysqld]</code>：mysqld程序</li>
<li><code>[mysql]</code>：mysql程序</li>
<li><code>[client]</code>：所有客户端程序</li>
<li><code>[mysqldump]</code>：mysqldump程序</li>
</ul>
</li>
<li>opt_name：选项，与命令行–opt_name作用一样</li>
<li>opt_name=value：与命令行–opt_name=value作用一样</li>
<li>!include、!includedir：包含其他配置文件或目录</li>
</ul>
<h2 id="服务端配置项"><a href="#服务端配置项" class="headerlink" title="服务端配置项"></a>服务端配置项</h2><blockquote>
<p>mysqld读取[mysqld] and [server]配置项，类似的mysqld_safe读取[mysqld], [server], [mysqld_safe], and [safe_mysqld] 配置项</p>
</blockquote>
<h3 id="运行时查看与设置"><a href="#运行时查看与设置" class="headerlink" title="运行时查看与设置"></a>运行时查看与设置</h3><ul>
<li>查看变量：SHOW VARIABLES;</li>
<li>设置变量：SET <code>[GLOBAL]</code> var_name = value;</li>
<li>统计信息和状态值查看：SHOW STATUS;</li>
</ul>
<h3 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端配置包含以下内容</span><br><span class="line"># 命令选项：https://dev.mysql.com/doc/refman/5.6/en/server-options.html</span><br><span class="line"># 系统变量：https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html</span><br><span class="line"># innodb参数：https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html</span><br><span class="line"># 主从复制从配置：https://dev.mysql.com/doc/refman/5.6/en/replication-options-slave.html</span><br><span class="line">[client]</span><br><span class="line">default-character-set = utf8               </span><br><span class="line">socket = /application/mysql/mysqld.sock</span><br><span class="line"># user=&quot;root&quot;</span><br><span class="line"># password=&quot;root</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 杂项</span><br><span class="line">lower_case_table_names = 0 #表名大小写敏感</span><br><span class="line"></span><br><span class="line"># 连接</span><br><span class="line">basedir = /application/mysql/</span><br><span class="line">datadir = /application/mysql/data</span><br><span class="line">socket = /application/mysql/mysqld.sock</span><br><span class="line">pid_file = /application/mysql/mysqld.pid</span><br><span class="line">back_log = 300 #操作系统监听队列保持的连接数【默认50 + (max_connections / 5)】</span><br><span class="line">max_connections = 300 # mysql允许的连接数</span><br><span class="line"></span><br><span class="line"># 日志</span><br><span class="line"># log_err 自定义设置有bug：mysqld_safe error: log-error set to</span><br><span class="line"># https://bugs.mysql.com/bug.php?id=84427</span><br><span class="line">log_error = /application/mysql/mysqld.err</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 1</span><br><span class="line">slow_query_log_file = /application/mysql/slow.log</span><br><span class="line"></span><br><span class="line"># binlog设置</span><br><span class="line"># expire_logs_days = 10 #保留的日志天数</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">log-bin-index = mysql-bin.index</span><br><span class="line">binlog_format = statement # binlog格式</span><br><span class="line"></span><br><span class="line"># 复制操作从配置</span><br><span class="line">server-id = 1 </span><br><span class="line"># replicate-ignore-db = mysql #忽略库mysql更新   </span><br><span class="line"># replicate-ignore-table=db_name.tbl_name #忽略表db_name.tbl_name更新                            </span><br><span class="line"># log-slave-updates # 默认从库不写binlog；但，从库作为其他从库的主库时，需开启binlog写入【配合log-bin设置】</span><br><span class="line"># read-only=yes # 只读设置</span><br><span class="line"># slave-skip-errors = 1032,1062,126,1114,1146,1048,1396  #从库更新时跳过指定错误</span><br><span class="line"># relay-log-index = /usr/local/mysql/log/relaylog.index # relay-log设置</span><br><span class="line"># relay-log-info-file = /usr/local/mysql/log/relaylog.info</span><br><span class="line"># relay-log = /usr/local/mysql/log/relaylog</span><br></pre></td></tr></table></figure>
<h1 id="启动错误"><a href="#启动错误" class="headerlink" title="启动错误"></a>启动错误</h1><ul>
<li>现象：【Can’t start server : Bind on unix socket: Permission denied】</li>
<li>解决：查看my.cnf文件，找到.sock文件设置的路径，给此文件所在文件夹更改为mysql的用户所有，并且增加所有用户的读写权限</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>my.cnf</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql备份与恢复</title>
    <url>/blog/2019/09/25/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="备份命令mysqldump"><a href="#备份命令mysqldump" class="headerlink" title="备份命令mysqldump"></a>备份命令mysqldump</h1><ul>
<li>-u 用户名</li>
<li>-p 密码</li>
<li>-h 主机</li>
<li>-P 端口</li>
<li>-S 指定链接mysql的socket</li>
<li>–default-character-set  设置导出的字符集</li>
<li>-F, –flush-logs  在每个数据库备份前，刷新binlog日志</li>
<li>–compact 去除注释部分</li>
<li>–master-data：主要用于主从复制，–single-transaction会覆盖此选项<ul>
<li>在导出数据前，对所有表添加读锁【turn –lock-all-tables on】；</li>
<li>导出数据后，自动解锁【turns –lock-tablesoff】，并显示binlog文件名和文件内的position信息【CHANGE MASTER】。</li>
</ul>
</li>
<li>–single-transaction      适用于innodb，保持数据一致性，隔离级别为：repeatable-read</li>
<li>-A, –all-databases 备份所有库，等同于–databases DB1 DB2 。。。</li>
<li>-B, –databases  导出多个数据库</li>
<li>–ignore-table=database.table 备份库时忽略指定的表【可多次使用，每次一个表】</li>
<li>-d, –no-data 导出表结构【不导出数据】</li>
<li>-t, –no-create-info 导出数据【不添加create table语句】</li>
<li>-R, –routines  导出存储过程和自定义函数</li>
<li>-E, –events 导出事件</li>
<li>–skip-triggers 不导出触发器【默认导出–triggers】</li>
</ul>
<h1 id="备份库表"><a href="#备份库表" class="headerlink" title="备份库表"></a>备份库表</h1><h2 id="备份所有库"><a href="#备份所有库" class="headerlink" title="备份所有库"></a>备份所有库</h2><p><code>mysqldump [OPTIONS] --all-databases [OPTIONS]</code></p>
<h2 id="备份多个库"><a href="#备份多个库" class="headerlink" title="备份多个库"></a>备份多个库</h2><p><code>mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]</code></p>
<h2 id="备份单个库"><a href="#备份单个库" class="headerlink" title="备份单个库"></a>备份单个库</h2><p><code>mysqldump [OPTIONS] database [tables]</code></p>
<ul>
<li>第1个字符串为数据库</li>
<li>第2个字符串及之后字符串为数据表</li>
</ul>
<h2 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h2><p>mysqldump db1 table1 &gt; db1_table1.sql</p>
<h2 id="备份表数据"><a href="#备份表数据" class="headerlink" title="备份表数据"></a>备份表数据</h2><p>mysqldump db1 table1 -t &gt; db1_table1.sql</p>
<h2 id="备份表结构"><a href="#备份表结构" class="headerlink" title="备份表结构"></a>备份表结构</h2><p>mysqldump db1 table1 -d &gt; db1_table1.sql</p>
<h2 id="分库分表备份"><a href="#分库分表备份" class="headerlink" title="分库分表备份"></a>分库分表备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_NAME=`mysql -uadmin -pzjht0724# -e &quot;show databases;&quot;|sed &apos;1,2d&apos;`</span><br><span class="line">mkdir  /home/zj-db/backup/$(date +%F) -p</span><br><span class="line">cd /home/zj-db/backup/$(date +%F)</span><br><span class="line"># backup every database with every table</span><br><span class="line">for db in $DB_NAME</span><br><span class="line">do</span><br><span class="line">    if [[ &quot;$db&quot; != &apos;information_schema&apos; &amp;&amp; &quot;$db&quot; != &apos;performance_schema&apos; &amp;&amp; &quot;$db&quot; != &apos;mysql&apos; &amp;&amp; &quot;$db&quot; != &apos;sys&apos; ]];then</span><br><span class="line">        mkdir /home/zj-db/backup/$(date +%F)/$db -p</span><br><span class="line">            TB_NAME=`mysql -uadmin -pzjht0724# -e &quot;show tables from $db;&quot;|sed &apos;1d&apos;`</span><br><span class="line">            for tb in $TB_NAME</span><br><span class="line">            do</span><br><span class="line">                    mysqldump -uadmin -pzjht0724# --lock-tables=0 $db $tb &gt; /home/zj-db/backup/$(date +%F)/$&#123;db&#125;/$&#123;tb&#125;.sql</span><br><span class="line">            done</span><br><span class="line">        # 备份压缩及加密</span><br><span class="line">        zip -r -Pzjht1234 $&#123;db&#125;.zip $db</span><br><span class="line">        rm -rf $db</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="导出存储过程与函数"><a href="#导出存储过程与函数" class="headerlink" title="导出存储过程与函数"></a>导出存储过程与函数</h2><ul>
<li>注意事项：必须结合数据的导出</li>
<li>查看存储过程与函数<ul>
<li>查看自定义函数：show function status;</li>
<li>查看存储过程：show procedure status;</li>
</ul>
</li>
<li>操作：mysqldump crm_test -R &gt; crm_test.sql</li>
</ul>
<h1 id="备份选项"><a href="#备份选项" class="headerlink" title="备份选项"></a>备份选项</h1><h2 id="全量备份与增量备份"><a href="#全量备份与增量备份" class="headerlink" title="全量备份与增量备份"></a>全量备份与增量备份</h2><ul>
<li>全量备份：使用mysqldump命令导出的数据</li>
<li>增量备份：由于mysql的数据修改操作都记录在binlog中，执行日志文件切割轮转后，新增的binlog文件即视为增量备份<ul>
<li>可以使用mysqldump -F或mysqladmin flush-logs切割轮转binlog文件</li>
</ul>
</li>
</ul>
<h2 id="物理备份和逻辑备份"><a href="#物理备份和逻辑备份" class="headerlink" title="物理备份和逻辑备份"></a>物理备份和逻辑备份</h2><table>
<thead>
<tr>
<th>逻辑备份</th>
<th>物理备份</th>
</tr>
</thead>
<tbody>
<tr>
<td>导出sql语句</td>
<td>直接复制数据文件</td>
</tr>
<tr>
<td>mysqldump</td>
<td>scp、cp、rsync等</td>
</tr>
<tr>
<td>速度较慢</td>
<td>速度较快</td>
</tr>
<tr>
<td>支持server跨版本备份与恢复</td>
<td>要求导入和导出的server版本尽量一致</td>
</tr>
<tr>
<td>数据量小于100G使用逻辑备份</td>
<td>数据量大于100G使用物理备份</td>
</tr>
</tbody>
</table>
<h2 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h2><ul>
<li>每天凌晨做一个全量备份</li>
<li>在全量备份的同时执行日志轮转切割【flush-logs】作为增量备份点</li>
</ul>
<h1 id="binlog介绍"><a href="#binlog介绍" class="headerlink" title="binlog介绍"></a>binlog介绍</h1><h2 id="binlog介绍-1"><a href="#binlog介绍-1" class="headerlink" title="binlog介绍"></a>binlog介绍</h2><ul>
<li>数据恢复：当数据库误删或者发生不可描述的事情时，可以通过 binlog 恢复到某个时间点的数据。</li>
<li>主从复制：当有数据库更新之后，主库通过 binlog 记录并通知从库进行更新，从而保证主从数据库数据一致；</li>
</ul>
<h2 id="binlog功能设置"><a href="#binlog功能设置" class="headerlink" title="binlog功能设置"></a>binlog功能设置</h2><ul>
<li>功能开关及文件名设置：log_bin=mysql-bin</li>
</ul>
<ul>
<li>binlog日志格式：binlog_format=statement，可选参数值如下<ul>
<li>statement：记录数据库执行的原始 SQL 语句</li>
<li>row：记录具体的行的修改，这个为目前默认值</li>
<li>mixed ：因为上边两种格式各有优缺点，所以就出现了 mixed 格式</li>
</ul>
</li>
</ul>
<ul>
<li>binlog文件切换条件<ul>
<li>文件大小达到max_binlog_size参数大小</li>
<li>执行 flush logs 命令</li>
<li>重启 mysql 服务</li>
</ul>
</li>
</ul>
<h2 id="binlog删除"><a href="#binlog删除" class="headerlink" title="binlog删除"></a>binlog删除</h2><ul>
<li>设置日志过期变量：<ul>
<li>查看：show variables like ‘expire_logs_days’;</li>
<li>设置：set global expire_logs_days = 3;</li>
</ul>
</li>
<li>手动删除日志<ul>
<li>删除全部：reset master;</li>
<li>清除MySQL-bin.010之前的日志文件：PURGE MASTER LOGS TO ‘MySQL-bin.010’;</li>
<li>删除3天前：PURGE MASTER LOGS BEFORE DATE_SUB( NOW( ), INTERVAL 3 DAY);</li>
<li>删除指定日期前：PURGE MASTER LOGS BEFORE ‘2008-06-22 13:00:00’;</li>
</ul>
</li>
</ul>
<h2 id="binlog查看"><a href="#binlog查看" class="headerlink" title="binlog查看"></a>binlog查看</h2><p>因为 binlog 是二进制文件，不能像其他文件一样，直接打开查看。但 mysql 提供了 binlog 查看工具 mysqlbinlog，可以解析二进制文件。<br>不同格式的binlog查看方式也有不同，具体如下：  </p>
<ul>
<li>statement：执行 mysqlbinlog /path/bin-log.000001，可以直接看到原始执行的 SQL 语句</li>
<li>row：则可读性没有那么好，但仍可通过参数使文档更加可读 mysqlbinlog -v /path/bin-log.000001</li>
</ul>
<h1 id="binlog解析命令mysqlbinlog"><a href="#binlog解析命令mysqlbinlog" class="headerlink" title="binlog解析命令mysqlbinlog"></a>binlog解析命令mysqlbinlog</h1><ul>
<li>-u, –user=name</li>
<li>-h, –host=name </li>
<li>-p, –password[=name]</li>
<li>-P, –port=#</li>
<li>-S, –socket=name</li>
<li>-r, –result-file=name：导出内容到文件【重定向输出】</li>
<li>–server-id=#：只导出指定server-id的内容</li>
<li>–set-charset=name：设置字符集</li>
<li>–base64-output=DECODE-ROWS：将base64编码的内容解码，以便于查看内容</li>
<li>-d, –database=name 只导出指定数据库的内容</li>
<li>-o, –offset=# 跳过开始的n行内容</li>
<li>-start-datetime、–stop-datetime 解析两个时间点之间的 binlog，时间类型为DATETIME和TIMESTAMP<ul>
<li>范例：mysqlbinlog mysql-bin.000001 -d seo -vv –base64-output=DECODE-ROWS –start-datetime=’2019-06-01 00:00:00’  –stop-datetime=’2019-07-01 00:00:00’ -r seo2.sql</li>
</ul>
</li>
<li>-start-position、–stop-position 解析两个position 之间的 binlog【包含开始点，不包含结束点】<ul>
<li>范例：mysqlbinlog mysql-bin.000001 -d seo -vv –base64-output=DECODE-ROWS –start-position=46301253  –stop-position=46328958 -r seo3.sql</li>
</ul>
</li>
</ul>
<h1 id="binlog恢复数据"><a href="#binlog恢复数据" class="headerlink" title="binlog恢复数据"></a>binlog恢复数据</h1><h2 id="指定库恢复"><a href="#指定库恢复" class="headerlink" title="指定库恢复"></a>指定库恢复</h2><p>将全量备份之后的binlog使用-d参数后导出指定数据库</p>
<h2 id="指定表恢复"><a href="#指定表恢复" class="headerlink" title="指定表恢复"></a>指定表恢复</h2><ul>
<li>在测试库上将指定表所在库的数据恢复</li>
<li>将指定表的数据导出</li>
<li>将导出的表数据恢复到指定的库</li>
</ul>
<h1 id="备份与恢复操作"><a href="#备份与恢复操作" class="headerlink" title="备份与恢复操作"></a>备份与恢复操作</h1><blockquote>
<p>开启binlog，并且binlog不能有过期删除操作</p>
</blockquote>
<ul>
<li>【备份】mysqldump备份数据【全量备份】，添加-F参数切换binlog文件，并获取备份后的第一个binlog文件名【增量备份】</li>
<li>【问题】服务出现异常，查明是因为mysql出现问题操作</li>
<li>【停止服务】停止mysql的对外服务【可通过iptables封禁3306端口】</li>
<li>【保护现场】备份全量备份数据和所有的binlog文件，防止数据二次破坏</li>
<li>【获取增量备份（删除问题sql）】找到全量备份后的所有binlog，并使用mysqlbinlog工具将binlog转换为sql，同时删除有问题的sql语句</li>
<li>【恢复全量备份】</li>
<li>【恢复增量备份】</li>
<li>【开启服务】检查恢复结果，确认正常后，开启对外服务</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://learnku.com/articles/20628" target="_blank" rel="noopener">MySQL 通过 binlog 恢复数据</a></li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysqlbinlog</tag>
        <tag>mysqldump</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql介绍</title>
    <url>/blog/2019/09/19/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>mysql-5.5</li>
<li>mysql-5.6【牧客，测试环境版本：5.6.43】</li>
<li>mysql-5.7【中冀汇通，全环境版本：5.7.17】</li>
<li>mariadb</li>
<li>mysql-8.0</li>
</ul>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><ul>
<li>mysql相关资源下载目录：<a href="https://www.mysql.com/products/community/" target="_blank" rel="noopener">https://www.mysql.com/products/community/</a></li>
<li>社区版server下载地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></li>
</ul>
<h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/mysql-arch.jpg" alt></p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口、分析器、优化器、缓冲组件</li>
<li>存储引擎</li>
<li>物理文件</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/mysql-engine.jpg" alt></p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><ul>
<li>查看支持的存储引擎：show engines;【常见引擎如上】</li>
<li>查看当前的存储引擎选项：show variables like ‘%engine%’;</li>
<li>查看表的存储引擎：show create table tb_name;</li>
</ul>
<h2 id="设置与修改"><a href="#设置与修改" class="headerlink" title="设置与修改"></a>设置与修改</h2><ul>
<li>alter table table_name engine=innodb；</li>
<li>将表结构导出使用sed替换，将数据导出，再将表结构导入，数据导入</li>
<li>使用mysql_convert_table_format命令</li>
<li>建表时使用engine=innodb参数</li>
</ul>
<h2 id="InnoDB与MyISAM对比"><a href="#InnoDB与MyISAM对比" class="headerlink" title="InnoDB与MyISAM对比"></a>InnoDB与MyISAM对比</h2><table>
<thead>
<tr>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>不支持事务</td>
<td>支持事务、分区、表空间</td>
</tr>
<tr>
<td>写操作时表级别锁定</td>
<td>写操作时行级别锁定</td>
</tr>
<tr>
<td>只缓存索引</td>
<td>缓存索引和数据</td>
</tr>
<tr>
<td>读操作会阻塞写操作</td>
<td>读写操作相对独立【根据事务隔离级别】</td>
</tr>
<tr>
<td>支持全表索引，不支持外键约束</td>
<td>支持外键约束，不支持全表索引</td>
</tr>
</tbody>
</table>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><ul>
<li>物理文件：每一个myisam表对应于硬盘上的3个文件。这三个文件有一样的文件名，但是有不同的扩展名以指示其用途：<ul>
<li>frm：保存表的定义，但这个文件不是myisam引擎的一部分，而是mysql数据库本身的一部分</li>
<li>MYD(data)：保存表的数据</li>
<li>MYI(index)：表的索引文件</li>
</ul>
</li>
<li>应用：<ul>
<li>并发较低的业务</li>
<li>以读为主的业务</li>
<li>不需要事务支持的业务</li>
</ul>
</li>
<li>优化：<ul>
<li>尽量索引及使用缓存</li>
<li>尽量顺序操作将数据插入尾部</li>
<li>分解复杂操作，延迟写入，批量插入</li>
<li>降低并发数，高并发应用引入排队机制</li>
</ul>
</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><ul>
<li>物理文件：<ul>
<li>ibdata1，默认表空间文件，通过innodb_data_file_path参数设置，所有基于innodb存储引擎的表都会存储在该文件中<ul>
<li>如果想基于每个表单独生成一个表空间文件，可以设置参数innodb_file_per_table为ON，这样表的数据、索引、插入缓冲等信息会存储在单独的表空间文件中，但是其余的信息还是存储在默认的表空间文件中</li>
</ul>
</li>
<li>frm：表结构定义文件，mysql里每个表和视图都对应一个frm文件。frm文件时mysql数据库的一部分，和存储引擎无关</li>
<li>ibd：单独的表空间文件</li>
<li>ib_logfile：innodb存储引擎的事务日志；在数据库实例意外宕机，重启后可以利用重做日志恢复到宕机前的一致性状态</li>
</ul>
</li>
<li>应用：<ul>
<li>支持高并发，但需要确保查询时通过索引完成</li>
<li>支持事务</li>
<li>数据更新频繁</li>
</ul>
</li>
<li>优化：<ul>
<li>避免全表扫描，因为会使用表锁</li>
<li>尽可能缓存所有索引和数据，提高响应速度，降低磁盘io</li>
<li>在大批量小插入时，尽量自己控制事务而不要使用autocommit自动提交</li>
<li>合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性</li>
<li>避免主键更新，因为这会带来大量的数据移动</li>
<li>主键尽可能小，避免给secondary index带来过大的空间负担</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>在mysql中只有使用了innodb引擎的数据库才支持事务</li>
<li>事务处理可以用来维护数据库的一致性，保证多条sql语句要么全部执行，要么全部不执行</li>
<li>事务用来管理insert、update、delete语句</li>
</ul>
<h3 id="特点-ACID"><a href="#特点-ACID" class="headerlink" title="特点-ACID"></a>特点-ACID</h3><ul>
<li>原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li>
<li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>
<li>持久性（Durability）：事务处理结束后，对数据的修改是永久性的</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>查询：SELECT @@tx_isolation;【默认REPEATABLE-READ】</li>
<li>设置：set session transaction isolation level 隔离级别</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
<th>解决的问题</th>
<th>引发的新问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>serializable</td>
<td>串行读取数据</td>
<td>虚读</td>
<td>数据库就变成了单线程访问的数据库，导致性能降低很多</td>
</tr>
<tr>
<td>repeatable read</td>
<td>可重复读</td>
<td>不可重复读</td>
<td>虚读：前后读取到表中的记录数不一样，读取到了其他事务插入的数据</td>
</tr>
<tr>
<td>read committed</td>
<td>读取提交的记录</td>
<td>脏读</td>
<td>不可重复读：一个事务读取表中的某一行数据时，多次读取结果不一致</td>
</tr>
<tr>
<td>read uncommitted</td>
<td>读取未提交的数据</td>
<td>-</td>
<td>脏读：一个事务读取了另外一个事务未提交的数据</td>
</tr>
</tbody>
</table>
<h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>mysql命令行下默认设置下，事务都是自动提交的；开启事务有以下两种方式：</p>
<ul>
<li>关闭事务自动提交模式：SET AUTOCOMMIT=0</li>
<li>自动提交模式下，使用命令显式开启一个事务：begin或start transaction</li>
</ul>
<h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><ul>
<li>begin或start transaction：开启一个事务</li>
<li>commit：提交一个事务</li>
<li>rollback：结束用户的事务，并撤销之前的修改</li>
<li>savepoint identifier：在事务中创建一个保存点</li>
<li>release savepoint identifier：删除一个事务保存点</li>
<li>rollback to identifier：把事务回滚到保存点</li>
</ul>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>字符集（character set）：字符和编码对组成的集合</li>
<li>字符序（collection）：同一个字符集内字符之间的比较规则</li>
</ul>
<h2 id="字符集变量"><a href="#字符集变量" class="headerlink" title="字符集变量"></a>字符集变量</h2><h3 id="字符集相关变量"><a href="#字符集相关变量" class="headerlink" title="字符集相关变量"></a>字符集相关变量</h3><ul>
<li>查看支持的字符集：SHOW CHARACTER SET;</li>
<li>查看当前的字符集设置：show variables like ‘%character%’;<ul>
<li>character_set_client ：客户端使用的字符集，相当于网页中那个的字符集设置</li>
<li>character_set_connection：客户端连接数据库的使用的字符集</li>
<li>character_set_results：数据库给客户端返回时使用的字符集设定</li>
<li><del>character_set_system</del>：数据库所在操作系统使用的字符集，character_set_system是个只读数据不能更改</li>
<li>character_set_server：数据库实例启动时的默认字符集，也是建库时的默认字符集</li>
<li><del>character_set_database</del>：当前数据库的字符集设置，可通过建库语句查看。</li>
</ul>
</li>
</ul>
<h3 id="字符序相关变量"><a href="#字符序相关变量" class="headerlink" title="字符序相关变量"></a>字符序相关变量</h3><ul>
<li>查看支持的字符序：show collation;</li>
<li>查看当前的字符序设置：show variables like ‘%collation%’;<ul>
<li>collation_server：数据库实例默认校对规则</li>
<li>collation_database ：当前数据库的字符序设置</li>
<li>collation_connection：连接字符集校对规则</li>
</ul>
</li>
</ul>
<h3 id="字符集的转换过程"><a href="#字符集的转换过程" class="headerlink" title="字符集的转换过程"></a>字符集的转换过程</h3><ul>
<li>客户端连接数据库时，如果不指定字符集【default-character-set】，则使用服务端默认设置【character-set-server】</li>
<li>mysql server收到请求时将请求从character_set_client转换为character_set_connection</li>
<li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，确定顺序如下：<ul>
<li>使用字段的字符集</li>
<li>使用表的字符集</li>
<li>使用库的字符集【建库时，未指定则使用character-set-server】</li>
</ul>
</li>
<li>将操作结果从内部操作字符集转换为character_set_results返回给客户端</li>
</ul>
<h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><ul>
<li>设置参数：default-character-set【服务端已不支持此参数】</li>
<li>影响变量：<ul>
<li>character_set_client </li>
<li>character_set_connection</li>
<li>character_set_results</li>
<li>collation_connection</li>
</ul>
</li>
</ul>
<h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><h3 id="字符集的继承关系"><a href="#字符集的继承关系" class="headerlink" title="字符集的继承关系"></a>字符集的继承关系</h3><ul>
<li>创建数据库没有指定字符集，使用character_set_server设定值</li>
<li>创建表没有指定字符集，默认使用数据库的的字符集</li>
<li>字段没有设置字符集，默认使用表的字符集</li>
</ul>
<h3 id="server级别设置"><a href="#server级别设置" class="headerlink" title="server级别设置"></a>server级别设置</h3><ul>
<li>设置参数：character-set-server、collation-server</li>
<li>影响变量：<ul>
<li>character_set_server</li>
<li>character_set_database</li>
<li>collation_server</li>
<li>collation_database</li>
</ul>
</li>
<li>设置方式<ul>
<li>服务启动时命令行指定：mysqld –character-set-server=latin1</li>
<li>配置文件my.cnf指定：character-set-server = utf8</li>
<li>运行时修改：SET character_set_server = utf8 ;</li>
</ul>
</li>
</ul>
<h3 id="database级别设置"><a href="#database级别设置" class="headerlink" title="database级别设置"></a>database级别设置</h3><ul>
<li>查看库字符集：SHOW CREATE DATABASE db_name;</li>
<li>建库时设置：<code>CREATE DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name]</code></li>
<li>修改数据库的默认字符集：<code>ALTER DATABASE db_name DEFAULT CHARACTER SET character_name [COLLATE ...];</code><ul>
<li>范例：alter database shiyan default character set utf8 COLLATE utf8_general_ci;</li>
</ul>
</li>
</ul>
<h3 id="table级别设置"><a href="#table级别设置" class="headerlink" title="table级别设置"></a>table级别设置</h3><ul>
<li>查看表字符集：SHOW CREATE TABLE tbl_name;</li>
<li>建表时设置：CREATE TABLE tb_name ( id INT NOT NULL) DEFAULT CHARACTER SET = utf8;</li>
<li>修改表默认字符集：<code>ALTER TABLE tbl_name DEFAULT CHARACTER SET character_name [COLLATE...];</code><ul>
<li>范例：ALTER TABLE logtest DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</li>
</ul>
</li>
<li>修改表的当前字符集：<code>ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]</code><ul>
<li>范例：ALTER TABLE logtest CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; </li>
</ul>
</li>
</ul>
<h3 id="column级别设置"><a href="#column级别设置" class="headerlink" title="column级别设置"></a>column级别设置</h3><ul>
<li>查看字符字符集：SHOW FULL COLUMNS FROM tbl_name;</li>
<li>新增字段设置：ALTER TABLE test_table ADD COLUMN char_column VARCHAR(25) CHARACTER SET utf8;</li>
<li>修改当前字段：<code>alter table table_name modify column column_attr character set character_name [COLLATE ...]</code><ul>
<li>范例：alter table test1 modify name char(10) character set utf8 COLLATE utf8_general_ci; </li>
</ul>
</li>
</ul>
<h1 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h1><ul>
<li>一般日志：记录 mysql 正在运行的语句，包括查询、修改、更新等的每条 sql<ul>
<li>功能开关：general_log=OFF</li>
<li>文件位置：general_log_file</li>
</ul>
</li>
<li>错误日志：mysql运行过程中的错误信息<ul>
<li>功能开关：无</li>
<li>文件位置：log_error</li>
</ul>
</li>
<li>慢查询日志：记录查询比较耗时的 SQL 语句<ul>
<li>功能开关：slow_query_log=OFF</li>
<li>阈值设置：long_query_time</li>
<li>文件位置：slow_query_log_file</li>
</ul>
</li>
<li>binlog日志：记录数据修改记录，包括创建表、数据更新等<ul>
<li>功能开关：log_bin=ON</li>
<li>文件位置：log_bin_index、log_bin_basename</li>
</ul>
</li>
</ul>
<h1 id="SQL操作分类"><a href="#SQL操作分类" class="headerlink" title="SQL操作分类"></a>SQL操作分类</h1><ul>
<li>DDL(数据定义语言)：create、alter、drop</li>
<li>DML(数据修改语言)：insert、delete、update</li>
<li>DQL(数据查询语言)：select、order by、group by、having</li>
<li>DCL(数据控制语言)：create user、grant、revoke、drop user</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html" target="_blank" rel="noopener">字符集设置</a></li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>存储引擎</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql用户和权限</title>
    <url>/blog/2019/08/23/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="所有权限"><a href="#所有权限" class="headerlink" title="所有权限"></a>所有权限</h1><ul>
<li>ALL：全局或者全数据库对象级别的所有权限</li>
<li>ALTER：修改表结构的权限，但必须要求有create和insert权 限配合。如果是rename表名，则要求有alter和drop原表，create和 insert新表</li>
<li>ALTER ROUTINE：修改或者删除存储过程、函数</li>
<li>CREATE：创建存储过程、函数</li>
<li>CREATE ROUTINE：创建存储过程和函数</li>
<li>CREATE TABLESPACE：创建、修改、删除表空间和日志组</li>
<li>CREATE TEMPORARY TABLES：创建临时表</li>
<li>CREATE USER：创建、修改、删除、重命名用户</li>
<li>CREATE VIEW：创建视图</li>
<li>DELETE：删除行数据</li>
<li>DROP：删除数据库、表、视图的权限，包括truncatetable命令</li>
<li>EVENT：查询，创建，修改，删除MySQL事件</li>
<li>EXECUTE：执行存储过程和函数</li>
<li>FILE：在MySQL可以访问的目录进行读写磁盘文件操作，可使用 的命令包括load data infile,select … into outfile,load file()函数</li>
<li>INDEX：创建、删除索引</li>
<li>INSERT：插入数据，同时在执行analyze table,optimize table,repair table语句的时候也需要insert权限</li>
<li>LOCK TABLES：锁表</li>
<li>PROCESS：看MySQL中的进程信息，比如执行showprocesslist,</li>
<li>REFERENCES：创建外键</li>
<li>RELOAD：执行flush命令，指明重新加载权限表到系统内存中， refresh命令代表关闭和重新开启日志文件并刷新所有的表</li>
<li>REPLICATION SLAVE：允许slave主机通过此用户连接master以便建立主从复制关系</li>
<li>REPLICATION CLIENT：执行show master status,show slave status,show binary logs命令</li>
<li>SELECT：查询</li>
<li>SHOW DATABASES：查看数据库</li>
<li>SHOW VIEW：执行show create view命令查看视图创建的语句mysqladmin processlist, show engine等命令</li>
<li>SHUTDOWN：允许关闭数据库实例，执行语句包括mysqladmin shutdown</li>
<li>SUPER：执行一系列数据库管理命令，包括kill强制关闭某个连接 命令，change master to创建复制关系命令，以及create/alter/drop server等命令</li>
<li>UPDATE：修改数据</li>
<li>TRIGGER：允许创建，删除，执行，显示触发器</li>
</ul>
<h1 id="系统权限表"><a href="#系统权限表" class="headerlink" title="系统权限表"></a>系统权限表</h1><ul>
<li>user：存放用户账户信息以及全局级别(所有数据库)权限<ul>
<li>查询用户：select user,host mysql.user;</li>
</ul>
</li>
<li>db：存放数据库级别的权限</li>
<li>Tables_priv：存放表级别的权限</li>
<li>Columns_priv：存放列级别的权限</li>
<li>Procs_priv：存放存储过程和函数级别的权限</li>
</ul>
<h1 id="mysql用户"><a href="#mysql用户" class="headerlink" title="mysql用户"></a>mysql用户</h1><h2 id="用户定义"><a href="#用户定义" class="headerlink" title="用户定义"></a>用户定义</h2><ul>
<li>由用户名和主机名构成，形如：‘user_name‘@’host_name’</li>
<li>单引号不是必须的，但有特殊字符时则必须使用</li>
<li>‘‘@’localhost’代表匿名登录的用户</li>
<li>主机名可以是主机名或者ipv4/ipv6的地址。Localhost代表本机，127.0.0.1代表ipv4的 本机地址，::1代表ipv6的本机地址</li>
<li>允许使用%和_两个匹配字符，比如’%’代表所有主机，’%.mysql.com’代表 来自mysql.com这个域名下的所有主机，’192.168.1.%’代表所有来自192.168.1网段的主机</li>
</ul>
<h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><p>show grants for ‘用户名’@‘ip地址’;</p>
<h2 id="创建和授权"><a href="#创建和授权" class="headerlink" title="创建和授权"></a>创建和授权</h2><ul>
<li>方式1：<ul>
<li>创建用户：<code>CREATE USER &#39;finley&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;some_pass&#39;;</code> </li>
<li>授权：<code>GRANT ALL ON *.* TO &#39;finley&#39;@&#39;localhost&#39;;</code></li>
</ul>
</li>
<li>方式2：<code>grant all on *.* to &#39;finley&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;some_pass&#39;;</code></li>
</ul>
<h2 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h2><p><code>revoke DROP,RELOAD,SHUTDOWN,PROCESS,FILE,REPLICATION SLAVE, REPLICATION CLIENT,CREATE USER on *.* from &#39;finley&#39;@&#39;localhost&#39;;</code></p>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>DROP USER ‘jeffrey‘@’localhost’;</p>
<h2 id="权限生效"><a href="#权限生效" class="headerlink" title="权限生效"></a>权限生效</h2><ul>
<li>执行grant,revoke,set password,renameuser命令修改权限之后，MySQL会自动将修改后的权限信息同步加载到系统内存中</li>
<li>如果执行insert/update/delete操作上述的系统权限表之后，则必须再执行刷新权限命令才能同步到系统内存中，刷新权限命令包括:flush privileges/mysqladmin flush-privileges/mysqladmin reload</li>
<li>如果是修改tables和columns级别的权限，则客户端的下次操作新权限就会生效</li>
<li>如果是修改database级别的权限，则新权限在客户端执行use database命令后 生效</li>
<li>如果是修改global级别的权限，则需要重新创建连接新权限才能生效</li>
<li>–skip-grant-tables可以跳过所有系统权限表而允许所有用户登录，只在特殊情况下暂时使用</li>
</ul>
<h2 id="变更密码"><a href="#变更密码" class="headerlink" title="变更密码"></a>变更密码</h2><ul>
<li>方式1：ALTER USER ‘jeffrey‘@’localhost’ IDENTIFIED BY ‘mypass’;<ul>
<li>变更自身：ALTER USER USER() IDENTIFIED BY ‘mypass’;</li>
</ul>
</li>
<li>方式2：<ul>
<li>update mysql.user set authentication_string=password(“新密码”) where user=”test” and host=”localhost”;</li>
<li>flush privileges;</li>
</ul>
</li>
<li>方式3：SET PASSWORD FOR ‘jeffrey‘@’localhost’ = PASSWORD(‘mypass’);<ul>
<li>变更自身：SET PASSWORD = PASSWORD(‘mypass’);</li>
</ul>
</li>
<li>方式4(mysqladmin)：mysqladmin -u user_name -h host_name password “new_password”</li>
</ul>
<h2 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h2><ul>
<li><p>跳过授权表启动：mysqld_safe –defaults-file=my.cnf –skip-grant-tables &amp;</p>
</li>
<li><p><a href="#变更密码">变更密码</a></p>
<ul>
<li><p>错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 1290 (HY000): The MariaDB server is running with the --skip-grant-tables option so it cannot execute this statement</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;flush privileges;</span><br><span class="line">mysql&gt;alter user ‘root’@‘XX.XX.XX.XX’ identified by ‘PASSWORD’;</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>刷新权限：flush privileges;</p>
</li>
<li><p>退出安全启动模式，以正常方式启动</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql管理</title>
    <url>/blog/2019/09/30/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h1><h2 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h2><p>shell命令行下服务端mysqld的管理工具，帮助信息：mysqladmin –help</p>
<h2 id="mysql内建命令"><a href="#mysql内建命令" class="headerlink" title="mysql内建命令"></a>mysql内建命令</h2><ul>
<li>system：调用系统命令</li>
<li>help：帮助信息</li>
<li>show <code>[full]</code>processlist;：进程列表</li>
<li>show variables;：变量信息</li>
<li>show <code>[func_name]</code> status;：状态和统计信息</li>
</ul>
<h1 id="使用优化"><a href="#使用优化" class="headerlink" title="使用优化"></a>使用优化</h1><ul>
<li>能用定长char的就不用varchar</li>
<li>查询时，尽量不要使用select *，同时要用where条件匹配</li>
<li>尽量使用批量插入</li>
</ul>
<h1 id="锁表处理"><a href="#锁表处理" class="headerlink" title="锁表处理"></a>锁表处理</h1><h2 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h2><ul>
<li>现象与解释：mysql命令行执行时，sql挂起；使用show processlist查看，该sql线程状态为【waiting for table metadata lock】；这是由于该表有正在执行的其他长事务（sql），进而阻塞了同表的后续操作。</li>
<li>处理<ul>
<li>使用【show processlist】查看长事务的线程id</li>
<li>使用kill命令杀死改线程</li>
</ul>
</li>
</ul>
<h2 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h2><ul>
<li>现象和解释：对该表进行操作时，客户端显示锁表（比如：java客户端中出现错误【Lock wait timeout exceeded; try restarting transaction】，但是通过show processlist命令看不到该表的任何操作；实际上该表存在未提交的事务，可以在<br>information_schema.innodb_trx中查看到。</li>
<li>处理<ul>
<li>使用【select * from information_schema.innodb_trx\G】查找相关表的线程id</li>
<li>使用kill命令杀死该线程【由于是事务类型操作，杀死线程后，事务会回滚】</li>
</ul>
</li>
</ul>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><ul>
<li>应用程序自己实现读写路由</li>
<li>官方代理插件：mysql-proxy(已停止维护)–》MySQL Router【需要在应用中配置读写端口】</li>
<li>第三方插件：<ul>
<li>Amoeba(已停止维护)–》Cobar(已停止维护)–》<a href="https://github.com/MyCATApache/Mycat2" target="_blank" rel="noopener">MyCAT</a></li>
<li><a href="https://blog.csdn.net/xiaoying5191/article/details/81112747#2-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%AD%E9%97%B4%E4%BB%B6atlas" target="_blank" rel="noopener">atlas</a>：360公司团队基于mysql-proxy进行的二次开发</li>
</ul>
</li>
</ul>
<h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a><a href="https://www.cnblogs.com/robbinluobo/p/8294782.html" target="_blank" rel="noopener">高可用方案</a></h1><h2 id="数据同步-故障切换"><a href="#数据同步-故障切换" class="headerlink" title="数据同步+故障切换"></a>数据同步+故障切换</h2><ul>
<li>数据同步<ul>
<li>异步<br>-[半同步][replication-semisync]：主库事务的提交必须保证至少有一个从库也执行了相应操作【阿里云rds高可用即采用半同步】</li>
</ul>
</li>
<li>故障切换<ul>
<li><a href="https://www.jianshu.com/p/7331779dbae8" target="_blank" rel="noopener">MMM(Master-Master replication managerfor Mysql)</a></li>
<li>MHA（Master High Availability）<ul>
<li>MySQL阿里云ecs不支持虚拟ip，所以无法使用keepalived、heartbeat类高可用软件</li>
<li>需要添加多个多个节点之间的ssh免密登陆</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><ul>
<li>SAN：数据库服务器和存储分离</li>
<li>DRBD：DRBD是一种基于软件、基于网络的块复制存储解决方案，主要用于对服务器之间的磁盘、分区、逻辑卷等进行数据镜像，当用户将数据写入本地磁盘时，还会将数据发送到网络中另一台主机的磁盘上，这样的本地主机(主节点)与远程主机(备节点)的数据就可以保证实时同步。</li>
</ul>
<h2 id="分布式协议"><a href="#分布式协议" class="headerlink" title="分布式协议"></a>分布式协议</h2><ul>
<li>mysql cluster(官方)：使用NDB存储引擎的集群，因为各种问题，国内应用的不多</li>
<li>group replication(官方)：mysql5.7出现的组复制功能<ul>
<li>单主模式下，组复制具有自动选主功能，每次只有一个 Server成员接受更新，其它成员只提供读服务。</li>
<li>多主模式下，所有的Server 成员都可以同时接受更新，没有主从之分，成员角色是完全对等的。</li>
</ul>
</li>
<li><a href="https://blog.51cto.com/11912662/2155443" target="_blank" rel="noopener">Galera</a></li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
        <tag>mysqladmin</tag>
        <tag>锁表</tag>
        <tag>架构</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>pgsql-sql操作</title>
    <url>/blog/2019/10/13/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/pgsql-sql%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><ul>
<li>查看当前会话连接：select * from pg_stat_activity;</li>
<li>取消一个查询：pg_cancel_backend(pid int)</li>
<li>终止一个会话：pg_terminate_backend(pidint)</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>查询：select current_setting(setting_name)或show var</li>
<li>设置：select set_config(setting_name, new_value, is_local)或【SET old_var TO new_val;】<ul>
<li>如果 is_local 设置为 true，那么新数值将只应用于当前事务。 如果你希望新的数值应用于当前会话，那么应该使用 false。</li>
</ul>
</li>
</ul>
<h2 id="数据库对象存储位置"><a href="#数据库对象存储位置" class="headerlink" title="数据库对象存储位置"></a>数据库对象存储位置</h2><ul>
<li>pg_relation_filenode(relation regclass)：获取指定对象的文件节点编号(通常为对象的oid值)。</li>
<li>pg_relation_filepath(relation regclass)：获取指定对象的完整路径名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">showba=# select pg_relation_filenode(&apos;auth_group&apos;);</span><br><span class="line">pg_relation_filenode</span><br><span class="line">----------------------</span><br><span class="line">                16388</span><br><span class="line">select pg_relation_filepath(&apos;auth_group&apos;);</span><br><span class="line">pg_relation_filepath</span><br><span class="line">----------------------</span><br><span class="line">base/16387/16388</span><br></pre></td></tr></table></figure>
<h2 id="数据库对象尺寸大小"><a href="#数据库对象尺寸大小" class="headerlink" title="数据库对象尺寸大小"></a>数据库对象尺寸大小</h2><ul>
<li>pg_column_size(any)</li>
<li>pg_tablespace_size(oid/name)</li>
<li>pg_relation_size(oid/name)</li>
<li>pg_database_size(oid/name)</li>
<li>pg_size_pretty(bigint):把字节计算的尺寸转换成一个人类易读的尺寸单位<ul>
<li>select pg_size_pretty(pg_database_size(‘test’));</li>
</ul>
</li>
</ul>
<h2 id="sql命令"><a href="#sql命令" class="headerlink" title="sql命令"></a>sql命令</h2><ul>
<li>\h：查看sql命令帮助</li>
</ul>
<h2 id="psql命令"><a href="#psql命令" class="headerlink" title="psql命令"></a>psql命令</h2><ul>
<li>\?：查看psql命令帮助</li>
<li>\a:切换对齐和非对齐模式</li>
<li>\l：查看数据库列表</li>
<li>\q：退出sql连接</li>
<li>\c db：切换数据库</li>
<li>\d：查看当前数据库的对象【表、视图、函数、索引】<ul>
<li>\dt：查看当前路径下的表</li>
</ul>
</li>
<li>\d table1:查看表结构</li>
<li>\du:查看用户【select * from pg_roles】</li>
</ul>
<h1 id="导入导出csv"><a href="#导入导出csv" class="headerlink" title="导入导出csv"></a>导入导出csv</h1><ul>
<li>设置编码【保证windows下excel可读不乱码】：set client_encoding=’gb18030’;</li>
<li>导出数据【括号内为可执行语句】：copy (select * from xueji) to ‘/home/postgres/nnn.csv’ with csv HEADER;</li>
<li>导入数据：copy xueji from ‘/home/postgres/nnn.csv’ with csv HEADER;</li>
</ul>
<h1 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h1><ul>
<li>修改服务监听端口（postgresql.conf)<ul>
<li>listen_address=’*’</li>
<li>允许连接的主机</li>
</ul>
</li>
<li>添加连接授权（pg_hba.conf）<ul>
<li>【host  test aa   192.168.30.91/24 password】</li>
<li>允许用户aa在主机 .91上以密码登陆方式操作test数据库</li>
</ul>
</li>
<li>建立用户和授予操作权限<ul>
<li>create user aa superuser password ‘ceshi-aa123’;</li>
<li>grant all on DATABASE test to aa;</li>
</ul>
</li>
<li>更改用户密码：alter user postgres with password ‘123456’;</li>
</ul>
<h2 id="添加只读账号"><a href="#添加只读账号" class="headerlink" title="添加只读账号"></a>添加只读账号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create role xiu LOGIN  NOSUPERUSER NOCREATEDB NOCREATEROLE  encrypted password &apos;wiquxiu8&apos;;</span><br><span class="line"># showba库授权</span><br><span class="line">grant connect on database showba to xiu;</span><br><span class="line">grant usage on schema public to xiu;</span><br><span class="line">grant usage on schema topology to xiu;</span><br><span class="line">grant select on all tables in schema public to xiu;</span><br><span class="line">grant select on all tables in schema topology to xiu;</span><br><span class="line">grant select on all sequences in schema public to xiu;</span><br><span class="line">grant select on all sequences in schema topology to xiu;</span><br><span class="line">grant select on geography_columns to xiu;</span><br><span class="line">grant select on geometry_columns to xiu;</span><br><span class="line">grant select on raster_overviews to xiu;</span><br><span class="line">grant select on raster_columns to xiu;</span><br><span class="line">grant select on coupons_orders to xiu;</span><br><span class="line">grant select on subscribe_orders to xiu;</span><br><span class="line">grant select on total_orders to xiu;</span><br><span class="line"># 更改新建库默认权限</span><br><span class="line">ALTER DEFAULT PRIVILEGES IN SCHEMA public grant select on tables to xiu;</span><br><span class="line">ALTER DEFAULT PRIVILEGES IN SCHEMA public grant select on sequences to xiu;</span><br><span class="line">ALTER DEFAULT PRIVILEGES IN SCHEMA topology grant select on tables to xiu;</span><br><span class="line">ALTER DEFAULT PRIVILEGES IN SCHEMA topology grant select on sequences to xiu;</span><br></pre></td></tr></table></figure>
<h1 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h1><ul>
<li>功能：可以指定数据库对象的存储位置，方便扩展存储空间</li>
<li>创建：<ul>
<li>语法：CREATE TABLESPACE tb_space LOCATION ‘/home/postgres/db0/tb_space’;</li>
<li>说明：os_path必须是空的、postgresql帐号有权的目录。创建表空间的用户必须是superuser，创建完表空间之后，可以将表空间的create权限赋给普通用户使用！</li>
</ul>
</li>
<li>使用：<ul>
<li>可使用对象：表、index、数据库：在创建这些对象时，可以显式的指定tablespace tals_name子句指示对象使用的表空间。</li>
<li>说明：<ul>
<li>postgresql允许通过符号链接简化表空间的实施，那在不支持符号链接的os上就无法简化，只能显式的创建所需的表空间了！</li>
<li>表空间是和单个数据库无关的，他被所有的数据库使用。因为，表空间只有没有任何对象使用时，才能drop掉</li>
</ul>
</li>
<li>语法：create database test tablespace tb_space;</li>
</ul>
</li>
</ul>
<h1 id="逻辑备份和恢复"><a href="#逻辑备份和恢复" class="headerlink" title="逻辑备份和恢复"></a>逻辑备份和恢复</h1><h2 id="备份特点"><a href="#备份特点" class="headerlink" title="备份特点"></a>备份特点</h2><ul>
<li>可以远程执行备份</li>
<li>可以备份全部库、库、表、表结构、数据</li>
<li>备份的数据可以在当前版本或新版本数据库恢复</li>
<li>备份的数据可以同时在32或64系统上使用</li>
<li>备份的数据是备份开始的一个快照，他不会阻塞其他操作，但例外是会添加一个排它锁【如alter table】</li>
</ul>
<h2 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h2><h3 id="pg-dump"><a href="#pg-dump" class="headerlink" title="pg_dump"></a>pg_dump</h3><ul>
<li>特点：<ul>
<li>只备份单个库；</li>
<li>指定备份格式(custom、directory、tar)时，使用pg_restore命令恢复数据；</li>
<li>没有指定备份格式时，备份为文本格式，用psql命令恢复数据，示例如下<ul>
<li>备份：pg_dump dbname &gt; dumpfile</li>
<li>恢复(先创建库)：psql dbname &lt; dumpfile</li>
</ul>
</li>
</ul>
</li>
<li>命令选项<ul>
<li>-F：指定输出备份格式</li>
<li>-a：只导出库数据</li>
<li>-s：只导出数据库结构</li>
<li>-t：备份指定表</li>
<li>-T：不备份特定表</li>
<li>-C：包含创建数据库命令</li>
<li>-f：指定备份输出文件或目录</li>
<li>-d：需要备份的数据库</li>
</ul>
</li>
<li>备份范例<ul>
<li>备份数据库 pg_dump -Fc test &gt; test.all</li>
<li>备份表数据 pg_dump -Fc -a -t xuji test &gt; xuji.db</li>
<li>备份表结构 pg_dump -Fc -s -t xuji test &gt; xuji.sql</li>
</ul>
</li>
</ul>
<h3 id="pg-dumpall"><a href="#pg-dumpall" class="headerlink" title="pg_dumpall"></a>pg_dumpall</h3><ul>
<li>特点：备份全部的库、用户信息、表空间信息</li>
<li>特例：单独导出全局信息【用户、表空间】：pg_dumpall –globals-only</li>
</ul>
<h3 id="pg-restore"><a href="#pg-restore" class="headerlink" title="pg_restore"></a>pg_restore</h3><ul>
<li>选项<ul>
<li>-a：只恢复库数据</li>
<li>-s：只恢复数据库结构</li>
<li>-t：只恢复指定表</li>
<li>-d：连接的数据库</li>
</ul>
</li>
<li>范例<ul>
<li>恢复表结构 pg_restore -s -t xuji -d test xuji.sql</li>
<li>恢复表数据 pg_restore -a -t xuji -d test xuji.db</li>
<li>恢复表  pg_restore -t xuji -d test xuji.all</li>
</ul>
</li>
</ul>
<h2 id="大数据量处理"><a href="#大数据量处理" class="headerlink" title="大数据量处理"></a>大数据量处理</h2><ul>
<li>使用压缩<ul>
<li>pg_dump dbname | gzip &gt; filename.gz</li>
<li>gunzip -c filename.gz | psql dbname</li>
</ul>
</li>
<li>使用切分<ul>
<li>pg_dump dbname | split -b 1m - filename</li>
<li>cat filename* | psql dbname</li>
</ul>
</li>
<li>使用pg_dump自定义备份格式<ul>
<li>pg_dump -Fc dbname &gt; filename</li>
<li>pg_dump -Fc dbname &gt; filename</li>
</ul>
</li>
<li>并行处理<ul>
<li>pg_dump -j num -F d -f out.dir dbname</li>
<li>pg_restore -j </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>pgsql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>pgsql-pgpool使用</title>
    <url>/blog/2019/10/13/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/pgsql-pgpool%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="pgpool简介"><a href="#pgpool简介" class="headerlink" title="pgpool简介"></a>pgpool简介</h1><p>pgpool是一个位于数据库服务端和客户端之间的中间件，可以实现如下功能：</p>
<ul>
<li>连接池</li>
<li>复制功能：可以实时的把数据备份到单独的磁盘</li>
<li>负载均衡：将查询语句拆分到多台后端数据库</li>
<li>限制过量的连接：将超过限制的连接排队，但不直接返回错误</li>
<li>看门狗功能：同时在两个节点部署pgpool，通过vip偏移执行高可用</li>
<li>基于内存的查询缓存</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>./configure –prefix=/usr/local/pgpool –with-pgsql=/usr/local/pgsql/<br>make<br>make install</p>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><h2 id="pgpool-recovery"><a href="#pgpool-recovery" class="headerlink" title="pgpool_recovery"></a>pgpool_recovery</h2><p>$ cd pgpool-II-x.x.x/src/sql/pgpool-recovery<br>$ make<br>$ make install<br>$ psql -f pgpool-recovery.sql template1<br>$ 【vim postgresql.conf】：pgpool.pg_ctl = ‘/usr/local/pgsql/bin/pg_ctl’<br>$ pg_ctl reload -D /usr/local/pgsql/data</p>
<h2 id="pgpool-regclass"><a href="#pgpool-regclass" class="headerlink" title="pgpool-regclass"></a>pgpool-regclass</h2><p> PostgreSQL 9.4 or later可以省略</p>
<h2 id="insert-lock表"><a href="#insert-lock表" class="headerlink" title="insert_lock表"></a>insert_lock表</h2><p>如果打算使用原生的复制模式和insert_lock，需要创建：<br>$ cd pgpool-II-x.x.x/src/sql<br>$ psql -f insert_lock.sql template1</p>
<h1 id="配置pgpool-conf"><a href="#配置pgpool-conf" class="headerlink" title="配置pgpool.conf"></a>配置<a href="https://www.pgpool.net/docs/latest/en/html/runtime-config.html" target="_blank" rel="noopener">pgpool.conf</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#连接</span><br><span class="line">listen_addresses = &apos;*&apos;</span><br><span class="line">port = 9833</span><br><span class="line">pcp_listen_addresses = &apos;*&apos;</span><br><span class="line">pcp_port = 9898</span><br><span class="line"></span><br><span class="line">#后端</span><br><span class="line">backend_hostname0 = &apos;10.86.0.10&apos;</span><br><span class="line">backend_port0 = 5432</span><br><span class="line">backend_weight0 = 16</span><br><span class="line">backend_data_directory0 = &apos;/home/postgres/db0/db/9.3/data/&apos;</span><br><span class="line">backend_flag0 = &apos;ALLOW_TO_FAILOVER&apos;</span><br><span class="line">backend_hostname1 = &apos;10.86.0.12&apos;</span><br><span class="line">backend_port1 = 5432</span><br><span class="line">backend_weight1 = 128</span><br><span class="line">backend_data_directory1 = &apos;/home/postgres/db0/db/9.3/data&apos;</span><br><span class="line">backend_flag1 = &apos;ALLOW_TO_FAILOVER&apos;</span><br><span class="line"></span><br><span class="line">#安全</span><br><span class="line">enable_pool_hba = on</span><br><span class="line">pool_passwd = &apos;&apos;</span><br><span class="line">authentication_timeout = 60</span><br><span class="line">ssl = off</span><br><span class="line"></span><br><span class="line">#连接池</span><br><span class="line">num_init_children = 64</span><br><span class="line">max_pool = 16</span><br><span class="line">child_life_time = 300</span><br><span class="line">child_max_connections = 200</span><br><span class="line">connection_life_time = 120</span><br><span class="line">client_idle_limit = 60</span><br><span class="line">connection_cache = on</span><br><span class="line">reset_query_list = &apos;ABORT; DISCARD ALL&apos;</span><br><span class="line">relcache_expire = 0</span><br><span class="line">relcache_size = 256</span><br><span class="line">check_temp_table = on</span><br><span class="line"></span><br><span class="line">#日志</span><br><span class="line">log_destination = &apos;syslog&apos;</span><br><span class="line">print_timestamp = on</span><br><span class="line">log_connections = off</span><br><span class="line">log_hostname = off</span><br><span class="line">log_statement = off</span><br><span class="line">log_per_node_statement = off</span><br><span class="line">log_standby_delay = &apos;none&apos;</span><br><span class="line">syslog_facility = &apos;LOCAL0&apos;</span><br><span class="line">syslog_ident = &apos;pgpool&apos;</span><br><span class="line">debug_level = 0</span><br><span class="line"></span><br><span class="line">#文件位置</span><br><span class="line">pid_file_name = &apos;/home/postgres/pgpool2/run/pgpool.pid&apos;</span><br><span class="line">logdir = &apos;/home/postgres/pgpool2/log/&apos;</span><br><span class="line"></span><br><span class="line">#基于流复制的负载均衡模式（主备模式）</span><br><span class="line">replication_mode = off</span><br><span class="line">insert_lock = on</span><br><span class="line">load_balance_mode = on</span><br><span class="line">master_slave_mode = on</span><br><span class="line">master_slave_sub_mode = &apos;stream&apos;</span><br><span class="line">ignore_leading_white_space = on</span><br><span class="line">white_function_list = &apos;&apos;</span><br><span class="line">black_function_list = &apos;nextval,setval&apos;</span><br><span class="line">sr_check_period = 3</span><br><span class="line">sr_check_user = &apos;replication&apos;</span><br><span class="line">sr_check_password = &apos;repl-pg-0232&apos;</span><br><span class="line">delay_threshold = 0</span><br><span class="line"></span><br><span class="line">#健康检查</span><br><span class="line">health_check_period = 10</span><br><span class="line">health_check_timeout = 20</span><br><span class="line">health_check_user = &apos;postgres&apos;</span><br><span class="line">health_check_password = &apos;YUTR0-Lew&amp;4-DE74GF-qePi8&apos;</span><br><span class="line">health_check_max_retries = 0</span><br><span class="line">health_check_retry_delay = 3</span><br><span class="line"></span><br><span class="line">#故障切换</span><br><span class="line">failover_command = &apos;/home/postgres/bin/failover_stream.sh %d %H /home/postgres/db0/tmp/trigger_file&apos;</span><br><span class="line">failback_command = &apos;/bin/rm -f /home/postgres/db0/tmp/trigger_file&apos;</span><br><span class="line">fail_over_on_backend_error = on #设置health_check_max_retries则关闭此选项</span><br><span class="line">search_primary_node_timeout = 10</span><br><span class="line"></span><br><span class="line">#在线恢复</span><br><span class="line">recovery_user = &apos;postgres&apos;</span><br><span class="line">recovery_password = &apos;YUTR0-Lew&amp;4-DE74GF-qePi8&apos;</span><br><span class="line">recovery_1st_stage_command = &apos;/home/postgres/bin/basebackup.sh&apos;</span><br><span class="line">recovery_2nd_stage_command = &apos;&apos;</span><br><span class="line">recovery_timeout = 90</span><br><span class="line">client_idle_limit_in_recovery = 0</span><br><span class="line"></span><br><span class="line">#双击热备配置</span><br><span class="line">use_watchdog = on                   #   开启看门狗，用于监控pgpool 集群健康状态</span><br><span class="line">wd_hostname = &apos;10.86.0.10&apos;             #   本地看门狗地址</span><br><span class="line">wd_port = 9000                          #</span><br><span class="line">wd_priority = 1                         #   看门狗优先级，用于pgpool 集群中master选举</span><br><span class="line">delegate_IP = &apos;10.86.0.100&apos;             #    VIP 地址</span><br><span class="line">if_up_cmd = &apos;ip addr add $_IP_$/24 dev eth0 label eth0:0&apos;  # 配置虚拟IP到本地网卡</span><br><span class="line">if_down_cmd = &apos;ip addr del $_IP_$/24 dev eth0&apos;          #   </span><br><span class="line">wd_lifecheck_method = &apos;heartbeat         # &apos;  看门狗健康检测方法</span><br><span class="line">wd_heartbeat_port = 9694                #     看门狗心跳端口，用于pgpool 集群健康状态通信</span><br><span class="line">wd_heartbeat_keepalive = 2              #     看门狗心跳检测间隔</span><br><span class="line">wd_heartbeat_deadtime = 30              #</span><br><span class="line">heartbeat_destination0 = &apos;10.86.0.12&apos;  #     配置需要监测健康心跳的IP地址，非本地地址，即互相监控，配置对端的IP地址</span><br><span class="line">heartbeat_destination_port0 = 9694      # 监听的端口</span><br><span class="line">heartbeat_device0 = &apos;eth0&apos;              # 监听的网卡名称</span><br><span class="line">wd_life_point = 3               #    生命检测失败后重试次数</span><br><span class="line">wd_lifecheck_query = &apos;SELECT 1&apos; #   用于检查 pgpool-II 的查询语句。默认为“SELECT 1”。</span><br><span class="line">wd_lifecheck_dbname = &apos;postgres&apos;        # 检查健康状态的数据库名称</span><br><span class="line">wd_lifecheck_user = &apos;pgcheck&apos;           # 检查数据库的用户，该用户需要在Postgres数据库存在，且有查询权限</span><br><span class="line">wd_lifecheck_password = &apos;123456&apos;        #   看门狗健康检查用户密码</span><br><span class="line">other_pgpool_hostname0 = &apos;10.86.0.12&apos;  # 指定被监控的 pgpool-II 服务器的主机名</span><br><span class="line">other_pgpool_port0 = 9999       # 指定被监控的 pgpool-II 服务器的端口号</span><br><span class="line">other_wd_port0 = 9000           # 指定 pgpool-II 服务器上的需要被监控的看门狗的端口号</span><br></pre></td></tr></table></figure>
<h1 id="配置pcp-conf"><a href="#配置pcp-conf" class="headerlink" title="配置pcp.conf"></a>配置pcp.conf</h1><p>pcp为pgpool管理接口，pcp.conf里包含有管理接口的认证信息，内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># USERID:MD5PASSWD</span><br><span class="line">postgres:e10adc3949ba59abbe56e057f20f883e</span><br></pre></td></tr></table></figure></p>
<p>md5密码产生：pg_md5 123456</p>
<h1 id="配置pool-hba-conf"><a href="#配置pool-hba-conf" class="headerlink" title="配置pool_hba.conf"></a>配置pool_hba.conf</h1><ul>
<li>pool_hba和pg_hba类似，是客户端连接pgpool的认证</li>
<li>当pgpool使用pg原生模式或只有一个后端服务器时，可以不使用pool_hba</li>
<li>配置：<ul>
<li>从数据库中查询用户及密码：select rolpassword from pg_authid where rolname=’pgtest’; </li>
<li>建立文件pool_passwd，并写入查询到的账号信息：【pgtest:md5adbe22045e9d4ebb5254ed06a0987528】</li>
</ul>
</li>
</ul>
<h1 id="服务启停控制"><a href="#服务启停控制" class="headerlink" title="服务启停控制"></a>服务启停控制</h1><ul>
<li>启动服务：pgpool<ul>
<li>前台debug模式：pgpool -n -d</li>
</ul>
</li>
<li>停止服务：pgpool 【-m smart|fast|immediate】stop</li>
<li>重载配置：pgpool reload</li>
</ul>
<h1 id="服务状态查看"><a href="#服务状态查看" class="headerlink" title="服务状态查看"></a>服务状态查看</h1><p>sql命令行下执行如下命令：</p>
<ul>
<li>节点状态：show pool_nodes;</li>
<li>进程池：show pool_processes;</li>
<li>配置信息：show pool_status;</li>
<li>连接池：show pool_status;</li>
</ul>
<h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><ul>
<li>卸载节点：pcp_detach_node -h 127.0.0.1 -p 9898 -n 1</li>
<li>添加节点：pcp_attach_node -h 127.0.0.1 -p 9898 -n 1</li>
<li>恢复节点为可用状态：pcp_recovery_node【配合pgpool.conf中的ONLINE RECOVERY配置】</li>
</ul>
<h1 id="故障自动切换配置"><a href="#故障自动切换配置" class="headerlink" title="故障自动切换配置"></a><a href="https://www.pgpool.net/docs/latest/en/html/runtime-config-failover.html" target="_blank" rel="noopener">故障自动切换配置</a></h1><ul>
<li>failover_command = ‘/usr/local/pgpool/failover.sh’</li>
<li>failover.sh</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T 172.16.0.215 &quot;/usr/local/pgsql/bin/pg_ctl -D /usr/local/pgsql/data/ -l /home/postgres/logfile promote&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pgsql</category>
      </categories>
      <tags>
        <tag>pgpool</tag>
      </tags>
  </entry>
  <entry>
    <title>pgsql-安装与介绍</title>
    <url>/blog/2019/10/13/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/pgsql-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><blockquote>
<p>示例为ubuntu16.04下的软件包</p>
</blockquote>
<ul>
<li>make</li>
<li>gcc</li>
<li>readline：libreadline6 libreadline6-dev【用于sql命令行提示】</li>
<li>zlib：zlib1g zlib1g-dev【备份和恢复时压缩】</li>
<li>libpython2.7 libpython2.7-dev libpython3.5 libpython3.5-dev【python语言支持】</li>
<li>ssl：OpenSSL【连接加密】</li>
<li>xml2：libxml2 libxml2-dev</li>
<li>xslt：libxslt1.1  libxslt1-dev</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><blockquote>
<p>软件版本：v9.6.15</p>
</blockquote>
<ul>
<li>./configure –with-python –with-openssl –with-libxml –with-libxslt</li>
<li>make </li>
<li>sudo make install</li>
</ul>
<h1 id="链接库设置"><a href="#链接库设置" class="headerlink" title="链接库设置"></a>链接库设置</h1><ul>
<li>动态设置【官方参考】<ul>
<li>【普通用户】LD_LIBRARY_PATH=/usr/local/pgsql/lib;export LD_LIBRARY_PATH</li>
<li>【root】/sbin/ldconfig /usr/local/pgsql/lib</li>
</ul>
</li>
<li>持久化设置：echo /usr/local/pgsql/lib &gt;&gt; /etc/ld.so.conf;ldconfig</li>
</ul>
<h1 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;PATH=/usr/local/pgsql/bin:\$PATH&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export PATH&quot; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser postgres</span><br><span class="line">mkdir /usr/local/pgsql/data</span><br><span class="line">chown postgres /usr/local/pgsql/data</span><br><span class="line">su - postgres</span><br><span class="line">initdb -D /usr/local/pgsql/data --no-locale</span><br><span class="line">pg_ctl -D /usr/local/pgsql/data -l logfile start</span><br><span class="line">createdb test</span><br><span class="line">psql test</span><br></pre></td></tr></table></figure>
<h1 id="postgis安装"><a href="#postgis安装" class="headerlink" title="postgis安装"></a>postgis安装</h1><p>postgis是PostgreSQL的空间和地理对象</p>
<h2 id="依赖安装-1"><a href="#依赖安装-1" class="headerlink" title="依赖安装"></a><a href="http://www.postgis.net/docs/postgis_installation.html#install_requirements" target="_blank" rel="noopener">依赖安装</a></h2><ul>
<li>PostgreSQL9.4以上</li>
<li>gcc</li>
<li>make</li>
<li>proj4：proj-bin</li>
<li>geos：libgeos-c1v5 libgeos-dev </li>
<li>xml2：libxml2 libxml2-dev</li>
<li>json-c：libjson-c2 libjson-c-dev</li>
<li>gdal：libgdal20 gdal-bin libgdal-dev </li>
<li>llvm：llvm-6.0 llvm-6.0-dev </li>
</ul>
<h2 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h2><ul>
<li>./configure –with-pgconfig=/usr/local/pgsql/bin/pg_config</li>
<li>make</li>
<li>sudo make install</li>
</ul>
<h2 id="开启postgis"><a href="#开启postgis" class="headerlink" title="开启postgis"></a>开启postgis</h2><ul>
<li>postgis：psql -d test -c “CREATE EXTENSION postgis;”</li>
<li>postgis_topology:psql -d test -c “CREATE EXTENSION postgis_topology;”</li>
</ul>
<h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><ul>
<li>createdb、createuser：创建库、用户</li>
<li>dropdb、dropuser：删除库、用户</li>
<li>initdb：初始化数据库</li>
<li>pg_basebackup：创建数据目录的备份【主要用于归档中建立基础数据备份】</li>
<li>pg_config：一般用于扩展插件编译时加载pgsql的header信息</li>
<li>pg_ctl：数据库服务启停控制</li>
<li>pg_dump：逻辑备份单个库表</li>
<li>pg_dumpall：备份整个数据库实例的全部信息</li>
<li>pg_restore：用于恢复非文本类型的备份</li>
<li>postgres：数据库服务运行程序</li>
<li>psql：pgsql的客户端</li>
</ul>
<h1 id="名词术语"><a href="#名词术语" class="headerlink" title="名词术语"></a>名词术语</h1><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>checkpoint(sql命令：checkpoint)会把所有的脏数据flush到磁盘，部分参数如下：</p>
<ul>
<li>checkpoint_timeout：两次checkpoint间隔时长</li>
<li>checkpoint_segments:：两次checkpoint间隔最大的xlog日志文件数量</li>
</ul>
<h2 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h2><p>xlog(事务)日志归档，部分参数如下：</p>
<ul>
<li>archive_mode：是否开启归档</li>
<li>archive_command：将xlog拷贝到一个地方的命令</li>
</ul>
<h2 id="流复制"><a href="#流复制" class="headerlink" title="流复制"></a>流复制</h2><ul>
<li>max_wal_senders：master上执行流复制协议的wal_sender数量</li>
<li>wal_keep_segments：xlog目录中最多容纳多少个wal日志文件，超过了则删掉最初的几个。（一个日志文件16M）</li>
<li>hot_standby：是否允许standy节点执行查询功能</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>pgsql的各种日志的默认位置都是在PGDATA目录下，主要包含：</p>
<ul>
<li>pg_log：这个日志一般是记录服务器与DB的状态，比如各种Error信息，定位慢查询SQL，数据库的启动关闭信息，发生checkpoint过于频繁等的告警信 息，诸如此类，常见参数如下<ul>
<li>log_destination = ‘csvlog’</li>
<li>logging_collector = on</li>
<li>【慢日志】log_min_duration_statement = 200：只记录大于200ms的sql语句；0为记录所有语句，-1关闭记录功能。</li>
</ul>
</li>
<li>pg_xlog：是pgsql的wal信息，也就是事务日志，这些日志会在定时回滚恢复(PITR)，流复制(Replication Stream)以及归档时能被用到，不能随意删除或移动</li>
<li>pg_clog：事务的状态信息，这个日志告诉我们哪些事务完成了，哪些没完成。这个日志文件一般非常小，但是很重要。</li>
</ul>
]]></content>
      <categories>
        <category>pgsql</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
        <tag>pgsql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql表结构与数据操作</title>
    <url>/blog/2018/05/14/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h1><ul>
<li>查看存在的库：show databases;</li>
<li>建数据库：create database olgboy_utf8 default character set utf8 collate utf8_general_ci;<ul>
<li>不存在再建立：create database if not exists oldboy_default; </li>
</ul>
</li>
<li>进入数据库：use db1</li>
<li>删除数据库： drop database db1;<ul>
<li>存在才删除：drop database if exists test1;</li>
</ul>
</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>tinyint：1字节<ul>
<li>无符号：(0，255)</li>
<li>有符号：(-128，127)</li>
</ul>
</li>
<li>smallint：2字节<ul>
<li>无符号：(0，65 535)</li>
<li>有符号：(-32 768，32 767)</li>
</ul>
</li>
<li>int：4字节<ul>
<li>无符号：(0，4 294 967 295)</li>
<li>有符号：(-2 147 483 648，2 147 483 647)</li>
</ul>
</li>
<li>bigint：8字节</li>
<li>float：4字节</li>
<li>double：8字节</li>
<li>decimal【精确的小数】</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>char：定长存储，最长255</li>
<li>varchar：不定长存储，最长65535</li>
<li>text：存储文本，最长(2**16-1)65535</li>
<li>mediumtext：最长（2**24-1）</li>
<li>longtext：最长4GB（2**32-1）</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul>
<li>date【日期】：1000-01-01/9999-12-31</li>
<li>time【时间】：’-838:59:59’/‘838:59:59’</li>
<li>datetime【日期 时间】：1000-01-01 00:00:00/9999-12-31 23:59:59</li>
<li>year：1901/2155</li>
<li>timestamp【时间戳、4字节存储】：开始时间0表示1970-01-01 00:00:00，结束时间是第 2147483647 秒【北京时间 2038-1-19 11:14:07（格林尼治时间 2038年1月19日 凌晨 03:14:07）】</li>
</ul>
<h1 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h1><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE subject_comment_manager (</span><br><span class="line">  subject_comment_manager_id bigint(12) NOT NULL auto_increment COMMENT &apos;主键&apos;,</span><br><span class="line">  subject_type tinyint(2) NOT NULL COMMENT &apos;素材类型&apos;,</span><br><span class="line">  subject_primary_key varchar(255) NOT NULL COMMENT &apos;素材的主键（词条是名称，文章是iden，组图是id，视频是MD5）&apos;,</span><br><span class="line">  subject_title varchar(255) NOT NULL COMMENT &apos;素材的名称&apos;,</span><br><span class="line">  edit_user_nick varchar(64) default NULL COMMENT &apos;修改人&apos;,</span><br><span class="line">  edit_user_time timestamp NULL default NULL COMMENT &apos;修改时间&apos;,</span><br><span class="line">  edit_comment varchar(255) default NULL COMMENT &apos;修改的理由&apos;,</span><br><span class="line">  state tinyint(1) NOT NULL default &apos;1&apos; COMMENT &apos;0代表关闭，1代表正常&apos;,</span><br><span class="line">  PRIMARY KEY  (subject_comment_manager_id),</span><br><span class="line">  KEY IDX_PRIMARYKEY (subject_primary_key(32)), </span><br><span class="line">  KEY IDX_SUBJECT_TITLE (subject_title(32)),</span><br><span class="line">  KEY index_nick_type (edit_user_nick(32),subject_type)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb1(</span><br><span class="line">    id int not null auto_increment primary key, </span><br><span class="line">    name char(20),</span><br><span class="line">    age int default 18,</span><br><span class="line">    gender char(1)</span><br><span class="line">    )engine=innodb default charset=&apos;utf8&apos; comment=&apos;跟进表（基于客户、联系人、询盘）&apos;;</span><br></pre></td></tr></table></figure>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><table>
<thead>
<tr>
<th>字段名</th>
<th>数据类型</th>
<th>是否为空</th>
<th>是否为<a href="#主键">主键</a></th>
<th>是否有默认值</th>
<th>是否<a href="#自增">自增</a></th>
<th><a href="#外键">外键约束</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td><a href="#数字">数字</a>/<a href="#字符串">字符串</a>/<a href="#时间">时间</a></td>
<td>【not】null</td>
<td>primary key</td>
<td>default 【xxx】</td>
<td>auto_increment</td>
<td>constraint</td>
</tr>
</tbody>
</table>
<h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><ul>
<li>关键字：auto_increment</li>
<li>限制：一个表只能有一个自增列</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><ul>
<li>约束：不能为空，不能重复</li>
<li>索引：对字段建立索引可以加速查找</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul>
<li>约束：只能是某个表中已经存在的字段</li>
<li>语法：constraint 约束名称 foreign key(本表字段名) references 外表(外表字段名)</li>
</ul>
<h2 id="批量建表"><a href="#批量建表" class="headerlink" title="批量建表"></a>批量建表</h2><blockquote>
<p>使用like语法创建结构一样的表：create table tb_name1 like tb_name2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">tb_list = [&apos;c_fu&apos;, &apos;c_fu_file&apos;, &apos;e_email&apos;, &apos;e_email_body&apos;, &apos;e_email_file&apos;, &apos;e_email_to&apos;, &apos;e_email_track&apos;, &apos;f_mem_upload&apos;]</span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;user&apos;, password=&apos;pass_str&apos;, database=&apos;crm_big3&apos;, charset=&apos;utf8&apos;)</span><br><span class="line">for index in range(2001, 2003):</span><br><span class="line">    for table in tb_list:</span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.Cursor)</span><br><span class="line">        cursor.execute(&apos;create table %s_%s like %s_2000&apos; % (table, index, table))</span><br><span class="line">        cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h1 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h1><h2 id="表名修改"><a href="#表名修改" class="headerlink" title="表名修改"></a>表名修改</h2><p>alter table 表名 rename 新表名;</p>
<h2 id="字段类型修改"><a href="#字段类型修改" class="headerlink" title="字段类型修改"></a>字段类型修改</h2><ul>
<li>修改字段类型：alter table 表名 modify 列名 列类型;</li>
<li>修改字段名及字段类型：alter table 表名 change 列名 新列名 列类型;</li>
</ul>
<h2 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h2><ul>
<li>增加字段到其他字段末尾【默认】：alter table 表名 add 列名 列类型 </li>
<li>添加字段为第一个字段：alter table 表名 add 列名 列类型 FIRST</li>
<li>在指定的字段后添加字段：alter table 表名 add 列名 列类型  AFTER col_name</li>
</ul>
<h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><p>alter table 表名 drop 列名;</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li>设置字段默认值：ALTER TABLE tbl_name ALTER col_name SET DEFAULT literal</li>
<li>删除字段默认值：ALTER TABLE tbl_name ALTER col_name  DROP DEFAULT</li>
</ul>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><ul>
<li>删除空表：drop table tb1;</li>
<li>删除表数据：delete from tb1;<ul>
<li>自增列会继续之前的ID</li>
</ul>
</li>
<li>清空表：truncate table tb1;<ul>
<li>物理删除，速度快，重新计算ID</li>
</ul>
</li>
</ul>
<h1 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h1><ul>
<li>查看存在的表：show tables;</li>
<li>表结构：desc tb_name;</li>
<li>建表语句：show create table tb_name;</li>
</ul>
<h1 id="多表范例"><a href="#多表范例" class="headerlink" title="多表范例"></a>多表范例</h1><h2 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table department(</span><br><span class="line">    id int not null auto_increment primary key,</span><br><span class="line">    title char(20)</span><br><span class="line">    );</span><br><span class="line">create table userinfo(</span><br><span class="line">    id int not null auto_increment primary key, </span><br><span class="line">    name char(20),</span><br><span class="line">    age int default 18,</span><br><span class="line">    gender char(1),</span><br><span class="line">    department_id int,</span><br><span class="line">    constraint user_depar foreign key (department_id) references department(id)</span><br><span class="line">    )engine=innodb default charset=&apos;utf8&apos;;</span><br></pre></td></tr></table></figure>
<h2 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table boy(</span><br><span class="line">    id int not null auto_increment primary key,</span><br><span class="line">    name char(32)</span><br><span class="line">    )engine=innodb default charset=&apos;utf8&apos;;</span><br><span class="line">create table girl(</span><br><span class="line">    id int not null auto_increment primary key,</span><br><span class="line">    name char(32)</span><br><span class="line">    )engine=innodb default charset=&apos;utf8&apos;;</span><br><span class="line">create table b2g(</span><br><span class="line">    id int not null auto_increment primary key,</span><br><span class="line">    bid int,</span><br><span class="line">    gid int,</span><br><span class="line">    constraint to_boy foreign key (bid) references boy(id),</span><br><span class="line">    constraint to_girl foreign key (gid) references girl(id)</span><br><span class="line">    )engine=innodb default charset=&apos;utf8&apos;;</span><br></pre></td></tr></table></figure>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><ul>
<li>单行数据：<code>insert into tb1(name,age,gender) values(&#39;hejingqi&#39;,30,&#39;0&#39;);</code></li>
<li>多行数据：<code>insert into tb1(name,age,gender) values(&#39;yuanshuo&#39;, 24, &#39;1&#39;),(&#39;yangxiaomeng&#39;, 29, &#39;1&#39;);</code></li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>精确删除：<code>delete from tb1 where name=&#39;hejingqi&#39;;</code></li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>单字段修改：<code>update tb1 set age=18 where id=1;</code></li>
<li>多字段修改：<code>update tb1 set id=2,age=30 where name=&#39;yangxiaomeng&#39;;</code> </li>
</ul>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><h2 id="排序（order-by）"><a href="#排序（order-by）" class="headerlink" title="排序（order by）"></a>排序（order by）</h2><ul>
<li>从大到小：select * from score order by number desc;</li>
<li>从小到大：select * from score order by number asc;</li>
</ul>
<h2 id="限定数量（limit）"><a href="#限定数量（limit）" class="headerlink" title="限定数量（limit）"></a>限定数量（limit）</h2><ul>
<li>输出前2行：select * from score limit 2;</li>
<li>从第1个之后取2个：select * from score limit 1,2;</li>
</ul>
<h2 id="模糊匹配（like）"><a href="#模糊匹配（like）" class="headerlink" title="模糊匹配（like）"></a>模糊匹配（like）</h2><ul>
<li>单字符匹配（<code>_</code>）：select * from class where caption like ‘_三一班’;</li>
<li>多字符匹配（<code>%</code>）:select * from class where caption like ‘三%’;</li>
</ul>
<h2 id="左右连表（join）"><a href="#左右连表（join）" class="headerlink" title="左右连表（join）"></a>左右连表（join）</h2><ul>
<li>INNER JOIN即为JOIN，只保留2个表均有的数据</li>
<li>LEFT JOIN以左边的表为主输出数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    student.sname AS &apos;姓名&apos;, # &apos;指明表和列&apos;</span><br><span class="line">    class.caption AS &apos;班级&apos;</span><br><span class="line">FROM </span><br><span class="line">    student #查的主表</span><br><span class="line">LEFT JOIN class ON student.class_id = class.cid;</span><br><span class="line"># LEFT JOIN要连接的表</span><br><span class="line"># ON 2个表的桥接</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    student.sname</span><br><span class="line">FROM</span><br><span class="line">    student</span><br><span class="line">LEFT JOIN score ON score.student_id = student.sid</span><br><span class="line">LEFT JOIN cource ON score.course_id = cource.cid # 多表关联</span><br><span class="line">WHERE cource.cname = &apos;体育&apos;; # 连表之后条件过滤</span><br></pre></td></tr></table></figure>
<h2 id="分组（group-by）"><a href="#分组（group-by）" class="headerlink" title="分组（group by）"></a>分组（group by）</h2><ul>
<li>先分组，再过滤</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  class.caption as &apos;班级&apos;,</span><br><span class="line">    count(class_id) as &apos;数量&apos; #对重复数据的聚合处理：count|max|min|avg</span><br><span class="line">FROM</span><br><span class="line">    student</span><br><span class="line">LEFT JOIN class ON class.cid = student.class_id</span><br><span class="line">GROUP BY # 分组依据</span><br><span class="line">    student.class_id</span><br><span class="line">HAVING count(class_id) &gt; 1; #先分组，然后对分组进行二次过滤</span><br></pre></td></tr></table></figure>
<ul>
<li>先过滤，再分组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  class.caption as &apos;班级&apos;,</span><br><span class="line">    count(class_id) as &apos;数量&apos; #对重复数据的聚合处理</span><br><span class="line">FROM</span><br><span class="line">    student</span><br><span class="line">LEFT JOIN class ON class.cid = student.class_id</span><br><span class="line">WHERE class_id &gt; 1          #先使用条件过滤再进行分组</span><br><span class="line">GROUP BY # 分组依据</span><br><span class="line">    student.class_id;</span><br></pre></td></tr></table></figure>
<h2 id="上下连表（union）"><a href="#上下连表（union）" class="headerlink" title="上下连表（union）"></a>上下连表（union）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sid,sname from student union select tid,tname</span><br><span class="line"> from teacher;</span><br></pre></td></tr></table></figure>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><ul>
<li>结果无重复的查询（distinct ）：select distinct 列名 from 表名 where 条件；</li>
<li>拼接查询结果（concat）：select concat (id, name, score) as info from tt2;</li>
<li>别名设置（as）</li>
<li>聚合函数：count、sum、max、min、avg</li>
</ul>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><ul>
<li>逻辑操作<ul>
<li>or</li>
<li>and</li>
<li>in</li>
<li>not</li>
<li>between 。。。and。。。</li>
</ul>
</li>
<li>比较操作<ul>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>=</code></li>
</ul>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>一般对select查询的where条件列建立索引</li>
<li>可以对多个字段、一个字段、一个字段的前n个字符建立索引</li>
<li>由于复合索引的前缀特性，索引内的字段顺序很重要【一般将常用的列放在前边】</li>
<li>不应当建立索引的情况<ul>
<li>频繁更新的字段【数据插入时，也需要更新索引，这会降低更新操作性能】</li>
<li>数据量小的表，或字段内容较少的字段（如性别、旗标）</li>
<li>字段值为空【此时，查询不走索引】</li>
<li>字段为主键【主键创建时默认会创建索引】</li>
</ul>
</li>
</ul>
<h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><ul>
<li>建立索引：<ul>
<li>create table test1(id int not null,name char(20),sex char(3),primary key(id),index k_name(name(2))); </li>
<li>alter table test add index index_name(column1,column2…);</li>
<li>create index index_name on test(name); </li>
</ul>
</li>
<li>删除索引<ul>
<li>alter table test DROP INDEX index_name</li>
<li>drop index index_Sage on student;</li>
</ul>
</li>
<li>查询是否有索引：show crate table tb_name</li>
<li>查询是否使用索引：explain select * 。。。</li>
</ul>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote>
<p>批量建表的范例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter // -- 定义分界符</span><br><span class="line">drop procedure if exists create_batch_table; -- 删除已经存在的存储过程</span><br><span class="line">create procedure create_batch_table() -- 创建存储过程</span><br><span class="line">begin -- 开始存储过程</span><br><span class="line">declare i int; -- 定义变量类型</span><br><span class="line">set i = 2001; -- 设置变量</span><br><span class="line">while i &lt; 2005 do -- 循环开始</span><br><span class="line">  set @create=CONCAT(&apos;create table c_fu_&apos;, i , &apos; like c_fu_2000;&apos;); -- 定义创建表的语句</span><br><span class="line">  select @create; -- 显示建表语句</span><br><span class="line">   prepare tmt from @create; -- 预编译sql语句</span><br><span class="line">   execute tmt; -- 执行sql语句</span><br><span class="line">   deallocate prepare tmt;  -- 收回sql游标cursor</span><br><span class="line">  set i = i + 1; -- 循环自增</span><br><span class="line">end while; -- 循环结束</span><br><span class="line">end // -- 结束存储过程</span><br><span class="line">call create_batch_table(); -- 调用存储过程</span><br></pre></td></tr></table></figure>
<h1 id="python使用"><a href="#python使用" class="headerlink" title="python使用"></a>python使用</h1><blockquote>
<p>pymysql模块</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;kingold&apos;, password=&apos;zjht098_kingold&apos;,</span><br><span class="line">                       database=&apos;db1&apos;, charset=&apos;utf8&apos;)</span><br><span class="line">cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"># 查询</span><br><span class="line">cursor.execute(&apos;select name,age,gender from tb1&apos;)</span><br><span class="line"># 取所有结果</span><br><span class="line">res1 = cursor.fetchall()</span><br><span class="line"># 取一个结果</span><br><span class="line">res2 = cursor.fetchone()</span><br><span class="line"># 取指定数目结果</span><br><span class="line">res3 = cursor.fetchmany(2)</span><br><span class="line"># 插入</span><br><span class="line">cursor.execute(&apos;insert into tb1(name, age, gender) values(%s, %s, %s)&apos;, (&apos;hejingqi&apos;, 30, &apos;0&apos;))</span><br><span class="line"># 删除</span><br><span class="line">cursor.execute(&apos;delete from tb1 where name=%s&apos;, (&apos;yangxiaomeng&apos;))</span><br><span class="line">cursor.close()</span><br><span class="line"># 增删改数据时提交变更</span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/blog/2018/02/28/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>进程间的通讯IPC (Inter-process communication))：指至少两个进程或线程间传送数据或信号的一些技术或方法。</p>
<h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M字节之间</li>
<li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<h2 id="基于相对位置的分类"><a href="#基于相对位置的分类" class="headerlink" title="基于相对位置的分类"></a>基于相对位置的分类</h2><ul>
<li>本地过程调用(LPC)LPC用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务共享内存空间使任务同步和互相发送信息。</li>
<li>远程过程调用(RPC)RPC类似于LPC，只是在网上工作。RPC开始是出现在Sun微系统公司和HP公司的运行UNIX操作系统的计算机中。</li>
</ul>
<h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><ul>
<li>管道(pipe)：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道(named pipe)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>消息队列：消息队列是消息的链接表，包括Posix消息队列和system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息传递与传统的应用程序交互的区别：实时性。Message Queue不适合实时性要求比较高的场景，因为Message Queue通过异步的方式与server端进行交互，不用担心server端的长时间处理过程。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>消息：两个计算机（或进程）之间传递的数据单位，例如字符串、文本等</li>
<li>消息队列（queue、message queue）：消息的容器；用于在消息传递的过程中保存消息的容器，充当消息源和目标之间的中间桥梁。队列的主要目的就在于提供路由保证消息的传递。</li>
<li>消息中间件：利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，可以在分布式环境下扩展进程间的通信。 </li>
</ul>
<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）、Broker（中转角色）；主要实现以下几个功能：</p>
<ul>
<li>优先级(Message Priority)：Producer把消息发送给Broker来存储，那么我们就可以在消息队列中对我们的消息来进行排序，实现不同的优先级。从而满足我们复杂的业务需求。</li>
<li>消息排序(Message Order)，有的消息的处理是需要按照一定的顺序进行处理的，比如用户的创建订单、订单付款、订单完成。那么对于消费者也需要按照这个流程来消费，否则就没有意义了。</li>
<li>过滤器(Message Filter)：在消息队列中，也可以对我们的消息进行过滤，比如按照消息类型等条件来过滤</li>
<li>持久化存储(Message Persistence)：消息的持久化，防止了系统挂掉后，仍然能够从之前备份中恢复出来。持久化方式有以下几种：<ul>
<li>持久化到数据库，比如MySQL</li>
<li>持久化到KV存储，比如Redis</li>
<li>文件形式持久化</li>
</ul>
</li>
<li>丢弃策略：我们知道Broker是用来存储需要处理的消息，如果消息过多，导致Buffer满了，这时候就会采取一定的策略来丢弃已有的消息。  </li>
<li>事务的支持：正如上面所谈到的订单的操作，因此消息中间件中也会提供对分布式事务的支持。</li>
<li>定时消息：在实际应用中，有时也会需要定时消费的功能，因此中间件中，也会对消息进行排序，然后实现定时发送或者消费消息的业务需求。</li>
<li>消息重试：考虑一下这个问题，如果消息消费失败后，怎么办，是等待处理这个消息呢？还是让消费者再次消费一次呢？通常情况下，采取后者的形式，因为大多数情况下，消费失败的原因在于该消息本身的原因，如果再次消费这个消息的话，还是会出现失败的情况，因此通常采取再次发送消息的方式。</li>
<li>回溯消费：什么是回溯消费呢？对于已经消费成功的消息，是不是在Broker中就丢弃该消息呢？显而易见是不可能的，因此需要中间件对该功能支持，支持已经消费的信息进行时间段内的存储，等待某一刻内该消息会被重新消费的可能。</li>
</ul>
<h1 id="python范例"><a href="#python范例" class="headerlink" title="python范例"></a>python范例</h1><h2 id="共享内存空间-Manager"><a href="#共享内存空间-Manager" class="headerlink" title="共享内存空间-Manager"></a>共享内存空间-Manager</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def work(l, d):</span><br><span class="line">    l.append(os.getpid())</span><br><span class="line">    d[os.getpid()] = os.getpid()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    m = Manager()</span><br><span class="line">    # 由manager创建的列表和字典对象可以被所有进程操作</span><br><span class="line">    l = m.list([&apos;init&apos;])</span><br><span class="line">    d = m.dict(&#123;&apos;name&apos;: &apos;egon&apos;&#125;)</span><br><span class="line">    p_l = []</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p = Process(target=work, args=(l, d))</span><br><span class="line">        p_l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    for p in p_l:</span><br><span class="line">        p.join()</span><br><span class="line">    print(d, l)</span><br></pre></td></tr></table></figure>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列-Queue"></a>队列-Queue</h2><ul>
<li>q=Queue(3) 定义队列及其大小</li>
<li>q.put() 向队列放置元素</li>
<li>q.full() 队列是否已满</li>
<li>q.empty() 队列是否为空</li>
<li>q.put_nowait() 不能放置元素直接报异常</li>
<li>q.put(‘4’, block=False) 不能放则报异常【默认block为True】</li>
<li>q.put(‘4’, timeout=2) 放置时最多等待2s，超时则报异常</li>
</ul>
<h2 id="队列-JoinableQueue"><a href="#队列-JoinableQueue" class="headerlink" title="队列-JoinableQueue"></a>队列-JoinableQueue</h2><blockquote>
<p>和Queue方法类似，但是JoinableQueue消费者消费完时必须向生产者发送信号，生产者必须等待消费者消费完成时发送的信号</p>
</blockquote>
<ul>
<li>JoinableQueue.task_done()：向生产者发送已消费的信号</li>
<li>JoinableQueue.join()：等待消费者发送已消费的信号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Queue, Pool, Manager, JoinableQueue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def write(seq, q):</span><br><span class="line">    print(&apos;Process to write: %s&apos; % os.getpid())</span><br><span class="line">    for value in seq:</span><br><span class="line">        time.sleep(random.randint(1, 3))</span><br><span class="line">        print(&apos;put %s to queue...&apos; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">    # (JoinableQueue下）等待消费者发送已消费的信号</span><br><span class="line">    q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read(q):</span><br><span class="line">    print(&apos;Process to read: %s&apos; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        time.sleep(random.randint(1, 3))</span><br><span class="line">        value = q.get(True)</span><br><span class="line">        # （JoinableQueue下）向生产者发送已消费的信号</span><br><span class="line">        q.task_done()</span><br><span class="line">        print(&apos;get %s from queue&apos; % value)</span><br><span class="line"></span><br><span class="line"># 进程模式下队列使用【使用原生的queue】</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    #q = Queue()</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line">    data = list(range(5))</span><br><span class="line">    pw = Process(target=write, args=(data, q))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 当主进程结束时子进程也跟着结束，子进程的daemon属性必须先于start设置</span><br><span class="line">    pr.daemon = True</span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr.join()</span><br><span class="line"></span><br><span class="line"># 进程池模式下队列使用【使用Manager的queue】</span><br><span class="line">#if __name__ == &apos;__main__&apos;:</span><br><span class="line">#    manager = Manager()</span><br><span class="line">#    q = manager.Queue()</span><br><span class="line">#    p = Pool()</span><br><span class="line">#    p.apply_async(write, args=(q,))</span><br><span class="line">#    p.apply_async(read, args=(q,))</span><br><span class="line">#    p.close()</span><br><span class="line">#    p.join()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>IPC</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>pgsql-归档和流复制</title>
    <url>/blog/2019/10/13/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/pgsql-%E5%BD%92%E6%A1%A3%E5%92%8C%E6%B5%81%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="文件级别备份"><a href="#文件级别备份" class="headerlink" title="文件级别备份"></a>文件级别备份</h1><h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><ul>
<li>在开始备份或恢复前，需要关闭服务【只是停止对外服务是不可行的，因为无法产生原子快照或服务的内部缓冲机制】</li>
<li>无法单独恢复表【表文件和事务数据单独存储，只使用表文件和事务状态日志(pg_clog)则会造成其他表不可用】，文件级别备份只能用于完整备份和集群级别的恢复</li>
</ul>
<h2 id="不停机处理"><a href="#不停机处理" class="headerlink" title="不停机处理"></a>不停机处理</h2><ul>
<li>获取数据目录的一致性”快照”；<ul>
<li>数据目录和WAL日志在不同磁盘，或表空间文件在不同文件系统时，获取一致性快照则比较困难</li>
<li>可以使用归档备份【continuous archiving base backup】来获取一致性的数据</li>
</ul>
</li>
<li>由于此”快照”是在服务运行时的数据，当此数据目录快照在执行恢复时会认为服务没有正常关闭，服务会应用上次checkpoint之后WAL日志【即，此时数据恢复也需要pg_xlog目录下的wal日志】；</li>
<li>在获取快照前，执行CHECKPOINT可以减少恢复时间。</li>
</ul>
<h1 id="归档备份和恢复"><a href="#归档备份和恢复" class="headerlink" title="归档备份和恢复"></a><a href="https://www.postgresql.org/docs/9.6/continuous-archiving.html" target="_blank" rel="noopener">归档备份和恢复</a></h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>wal文件不包含索引信息，所以索引需要手动处理</li>
<li>基础备份进行中，如果有 CREATE DATABASE执行会出现意料之外的事</li>
<li>创建表空间时，使用的是字面意思的绝对路径，在跨主机恢复会有问题</li>
</ul>
<h2 id="归档设置"><a href="#归档设置" class="headerlink" title="归档设置"></a>归档设置</h2><ul>
<li>参数设置【postgresql.conf】<ul>
<li>wal_level = replica</li>
<li>archive_mode = on</li>
<li>archive_command = ‘test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f’</li>
<li>【pg_baseback命令使用】max_wal_senders = 5</li>
<li>【pg_baseback命令使用】wal_keep_segments = 10</li>
</ul>
</li>
<li>【pg_baseback命令使用】添加复制用户（pg_hba.conf） <ul>
<li>【local   replication     postgres                                trust】</li>
</ul>
</li>
<li>建立归档目录，并设置目录权限为pg server运行用户</li>
<li>重启数据库</li>
<li>测试归档是否正常<ul>
<li>checkpoint;</li>
<li>select pg_switch_xlog();</li>
</ul>
</li>
</ul>
<h2 id="基础备份"><a href="#基础备份" class="headerlink" title="基础备份"></a>基础备份</h2><ul>
<li>方式1：使用pg_basebackup命令</li>
<li>方式2：使用sql命令行下的API手动处理<ul>
<li>开启归档设置</li>
<li>打开强制检查点【保持会话连接】：SELECT pg_start_backup(‘label’, false, false);</li>
<li>备份数据目录，并排除如下文件和目录<ul>
<li>postmaster.pid、postmaster.opts</li>
<li>recovery.conf、recovery.done</li>
<li>pg_log</li>
<li>pg_xlog</li>
<li>pg_replslot</li>
</ul>
</li>
<li>关闭强制检查点【同一会话】：SELECT * FROM pg_stop_backup(false);</li>
<li>【可选】：删除检查点之前的归档文件</li>
</ul>
</li>
</ul>
<h3 id="手动模式备份实践"><a href="#手动模式备份实践" class="headerlink" title="手动模式备份实践"></a>手动模式备份实践</h3><ul>
<li>备份数据目录：tar czf /home/postgres/backup/data_$(date +%F).tar.gz     data/ –exclude=pg_xlog &gt;/dev/null 2&gt;&amp;1</li>
<li>跨主机同步数据目录：rsync -C -a –delete -e ssh –exclude pg_log –exclude pg_xlog –exclude recovery.conf –exclude recovery.done data/ 10.150.10.41:~/db0/data/</li>
<li>跨主机同步归档目录：rsync -C -a –delete -e ssh archive/ 10.150.10.41:/home/postgres/db0/archive/</li>
</ul>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><ul>
<li>停止服务</li>
<li>保留并转储pg_xlog目录内容，因为它们可能包含系统宕机时还没有归档的日志</li>
<li>删除数据目录及表空间根目录下的内容</li>
<li>从基础备份中恢复数据目录</li>
<li>删除基础备份中的pg_xlog的文件【因为它们可能比当前的数据陈旧】</li>
<li>将转储的pg_xlog文件复制到数据目录</li>
<li>在数据目录创建recovery.conf文件，并设置策略阻止普通用户连接并使用服务【pg_hba.conf或iptables】</li>
<li>【原理：恢复过程】：此时将使用上次基础备份以后的归档wal文件，及当前pg_xlog目录下的wal文件用于恢复数据<ul>
<li>归档目录不存在的内容将认为存在于pg_xlog中，这样就允许使用最近没有归档的wal文件</li>
<li>归档目录中存在的内容优先于pg_xlog被应用</li>
<li>恢复时将不会覆盖现有pg_xlog下的内容</li>
</ul>
</li>
<li>恢复完成后，服务会自动将recovery.conf重命名为recovery.done</li>
<li>确认恢复完成后，开启对外服务</li>
</ul>
<h3 id="recovery-conf"><a href="#recovery-conf" class="headerlink" title="recovery.conf"></a>recovery.conf</h3><ul>
<li>可以在安装目录的share目录下找到recovery.conf.sample作为范例</li>
<li>文件选项<ul>
<li>恢复命令【必选】：restore_command = ‘cp /mnt/server/archivedir/%f %p’</li>
<li>恢复截止时间：recovery_target_time (timestamp)</li>
<li>是否包含截止点：recovery_target_inclusive (boolean)<ul>
<li>默认为true，包含截止点，即在截止点停止</li>
<li>false，不包含截止点，在截止点之前停止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="流复制"><a href="#流复制" class="headerlink" title="流复制"></a><a href="https://www.postgresql.org/docs/9.6/warm-standby.html" target="_blank" rel="noopener">流复制</a></h1><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><ul>
<li>表空间：如果使用表空间，因为表空间使用绝对路径的原因，需要主备可以建立相同的路径</li>
<li>硬件方面：主备的硬件架构需要一致，比如都是32或64位系统</li>
<li>软件版本：主备大版本要尽可能保持一致，备机小版本高于主是可以的，这是因为高版本可以读取低版本的wal文件</li>
</ul>
<h2 id="备机操作原理"><a href="#备机操作原理" class="headerlink" title="备机操作原理"></a>备机操作原理</h2><ul>
<li>重放wal的顺序<ul>
<li>归档目录中的文件</li>
<li>pg_xlog中的文件</li>
<li>连接主机获取的wal</li>
</ul>
</li>
<li>备机转换为正常的可读写主机<ul>
<li>使用命令：pg_ctl promote</li>
<li>触发器文件：trigger_file</li>
</ul>
</li>
</ul>
<h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><ul>
<li>归档目录可以被备机访问【如scp】，或直接在备机复制同样的归档文件</li>
<li>流复制设置：<ul>
<li>建立复制权限用户<ul>
<li>sql—》create user repl replication password ‘repl-123456’;</li>
<li>pg_hba.conf —》【host    replication     repl            172.16.0.0/24           password】</li>
</ul>
</li>
<li>其他配置：<ul>
<li>开启流复制线程【根据备机数量调整大小】：max_wal_senders </li>
<li>保持主备一致的配置：hot_standby = on</li>
</ul>
</li>
<li>【可选功能】 max_replication_slots</li>
</ul>
</li>
</ul>
<h2 id="备机配置"><a href="#备机配置" class="headerlink" title="备机配置"></a>备机配置</h2><ul>
<li>【高可用】保持和主机相同的配置，如：归档、连接、授权等，其中archive_mode的设置参考如下<ul>
<li>在非恢复模式时，on和always作用一样，都会产生归档文件</li>
<li>在恢复模式时，on并不会起作用（提升为主时才起作用）；always只有则会产生自己的归档文件【处理复杂，不建议使用】</li>
</ul>
</li>
<li>从主机恢复一个基础备份：pg_basebackup -h 172.16.0.215 -U ‘repl’ -D data/ -RP</li>
<li>从主机复制归档文件：rsync -az -e ssh <a href="mailto:postgre@172.16.0.215" target="_blank" rel="noopener">postgre@172.16.0.215</a>:/usr/local/pgsql/archive archive</li>
<li>创建配置文件 recovery.conf【pg_basebackup自动创建】<ul>
<li>standby_mode = ‘on’</li>
<li>primary_conninfo = ‘host=192.168.1.50 port=5432 user=foo password=foopass’</li>
<li>restore_command = ‘cp /path/to/archive/%f %p’</li>
<li>【从机可读设置】 hot_standby = ‘on’（postgresql.conf）</li>
<li>【多备机故障切换设置】recovery_target_timeline=‘latest’</li>
</ul>
</li>
</ul>
<h2 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h2><ul>
<li>【主】pg_current_xlog_location：产生的wal记录</li>
<li>【备】pg_last_xlog_receive_location：已接收但未执行的wal记录</li>
<li>【主】pg_stat_replication：wal发送进程列表<ul>
<li>sent_location与pg_current_xlog_location的差异表明主处于高负载状态</li>
<li>sent_location与pg_last_xlog_receive_location的差异表明主备的网络处于高负载，或从处于高负载状态</li>
</ul>
</li>
</ul>
<h2 id="备升级为主"><a href="#备升级为主" class="headerlink" title="备升级为主"></a>备升级为主</h2><ul>
<li>切换注意事项：需要保证同一时间只有一个主对外提供读写服务，通行的方案是heartbeat、vip偏移</li>
<li>切换方式<ul>
<li>方式1：设置 trigger_file（recovery.conf）</li>
<li>方式2：使用 pg_ctl promote</li>
</ul>
</li>
</ul>
<h1 id="其他复制技术"><a href="#其他复制技术" class="headerlink" title="其他复制技术"></a>其他复制技术</h1><h2 id="复制槽"><a href="#复制槽" class="headerlink" title="复制槽"></a>复制槽</h2><ul>
<li>作用：保护wal文件避免被轮转或删除，与wal_keep_segments、archive_command作用相同</li>
<li>优势：相比其他两种凡是，它只保持最小量的wal文件</li>
</ul>
<h2 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h2><ul>
<li>max_wal_senders</li>
<li>hot_standby</li>
<li>host-based authentication</li>
</ul>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><ul>
<li>原理与限制条件<ul>
<li>主无需从库返回确认信息的情况<ul>
<li>只读事务、事务回滚</li>
<li>顶层的事务需要备库返回信息、而子事务不需要</li>
<li>长时间运行的操作，包括数据加载、建立索引</li>
</ul>
</li>
<li>主需要从库返回确认信息：两阶段的操作（prepare、commit）</li>
<li>因为主库必须知道从库的状态信息，主库和从库必须直连，所以级联不能使用同步复制</li>
<li>主服务器必须等待所有同步服务器返回事务确认信息，否则事务永远不会完成；但可以定义同步、半同步、异步服务器减弱这种影响（synchronous_standby_names）</li>
<li>在事务等待返回信息时创建备用服务器，应当在运行pg_start_backup和pg_stop_backup的同一个会话中设置synchronous_commit = off，否则事务提交会一直等待新的备用服务器出现才会完成</li>
</ul>
</li>
<li>配置<ul>
<li>synchronous_standby_names：从库名称信息，由application_name（recover.conf）组成，逗号分隔<ul>
<li>范例：synchronous_standby_names = ‘2 (s1, s2, s3)’</li>
<li>解释：如果有s1, s2, s3 and s4 4个备用服务器，则s1，s2是主的同步服务器，s3是备主同步服务器（s1或s2出故障时被提升为主同步），s4为异步服务器【无需设置，默认为异步】</li>
</ul>
</li>
<li>synchronous_commit：数据持久化级别【也可以在整个数据库级别、连接、事务级别指定数据持久化级别？？？】<ul>
<li>on：默认设置，从库写一大块wal数据到磁盘</li>
<li>remote_write：从库接收记录，并将内容写入操作系统，但不是持久化到磁盘</li>
<li>remote_apply：从库已经应用接收的事务提交，但没有到数据写入阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><ul>
<li>共享存储：NAS</li>
<li>块设备复制（文件系统级别）：DRBD</li>
<li>事务日志传送：文件级别的日志传送、流复制</li>
<li>基于触发器的主备复制：Slony-I </li>
<li>基于语句复制的中间件：Pgpool-II</li>
<li>异步多主复制：Bucardo </li>
<li>同步多主复制：无</li>
<li>商业解决方案</li>
</ul>
<h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><ul>
<li>数据分区（Data Partitioning）：数据拆分后分布式存储，需要使用时再组合返回给终端</li>
<li>并行查询【提高查询速度】<ul>
<li>原理：将单个sql查询语句拆分成多个部分，分别交给不同后端处理，多个后端的查询结果经过聚合后返回给客户端</li>
<li>实现：Pgpool-II、PL/Proxy</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>pgsql</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>归档</tag>
        <tag>流复制</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列RabbitMQ</title>
    <url>/blog/2019/11/01/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/</url>
    <content><![CDATA[<h1 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h1><h2 id="与python中的queue"><a href="#与python中的queue" class="headerlink" title="与python中的queue"></a>与python中的queue</h2><ul>
<li>线程queue：同一个进程下不同线程间的交互</li>
<li>进程Queue：父子进程交互，或同属于一个进程下的多个子进程间交互</li>
<li>消息中间件(rabbitmq)：不同程序间的交互</li>
</ul>
<h2 id="同类产品对比"><a href="#同类产品对比" class="headerlink" title="同类产品对比"></a>同类产品对比</h2><ul>
<li>RabbitMQ<ul>
<li>由高并发语言Erlang编写</li>
<li>基于AMQP协议实现</li>
<li>为了保证消息的可靠性，有消息确认机制、支持事务，不支持批量操作</li>
</ul>
</li>
<li>Kafka<ul>
<li>linkedin开源的产品，目前归属apache基金会</li>
<li>追求吞吐量，内部采用消息的批量处理</li>
<li>数据的存储和获取是本地磁盘顺序批量操作</li>
</ul>
</li>
<li>RocketMQ：阿里巴巴基于kafka，使用java重写的产品</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>broker：简单来说就是消息队列服务器实体</li>
<li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列；目前支持的规则类型<ul>
<li>Direct：精确匹配，完全根据key进行消息投递</li>
<li>Topic：模式匹配，对key进行模式匹配后进行消息投递（符 号”#”匹配一个或多个词，符号”*“匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*“只匹配”abc.def”）</li>
<li>fanout：广播功能，不需要key，此时会把所有发送到该exchange的消息路由到与它绑定的Queue中</li>
</ul>
</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li>
<li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离</li>
<li>producer：消息生产者，就是投递消息的程序</li>
<li>consumer：消息消费者，就是接受消息的程序</li>
<li>channel：消息通道，在客户端的每个连接里，都可以建立多个channel，每个channel代表一个会话任务</li>
</ul>
<h1 id="高可用安装"><a href="#高可用安装" class="headerlink" title="高可用安装"></a>高可用安装</h1><p>高可用架构，需要同时使用cluster和队列的镜像模式：</p>
<ul>
<li><a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">cluster</a>：在所有节点同步对broker的管理和状态信息，因此可以连接任意节点对集群操作</li>
<li><a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">镜像模式</a>：使用镜像模式对exchange、queue做多副本管理，消除默认情况下exchange、queue单节点存储的危险</li>
</ul>
<p>集群共使用3个节点【192.168.31.231、192.168.31.232、192.168.31.233】</p>
<h2 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h2><blockquote>
<p>默认在3个节点操作</p>
</blockquote>
<ul>
<li><p>节点hosts配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.31.231 rabbitmq-1</span><br><span class="line">192.168.31.232 rabbitmq-2</span><br><span class="line">192.168.31.233 rabbitmq-3</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装rabbitmq软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y rabbitmq-server</span><br><span class="line">systemctl start rabbitmq-server # 单机模式启动，产生cookie信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>统一节点cookie【既用于客户端认证，也用于集群节点间认证】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 停止rabbitmq服务</span><br><span class="line">rabbitmqctl stop</span><br><span class="line"></span><br><span class="line"># 将rabbitmq-1的cookie复制到rabbitmq-2、rabbitmq-3</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie rabbitmq-2:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie rabbitmq-3:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br><span class="line"># 更改cookie权限</span><br><span class="line">chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">chmod 400 /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure>
</li>
<li><p>独立方式启动rabbitmq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br><span class="line">rabbitmqctl cluster_status # 查看状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建集群【在节点rabbitmq-2、rabbitmq-3上，将节点加入rabbitmq-1创建的集群】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbitmq-1</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status # 查看状态</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>设置：所有queue、exchange自动在所有节点进行镜像备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all &quot;.*&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>更详细的镜像模式介绍如下：</p>
<ul>
<li><p>镜像操作类型</p>
<ul>
<li>exactly：集群中共保留几个副本【主+镜像数】</li>
<li>all：在集群的其他所有节点都保留副本</li>
<li>nodes：在集群指定的节点保留副本</li>
</ul>
</li>
<li><p>操作范例</p>
<ul>
<li><p>exactly：名字以two开始的queue，自动在集群中保留2个副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-two &quot;^two\.&quot; \</span><br><span class="line">  &apos;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>all：名字以ha开始的queue，在集群其他所有节点都保留副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all &quot;^ha\.&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nodes：名字以nodes开头的queue，在rabbit@nodeA、rabbit@nodeB保留副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-nodes &quot;^nodes\.&quot; \</span><br><span class="line">&apos;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><ul>
<li>如果客户端支持连接多个rabbitmq实例（如pika），可以直接使用</li>
<li>如果客户端不支持连接多个rabbitmq实例（如celery），则需要使用nginx对多个mq实例进行负载均衡代理</li>
</ul>
<h1 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h1><ul>
<li><p>虚拟机管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_vhost &lt;vhostpath&gt;</span><br><span class="line">delete_vhost &lt;vhostpath&gt;</span><br><span class="line">list_vhosts [&lt;vhostinfoitem&gt; ...]</span><br><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">clear_permissions [-p &lt;vhostpath&gt;] &lt;username&gt;</span><br><span class="line">list_permissions [-p &lt;vhostpath&gt;]</span><br><span class="line">list_user_permissions &lt;username&gt;</span><br><span class="line"></span><br><span class="line"># 范例</span><br><span class="line">添加：rabbitmqctl add_vhost celery</span><br><span class="line">列表：rabbitmqctl list_vhosts</span><br><span class="line">授权：rabbitmqctl set_permissions -p celery ever01 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_user &lt;username&gt; &lt;password&gt;</span><br><span class="line">delete_user &lt;username&gt;</span><br><span class="line">change_password &lt;username&gt; &lt;newpassword&gt;</span><br><span class="line">clear_password &lt;username&gt;</span><br><span class="line">set_user_tags &lt;username&gt; &lt;tag&gt; ...</span><br><span class="line">list_users</span><br><span class="line"></span><br><span class="line"># 范例</span><br><span class="line">添加用户： rabbitmqctl add_user ever01 Theistyle     </span><br><span class="line">开启用户web功能：rabbitmqctl set_user_tags ever01 administrator</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像模式设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_policy [-p &lt;vhostpath&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] </span><br><span class="line">&lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br><span class="line">clear_policy [-p &lt;vhostpath&gt;] &lt;name&gt;</span><br><span class="line">list_policies [-p &lt;vhostpath&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_queues [-p &lt;vhostpath&gt;] [&lt;queueinfoitem&gt; ...]</span><br><span class="line">list_exchanges [-p &lt;vhostpath&gt;] [&lt;exchangeinfoitem&gt; ...]</span><br><span class="line">list_bindings [-p &lt;vhostpath&gt;] [&lt;bindinginfoitem&gt; ...]</span><br><span class="line">list_connections [&lt;connectioninfoitem&gt; ...]</span><br><span class="line">list_channels [&lt;channelinfoitem&gt; ...]</span><br><span class="line">list_consumers [-p &lt;vhostpath&gt;]</span><br><span class="line">status</span><br><span class="line">environment</span><br><span class="line">report</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="web管理功能"><a href="#web管理功能" class="headerlink" title="web管理功能"></a>web管理功能</h1><ul>
<li>开启web功能：<ul>
<li>启用功能：rabbitmq-plugins enable rabbitmq_management</li>
<li>重启rabbitmq：systemctl restart rabbitmq-server</li>
<li>web访问【默认guest/guest】：<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></li>
</ul>
</li>
<li>自定义web管理用户：<ul>
<li>建立用户：rabbitmqctl add_user full_access qaz123</li>
<li>开启用户管理员功能：rabbitmqctl set_user_tags full_access administrator</li>
</ul>
</li>
</ul>
<h1 id="持久化设置"><a href="#持久化设置" class="headerlink" title="持久化设置"></a>持久化设置</h1><p>rabbitMQ支持消息持久化，持久化包含三个部分：  </p>
<ul>
<li>exchange：声明时指定durable </li>
<li>queue：声明时指定durable</li>
<li>message：在投递时指定delivery_mode =》2（1是非持久化）</li>
</ul>
<p>只有exchange和queue都是持久化的，那么他们的binding才是持久化的；如果两者之一不能持久化，就不允许建立绑定。</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul>
<li>客户端连接到消息队列服务器（vhost、账号、密码），打开一个channel</li>
<li>客户端声明一个exchange，并设置相关属性</li>
<li>客户端声明一个queue，并设置相关属性</li>
<li>客户端使用routing key，在exchange和queue之间建立绑定关系</li>
<li>客户端投递消息到exchange</li>
</ul>
<h1 id="python客户端-pika"><a href="#python客户端-pika" class="headerlink" title="python客户端-pika"></a>python客户端-pika</h1><ul>
<li>生产者producer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pika, sys</span><br><span class="line"></span><br><span class="line"># 建立链接</span><br><span class="line">auth = pika.credentials.PlainCredentials(&apos;ever01&apos;, &apos;Theistyle&apos;)</span><br><span class="line"># 连接单个mq实例</span><br><span class="line"># conn_para = pika.ConnectionParameters(</span><br><span class="line">#     host=&apos;127.0.0.1&apos;,</span><br><span class="line">#     port=5672,</span><br><span class="line">#     virtual_host=&apos;celery&apos;,</span><br><span class="line">#     credentials=auth</span><br><span class="line"># )</span><br><span class="line"></span><br><span class="line"># 连接多个mq实例</span><br><span class="line">conn_para = (</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.231&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.232&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.233&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">conn = pika.BlockingConnection(parameters=conn_para)</span><br><span class="line"></span><br><span class="line"># 创建channel</span><br><span class="line">channel = conn.channel()</span><br><span class="line"># direct模式</span><br><span class="line"># channel.exchange_declare( # 创建exchange</span><br><span class="line">#     exchange=&apos;direct_log&apos;,</span><br><span class="line">#     exchange_type=&apos;direct&apos;,</span><br><span class="line">#     durable=True)</span><br><span class="line"># topic模式</span><br><span class="line"># channel.exchange_declare( # 创建exchange</span><br><span class="line">#     exchange=&apos;topic_log&apos;,</span><br><span class="line">#     exchange_type=&apos;topic&apos;,</span><br><span class="line">#     durable=True)</span><br><span class="line">channel.exchange_declare( # 创建exchange</span><br><span class="line">    exchange=&apos;fanout_log&apos;,</span><br><span class="line">    exchange_type=&apos;fanout&apos;,</span><br><span class="line">    durable=True)</span><br><span class="line"></span><br><span class="line"># 定义发送的key和内容</span><br><span class="line">keys = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;anonymous.info&apos; # 定义key</span><br><span class="line">message = &apos;&apos;.join(sys.argv[2:]) or &apos;Hello World!&apos; # 定义message</span><br><span class="line"></span><br><span class="line"># 发布消息</span><br><span class="line">channel.basic_publish(</span><br><span class="line">    # exchange=&apos;direct_log&apos;,</span><br><span class="line">    # exchange=&apos;topic_log&apos;,</span><br><span class="line">    exchange=&apos;fanout_log&apos;,</span><br><span class="line">    routing_key=keys,</span><br><span class="line">    body=message,</span><br><span class="line">    properties=pika.BasicProperties(delivery_mode=2)</span><br><span class="line">)</span><br><span class="line">print(&quot;[x] Sent %r:%r&quot; % (keys, message))</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>消费者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pika, sys</span><br><span class="line"></span><br><span class="line"># 建立链接</span><br><span class="line">auth = pika.credentials.PlainCredentials(&apos;ever01&apos;, &apos;Theistyle&apos;)</span><br><span class="line"># 连接单个mq实例</span><br><span class="line"># conn_para = pika.ConnectionParameters(</span><br><span class="line">#     host=&apos;127.0.0.1&apos;,</span><br><span class="line">#     port=5672,</span><br><span class="line">#     virtual_host=&apos;celery&apos;,</span><br><span class="line">#     credentials=auth</span><br><span class="line"># )</span><br><span class="line"></span><br><span class="line"># 连接多个mq实例</span><br><span class="line">conn_para = (</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.231&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.232&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">    pika.ConnectionParameters(</span><br><span class="line">        host=&apos;192.168.31.233&apos;,</span><br><span class="line">        port=5672,</span><br><span class="line">        virtual_host=&apos;celery&apos;,</span><br><span class="line">        credentials=auth,</span><br><span class="line">        connection_attempts=3,</span><br><span class="line">        retry_delay=1</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">conn = pika.BlockingConnection(parameters=conn_para)</span><br><span class="line"></span><br><span class="line"># 创建channel</span><br><span class="line">channel = conn.channel()</span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;, durable=True) # 创建queue</span><br><span class="line"># direct模式</span><br><span class="line"># channel.exchange_declare( # 创建exchange</span><br><span class="line">#     exchange=&apos;direct_log&apos;,</span><br><span class="line">#     exchange_type=&apos;direct&apos;,</span><br><span class="line">#     durable=True)</span><br><span class="line"># topic模式</span><br><span class="line"># channel.exchange_declare( # 创建exchange</span><br><span class="line">#     exchange=&apos;topic_log&apos;,</span><br><span class="line">#     exchange_type=&apos;topic&apos;,</span><br><span class="line">#     durable=True)</span><br><span class="line">channel.exchange_declare( # 创建exchange</span><br><span class="line">    exchange=&apos;fanout_log&apos;,</span><br><span class="line">    exchange_type=&apos;fanout&apos;,</span><br><span class="line">    durable=True)</span><br><span class="line"></span><br><span class="line"># 定义接收的key，并将queue和exchange绑定【建立通道接收消息】</span><br><span class="line"># key = sys.argv[1] # 命令行接收routing_key</span><br><span class="line"># if not key:</span><br><span class="line">#     sys.stderr.write(&quot;Usage:%s key \n&quot; % sys.argv[0])</span><br><span class="line">#     sys.exit(1)</span><br><span class="line">channel.queue_bind(</span><br><span class="line">    # exchange=&apos;direct_log&apos;,</span><br><span class="line">    # exchange=&apos;topic_log&apos;,</span><br><span class="line">    exchange=&apos;fanout_log&apos;,</span><br><span class="line">    queue=&apos;hello&apos;,</span><br><span class="line">    # routing_key=key # fanout模式下无需绑定绑定key</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">def callback(ch, method, properties, body): # 消息的具体功能</span><br><span class="line">    print(&quot;[x] Received %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=&apos;hello&apos;,</span><br><span class="line">    on_message_callback=callback,</span><br><span class="line">    auto_ack=True</span><br><span class="line">)</span><br><span class="line">print(&apos;[*] Waiting for logs.To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming() # 开启阻塞式消费，持续接收发布的消息</span><br></pre></td></tr></table></figure>
<h1 id="python客户端-celery"><a href="#python客户端-celery" class="headerlink" title="python客户端-celery"></a>python客户端-celery</h1><h2 id="celery架构"><a href="#celery架构" class="headerlink" title="celery架构"></a>celery架构</h2><p>celery+rabbitmq+redis</p>
<ul>
<li>celery worker：任务执行单元【单独开启进程提供任务执行】</li>
<li>rabbitmq：消息中间件【传递消息和定义消息队列】</li>
<li>redis：存储worker执行结果</li>
</ul>
<h2 id="软件安装和配置"><a href="#软件安装和配置" class="headerlink" title="软件安装和配置"></a>软件安装和配置</h2><ul>
<li>安装rabbitmq-server、redis-server</li>
<li>配置mq和redis</li>
<li>安装python模块celery、celery-with-redis</li>
</ul>
<h2 id="开启一个任务调度进程"><a href="#开启一个任务调度进程" class="headerlink" title="开启一个任务调度进程"></a>开启一个任务调度进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;task01&apos;, backend=&apos;redis://127.0.0.1:6379/0&apos;, broker=&apos;amqp://ever01:Theistyle@127.0.0.1:5672/celery&apos;)</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x,y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure>
<p>开启任务：celery -A tasks worker -l info【-A 指定一个模块，即文件名】</p>
<h2 id="客户端测试"><a href="#客户端测试" class="headerlink" title="客户端测试"></a>客户端测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line">from tasks import add</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">result = add.delay(4, 4)</span><br><span class="line">print(&quot;waiting result...&quot;)</span><br><span class="line">while not result.ready():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">print(&quot;Result:&quot;, result.get())</span><br></pre></td></tr></table></figure>
<p>测试：python3 test.py</p>
<h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><ul>
<li>查看celery worker输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2019-11-01 18:15:07,708: INFO/MainProcess] Received task: tasks.add[05d41d34-9e5d-4e59-bb15-23ddc74f2e08]  </span><br><span class="line">[2019-11-01 18:15:07,715: INFO/ForkPoolWorker-2] Task tasks.add[05d41d34-9e5d-4e59-bb15-23ddc74f2e08] succeeded in 0.00482514314353466s: 8</span><br></pre></td></tr></table></figure>
<ul>
<li>查看redis存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;celery-task-meta-05d41d34-9e5d-4e59-bb15-23ddc74f2e08&quot;</span><br><span class="line">127.0.0.1:6379&gt; type celery-task-meta-05d41d34-9e5d-4e59-bb15-23ddc74f2e08</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; get celery-task-meta-05d41d34-9e5d-4e59-bb15-23ddc74f2e08</span><br><span class="line">&quot;&#123;\&quot;date_done\&quot;: \&quot;2019-11-01T10:15:07.710361\&quot;, \&quot;task_id\&quot;: \&quot;05d41d34-9e5d-4e59-bb15-23ddc74f2e08\&quot;, \&quot;status\&quot;: \&quot;SUCCESS\&quot;, \&quot;result\&quot;: 8, \&quot;children\&quot;: [], \&quot;traceback\&quot;: null&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>celery</tag>
        <tag>pika</tag>
      </tags>
  </entry>
  <entry>
    <title>redis主从高可用-sentinel</title>
    <url>/blog/2020/09/29/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E4%B8%BB%E4%BB%8E%E9%AB%98%E5%8F%AF%E7%94%A8-sentinel/</url>
    <content><![CDATA[<h1 id="sentinel功能"><a href="#sentinel功能" class="headerlink" title="sentinel功能"></a><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">sentinel功能</a></h1><ul>
<li>监控：持续监控master和slave是否处于工作状态</li>
<li>通知：通过API通知系统管理员或程序某个redis实例故障</li>
<li>自动故障转移：当master故障时，自动将其中的一个slave提升为master，并配置其他slave连接新的master；当有客户端连接时，通知通知客户端使用新的地址</li>
<li>配置提供者：向客户端提供服务发现功能：即master的地址</li>
</ul>
<h1 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h1><h2 id="运行sentinel"><a href="#运行sentinel" class="headerlink" title="运行sentinel"></a>运行sentinel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">或：redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>配置文件是必须的，因为在重启时要保存集群状态；没有配置文件或配置文件不可写，sentinel将拒绝启动<br>sentinel默认监听在26379端口，用于和其他sentinel实例以及客户端通信</p>
<h2 id="部署前的基础知识"><a href="#部署前的基础知识" class="headerlink" title="部署前的基础知识"></a>部署前的基础知识</h2><ol>
<li>需要至少3个实例保证部署的健壮性，并需要保证它们不在一个故障区</li>
<li>Sentinel + Redis的分布式系统不保证在故障转移期间已确认的写操作数据也保留，因为主从是异步复制的；但是一些部署方式可以限制写操作丢失只在某些特定的时刻，当然也会有一些其他不安全的部署方式</li>
<li>需要客户端支持sentinel功能；大部分都支持，并非全部</li>
<li>HA设置需要不断测试才能保证安全，因为错误的配置可能只在某些特定的情况下才会发挥作用</li>
<li>sentinel、docker和其他形式的nat、端口转换被混合使用时都应该注意：docker默认的端口映射行为，破坏了sentinel对其他sentinel进程的自动服务发现、以及获取redis master的slave列表；应该查询sentinel和docker的相关内容进行设置</li>
</ol>
<h2 id="配置sentinel"><a href="#配置sentinel" class="headerlink" title="配置sentinel"></a>配置sentinel</h2><p>sentinel.conf 是一个自文档配置文件，典型的最小配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure>
<p>只需要设置要监控的master节点，并为每个独立的master节点设置不同的名称；不需要设置slave节点，这会通过自动发现实现；sentinel会用额外的信息自动更新关于slave的配置，为了在重启时依然保留相关配置信息。<br>每次在故障转移期间将slave提升为master时，以及每次发现新的Sentinel时，都会重写配置；以上配置监控了两组redis实例，每个实例都包含了数量不定的slave；一组实例叫mymaster，另一组叫resque。</p>
<p>sentinel monitor语句参数的含义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
<p>第一行告诉sentinel监控一个叫mymaster的master，地址127.0.0.1，端口6379，选举需要的最小成员数2；<br>quorum参数含义如下：</p>
<ul>
<li>标记master不可用所需sentinel的最小数量</li>
<li>quorum只用于检测master故障；为了执行故障转移，需要将一个sentinel选举为故障转移负责人，然后才有权继续进行故障转移操作，而这种选举只发生在具有多数sentinel进程可以互相通信的情况下。</li>
</ul>
<p>对于有5个sentinel进程的例子，quorum设置为2表示如下含义：</p>
<ul>
<li>如果有2个sentinel同意master不可达，则其中的2个将尝试启动故障转移</li>
<li>如果有至少3个sentinel同意mster不可达，并且可以互相通信，则故障转移被授权并实际执行</li>
</ul>
<p>实际上，这意味着在发生故障期间，如果大多数Sentinel进程无法进行对话（在少数分区中也没有故障转移），则Sentinel不会启动故障转移。</p>
<h2 id="其他sentinel选项"><a href="#其他sentinel选项" class="headerlink" title="其他sentinel选项"></a>其他sentinel选项</h2><p>其他sentinel选项的格式一般如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;</span><br></pre></td></tr></table></figure>
<p>一些选项的作用如下：</p>
<ul>
<li>down-after-milliseconds：sentinel认为实例不可达(不回复ping或回复错误)需要的时间，以毫秒计</li>
<li>parallel-syncs：设置故障转移期间同时向新master进行数据同步的slave数量；这个slave数量越少，则故障转移完成需要的时间也就越多（一次同步一个，直到所有副本节点同步完成）；尽管多数情况下复制是非阻塞的，但也有一些情况会造成副本节点不可用；当设置为1时，可以保证复制期间仅有1个副本节点不可用，而此时未完成同步的其他副本节点可以使用旧数据向客户端提供服务。</li>
</ul>
<p>可以使用SENTINEL SET命令实时修改参数</p>
<h2 id="避免写丢失的配置"><a href="#避免写丢失的配置" class="headerlink" title="避免写丢失的配置"></a>避免写丢失的配置</h2><blockquote>
<p>redis.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min-replicas-to-write 1</span><br><span class="line">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure>
<p>当master可以写入至少1个slave中，且收到异步确认的消息不超过10s时，master才可以继续接受客户端的写操作；这样可以防止在发生故障转移时，旧的master依然接受写操作造成部分写操作丢失。</p>
<h2 id="sentinel-docker-NAT问题"><a href="#sentinel-docker-NAT问题" class="headerlink" title="sentinel/docker/NAT问题"></a>sentinel/docker/NAT问题</h2><p>端口和地址映射对sentinel的影响：</p>
<ul>
<li>sentinel通过自动发现和其他sentinel协同工作，由于端口和地址映射，sentinel声明的地址和端口对其他sentinel而言是不正确且不能连接的</li>
<li>sentinel通过在master使用命令INFO检测slave的连接信息，同样由于端口和地址映射，sentinel获取的slave连接信息是不正确的且不可达，最终会因为没有可用的slave无法完成故障切换工作</li>
</ul>
<p>对于第一个问题可以使用如下配置，使sentinel声明一个可以连接的地址和端口信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip &lt;ip&gt;</span><br><span class="line">sentinel announce-port &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>对于第二个问题可以使用如下配置，强制slave向master声明一个可以连接的地址和端口【v3.2.2之后】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replica-announce-ip 5.5.5.5</span><br><span class="line">replica-announce-port 1234</span><br></pre></td></tr></table></figure>
<p>相应地，集群模式下也有相关的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster-announce-ip 10.1.1.5</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 6380</span><br></pre></td></tr></table></figure>
<p>当然为了操作简单，也可以直接使用docker的host网络模式，直接使用宿主机的网络。</p>
<h1 id="集群状态检查"><a href="#集群状态检查" class="headerlink" title="集群状态检查"></a>集群状态检查</h1><p>在本机运行3个sentinel实例(端口 5000, 5001, 5002)，同时运行一个master(6379)和一个slave(6380)，使用127.0.0.1进行相互连接<br>sentinel配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 5000</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>
<ul>
<li>从sentinel处检查redis master运行状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis-cli -p 5000</span><br><span class="line">127.0.0.1:5000&gt; sentinel master mymaster</span><br></pre></td></tr></table></figure>
<ul>
<li>检查其他sentinel和redis slave的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SENTINEL replicas mymaster</span><br><span class="line">SENTINEL sentinels mymaster</span><br></pre></td></tr></table></figure>
<ul>
<li>查看redis master的地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SENTINEL get-master-addr-by-name mymaster</span><br></pre></td></tr></table></figure>
<h1 id="配置修改和查看"><a href="#配置修改和查看" class="headerlink" title="配置修改和查看"></a>配置修改和查看</h1><p>API功能：查看自身的状态、检查被监控的redis master和slave的状态、订阅特定的事件、实时变更配置</p>
<h2 id="查询sentinel状态"><a href="#查询sentinel状态" class="headerlink" title="查询sentinel状态"></a>查询sentinel状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING # 返回PONG信息</span><br><span class="line">SENTINEL masters                      # 显示被监控的多个master列表</span><br><span class="line">SENTINEL master &lt;master name&gt;         # 显示指定master信息</span><br><span class="line">SENTINEL replicas &lt;master name&gt;       # 显示指定master的slave列表和信息</span><br><span class="line">SENTINEL sentinels &lt;master name&gt;      # 显示监控指定master的sentinel列表和信息</span><br><span class="line">SENTINEL get-master-addr-by-name &lt;master name&gt; # 显示指定master的ip和端口</span><br><span class="line">SENTINEL reset &lt;pattern&gt;              # 重置匹配(glob匹配)的master的所有信息（包含slave和sentinel信息）</span><br><span class="line">SENTINEL failover &lt;master name&gt;       # 强制进行故障转移，无需其他sentinel同意</span><br><span class="line">SENTINEL ckquorum &lt;master name&gt;       # 检测当前sentinel的配置是否满足故障转移的条件</span><br><span class="line">SENTINEL flushconfig                  # 强制将当前sentinel的状态写到磁盘</span><br></pre></td></tr></table></figure>
<h2 id="实时修改sentinel配置"><a href="#实时修改sentinel配置" class="headerlink" title="实时修改sentinel配置"></a>实时修改sentinel配置</h2><blockquote>
<p>需要在多个sentinel上修改</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SENTINEL MONITOR &lt;name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; # 监控一个新的master主从集群，ip选项不能时主机名</span><br><span class="line">SENTINEL REMOVE &lt;name&gt;                       # 移除一个master主从集群</span><br><span class="line">SENTINEL SET &lt;name&gt; &lt;option&gt; &lt;value&gt;         # 指定master的参数配置</span><br></pre></td></tr></table></figure>
<h2 id="添加或移除sentinel"><a href="#添加或移除sentinel" class="headerlink" title="添加或移除sentinel"></a>添加或移除sentinel</h2><p><strong>添加</strong>：通过sentinel的自动发现功能，可以直接添加sentinel监控活动的master；为了保证在添加过程中，即使出现网络分区时也可以进行故障转移，应该一个一个的添加新的sentinel，间隔30s以上</p>
<p><strong>删除</strong>：由于sentinel不会主动删除发现的sentinel信息，即使sentinel不可达；为了保证故障转移的可用，同时又不想动态修改故障转移的条件(quorum)，我们应当在没有网络分区的情况下执行下列步骤：</p>
<ul>
<li>停止任意的sentinel</li>
<li>在所有可用sentinel实例执行<code>SENTINEL RESET *</code>命令【此命令是重置监控所有master的sentinel信息，也可以指定master】</li>
<li>在所有可用sentinel实例执行<code>SENTINEL MASTER mastername</code>，以使显示的sentinel信息和活动的sentinel保持一致</li>
</ul>
<h2 id="移除旧的master或slave"><a href="#移除旧的master或slave" class="headerlink" title="移除旧的master或slave"></a>移除旧的master或slave</h2><p>sentinel不会主动删除保存的master下的slave信息，为了删除不可用的slave或旧的master，应该在所有sentinel上执行<code>SENTINEL RESET mastername</code>，这样可以使sentinel通过INFO命令重新获取master下的slave信息。</p>
<h2 id="slave优先级"><a href="#slave优先级" class="headerlink" title="slave优先级"></a>slave优先级</h2><p>slave的设置<em>replica-priority</em>用于决定多个slave在故障转移中的优先级：</p>
<ul>
<li>replica-priority设置为0，slave永远不会提升为master</li>
<li>replica-priority数值越小优先级越高</li>
</ul>
<h2 id="redis和sentinel认证"><a href="#redis和sentinel认证" class="headerlink" title="redis和sentinel认证"></a>redis和sentinel认证</h2><p>redis认证：在master和所有slave中设置指令以启用认证功能</p>
<ul>
<li>requirepass <em>string</em>：启用客户端连接的授权密码</li>
<li>masterauth <em>string</em>：在slave中设置连接master的认证密码</li>
</ul>
<p>同时在master和slave中都设置这两个参数，以保障master与外部的任何连接(客户端、slave、sentinel)都需要认证、slave与外部的任何连接(客户端、sentinel)也需要认证、故障转移后master和slave角色转换后依然保持认证功能</p>
<p>如果需要一个可以匿名访问的slave，可以设置如下：</p>
<ul>
<li>只设置masterauth，不设置requirepass</li>
<li>设置replica-priority为0，此slave永远不能提升为master</li>
</ul>
<p>在redis启用认证的情况下，应该设置sentinel的认证参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel auth-pass &lt;master-group-name&gt; &lt;pass&gt;</span><br></pre></td></tr></table></figure>
<h2 id="sentinel实例认证"><a href="#sentinel实例认证" class="headerlink" title="sentinel实例认证"></a>sentinel实例认证</h2><p>从5.0.1之后，也可以开启sentinel自身的认证：<code>requirepass &quot;your_password_here&quot;</code>，<br>这个认证同时用于sentinel和其他sentinel实例，以及sentinel和客户端的认证<br>为了使sentinel运行正常，需要在所有sentinel实例配置此参数<br>这个参数也需要客户端库的支持。</p>
<h1 id="精简配置范例"><a href="#精简配置范例" class="headerlink" title="精简配置范例"></a>精简配置范例</h1><p>3个redis(1master 2slave)、3个sentinel</p>
<ul>
<li><p>redis最简配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">dbfilename &quot;dump.rdb&quot;</span><br><span class="line">dir &quot;./&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">min-replicas-to-write 1</span><br><span class="line">min-replicas-max-lag 10</span><br><span class="line"># replicaof 192.168.31.232 6379</span><br><span class="line"># replica-priority 50</span><br></pre></td></tr></table></figure>
</li>
<li><p>sentinel最简配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 5000</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/tmp&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.31.232 6379 2</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="python客户端使用"><a href="#python客户端使用" class="headerlink" title="python客户端使用"></a>python客户端使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pip install redis</span><br><span class="line">from redis.sentinel import Sentinel</span><br><span class="line">sentinel = Sentinel([</span><br><span class="line">    (&apos;192.168.31.231&apos;, 5000),</span><br><span class="line">    (&apos;192.168.31.232&apos;, 5000),</span><br><span class="line">    (&apos;192.168.31.233&apos;, 5000)],</span><br><span class="line">    socket_timeout=0.5)</span><br><span class="line"></span><br><span class="line"># 获取master的连接字符串（主要用于观察、显示）</span><br><span class="line"># master = sentinel.discover_master(&apos;mymaster&apos;)</span><br><span class="line"># print(master)</span><br><span class="line"># 获取master的连接（用于数据操作），mymaster为sentinel中配置的不同redis集群标识</span><br><span class="line">master = sentinel.master_for(&apos;mymaster&apos;, socket_timeout=0.5, password=&apos;123456&apos;, db=0)</span><br><span class="line">master.set(&apos;name&apos;, &apos;bar&apos;)</span><br><span class="line"></span><br><span class="line"># 获取slave的连接字符串（主要用于观察、显示）</span><br><span class="line"># slave = sentinel.discover_slaves(&apos;mymaster&apos;)</span><br><span class="line"># print(slave)</span><br><span class="line"># 获取slave连接，从slave读取数据（默认是round-roubin）</span><br><span class="line">slave = sentinel.slave_for(&apos;mymaster&apos;, socket_timeout=0.5, password=&apos;123456&apos;, db=0)</span><br><span class="line">res = slave.get(&apos;name&apos;)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>redis客户端redis-cli</title>
    <url>/blog/2019/10/22/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E5%AE%A2%E6%88%B7%E7%AB%AFredis-cli/</url>
    <content><![CDATA[<h1 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h1><ul>
<li>命令行使用：redis-cli incr mycounter<ul>
<li>重定向输出：redis-cli incr mycounter &gt; /tmp/output.txt</li>
<li>额外信息控制：<ul>
<li>–raw：只显示命令结果</li>
<li>–no-raw：显示操作的数据类型及操作结果【这是默认模式，但是客户端也会判断如果有tty终端则显示数据类型，没有tty（重定向）则不显示数据类型】</li>
</ul>
</li>
</ul>
</li>
<li>连接<ul>
<li>-h：连接主机</li>
<li>-p：连接端口，默认6379</li>
<li>-a：连接密码</li>
<li>-n：指定指定连接的库【默认连接数据库0】</li>
<li>-u：使用redis协议通过URI连接，如：redis-cli -u redis:<a href="mailto://password@redis-16379.hosted.com" target="_blank" rel="noopener">//password@redis-16379.hosted.com</a>:16379/0 ping</li>
</ul>
</li>
<li><p>重定向输入：</p>
<ul>
<li>-x：读取最后一个参数：redis-cli -x set foo &lt; /etc/services</li>
<li>执行文件内的命令：cat /tmp/commands.txt | redis-cli<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set foo 100</span><br><span class="line">incr foo</span><br><span class="line">append foo xxx</span><br><span class="line">get foo</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重复执行命令</p>
<ul>
<li>-r：执行次数</li>
<li>-i：时间间隔，单位是秒，最小为0.1，默认为0</li>
</ul>
</li>
<li>批量插入：–pipe【cat data.txt | redis-cli –pipe】</li>
<li>导出csv格式：–csv【redis-cli –csv lrange mylist 0 -1】</li>
</ul>
<h1 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h1><blockquote>
<p>默认可以浏览历史命令、命令补全功能</p>
</blockquote>
<ul>
<li>选择数据库：select 2</li>
<li>数据库大小：dbsize</li>
<li>认证：auth</li>
<li>连接其他实例：connect</li>
<li>执行命令n次：n command</li>
<li>帮助信息：<ul>
<li>分类帮助：<code>help @&lt;category&gt;</code><ul>
<li>@generic</li>
<li>@list</li>
<li>@set</li>
<li>@sorted_set</li>
<li>@hash</li>
<li>@pubsub</li>
<li>@transactions</li>
<li>@connection</li>
<li>@server</li>
<li>@scripting</li>
<li>@hyperloglog</li>
</ul>
</li>
<li>特定命令帮助：help command</li>
</ul>
</li>
<li>清屏：clear</li>
</ul>
<h1 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h1><ul>
<li>状态监控<ul>
<li>参数：–stat （-i interval）</li>
<li>范例：redis-cli –stat</li>
</ul>
</li>
<li>数据库中扫描出最大key<ul>
<li>参数：–bigkeys</li>
<li>范例：redis-cli –bigkeys</li>
</ul>
</li>
<li>获取key列表<ul>
<li>参数：–scan【对比交互模式下<code>keys *</code>，scan参数以非阻塞方式获取key列表】</li>
<li>范例：redis-cli –scan | head -10</li>
<li>模式匹配参数：–pattern</li>
<li>模式匹配范例：<code>redis-cli --scan --pattern &#39;*-11*&#39;</code></li>
</ul>
</li>
<li>发布订阅模式<ul>
<li>订阅：redis-cli psubscribe ‘*’</li>
<li>发布：redis-cli PUBLISH mychannel mymessage</li>
</ul>
</li>
<li>监控实例执行的命令：redis-cli monitor</li>
<li>用不同方式检测服务端实例延迟<ul>
<li>–latency：每秒100次向服务端发送ping信号</li>
<li>–latency-history：每15秒开启一个新的会话连接用于压测【-i指定时间间隔】</li>
<li>–latency-dist：以带颜色的光谱图形式显示延迟信息</li>
</ul>
</li>
<li>检测客户端延迟： –intrinsic-latency 【test-time】：redis-cli客户端所在主机的固有延迟【如内核调度，虚拟化开销等】</li>
<li>远程备份rdb<ul>
<li>参数：–rdb</li>
<li>范例：redis-cli -h 172.15.22.9 -a 123456 –rdb /tmp/dump.rdb</li>
</ul>
</li>
<li>测试复制模式下从机接收的内容<ul>
<li>参数：–slave</li>
<li>范例：redis-cli -h 172.15.22.9 -a 123456 –slave</li>
</ul>
</li>
<li>测试不同LRU策略下的key命中率<ul>
<li>影响因素：测试样本数量、最大可用内存(maxmemory )</li>
<li>参数：–lru-test sample-number</li>
<li>范例：./redis-cli –lru-test 10000000</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据操作</title>
    <url>/blog/2019/10/30/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="数据类型及抽象"><a href="#数据类型及抽象" class="headerlink" title="数据类型及抽象"></a><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">数据类型及抽象</a></h1><h2 id="key定义"><a href="#key定义" class="headerlink" title="key定义"></a>key定义</h2><ul>
<li>不建议使用非常长的key，因为在查找比较时需要消耗更多的资源；如果确实需要存储较长的key，可以存储key的hash值</li>
<li>也不建议使用较短的key，较短的key可读写太差</li>
<li>key定义时的格式要统一，比如使用冒号、点、横杠等</li>
<li>key的最大长度512MB</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>字符串是redis key最简单的数据类型</li>
<li>字符串类型在抓取html碎片和页面时非常有用</li>
<li>字符串中可以包含各种数据（包含二进制数据），所以可以在值中存储jpeg等的图片内容</li>
<li>字符串长度最大值512MB</li>
</ul>
<h2 id="key过期设置"><a href="#key过期设置" class="headerlink" title="key过期设置"></a>key过期设置</h2><ul>
<li>支持秒和毫秒级别设置</li>
<li>过期的设置以日期形式保存在磁盘或被复制</li>
<li>服务停止，时间也会被计算</li>
<li>独立操作命令<ul>
<li>expire key seconds：设置key过期</li>
<li>pexpire key milliseconds：设置key过期</li>
<li>persist key：取消过期设置</li>
<li>ttl：查看过期时间（秒）</li>
<li>pttl：查看过期时间（毫秒）</li>
</ul>
</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>redis列表通过链接列表实现</li>
<li>列表可以实现快速的插入数据，而有序集合(sorted sets)则可以实现快速的访问集合中间位置的元素</li>
<li>使用ltrim可以始终只保留一定数量的元素：ltrim mylist 0 999</li>
<li>列表的阻塞操作（blpop/brpop）可以实现队列功能<ul>
<li>阻塞命令(brpop/blpop)一次可以操作多个列表、阻塞时间可以设置为0(永不超时)</li>
<li>阻塞命令返回一个两元素的数组（列表名、元素）</li>
</ul>
</li>
<li>一般用法<ul>
<li>在社交网络展示最新发布的文章<ul>
<li>使用lpush将最新文章的id放入列表</li>
<li>使用lrange 0 9展示最新发布的10篇文章</li>
</ul>
</li>
<li>进程间的通信（生产者-消费者模型）</li>
</ul>
</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a href="https://redis.io/topics/data-types" target="_blank" rel="noopener">数据类型</a></h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>set key value：设置key<ul>
<li>ex seconds：设置键的过期秒数</li>
<li>px milliseconds：设置键的过期毫秒数</li>
<li>nx：键不存在才能对键操作</li>
<li>xx：键存在才能对键操作</li>
</ul>
</li>
<li>mset key value key1 value1：一次设置多个key</li>
<li>mget key key1：一次获取多个值</li>
<li>get key：获取key的值</li>
<li>getset key：设置key并返回key的旧值</li>
<li>incr counter：计数器加1</li>
<li>decr counter：计数器减1</li>
<li>incrby counter n：计数器加n</li>
<li>decrby counter n：计数器减n</li>
<li>getrange key start end：获取子串</li>
<li>setrange key index value：从索引处开始替换子串</li>
</ul>
<h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><ul>
<li>lpush/rpush key value：从列表左或右侧向列表添加值</li>
<li>lrange key start end：获取列表从start到end的值<ul>
<li>索引可以是负值，比如-1表示最后一个元素</li>
<li>索引从0开始，0表示第一个元素</li>
</ul>
</li>
<li>llen key：返回列表长度</li>
<li>ltrim key start end：只保留start到end的值</li>
<li>lpop/rpop key：弹出列表左侧或右侧的元素</li>
<li>blpop key key1… timeout：阻塞式弹出列表的值</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>成员间无固定顺序</li>
<li>成员不重复</li>
<li>支持交集、并集、差集</li>
<li>成员最大数量2^32-1（512MB）</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>sadd key value：集合添加成员</li>
<li>smembers key：查看集合成员</li>
<li>sismember key member：查看元素是否是集合成员</li>
<li>scard key：获取集合成员数量</li>
<li>sinter key key1：查看集合间的交集</li>
<li>sunionstore des_key key key1：获取集合间的并集并存储在新的key中</li>
<li>spop key：弹出集合中的成员</li>
<li>srandmember key：获取集合中随机一个成员</li>
</ul>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>与集合对比，有序集合的每个成员都关联一个分数值，这个分数值用于排序</li>
<li>可以通过分数、或索引获取一个范围内的成员</li>
</ul>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><blockquote>
<p>特殊定义：【-inf：负无穷】【inf：正无穷】</p>
</blockquote>
<ul>
<li>zadd key socre member：向有序集合key中添加分数为socre的成员member</li>
<li>zrank key member：获取成员索引位置<ul>
<li>zrevrank key member：成员的倒序</li>
</ul>
</li>
<li>zrange key start end [withscores]：根据索引区间获取成员<ul>
<li>zrevrange key start end：反向排序</li>
</ul>
</li>
<li>zrangebyscore key min max：根据socre区间获取成员<ul>
<li>zremrangebyscore key start end：根据score删除成员</li>
</ul>
</li>
<li>zrangebylex key min mex：根据key的首字符区间获取成员<ul>
<li><code>(</code>表示开区间、<code>[</code>表示闭区间</li>
<li>范例：ZRANGEBYLEX hackers [B [P【key首字母在B和P之间的key】</li>
</ul>
</li>
</ul>
<h2 id="哈希-字典"><a href="#哈希-字典" class="headerlink" title="哈希/字典"></a>哈希/字典</h2><ul>
<li>hmset key field value [field value …]：一次设置字典的多个字段</li>
<li>hset key field value：一次设置字典的一个字段</li>
<li>hgetall key：一次返回字典的所有字段及其值</li>
<li>hget key field：一次返回字典中某个字段的值</li>
<li>hmget key field1 field2：一次返回字典中多个字段的值</li>
<li>hincrby key field n：对字典中的某个字段自增n</li>
</ul>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><ul>
<li>setbit key offset value：设置offset处为0或1</li>
<li>getbit key offset：获取offset处的值</li>
<li>bitop operation destkey key：在字符串之间进行位操作（AND, OR, XOR and NOT.）</li>
<li>bicount key：统计键中设置为1的位的数量</li>
<li>bitpos key bit start end：返回键中1或0第一次出现的索引位置</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ul>
<li>用途：主要用于唯一性事务的概率统计</li>
<li>语法：<ul>
<li>pfadd key element element1：添加元素</li>
<li>pfcount key key1:唯一性统计</li>
</ul>
</li>
<li>应用范例：<a href="https://www.cnblogs.com/ysuzhaixuefei/p/4052110.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysuzhaixuefei/p/4052110.html</a></li>
</ul>
<h1 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h1><ul>
<li>type key：判断键的数据类型</li>
<li>exists key：判断键是否存在</li>
<li>del key：删除特定key</li>
<li>keys foo*：返回特定匹配的key列表</li>
<li>flushdb：删除当前库的所有key</li>
<li>flushall：删除所有数据库的key</li>
</ul>
<hr>
<h1 id="redis命令参考"><a href="#redis命令参考" class="headerlink" title="redis命令参考"></a><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">redis命令参考</a></h1>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>操作命令</tag>
      </tags>
  </entry>
  <entry>
    <title>redis简介与管理</title>
    <url>/blog/2019/10/25/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="https://redis.io/topics/introduction" target="_blank" rel="noopener">简介</a></h1><ul>
<li>redis是一个开源的、基于内存的数据结构存储，但也可以根据需要开启持久化存储（rdb、aof）</li>
<li>可以被当做数据库、缓存、消息代理使用</li>
<li>使用C语言编写，不需要外部依赖，官方默认支持linux系统，也可以使用在windows上运行<ul>
<li><a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">microsoft实现的3.0版本</a></li>
<li><a href="https://github.com/tporadowski/redis" target="_blank" rel="noopener">第三方实现的4/5版本</a></li>
</ul>
</li>
</ul>
<h2 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h2><ul>
<li>主从异步复制</li>
<li>lua脚本</li>
<li>数据过期策略：LRU</li>
<li>事务</li>
<li>数据持久化策略：rdb、aof</li>
<li>高可用：Redis Sentinel </li>
<li>自动分区：redis Cluster</li>
<li>发布、订阅、取消订阅（消息代理）：Pub/Sub</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>strings：二进制安全的字符串</li>
<li>hash：是由字段和其值构成的映射，字段和值都是字符串；和ruby、pyhon中的字典类似</li>
<li>lists：根据插入顺序排序的字符串元素的集合</li>
<li>sets：由独一无二的、未排序的元素构成的集合</li>
<li>sorted sets：排序的集合，每个字符串成员都关联一个浮点数值用于排序</li>
<li>bitmaps：位图，可以处理字符串中的每一位(设置、清除)，找到第一个设置或未设置的位</li>
<li>hyperloglogs：这是一个概率数据结构，用于估计集合的基数</li>
<li>streams</li>
<li>geospatial indexes</li>
</ul>
<h2 id="支持的原子操作"><a href="#支持的原子操作" class="headerlink" title="支持的原子操作"></a>支持的原子操作</h2><ul>
<li>字符串追加</li>
<li>增加hash中的值</li>
<li>向列表中添加元素</li>
<li>计算集合的交集、并集、差集</li>
<li>获取排序集合中最高排名的成员</li>
</ul>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><ul>
<li>版本重要提示：从5.0版本开始，redis内置关键词slave切换为replica，<a href="https://github.com/redis/redis/issues/5335" target="_blank" rel="noopener">相关issue</a></li>
<li>下载与安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">$ tar xzf redis-5.0.5.tar.gz</span><br><span class="line">$ cd redis-5.0.5</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<ul>
<li>安装错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：make安装报错 jemalloc/jemalloc.h: No such file or directory。</span><br><span class="line">原因：开始时gcc未安装，安装gcc后存在make编译残留</span><br><span class="line">解决：make distclean  &amp;&amp; make</span><br></pre></td></tr></table></figure>
<h1 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a><a href="https://redis.io/topics/replication" target="_blank" rel="noopener">复制操作</a></h1><h2 id="同异步"><a href="#同异步" class="headerlink" title="同异步"></a>同异步</h2><ul>
<li>异步：redis复制是异步的，主实时发送操作的命令到从机</li>
<li>部分同步：主从复制出现异常，从机可以通过部分同步功能(repl-backlog-size)与主机重新建立复制关系<ul>
<li>可以通过rdb文件(非aof)实现部分同步功能（例如从机重启或升级时，可以SHUTDOWN(save &amp; quit)保存数据）</li>
</ul>
</li>
<li>同步：使用WAIT命令可以实现同步复制</li>
</ul>
<h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><ul>
<li>主可以有多个从(从机只读)，这样可以分担主的读压力，同时增加数据安全性</li>
<li>从也可以有从，即构成级联架构，此时sub-slave从master接收复制流</li>
<li>主从结构<ul>
<li>为了安全性，主应当开启数据持久化（rdb、aof），从机也可以开启持久化（rdb）</li>
<li>如果主没有开启持久化，而从开启了持久化时：当主机重启，由于内存数据丢失，重启后复制流也会删除从机的数据</li>
</ul>
</li>
</ul>
<h2 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h2><ul>
<li>在master端，复制是非阻塞的</li>
<li>在slave端，大部分情况下，复制也是非阻塞的；<ul>
<li>在同步初始化阶段，可以配置允许从机向客户端提供旧的数据(slave-serve-stale-data )以避免阻塞</li>
<li>在同步后，依然会有一小段阻塞时间（4.0之前删除数据、加载新的数据都会阻塞；4.0之后会用单独的线程执行删除操作，但是加载数据依然会阻塞）</li>
</ul>
</li>
</ul>
<h2 id="从机过期key处理"><a href="#从机过期key处理" class="headerlink" title="从机过期key处理"></a>从机过期key处理</h2><ul>
<li>不依赖于主从间的同步时钟</li>
<li>从主上接收处理过期的命令(del)，然后本地执行此命令</li>
<li>为了保持数据一致性，对于应当删除而没有删除的key，从机返回错误</li>
<li>在lua脚本执行期间，主的数据会被冻结，不会产生过期删除操作</li>
</ul>
<h2 id="复制选项"><a href="#复制选项" class="headerlink" title="复制选项"></a>复制选项</h2><ul>
<li>无盘复制：repl-diskless-sync<ul>
<li>默认设置下，为了实现复制功能，即使没有开启持久化设置，也会写rdb文件，除非使用无盘复制功能（repl-diskless-sync）</li>
</ul>
</li>
<li>只读设置：slave-read-only<ul>
<li>如果从机可写，在4.0之前会存在内存泄漏（key过期，客户端不可见，但依然在内存中）</li>
<li>4.0之后的版本，当数据库序列小于63时，不会出现内存泄漏</li>
<li>4.0之后的版本，从机只是本地可写，即不会将本地变更传递给它的从机（sub-slave从master接收复制流）</li>
</ul>
</li>
<li>连接设置：<ul>
<li>slaveof 192.168.1.1 6379</li>
<li>masterauth password</li>
</ul>
</li>
<li>设置少于指定数量主机或大于某个延迟时停止写操作<ul>
<li>min-slaves-to-write 3</li>
<li>min-slaves-max-lag 10</li>
</ul>
</li>
<li>nat和端口转发环境下的配置（docker）<ul>
<li>slave-announce-ip</li>
<li>slave-announce-port</li>
</ul>
</li>
</ul>
<h2 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h2><ul>
<li>INFO replication</li>
<li>ROLE</li>
</ul>
<h1 id="服务端管理"><a href="#服务端管理" class="headerlink" title="服务端管理"></a>服务端管理</h1><h2 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a><a href="https://redis.io/topics/admin" target="_blank" rel="noopener">配置和优化</a></h2><ul>
<li>开启系统swap</li>
<li>内存调优：<ul>
<li>允许过量使用内存：sysctl vm.overcommit_memory=1</li>
<li>关闭影响内存使用和延迟的因素：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li>
</ul>
</li>
<li>内存大小设置：<ul>
<li>maxmemory限制的内存：数据、数据外的开销、碎片开销、rdb保存和aof重写占用的内存（最多会占用常规使用量的2倍）</li>
<li>复制缓冲区（repl-backlog-size）：确保从机可以更容易的重连（支持部分同步）</li>
</ul>
</li>
<li>当使用守护进程工具时(如supervisor、systemd)，设置daemonize为no</li>
<li>基于安全性，设置listen和requirepass参数</li>
<li>有用的工具<ul>
<li>延迟诊断：latency doctor【需要设置latency-monitor-threshold】</li>
<li>内存诊断：memory doctor</li>
</ul>
</li>
</ul>
<h2 id="升级或重启"><a href="#升级或重启" class="headerlink" title="升级或重启"></a>升级或重启</h2><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><ul>
<li>把要操作的实例作为从机与主机同步</li>
<li>检测同步日志，确保初始化同步完成</li>
<li>使用INFO命令，确保主从有相同数量的key</li>
<li>从机开启写权限：CONFIG SET slave-read-only no</li>
<li>停止主机写操作：CLIENT PAUSE</li>
<li>通过监控命令【redis-cli monitor】确保主不再接收到任何数据操作命令，此时：<ul>
<li>从提升为主：SLAVEOF NO ONE </li>
<li>旧主机关闭</li>
</ul>
</li>
</ul>
<h3 id="高可用或集群模式"><a href="#高可用或集群模式" class="headerlink" title="高可用或集群模式"></a>高可用或集群模式</h3><ul>
<li>常规流程：升级从机，执行主从手动切换</li>
<li>注意：由于4.0版本在集群总线协议级别与3.2版本不兼容，此时集群需要整体重启；5.0版本集群总线向后兼容4.0版本</li>
</ul>
<h1 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a><a href="https://redis.io/topics/clients" target="_blank" rel="noopener">客户端管理</a></h1><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul>
<li>最大连接数：maxclients；与os最大文件描述符相关，同时需要保留部分描述符用于redis内部使用<ul>
<li>redis可以设置最大文件描述符时，所需的最大文件描述符为：fd=maxclients+32(内部使用)</li>
<li>redis不可设置最大文件描述符时(即maxclients大于最大文件描述符)，maxclients=fd-32</li>
</ul>
</li>
<li>输出缓冲区限制：<ul>
<li>client-output-buffer-limit normal 0 0 0</li>
<li>client-output-buffer-limit slave 256mb 64mb 60</li>
<li>client-output-buffer-limit pubsub 32mb 8mb 60</li>
</ul>
</li>
<li>查询缓冲区：client-query-buffer-limit，主要用于避免客户端bug引起服务端崩溃；默认1GB，一般不做限制。</li>
<li>客户端超时：timeout，不是很精确的计算，只用于一般类型的客户端（非repl、pub/sub类型）</li>
<li>tcp心跳设置：tcp-keepalive，避免客户端”假死”(虽然连接，但是已不可用)</li>
</ul>
<h2 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h2><ul>
<li>client list：显示客户端列表，参数含义如下：<ul>
<li>addr：客户端ip和port</li>
<li>name：客户端名称<ul>
<li>client setname：设置当前会话名称</li>
<li>client getname：获取当前会话名称</li>
</ul>
</li>
<li>age：连接存在时间</li>
<li>idle：连接空闲时间</li>
<li>flags：连接类型<ul>
<li>S：复制客户端</li>
<li>N：一般客户端</li>
</ul>
</li>
<li>omem：已使用的输出缓冲区大小</li>
<li>cmd：最近执行的命令</li>
</ul>
</li>
<li>client kill：关闭客户端连接</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群</title>
    <url>/blog/2019/10/26/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">集群介绍</a></h1><ul>
<li>redis3.0之后提供集群模式</li>
<li>集群功能<ul>
<li>自动将数据拆分到多个节点</li>
<li>在一部分节点不可用时，依然可以进行数据操作</li>
</ul>
</li>
<li>集群端口<ul>
<li>服务端口(client port，如6379)：集群的其他节点(key迁移)、客户端都可以访问到</li>
<li>集群总线端口(client port+10000)：用于集群节点间的通信，如：失败检测、配置更新、故障切换授权等</li>
</ul>
</li>
<li>集群与docker<ul>
<li>当前redis集群不支持nat网络环境和ip、port都重新映射的通用环境</li>
<li>为了使docker兼容redis集群，docker应当使用host网络模式（–net=host）</li>
</ul>
</li>
<li>数据分片：<ul>
<li>集群共有16384个hash槽，分布在集群的所有节点上</li>
<li>每个key在逻辑上都是hash槽的一部分</li>
<li>在给定一个key时，通过对key的CRC16相对于16384取模来确定key要存储的hash槽</li>
<li>只需来回迁移hash槽到不同节点，就可以在线添加或删除节点</li>
<li>集群支持在一个命令（整个事务、lua脚本执行）执行多键操作，只需要所有的键都在同一个hash槽中</li>
<li>用户可以使用hash标签将多个键存储在同一个hash槽中</li>
</ul>
</li>
<li>支持主从复制功能</li>
<li>数据一致性保证<ul>
<li>redis集群不保证强的数据一致性：比如在数据刷新到磁盘前宕机、数据复制到从机前宕机等都会丢失部分数据</li>
<li>可以通过如下措施增加一致性<ul>
<li>变更数据刷新策略（fsync），即数据写入磁盘后才向客户端返回确认信息，但这回造成性能损失</li>
<li>使用WAIT命令后，启用同步复制功能</li>
</ul>
</li>
<li>网络隔离也会造成数据丢失<ul>
<li>产生网络隔离后，客户端Z1和至少一个主节点B位于其中一个网络，其他节点（A、A1、B1、C、C1）位于另一个网络</li>
<li>在节点超时前(cluster-node-timeout)，Z1依然可以向B发送写操作；</li>
<li>节点超时后，不能和其他主节点通信的主节点(B)会被认为是失败节点，不再接收写操作，集群也会将失败节点的从节点(B1)提升为主节点</li>
<li>由于B在不能和从节点通信时依然接收写操作，当从节点B1提升为主节点时会丢失部分数据</li>
</ul>
</li>
</ul>
</li>
<li>集群配置参数<ul>
<li>cluster-enabled：是否开启集群模式，集群模式和独立模式不能互相切换</li>
<li>cluster-config-file：集群状态文件，用户不可编辑</li>
<li>cluster-node-timeout：集群超时时间，超时则失败主停止写，从机执行故障切换</li>
<li>cluster-slave-validity-factor：【超时时间*衡量因子】之后从机执行故障切换，为了高可用，可以设置为0【从机一直尝试接管主机】</li>
<li>cluster-migration-barrier：主机应当保留的从机个数，超过的从机可以迁移到孤立主机上</li>
<li>cluster-require-full-coverage：数据不全时是否对外提供查询服务</li>
</ul>
</li>
</ul>
<h1 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h1><h2 id="内置脚本方式"><a href="#内置脚本方式" class="headerlink" title="内置脚本方式"></a>内置脚本方式</h2><p>utils/create-cluster/create-cluster start/create/stop</p>
<h2 id="手动创建方式"><a href="#手动创建方式" class="headerlink" title="手动创建方式"></a>手动创建方式</h2><ul>
<li>创建并启动多个redis实例(包含集群参数)</li>
<li>创建集群<ul>
<li>版本5之后已在redis-cli命令中内置集群功能，可以实现：创建集群、集群分片检查和重新分片等功能<ul>
<li>范例：redis-cli –cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 –cluster-replicas 1</li>
<li>解释：使用create创建集群，并保证每个主一个从节点</li>
</ul>
</li>
<li>版本4和3需要使用ruby工具：redis-trib.rb<ul>
<li>安装 redis gem：<ul>
<li>apt-get install rubygems</li>
<li>gem install redis</li>
</ul>
</li>
<li>使用ruby工具创建集群<ul>
<li>./redis-trib.rb create –replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="手动创建范例"><a href="#手动创建范例" class="headerlink" title="手动创建范例"></a>手动创建范例</h2><ul>
<li>解压redis源码，并将src目录绝对路径添加到PATH变量中</li>
<li>安装redis gem</li>
<li>执行创建脚本creat.sh</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># create.sh</span><br><span class="line">result=&quot;redis-trib.rb create --replicas 1 &quot;</span><br><span class="line">for port in `seq 7000 7005`</span><br><span class="line">do</span><br><span class="line">        mkdir $&#123;HOME&#125;/$&#123;port&#125;</span><br><span class="line">        cp redis.conf $&#123;HOME&#125;/$&#123;port&#125;/$&#123;port&#125;.conf</span><br><span class="line">        sed -i &apos;s/7000/&apos;$port&apos;/g&apos; $&#123;HOME&#125;/$&#123;port&#125;/$&#123;port&#125;.conf</span><br><span class="line">        sed -i &apos;s%/home/redis%&apos;$&#123;HOME&#125;&apos;%g&apos; $&#123;HOME&#125;/$&#123;port&#125;/$&#123;port&#125;.conf</span><br><span class="line">        echo $port</span><br><span class="line">        redis-server $&#123;HOME&#125;/$&#123;port&#125;/$&#123;port&#125;.conf</span><br><span class="line">        ip_port=&quot;127.0.0.1:&quot;$port</span><br><span class="line">        result=$&#123;result&#125;\ $&#123;ip_port&#125;</span><br><span class="line">done</span><br><span class="line">echo &quot;yes&quot; |$result</span><br><span class="line"></span><br><span class="line"># stop.sh</span><br><span class="line">for port in `seq 7000 7005`</span><br><span class="line">do</span><br><span class="line">    cat $&#123;HOME&#125;/$&#123;port&#125;/$&#123;port&#125;.pid  |xargs -i kill &#123;&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h1 id="客户端支持"><a href="#客户端支持" class="headerlink" title="客户端支持"></a>客户端支持</h1><ul>
<li>程序语言支持：<a href="https://redis.io/topics/cluster-tutorial#playing-with-the-cluster" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial#playing-with-the-cluster</a></li>
<li>redis-cli支持(-c参数)：例如：redis-cli -c -p 7000</li>
</ul>
<h1 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h1><ul>
<li>hash槽迁移：<ul>
<li>命令行(redis-trib)：redis-trib.rb reshard –from source_id –to dest_id –slots slot_num –yes ip:port</li>
<li>参数解释<ul>
<li>连接的节点ip和端口需要放在最后</li>
<li>源和目标节点id可以从【cluster nodes】中获取，源节点可以有多个(逗号分隔，all表示其他所有节点)</li>
<li>–from/–to：迁移的源和目标节点</li>
<li>–slots：迁移的槽数量</li>
<li>–yes：免交互确认</li>
</ul>
</li>
</ul>
</li>
<li>手动故障切换(主从状态切换)：cluster failover（在从节点执行）</li>
<li>添加主节点：<ul>
<li>命令行方式：redis-trib  add-node  new_host:new_port existing_host:existing_port</li>
<li>交互式命令行：cluster meet ip port </li>
</ul>
</li>
<li>添加从节点：<ul>
<li>命令行方式：redis-trib  add-node –slave –master-id new_host:new_port existing_host:existing_port【不指定master-id时，默认将其随机添加到具有最少从节点的主节点】</li>
<li>交互式命令行：cluster replicate master-id<ul>
<li>此种模式首先添加一个没有数据的空节点，然后连接到此节点后使用上述复制命令将其添加为从节点</li>
<li>此命令也可以用于改变从机的主节点</li>
</ul>
</li>
</ul>
</li>
<li>删除节点：<ul>
<li>删除方式：<ul>
<li>命令行：redis-trib del-node host:port node_id</li>
<li>交互式命令行：cluster forget node_id</li>
</ul>
</li>
<li>主从处理：<ul>
<li>从节点可以直接删除</li>
<li>主节点没有数据时才可以删除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="可用性预处理"><a href="#可用性预处理" class="headerlink" title="可用性预处理"></a>可用性预处理</h1><p>为了提高系统可用性，事先在每个实体机上预留1~2个多余的从节点作为备份，当某个主节点或从节点挂掉时，多余的从节点可以自动的迁移(cluster-migration-barrier)过来以达到集群所有主节点至少有一个从节点。</p>
<h2 id="少数主或从节点故障"><a href="#少数主或从节点故障" class="headerlink" title="少数主或从节点故障"></a>少数主或从节点故障</h2><ul>
<li>预处理：配置备份飘逸参数cluster-migration-barrier</li>
<li>主节点故障：客户端写操作会报错；不会形成备份飘逸；8、9秒后，从节点提升为主，客户端可以进行写操作。</li>
<li>从节点故障：客户端无影响；会形成备份飘逸</li>
</ul>
<h2 id="少数主和它的从节点同时挂掉"><a href="#少数主和它的从节点同时挂掉" class="headerlink" title="少数主和它的从节点同时挂掉"></a>少数主和它的从节点同时挂掉</h2><ul>
<li>预处理：配置cluster-require-full-coverage为no，集群出故障时可读不可写</li>
</ul>
<h2 id="多数主节点同时宕机"><a href="#多数主节点同时宕机" class="headerlink" title="多数主节点同时宕机"></a>多数主节点同时宕机</h2><p>集群处于不可用状态</p>
<h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><ul>
<li>redis支持迁移到集群的情况<ul>
<li>没有使用多键操作、事务、包含多键的lua脚本</li>
<li>使用hash标签的多键、事务、包含多键的lua脚本</li>
</ul>
</li>
<li>手动迁移步骤<ul>
<li>停止客户端连接。当前版本不能进行在线迁移</li>
<li>产生aof文件【BGREWRITEAOF】</li>
<li>拷贝aof文件到其他位置，停止旧实例</li>
<li>创建包含N个主和0个从的集群【从机稍后添加，并确保使用aof做持久化化】</li>
<li>停止所有集群节点，将迁移前产生的aof文件替换到集群中</li>
<li>重启集群</li>
<li>使用redis-trib fix让键值对自动迁移</li>
<li>使用redis-trib check查看迁移结果</li>
<li>重启客户端，连接到集群任意节点</li>
<li>向当前集群添加从节点</li>
</ul>
</li>
<li>5.0版本内置迁移命令：redis-cli –cluster import<ul>
<li>支持将一个运行中的实例数据迁移到一个预先搭建好的集群中（同时会删除源实例中的数据）</li>
<li>当2.8版本作为源实例时，由于没有实现迁移连接缓存，迁移过程会很慢，解决方案是使用3.x版本实例加载源数据</li>
</ul>
</li>
</ul>
<h1 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h1><ul>
<li>交互式迁移报错<ul>
<li>报错：[ERR] Calling MIGRATE: ERR Syntax error, try CLIENT (LIST | KILL | GETNAME | SETNAME | PAUSE | REPLY)</li>
<li>原因：官方bug</li>
<li>解决：安装低版本gem redis：gem install redis -v 3.3.5</li>
</ul>
</li>
<li>节点状态不一致<ul>
<li>现象<ul>
<li>连接不同的节点，获取cluster nodes输出不一致</li>
<li>使用./redis-trib [check|fix]命令得到如下报错：【 Nodes don’t agree about configuration】，并显示个别slot处于importing状态</li>
<li>由于状态不一致，所以不能进行slot迁移【不能使用reshard命令】</li>
</ul>
</li>
<li>解决：由于只是个别节点状态不一致，只需处理个别节点即可</li>
<li>步骤<ul>
<li>手动设置异常节点的slot：for i in {5461..10922};do redis-cli -h 172.29.88.117 -p 7004 -c cluster setslot $i node ca4757c010e6b6c028006bb4b8c1cd0852ab3033;done<ul>
<li>5461…10922为状态异常的slot</li>
<li>-h/-p  连接异常节点</li>
<li>ca4757c0… 为这些slot的正确节点id【根绝大多数节点返回获得】</li>
</ul>
</li>
<li>修复异常节点状态（循环：每次修复一个slot）：for i in {5461..10922};do ./redis-trib.rb fix 172.29.88.117:7004;done</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>redis服务端配置</title>
    <url>/blog/2019/10/22/web%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/%E7%BC%93%E5%AD%98%E4%B8%8Enosql/redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="服务端配置方法"><a href="#服务端配置方法" class="headerlink" title="服务端配置方法"></a>服务端配置方法</h1><ul>
<li>文件指令格式：keyword argument1 argument2 … argumentN<ul>
<li>使用引号处理包含的空格：requirepass “hello world”</li>
</ul>
</li>
<li>命令行传参：./redis-server –port 6380 –slaveof 127.0.0.1 6379</li>
<li>运行状态下变更配置：<ul>
<li>获取配置：config get keyword</li>
<li>设置参数：config set keyword value</li>
<li>将运行配置写入文件：config rewrite</li>
</ul>
</li>
</ul>
<h1 id="专项配置"><a href="#专项配置" class="headerlink" title="专项配置"></a>专项配置</h1><h2 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>日志条目id</li>
<li>日志记录时间戳</li>
<li>执行时间（微秒）</li>
<li>执行命令数组</li>
<li>客户端ip和端口（4.0版本）</li>
<li>通过client setname设置的客户端名称（4.0版本）</li>
</ul>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul>
<li>slowlog-log-slower-than：执行时间阈值</li>
<li>slowlog-max-len：记录日志条数</li>
</ul>
<h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><ul>
<li>查看（指定数目）日志：slowlog get （number）</li>
<li>查看日志记录总数：slowlog len</li>
<li>清空日志：slowlog reset</li>
</ul>
<h1 id="配置文件redis-conf"><a href="#配置文件redis-conf" class="headerlink" title="配置文件redis.conf"></a>配置文件redis.conf</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis.conf必须作为第一个参数，例如：./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line"># 涉及内存时的计量单位</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># include包含的文件不能被【config rewrite】命令改写</span><br><span class="line"># 针对相同的配置项，后面的配置会覆盖前面的配置，所以需要注意include的位置【首行？尾行】</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"></span><br><span class="line">################################## MODULES #####################################</span><br><span class="line"></span><br><span class="line"># 加载自定义模块</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"></span><br><span class="line">################################## NETWORK #####################################</span><br><span class="line"></span><br><span class="line"># 如果没有指定bind参数，redis运行在所有网络接口上</span><br><span class="line"># redis可以指定一个或多个网络接口</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 公网保护模式（默认开启）</span><br><span class="line"># 如果没有配置bind指令或密码认证信息，则只能从127.0.0.1等回环接口访问</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口（默认6379，设置为0，则不在tcp上监听）</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 定义tcp队列长度</span><br><span class="line"># 在linux环境下，linux内核会自动将其值变更为/proc/sys/net/core/somaxconn的值，</span><br><span class="line"># 以确保可以通过提高somaxconn的值达到最终目的</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 设置unix socket文件（默认不产生socket文件）</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># 客户端连接超时时间</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># tcp连接心跳检测（3.2.1之后，默认值为300s）</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># 是否开启后台运行模式（默认no）</span><br><span class="line"># 如果设置为后台模式，则会产生一个pid文件</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 如果使用其他控制程序(如upstart、systemd)控制redis服务启停，需要如下相关设置</span><br><span class="line">#   supervised no      - no supervision interaction</span><br><span class="line">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="line">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="line">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line"># Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># 后台运行时产生的pid文件位置（如果没有指定，默认写入/var/run/redis.pid）</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"># 日志级别</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># 日志文件位置</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 是否使用系统的syslog方式写日志</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># 设置数据库数量，每个库都有独立的命名空间</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"># 交互模式下，是否显示redis logo信息</span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line"></span><br><span class="line"># 设置保存数据到rdb文件的频率：save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># 取消所有保存频率的设置：save &quot;&quot;</span><br><span class="line"># </span><br><span class="line"># 以下设置的含义：</span><br><span class="line"># 900秒后至少有1个key发生变更</span><br><span class="line"># 300秒后至少有10个key发生变更</span><br><span class="line"># 60秒后至少有10000个key发生变更</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 开启rdb写入时，如果后台持久化存储失败则停止客户端写操作</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># rdb文件压缩存储</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># rdb校验【增加可用性，但会增加存储或加载开销】</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># rdb文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 指定rdb和aof文件的存储目录</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line"># 主从复制从机设置</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># 主机要求的验证密码（requirepass）</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 主从复制中断时，从机的处理（默认yes）：</span><br><span class="line"># 设置为yes，则从机可以使用过期的数据为客户端提供服务</span><br><span class="line"># 设置为no，则从机会对除了INFO和SLAVEOF的其他命令返回错误信息：&quot;SYNC with master in progress&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 从机只读设置</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># rdb文件传输方式（复制同步策略）：</span><br><span class="line"># 有盘方式：主开启写进程在本地写rdb文件，在rdb文件阶段性写完后，</span><br><span class="line">#   就可以和（多个）从机通信，然后由父进程传输文件到从机</span><br><span class="line"># 无盘方式（网络）：主开启写进程直接将rdb文件写入从机网络socket，</span><br><span class="line">#   当阶段性写操作完成后，主和另一个从机通信进行复制操作</span><br><span class="line">#</span><br><span class="line"># 无盘复制同步要点：</span><br><span class="line"># 1.无盘模式当前是实验性功能</span><br><span class="line"># 2.新建一个从机或从机重连时会执行一个全量同步</span><br><span class="line"># 3.使用无盘方式，会配置一个等待时间，以便所有从机可达以并行方式传输</span><br><span class="line"># 4.磁盘容量小或磁盘io小，同时网络带宽大的情况更适合使用无盘方式</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 无盘方式工作时，复制开始前主机的等待时间（默认5s，0则不等待）</span><br><span class="line"># 一旦同步开始，新的从机并不会被主接纳，所以需要配置一个等待时间，确保所有从机已连上。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 从机检测主机可达的时间间隔</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 复制超时时间</span><br><span class="line"># 它包含：主机视角的ping响应超时、从机角度的ping和数据传输超时</span><br><span class="line"># 它必须比repl-ping-slave-period时间长</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否关闭tcp nodelay功能（默认no，不关闭延迟）</span><br><span class="line"># 设置为yes，会传输更小的数据包并使用更小的带宽，但延迟会增加（linux内核限制，最多40ms）</span><br><span class="line"># 设置为no，延迟会更低，但是需要更大的带宽</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 允许从机断开并重连时可以继续同步的缓冲区大小【避免全量同步】</span><br><span class="line"># repl-backlog-size 512mb</span><br><span class="line"></span><br><span class="line"># 超时则主释放同步缓冲区，0则永不释放</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># 从机提升为主机时的优先级（数越小优先级越高）</span><br><span class="line"># 主要是redis sentinel使用，当主出现异常时提升从机为主</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 当少于指定数量的从机或复制延迟大于某个阈值时，主停止写操作（设置为0则关闭此功能）</span><br><span class="line"># 范例：至少3个从机的延迟小于10，否则master停止写入操作</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"># 主从复制时，主查看从机ip的方式：INFO replication 和 ROLE</span><br><span class="line"># 在端口转发和nat网络情况下，上述命令获取的信息会有误</span><br><span class="line"># 通过在从机声明如下变量，可以告诉主机自己真实的ip和port【可选设置】</span><br><span class="line"># slave-announce-ip 5.5.5.5</span><br><span class="line"># slave-announce-port 1234</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line"># 客户端认证密码（也是主从复制的密码），由于redis没有防爆破的手段，所以需要设置一个强密码</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># 重命名命令：</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"># 也可通过空字符串“删除”命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"># 【注意】重命名命令在写入aof或传输到从机时会出问题</span><br><span class="line"></span><br><span class="line">################################### CLIENTS ####################################</span><br><span class="line"></span><br><span class="line"># 客户端最大连接数</span><br><span class="line"># 如果redis不能设置最大文件描述符数量，</span><br><span class="line">#   则maxclients被设置为当前最大文件描述符数量减32（redis保留部分描述符供内部使用）</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">############################## MEMORY MANAGEMENT ################################</span><br><span class="line"></span><br><span class="line"># 最大可用内存（超过后根据驱逐策略删除key）</span><br><span class="line"># 1. 超过此阈值，如果驱逐策略为noeviction，则对于写命令则返回错误，读命令则正常返回</span><br><span class="line"># 2. 作为LRU或LFU缓存，或使用noeviction驱逐策略时，都应该设置硬限制</span><br><span class="line"># 3. 不包含主从复制的输出缓冲区大小（repl-backlog-size）</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># 内存使用达到限制时的key删除策略（默认noeviction）：</span><br><span class="line"># volatile-lru -&gt; 使用LRU策略驱逐具有过期设置的key</span><br><span class="line"># allkeys-lru -&gt; 使用LRU策略驱逐任意的key</span><br><span class="line"># volatile-lfu -&gt; 使用LFU策略驱逐具有过期设置的key</span><br><span class="line"># allkeys-lfu -&gt; 使用LFU策略驱逐任意的key</span><br><span class="line"># volatile-random -&gt; 从具有过期设置的key中随机删除一个</span><br><span class="line"># allkeys-random -&gt; 从所有key中随机删除一个</span><br><span class="line"># volatile-ttl -&gt; 删除最接近过期的key</span><br><span class="line"># noeviction -&gt; 不驱逐任何key，向写操作返回错误</span><br><span class="line">#</span><br><span class="line"># LRU：Least Recently Used【最近最少使用】</span><br><span class="line"># LFU：Least Frequently Used【经常最少使用】</span><br><span class="line"># LRU, LFU 和 volatile-ttl都使用了近似的随机算法</span><br><span class="line">#</span><br><span class="line"># 即使使用上述策略，如果没有合适的key被删除，依然会对写操作返回错误，包含的写操作如下：</span><br><span class="line"># set setnx setex append</span><br><span class="line"># incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line"># sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line"># zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line"># getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># 启动内存回收时，单次取样数量：</span><br><span class="line"># 3个速度最快，但是策略执行不精确；5个足够；10个最精确，但是更消耗cpu</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">############################# LAZY FREEING ####################################</span><br><span class="line"></span><br><span class="line"># 非阻塞式释放内存</span><br><span class="line">#</span><br><span class="line"># redis有两种删除key的模式：</span><br><span class="line"># 1.阻塞式：del命令是一种阻塞式删除，即在进行删除操作的同时停止处理新命令，阻塞时间的长短根据删除对象的大小而定</span><br><span class="line"># 2.非阻塞式：redis（4.0.0之上版本）也提供非阻塞式删除命令，比如unlink（非阻塞del）、flushdb|flushall的async选项</span><br><span class="line"># 这些命令会在限定时间内执行完，但是会在后台开启一个新线程持续释放内存空间</span><br><span class="line">#</span><br><span class="line"># 情景设置：</span><br><span class="line"># 一、在下列情景中，redis默认会以阻塞方式删除key或清空库：</span><br><span class="line"># 1.根据最大内存和驱逐策略删除key</span><br><span class="line"># 2.由于key的过期设置（EXPIRE）</span><br><span class="line"># 3.对一个已存在的key进行操作，如RENAME</span><br><span class="line"># 4.在复制操作时，从机执行全量复制时，会清空从机rdb</span><br><span class="line"># </span><br><span class="line"># 二、可以单独设置以上情况以非阻塞方式释放内存，具体命令如下：</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># 是否开启预写日志模式（aof和rdb可以同时开启）</span><br><span class="line"># 默认情况下，redis异步导出数据到磁盘（基于rdb的不同刷新策略（save）可能会有部分数据丢失）</span><br><span class="line"># 当aof开启时，redis启动时会将加载aof文件</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># fsync为数据写入磁盘的策略</span><br><span class="line"># no: 让操作系统处理什么时候刷新数据到磁盘，此时速度最快</span><br><span class="line"># always: 每次都等待数据写入aof文件，速度最慢，安全性最好</span><br><span class="line"># everysec: 每秒刷新数据到磁盘，折中选择【默认选项】</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在后台执行BGSAVE或BGREWRITEAOF命令时，是否阻止主进程进行磁盘刷新操作</span><br><span class="line"># 这个选项是为了减轻磁盘写压力，但会造成数据丢失【默认不开启】</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 自动重写aof文件时，增长的大小所占的百分比</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 自动重写aof文件时，最小增加的文件大小</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 是否允许加载不完整（被截断）的aof文件（如果设置为no，必须使用redis-check-aof修复aof文件）</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 使用aof和rdb混合方式持久化数据【可以更快的执行重写和恢复操作，默认关闭】</span><br><span class="line">aof-use-rdb-preamble no</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"></span><br><span class="line"># lua脚本执行超时时间（毫秒，0或负值则不限制时间）</span><br><span class="line"># 超过时间，redis会记录脚本依然在执行，并对查询信息返回错误</span><br><span class="line"># 【SCRIPT KILL】命令会停止一个不含写操作的脚本</span><br><span class="line"># 【SHUTDOWN NOSAVE】可以停止包含写操作的脚本</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line"></span><br><span class="line"># 是否开启redis集群功能</span><br><span class="line"># redis单实例模式和集群模式不能相互转换，只能在一开始就确定使用的方式</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群节点的配置文件（集群自动创建和更新，一般不需要手动编辑）每个节点都有一个配置文件</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 节点断开超时时间（毫秒，其他内部限制时间都是这个值的倍数）</span><br><span class="line"># 超过这个时间，节点被认为是失败状态</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 定义从机选举为主的因子（避免数据太旧的从机执行故障切换）</span><br><span class="line"># </span><br><span class="line"># 数据新旧情况判断：</span><br><span class="line"># 1.当有多个从机时：会根据他们从主上接收数据的多少（offset）选择谁执行故障切换</span><br><span class="line"># 2.单个从机角度计算：则根据距离上次接收ping响应、接收命令的时间（连接状态下）或与主断开的时间</span><br><span class="line"># </span><br><span class="line"># 第2点可以由用户控制，超过【(node-timeout * slave-validity-factor) + repl-ping-slave-period】</span><br><span class="line"># 的从机不能提升为主；其中slave-validity-factor是从机选举为主的因子：</span><br><span class="line"># 1）定义为n，则超过（n*timeout+ping）后选举为主，此段时间内，集群不可用除非原来的主恢复</span><br><span class="line"># 2）如果：非常大的值允许有非常旧数据的从机执行故障切换，值太小则无法在众多从机中选出提升为主的从机</span><br><span class="line"># 3）默认为0，超时即选为主；此设置保证了最大可用性，允许从机立即提升为主，但是依然会根据从主机接收数据的多少选择提升为主的从机</span><br><span class="line">#</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 主机在有如下数量的从机时，其他从机可以自动迁移到孤立的主机（没有从机的主机）</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 是否要求所有数据槽都可用时集群才可用</span><br><span class="line"># 设置为no时，允许集群数据不完整时依然可以提供查询服务</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line"># 主故障时，禁止从机执行故障切换（此时会手动处理主机故障切换操作）</span><br><span class="line"># 在有多个数据中心时非常有用，此时会期望只有这个数据中心的节点全部出现故障时才执行切换</span><br><span class="line"># cluster-slave-no-failover no</span><br><span class="line"></span><br><span class="line">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="line"></span><br><span class="line"># 当遇到nat网络或端口转发时【如docker等容器环境】集群节点地址发现会失败，所以</span><br><span class="line"># 每个集群节点都需要知道一个公共地址，即如下配置：</span><br><span class="line"># * cluster-announce-ip</span><br><span class="line"># * cluster-announce-port</span><br><span class="line"># * cluster-announce-bus-port</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># cluster-announce-ip 10.1.1.5</span><br><span class="line"># cluster-announce-port 6379</span><br><span class="line"># cluster-announce-bus-port 6380</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"></span><br><span class="line"># 慢日志在内存中记录超过一定执行时间的命令：</span><br><span class="line"># 不包含io操作，比如：和客户端通信、发送响应</span><br><span class="line"># 仅包含：命令的实际执行时间，此时线程被阻塞不能服务于其他请求</span><br><span class="line"></span><br><span class="line"># 执行时间阈值（微秒，负值则关闭slowlog功能，0则记录每一个命令）</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 保存多少条慢日志，超过则删除最旧的记录（【SLOWLOG RESET】强制回收内存）</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"></span><br><span class="line"># 超过阈值的延迟因素会被记录（毫秒；默认为0，关闭功能 ）</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line"></span><br><span class="line"># redis可以通知发布/订阅的客户端发生在键空间的事件，</span><br><span class="line"># 相关文档：http://redis.io/topics/notifications</span><br><span class="line">#</span><br><span class="line"># redis通过单字符定义要通知的事件：</span><br><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br><span class="line"># </span><br><span class="line"># notify-keyspace-events使用0或多个字符构成的字符串串作为参数：</span><br><span class="line"># 1. 0个字符串表示关闭事件通知功能（默认）</span><br><span class="line"># 2. 至少需要指定K或E，否则会没有事件通知</span><br><span class="line">#</span><br><span class="line"># 范例1：开启列表和通用事件，从事件名称的角度，使用如下</span><br><span class="line">#  notify-keyspace-events Elg</span><br><span class="line">#</span><br><span class="line"># 范例2：获取提交给频道&lt;__keyevent@0__:expired&gt;的过期key流</span><br><span class="line">#  notify-keyspace-events Ex</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"></span><br><span class="line"># ziplist是一个解决空间紧凑的数据存储结构，但是当数据超过此阈值时，将采用原生的数据存储结构</span><br><span class="line"># </span><br><span class="line"># 数据类型为hash，设置使用ziplist的条目数量、最大条目值的阈值</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 数据类型是list，设定使用ziplist的阈值</span><br><span class="line"># 定义为正值时，表示单个列表最大元素数量</span><br><span class="line"># 定义为负值时（-5到-1）表示单个列表的最大存储空间</span><br><span class="line"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"># 数据类型是list，也可以被压缩存储</span><br><span class="line"># 压缩深度定义如下</span><br><span class="line"># 0：关闭列表所有节点的压缩</span><br><span class="line"># 1：列表的首尾节点不压缩，其他节点都压缩</span><br><span class="line"># 2：列表的首及相邻节点、尾及相邻节点不压缩，其他节点都压缩</span><br><span class="line"># n：以此类推，首尾的n个节点不压缩，中间节点压缩</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line"># 数据类型为set，且仅由基数为10的整数（64为有符号整数）组成的字符串</span><br><span class="line"># 当set类型的大小小于阈值时，可以使用这种节省内存的编码</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># 数据类型sorted sets（zset），设定使用ziplist的阈值</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># HyperLogLog的稀疏表示限制（建议值是3000，取值范围是0到15000）</span><br><span class="line"># 1. 大于这个阈值，数据使用稠密数据结构；</span><br><span class="line"># 2. 小于此值，数据使用稀疏数据结构。</span><br><span class="line"># 3. 大于16000的值是无意义的，因为此时稠密表示法更能有效使用内存</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># 是否开启对主字典的二次哈希（hash会释放内存，但因为使用cpu会造成微量延迟）</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端输出缓冲区限制，如果客户端读取数据的速度不够快，则强制断开</span><br><span class="line"># 参数0不限制；一般的客户端（normal）不限制，因为他们使用应答模式返回数据</span><br><span class="line"># </span><br><span class="line"># 语法：</span><br><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">#</span><br><span class="line"># redis：定义了3种不同类型的客户端</span><br><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># slave  -&gt; slave clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line"># </span><br><span class="line"># 如果客户端使用达到硬限制或软限制（同时达到字节大小和持续时间）则断开客户端</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># 客户端查询缓冲区限制（如果有特殊需求可以设置）</span><br><span class="line"># client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line"># 使用redis协议时，单个大数据量请求的字符串长度限制（默认512mb）</span><br><span class="line"># proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line"># redis调用内部函数执行后台任务（如：超时关闭客户端，删除过期的key）的频率：</span><br><span class="line"># 1. 增大数值可以更精确的处理各类超时、删除过期key等问题，但是会消耗更多的cpu、也会增加redis的延迟</span><br><span class="line"># 2. 取值范围1到500，但是不建议使用超过100的值</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># 当aof文件重写时，每产生32MB数据就会执行一次刷新磁盘操作</span><br><span class="line"># 以这种渐进的方式进行重写操作可以降低磁盘写压力（从而降低常规写aof的延迟）</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># 【LFU算法调节】</span><br><span class="line"># 可调节参数：计数器对数因子（lfu-log-factor）和计数器衰减时间（lfu-decay-time）</span><br><span class="line">#</span><br><span class="line"># 【计数器对数因子-原理】</span><br><span class="line"># 针对每个key，LFU计数器只有8位，最大值是255；</span><br><span class="line"># 给旧的计数器一个值，当key被访问时，计数器以下面方式增长</span><br><span class="line"># 1.产生一个0~1之间的随机数R</span><br><span class="line"># 2.计算一个概率值P：1/(old_value*lfu_log_factor+1)</span><br><span class="line"># 3.只有当概率值P大于随机数R时，计数器才递增</span><br><span class="line">#</span><br><span class="line"># 下边是不同对数因子在不同访问次数下的频率计数器变化</span><br><span class="line"># （计数器的初试值为5，以便计算对象的累积命中率；测试命令如下）：</span><br><span class="line"># 1. redis-benchmark -n 1000000 incr foo</span><br><span class="line"># 2. redis-cli object freq foo</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line">#</span><br><span class="line"># 【计数器衰减时间-原理】</span><br><span class="line"># 必须是经过的时间，以便将key计数器除以2或直接递减（小于等于10时） </span><br><span class="line">#</span><br><span class="line"># 【计数器对数因子-设置】（0-255）（因子越高，为了达到最大值，需要更多的访问）</span><br><span class="line"># 如下表示：每100万个请求使计数器饱和</span><br><span class="line"># lfu-log-factor 10</span><br><span class="line">#</span><br><span class="line"># 【LFU衰减时间周期-设置】（分钟），默认1分钟；</span><br><span class="line"># 如下表示：每分钟使计数器衰减一次</span><br><span class="line"># lfu-decay-time 1</span><br><span class="line"></span><br><span class="line">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="line"></span><br><span class="line"># 开启实时内存碎片整理功能</span><br><span class="line"># activedefrag yes</span><br><span class="line"></span><br><span class="line"># 内存碎片化达到多少字节后开启整理</span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"># 内存碎片化达到多大比率时开启整理</span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"># 碎片整理的最大百分比</span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line"># 碎片整理占用的最小cpu使用率</span><br><span class="line"># active-defrag-cycle-min 25</span><br><span class="line"></span><br><span class="line"># 碎片整理占用的最大cpu使用率</span><br><span class="line"># active-defrag-cycle-max 75</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis.conf</tag>
        <tag>慢日志</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门介绍</title>
    <url>/blog/2019/11/19/%E5%AE%B9%E5%99%A8%E5%8C%96/docker/docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="docker引入"><a href="#docker引入" class="headerlink" title="docker引入"></a>docker引入</h1><h2 id="传统IT面临问题"><a href="#传统IT面临问题" class="headerlink" title="传统IT面临问题"></a>传统IT面临问题</h2><ul>
<li>部署流程繁琐(采购服务器、安装软件环境)、软件环境臃肿、难于扩展(不利于迅速应对业务高峰对资源需求)</li>
<li>环境不一致：开发、测试、生产环境不一致</li>
<li>资源浪费：硬件需要预采购，成本很高；同时面临cpu、内存等资源使用不足</li>
</ul>
<h2 id="容器优势"><a href="#容器优势" class="headerlink" title="容器优势"></a>容器优势</h2><ul>
<li>更快且保持一致性的交付应用程序【保持多阶段环境的一致性】</li>
<li>响应式部署和扩展【可以在物理机、虚拟机、云等多种环境部署，并可以根据负载弹性伸缩】</li>
<li>在同一个硬件上运行更多的负载</li>
</ul>
<h2 id="容器化devops"><a href="#容器化devops" class="headerlink" title="容器化devops"></a>容器化devops</h2><p>通过标准化“应用运行环境”，沟通开发(dev)和运维(ops)流程</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/devops-demo.jpg" alt></p>
<h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><ul>
<li>区别：容器是在操作系统层面实现虚拟化，直接复用本地操作系统内核，它的技术基础是linux容器技术（LXC，即cgroups）；传统虚拟化方式则基于硬件层面实现虚拟化。</li>
</ul>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/containerVSvm.jpg" alt></p>
<ul>
<li>融合：由于目前docker不支持热迁移，可以将docker容器放在KVM虚拟机里，通过虚拟机的迁移完成容器的迁移</li>
</ul>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/container%2BVM.jpg" alt></p>
<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a><a href="https://docs.docker.com/get-started/overview/#docker-architecture" target="_blank" rel="noopener">docker介绍</a></h1><h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><ul>
<li>docker daemon(dockerd)：监听API请求、管理docker对象（镜像、容器、网络、卷）</li>
<li>docker client：用户管理docker的入口</li>
<li>docker registry：镜像仓库</li>
</ul>
<p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt></p>
<h2 id="docker对象"><a href="#docker对象" class="headerlink" title="docker对象"></a>docker对象</h2><ul>
<li>容器：视图隔离、资源可限制、独立文件系统的进程集合<ul>
<li>可以把容器看做是一个简易的linux环境和运行在其中的应用程序</li>
<li>docker利用容器来运行应用</li>
<li>容器是从镜像创建的运行实例，它可以被开始、停止、删除。</li>
<li>每个容器都是相互隔离的</li>
</ul>
</li>
<li>镜像：容器运行所需的所有文件集合<ul>
<li>不包含linux内核的精简linux系统</li>
<li>一个镜像可以创建多个容器</li>
<li>它是一个只读模板，用来创建容器</li>
<li>容器在启动时会创建一个可写层作为多层文件系统的最上层</li>
</ul>
</li>
</ul>
<h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><ul>
<li>视图隔离(namespace)：pid、net、ipc、mnt、uts</li>
<li>资源限制(cgroups)：cpu、内存</li>
<li>联合文件系统(union file system)：容器和镜像的分层，即分层文件系统<ul>
<li>镜像拆分成多个模块，可以并行下载，提高分发效率</li>
<li>镜像数据是共享的，每次下载或构建镜像时，可以复用已存在的部分数据，此时，只需存储本地不存在的数据。</li>
<li>容器在启动时会创建一个可写层作为多层文件系统的最上层</li>
</ul>
</li>
<li>容器格式(container format)：docker engine将namespace、cgroups、UnionFS组合到容器格式的包装器中，默认的容器格式为libcontainer</li>
</ul>
<h2 id="docker产品"><a href="#docker产品" class="headerlink" title="docker产品"></a>docker产品</h2><ul>
<li><a href="https://docs.docker.com/engine/" target="_blank" rel="noopener">docker engine</a>：docker服务端引擎</li>
<li><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker compose</a>：简单的多容器部署工具，通过简单的命令和配置，管理服务于某个应用的多个容器</li>
<li><a href="https://docs.docker.com/desktop/" target="_blank" rel="noopener">docker desktop</a>：适用于Mac或Windows环境的易于安装的应用程序，可让您构建和共享容器化的应用程序和微服务；</li>
<li><a href="https://hub.docker.com/repositories" target="_blank" rel="noopener">docker hub</a>：公共镜像仓库</li>
</ul>
<h1 id="docker安装与配置"><a href="#docker安装与配置" class="headerlink" title="docker安装与配置"></a>docker安装与配置</h1><h2 id="软件安装-CentOS"><a href="#软件安装-CentOS" class="headerlink" title="软件安装-CentOS"></a>软件安装-CentOS</h2><ul>
<li><p><a href="https://docs.docker.com/engine/install/centos/#install-using-the-repository" target="_blank" rel="noopener">官方(较慢)</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo \</span><br><span class="line">   https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">sudo systemctl enable --now docker</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><a href="https://developer.aliyun.com/mirror/docker-ce" target="_blank" rel="noopener">阿里云镜像</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"># Step 3</span><br><span class="line">sudo sed -i &apos;s+download.docker.com+mirrors.aliyun.com/docker-ce+&apos; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"># Step 4: 更新并安装Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"># Step 4: 开启Docker服务</span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="engine配置"><a href="#engine配置" class="headerlink" title="engine配置"></a>engine配置</h2><blockquote>
<p>/etc/docker/daemon.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.m.daocloud.io&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;reg.abc.com&quot;],</span><br><span class="line">  &quot;data-root&quot;: &quot;/data/docker-data&quot;,</span><br><span class="line">  &quot;bridge&quot;: &quot;bridge0&quot;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;devicemapper&quot;,</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;storage-opts&quot; : [</span><br><span class="line">    &quot;dm.basesize=5G&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>registry-mirrors：公有registry或加速器地址</li>
<li>insecure-registries：私有registry地址</li>
<li>data-root：容器、镜像等资源的存储位置</li>
<li>bridge：设置docker容器的默认网络地址<ul>
<li>绑定网络地址(docker engine启动参数)：–bip 172.18.0.1</li>
<li>绑定网桥(docker engine启动参数)：-b, –bridge bridage_name</li>
</ul>
</li>
<li>storage-driver：容器存储驱动</li>
<li>storage-opts：存储驱动的选项<ul>
<li>dm.basesize=5G：限制容器磁盘的最大容量</li>
</ul>
</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><ul>
<li>现象：通过路由实现跨主机docker容器互联，如果ping对端容器出现：Dest Unreachable, Unknown Code: 10或Destination Host Prohibited</li>
<li>解决：则是由于对端宿主机开启防火墙或iptables原因导致</li>
</ul>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><ul>
<li>现象：docker容器网络不通</li>
<li>解决<ul>
<li>确定net.ipv4.conf.all.forwarding=1</li>
<li>重启docker服务【单独重启即可】</li>
</ul>
</li>
</ul>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><ul>
<li><p>现象：禁止普通用户使用docker命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：</p>
<ul>
<li>将当前用户加入docker组中：gpasswd -a python docker</li>
<li>重启docker进程：systemctl restart docker</li>
<li>重新登录服务器终端</li>
</ul>
</li>
</ul>
<h1 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h1><h2 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h2><ul>
<li>使用软件：portainer</li>
<li>启动：<code>docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer</code></li>
<li>web访问：<a href="http://ip:9000" target="_blank" rel="noopener">http://ip:9000</a></li>
</ul>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><ul>
<li>使用软件：<a href="https://github.com/google/cadvisor" target="_blank" rel="noopener">cadvisor</a></li>
<li>服务启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --volume=/:/rootfs:ro \</span><br><span class="line">  --volume=/var/run:/var/run:ro \</span><br><span class="line">  --volume=/sys:/sys:ro \</span><br><span class="line">  --volume=/var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">  --volume=/dev/disk/:/dev/disk:ro \</span><br><span class="line">  --publish=8080:8080 \</span><br><span class="line">  --detach=true \</span><br><span class="line">  --name=cadvisor \</span><br><span class="line">  --device=/dev/kmsg \</span><br><span class="line">  google/cadvisor:latest</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h2><ul>
<li>使用软件：<a href="https://prometheus.io/" target="_blank" rel="noopener">prometheus</a> 、<a href="https://github.com/prometheus" target="_blank" rel="noopener">github地址</a></li>
<li>服务启动：<code>docker run --name prometheus -d -p 9090:9090 prom/prometheus</code></li>
<li><p>添加cadvisor数据【重启prometheus】：/etc/prometheus/prometheus.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &apos;cadvisor&apos;</span><br><span class="line">    static_configs:     </span><br><span class="line">    - targets: [&apos;172.17.8.51:8080&apos;,&apos;172.17.8.52:8080&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>web界面：<a href="http://ip:9090" target="_blank" rel="noopener">http://ip:9090</a></p>
</li>
</ul>
<h2 id="监控可视化"><a href="#监控可视化" class="headerlink" title="监控可视化"></a>监控可视化</h2><ul>
<li>使用软件：<a href="https://grafana.com/grafana/" target="_blank" rel="noopener">grafana</a></li>
<li>服务启动：<code>docker run -d -p 3000:3000 --name grafana grafana/grafana</code></li>
<li>web登陆：<ul>
<li>web界面：<a href="http://ip:3000" target="_blank" rel="noopener">http://ip:3000</a></li>
<li>用户名密码：admin/admin</li>
</ul>
</li>
<li>添加数据源-prometheus</li>
<li>添加docker监控模板【ID：193】</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose学习</title>
    <url>/blog/2019/12/10/%E5%AE%B9%E5%99%A8%E5%8C%96/docker/docker-compose%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>docker compose是一个用于定义和管理多容器的docker工具，<br>可以通过使用yaml格式的compose文件定义多个服务应用（这些应用也就是容器），<br>并通过compose命令管理这些服务的创建、运行、停止、销毁等工作。</p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul>
<li>services：定义了一个应用包含的多个服务(服务的载体即是容器)；容器的镜像可以来自镜像仓库，也可以由本地的Dockerfile构建出来</li>
<li>networks：应用包含的服务(即容器)使用的网络</li>
<li>volumes：应用包含的服务(即容器)使用的存储</li>
</ul>
<h1 id="compose文件"><a href="#compose文件" class="headerlink" title="compose文件"></a>compose文件</h1><ul>
<li>默认使用docker-compose.yml作为文件名，命令行下可使用-f参数指定特定compose文件</li>
<li>默认连接在同一个自定义网络下的多个service（service即容器）可以通过service name实现容器间互连</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: mysql</span><br><span class="line">      WORDPRESS_DB_PASSWORD: root</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    links:</span><br><span class="line">      - mysql</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql-data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line">volumes:</span><br><span class="line">  mysql-data:</span><br><span class="line">networks:</span><br><span class="line">  my-bridge:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>
<h2 id="services定义"><a href="#services定义" class="headerlink" title="services定义"></a>services定义</h2><ul>
<li>build：构建启动服务所需要的镜像，等同于docker build命令<ul>
<li>可以直接包含Dockerfile目录位置：【build .】</li>
<li>也可以包含更复杂的数据结构：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  dockerfile: Dockerfile</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>image：定义要使用的image，或在build时给image命名</p>
</li>
<li><p>depends_on：定义各服务间的依赖关系，比如启动、关闭的先后顺序；依赖的服务会先于此服务启动，后于此服务关闭。</p>
</li>
<li><p>links：容器间可以通过service名称互相访问（类似ip、主机名）；和docker命令中的links功能类似，给容器名称添加一个别名。</p>
</li>
<li><p>environment：定义环境变量，可以是列表(- SHOW=true)或字典(SHOW: ‘true’)</p>
</li>
<li><p>env_file：从文件添加环境变量</p>
</li>
<li><p>ports：将主机端口绑定到容器暴露的端口</p>
<ul>
<li>同时定义主机和容器端口：host_port:container_port</li>
<li>只定义容器端口：此时将容器端口发布到主机随机端口上</li>
</ul>
</li>
<li><p>expose：暴露端口，但不映射到宿主机，用于服务间的内部访问。</p>
</li>
<li><p>networks：定义要使用的网络</p>
</li>
<li><p>volumes：将主机的的路径或命名的数据卷和容器的路径建立映射关系</p>
</li>
<li><p>command：覆盖或设置容器启动命令，以下为运行多条命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 多条命令顺序执行</span><br><span class="line">command: /bin/bash -c &quot;cp /app/dtest/config.default.yml /app/config.yml &amp;&amp; python -u /app/dtest/tcc.py&quot;</span><br><span class="line"></span><br><span class="line"># 多条命令顺序执行</span><br><span class="line">command:</span><br><span class="line">    - sh</span><br><span class="line">    - -c </span><br><span class="line">    - |</span><br><span class="line">        cmd1</span><br><span class="line">        cmd2</span><br><span class="line">        cmd3</span><br><span class="line"></span><br><span class="line"># 多条命令并行执行</span><br><span class="line">command:</span><br><span class="line">    - sh</span><br><span class="line">    - -c </span><br><span class="line">    - |</span><br><span class="line">        cmd1 &amp;</span><br><span class="line">        cmd2 &amp;</span><br><span class="line">        cmd3</span><br></pre></td></tr></table></figure>
</li>
<li><p>entrypoint：覆盖容器默认的entrypoint</p>
</li>
</ul>
<h2 id="volumes定义"><a href="#volumes定义" class="headerlink" title="volumes定义"></a>volumes定义</h2><p>见如上示例</p>
<h2 id="networks定义"><a href="#networks定义" class="headerlink" title="networks定义"></a>networks定义</h2><p>可选参数【driver】定义网络类型，在单机情况下默认是bridge，在Swarm中是overlay</p>
<ul>
<li>bridge</li>
<li>swarm</li>
<li>host</li>
<li>none</li>
</ul>
<h1 id="compose命令"><a href="#compose命令" class="headerlink" title="compose命令"></a>compose命令</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 官方</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># daocloud</span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>权限：chmod +x /usr/local/bin/docker-compose</p>
</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><blockquote>
<p>docker-compose命令默认使用当前目录下的docker-compose.yml文件，可以使用-f参数指定要使用的文件</p>
</blockquote>
<ul>
<li>up [-d]：构建并启动一个服务下的多个容器，-d参数以后台方式执行<ul>
<li>–scale service=num：增加或减少容器数量</li>
</ul>
</li>
<li>down：停止并销毁一个服务下的多个容器及使用的网络，但是不会销毁数据卷</li>
<li>start：启动服务(多个容器)</li>
<li>stop：停止服务(多个容器)</li>
<li>ps：显示正在运行的服务</li>
<li>exec [service]：进入service中执行命令</li>
</ul>
<h1 id="弹性伸缩容器数量"><a href="#弹性伸缩容器数量" class="headerlink" title="弹性伸缩容器数量"></a>弹性伸缩容器数量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  web:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    environment:</span><br><span class="line">      REDIS_HOST: redis</span><br><span class="line">  lb:</span><br><span class="line">    image: dockercloud/haproxy</span><br><span class="line">    links:</span><br><span class="line">      - web</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br></pre></td></tr></table></figure>
<ol>
<li>启动服务：docker-compose up</li>
<li>扩容web服务： docker-compose up –scale web=3 -d</li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器和镜像</title>
    <url>/blog/2019/11/11/%E5%AE%B9%E5%99%A8%E5%8C%96/docker/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="容器运行-run"><a href="#容器运行-run" class="headerlink" title="容器运行(run)"></a>容器运行(run)</h1><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>docker run -idt -v /home/Logs/:/root/Logs:ro -m 100m –memory-swap=100m –cpus 0.5 -p 10086:22 sshd</p>
<h2 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h2><ul>
<li><p>-t：分配一个伪终端tty</p>
</li>
<li><p>-i：保持容器的标准输入一直打开，常与-t结合使用</p>
</li>
<li><p>-d：让容器以后台方式运行</p>
</li>
<li><p>-e key=value：在容器内设置环境变量、设置多个变量时使用多个-e</p>
</li>
<li><p>–name：给运行的容器绑定一个名称</p>
</li>
<li><p>-h：配置容器主机名</p>
</li>
<li><p>–rm：容器存在就删除【运行一次性容器，运行结束后立即删除】</p>
</li>
<li><p>-v ：映射宿主机目录或数据卷到容器</p>
</li>
<li><p>-m, –memory 100m：设置容器内存为100m</p>
</li>
<li><p>–memory-swap=100m：设置容器内存和swap总和是100m</p>
</li>
<li><p>–oom-kill-disable：关闭系统oom，避免系统内存不足时杀死容器</p>
</li>
<li><p>–cpus 0.5：设置容器可以使用的cpu数量（最大值为cpu的最大核心数，最小值为0.1，可以是小数）</p>
<ul>
<li>–cpu-shares int：设置多个容器使用cpu的相对权重</li>
</ul>
</li>
<li><p>-p 10086:22（可多次使用）：映射宿主机端口10086到容器端口22</p>
<ul>
<li>publish：将容器端口映射到宿主机【命令行参数-p或-P】</li>
<li>expose：曝露端口用于容器间的访问【Dockerfile文件中的关键字EXPOSE】</li>
</ul>
</li>
<li><p>-P：将主机的49000~49900的端口随机映射到内部容器的开放端口</p>
</li>
<li><p>–link name:alias：链接容器【容器名称：别名】，这种链接关系可以在容器hosts文件看到</p>
</li>
<li><p>–network：容器链接到特定网桥</p>
</li>
<li><p>–restart：docker daemon重启后container的重启策略，默认no</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* no       不重启，默认策略</span><br><span class="line">* on-failure[:max-retries]  异常退出时重启容器，包括开机启动</span><br><span class="line">* unless-stopped 一直重启容器，正常停止的容器除外</span><br><span class="line">* always   一直重启容器，包括开机启动</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li><p>操作系统镜像，没有默认启动命令，需要设置-it及-d，保持容器运行</p>
</li>
<li><p>应用程序镜像，只需设置-d，就可保持容器运行</p>
</li>
<li><p>设置时区和时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-e TZ=Asia/Shanghai -v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><ul>
<li><p>start、stop、restart：启动、停止、重启一个容器</p>
</li>
<li><p>create、rm：创建、删除容器</p>
</li>
<li><p>container prune：移除所有停止的容器</p>
</li>
<li><p>logs [-f]：日志查看，-f相当于tailf效果</p>
</li>
<li><p>cp：在宿主机和容器直接复制文件或目录</p>
</li>
<li><p>exec：在容器中执行命令</p>
<ul>
<li>进入bash环境：docker exec -it 5c8f798e206e /bin/bash</li>
<li>查看ip地址：docker exec -it flask ip a</li>
</ul>
</li>
<li><p>ps：查看运行中的容器</p>
<ul>
<li>参数<ul>
<li>-a：查看所有存在的容器</li>
<li>-q：只显示容器id</li>
<li>-f：根据条件过滤容器</li>
<li>-l：最新创建的容器</li>
</ul>
</li>
<li>批量操作范例：docker rm $(docker ps -qf “status=exited”)</li>
</ul>
</li>
<li><p>inspect：查看docker对象信息</p>
</li>
<li><p>container update：修改容器run参数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container update --restart=on-failure jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>stats：查看容器资源使用情况，–no-stream【一次性输出，非数据流】</p>
</li>
<li><p>top：查看容器进程列表</p>
</li>
<li><p>commit：将当前运行的容器制作为镜像【被称为黑箱镜像，由于不确定镜像的具体操作，不利于镜像的传播使用】</p>
</li>
</ul>
<h1 id="存储管理-volume"><a href="#存储管理-volume" class="headerlink" title="存储管理(volume)"></a>存储管理(volume)</h1><h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><ul>
<li>docker存储引擎device mapper、aufs等实现的copy on write机制，在高频写操作下性能不高；使用volume，可以直接写磁盘</li>
<li>可以实现数据持久化<ul>
<li>启动时需要初始化数据，例如配置文件</li>
<li>运行过程中产生的业务数据、日志</li>
</ul>
</li>
<li>可以实现宿主机与容器、容器之间的数据共享</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li>直接映射宿主机目录到容器（bind Mounts）<ul>
<li>作用：可以实现宿主机和容器相关目录内容的同步更新，方便开发环境的实时调试</li>
<li>范例：docker run -idt –name test1 -v ~/nginx:/webapps ubuntu /bin/bash</li>
</ul>
</li>
<li>数据卷方式（data volume）<ul>
<li>作用：此时建立的数据卷不随容器的销毁而消失</li>
<li>建立数据卷：docker volume create hello</li>
<li>查看数据卷列表：docker volume ls</li>
<li>使用数据卷(docker会自动创建不存在的数据卷)：docker run -d -v hello:/world busybox ls /world</li>
<li>删除数据卷：docker volume rm hello</li>
</ul>
</li>
</ul>
<h1 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h1><ul>
<li>build：构建镜像</li>
<li>history：查看镜像制作历史(分层文件系统)</li>
<li>inspect：查看docker对象信息</li>
<li>rmi：删除本地镜像</li>
<li>search：查询docker公共仓库中的镜像</li>
<li>pull：从registry获取镜像</li>
<li>push：推送镜像到镜像仓库<ul>
<li>登录仓库：docker login <a href="mailto:--username=perfect_0426@qq.com" target="_blank" rel="noopener">--username=perfect_0426@qq.com</a> registry.cn-hangzhou.aliyuncs.com</li>
<li>本地打包：docker build -t registry.cn-hangzhou.aliyuncs.com/simple00426/flask_test:latest .</li>
<li>推送镜像到仓库：docker push registry.cn-hangzhou.aliyuncs.com/simple00426/flask_test:latest</li>
</ul>
</li>
<li>tag：给镜像添加一个标签</li>
<li>image prune [-a]：移除没有标签的镜像、移除没有使用及没有标签的镜像(-a)</li>
<li>images：查看本地镜像列表<ul>
<li>根据label过滤：docker images -f <a href="mailto:&#39;label=maintainer=istyle.simple@gmail.com" target="_blank" rel="noopener">&#39;label=maintainer=istyle.simple@gmail.com</a>‘</li>
<li>根据镜像名称过滤：<code>docker images -f reference=&#39;p*/*:latest&#39;</code>【用户/镜像:标签】</li>
<li>根据是否有tag过滤(删除不完整的image)：docker images -qf “dangling=true”</li>
<li>根据某个镜像的前后时间：docker images -qf “before=portainer/portainer”<ul>
<li>before：早于此镜像</li>
<li>since：此镜像之后</li>
</ul>
</li>
</ul>
</li>
<li>导出tar包<ul>
<li>从容器导出tar包：docker export adb102099609 &gt; adb102099609.tar</li>
<li>从镜像导出tar包：docker save ubuntu:ruby &gt; ubuntu-ruby.tar </li>
</ul>
</li>
<li>导入tar包创建镜像<ul>
<li>load方式：docker load &lt; ubuntu-ruby.tar </li>
<li>import方式：cat adb102099609.tar |sudo docker import - ubuntu:temp</li>
</ul>
</li>
</ul>
<h1 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h1><h2 id="镜像分类"><a href="#镜像分类" class="headerlink" title="镜像分类"></a>镜像分类</h2><ul>
<li>基础镜像，如centos、ubuntu</li>
<li>环境镜像，基于基础镜像构建，如java、php</li>
<li>项目镜像，基于环境镜像构建，是最终的交付物 </li>
</ul>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile</a>指令</h2><ul>
<li>FROM image：使用的基础镜像<ul>
<li>FROM scratch【scratch是一个基础的空镜像】</li>
</ul>
</li>
<li>LABEL key=value：标签信息<ul>
<li>maintainer=”<a href="mailto:istyle.simple@gmail.com" target="_blank" rel="noopener">istyle.simple@gmail.com</a>“</li>
<li>version=”1.0”</li>
<li>description=”This is simple”</li>
</ul>
</li>
<li>ENV key value：设置环境变量，它会被后续RUN命令使用，并在容器运行时保持</li>
<li>WORKDIR /path：为后续的RUN、CMD指定工作目录(建议使用绝对目录)，没有则创建</li>
<li>RUN command param1 param2：在创建镜像的过程中执行的命令<ul>
<li>有shell、exec两种执行方式，以上为shell方式</li>
<li>Dockerfile中可以写多条RUN指令，但是为了避免一次RUN增加一层文件层，应当将多条命令合并到一行中执行</li>
</ul>
</li>
<li>CMD command param1 param2：指定容器启动时执行的命令<ul>
<li>有shell、exec两种执行方式，以上为shell方式</li>
<li>定义了多个命令时，只有最后一条被执行</li>
<li>如果docker run指定了其他命令，CMD命令被忽略</li>
</ul>
</li>
<li>ENTRYPOINT [‘excutable’, ‘param1’, ‘param2’]：容器启动后运行的服务<ul>
<li>有shell、exec两种执行方式，示例为exec方式</li>
<li>让容器以应用程序或者服务的形式运行，只可添加一条</li>
<li>此命令默认不被docker run提供的命令覆盖</li>
</ul>
</li>
<li>ENTRYPOINT和CMD<ul>
<li>ENTRYPOINT和CMD都可以单独使用</li>
<li>ENTRYPOINT和CMD联合使用时<ul>
<li>ENTRYPOINT提供可执行程序和默认参数</li>
<li>CMD提供可选参数</li>
</ul>
</li>
</ul>
</li>
<li>COPY src dest：复制宿主机的src到容器的dest，</li>
<li>ADD src dest：<ul>
<li>add和copy功能类似(复制指定的src到容器的dest)，优先使用copy</li>
<li>额外功能：解压src到dest【但必须是gzip, bzip2 or xz格式的tar包】</li>
<li>其中src可以是Dockerfile所在目录的相对路径，也可以是一个url </li>
</ul>
</li>
<li>EXPOSE port：声明容器运行的服务端口</li>
<li>VOLUME [“/data”]：容器运行时，自动创建一个绑定到特定目录的数据卷<ul>
<li>这是为了保证某些数据(比如mysql等数据库)不随容器销毁而丢失</li>
<li>可以通过run -v参数覆盖相关目录</li>
</ul>
</li>
<li>ONBULID [instruction]：当所创建的镜像作为其他镜像的基础镜像时，所执行的命令</li>
</ul>
<h2 id="build构建镜像"><a href="#build构建镜像" class="headerlink" title="build构建镜像"></a>build构建镜像</h2><ul>
<li>范例：<code>docker build -t=&quot;ubuntu:ruby&quot; .</code></li>
<li>参数：<ul>
<li>-t 镜像名:标签</li>
<li>-f 指定dockerfile文件名称，默认文件名称Dockerfile</li>
<li>. 注明dockerfile的文件位置</li>
</ul>
</li>
</ul>
<h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul>
<li><p>减少镜像层：一次RUN指令形成新的一层，因此，多条shell命令要尽可能的写在一行；</p>
<ul>
<li>使用&amp;&amp;连接多个命令</li>
<li>过长的行使用反斜线续行</li>
</ul>
</li>
<li><p>优化镜像大小：一次RUN形成新的一层，如果没有在同一层删除，无论文件最后是否删除，都会带到下一层，所以要在每一层清理对应的残留数据，减小镜像大小</p>
</li>
<li><p>减少网络传输事件：使用软件包、maven仓库等</p>
</li>
<li><p>多阶段构建：代码编译、部署写在一个Dockerfile</p>
</li>
<li><p>选择尽可能小的基础镜像：如alpine</p>
</li>
<li><p>设置时区和时间</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">    echo &quot;Asia/shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Dockerfile范例"><a href="#Dockerfile范例" class="headerlink" title="Dockerfile范例"></a><a href="https://github.com/simple0426/dockerfile-hub/blob/master/ubuntu_sshd/Dockerfile" target="_blank" rel="noopener">Dockerfile范例</a></h2><blockquote>
<p>包含多个Dockerfile范例的git仓库：<a href="https://github.com/simple0426/dockerfile-hub.git" target="_blank" rel="noopener">https://github.com/simple0426/dockerfile-hub.git</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">LABEL maintainer hejingqi@zj-inv.cn</span><br><span class="line">ENV LANG C.UTF-8</span><br><span class="line">RUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n\</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n&apos;\</span><br><span class="line">&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">rm -rf /etc/apt/sources.list.d/* &amp;&amp; \</span><br><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">apt-get install -y openssh-server vim iputils-ping net-tools lrzsz &amp;&amp; \</span><br><span class="line">mkdir -p /var/run/sshd &amp;&amp; \</span><br><span class="line">sed -i &apos;/^PermitRootLogin/s/without-password/yes/&apos; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">sed -i &apos;/^#PasswordAuthentication/s/#//&apos; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">echo &quot;root:zjht4321&quot;|chpasswd &amp;&amp; \</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">rm -rf /var/cache/apt/*</span><br><span class="line">EXPOSE 22</span><br><span class="line">CMD /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>
<h2 id="多阶段构建范例"><a href="#多阶段构建范例" class="headerlink" title="多阶段构建范例"></a><a href="https://github.com/simple0426/tomcat-java-demo" target="_blank" rel="noopener">多阶段构建范例</a></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stage build</span></span><br><span class="line"><span class="comment"># 使用as为多阶段构建中的某一阶段命名</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">maven:3.6.3-jdk-8</span> <span class="string">as</span> <span class="string">build</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">'/&lt;mirrors&gt;/a\ \</span></span><br><span class="line"><span class="string">&lt;mirror&gt; \n\</span></span><br><span class="line"><span class="string">     &lt;id&gt;nexus-aliyun&lt;/id&gt; \n\</span></span><br><span class="line"><span class="string">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; \n\</span></span><br><span class="line"><span class="string">     &lt;name&gt;Nexus aliyun&lt;/name&gt; \n\</span></span><br><span class="line"><span class="string">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n\</span></span><br><span class="line"><span class="string">&lt;/mirror&gt;'</span> <span class="string">/usr/share/maven/conf/settings.xml</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">.</span> <span class="string">/tomcat-java-demo</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/tomcat-java-demo</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">package</span> <span class="string">-Dmaven.test.skip=true</span></span><br><span class="line"><span class="comment"># stage prod</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">tomcat:8.5.47</span> <span class="string">as</span> <span class="string">prod</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="comment"># 从构建的某一阶段复制文件</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=build</span> <span class="string">/tomcat-java-demo/target/*.war</span> <span class="string">/usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/usr/local/tomcat/bin</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">["catalina.sh",</span> <span class="string">"run"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<h1 id="应用运行"><a href="#应用运行" class="headerlink" title="应用运行"></a>应用运行</h1><h2 id="镜像内固定运行参数"><a href="#镜像内固定运行参数" class="headerlink" title="镜像内固定运行参数"></a>镜像内固定运行参数</h2><ul>
<li><p>Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:2.7</span><br><span class="line">LABEL maintainer=&quot;istyle.simple@gmail.com&quot;</span><br><span class="line">RUN pip install flask</span><br><span class="line">COPY app.py /app/</span><br><span class="line">WORKDIR /app</span><br><span class="line">EXPOSE 5000</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>app.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello docker&quot;</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=5000)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="容器运行时指定参数"><a href="#容器运行时指定参数" class="headerlink" title="容器运行时指定参数"></a>容器运行时指定参数</h2><ul>
<li><p>Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:xenial</span><br><span class="line">COPY sources.list /etc/apt/sources.list </span><br><span class="line">RUN apt update &amp;&amp; apt install -y stress</span><br><span class="line">ENTRYPOINT [&quot;/usr/bin/stress&quot;] #基础运行命令</span><br><span class="line">CMD [] #指定可添加参数</span><br></pre></td></tr></table></figure>
</li>
<li><p>sources.list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器运行</p>
<ul>
<li>前台：<code>docker run -it ubuntu_stress:latest -m 1 --verbose -t 10s</code></li>
<li>后台：<code>docker run -itd --name stress ubuntu_stress:latest -m 1 --verbose</code></li>
</ul>
</li>
</ul>
<h1 id="公有仓库镜像自动化构建"><a href="#公有仓库镜像自动化构建" class="headerlink" title="公有仓库镜像自动化构建"></a>公有仓库镜像自动化构建</h1><h2 id="可选仓库"><a href="#可选仓库" class="headerlink" title="可选仓库"></a>可选仓库</h2><ul>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">阿里云容器镜像服务</a></li>
<li><a href="https://hub.docker.com/repositories" target="_blank" rel="noopener">docker hub</a></li>
</ul>
<h2 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h2><ul>
<li>将Dockerfile等文件放入代码库管理，比如：<a href="https://github.com/simple0426/tomcat-java-demo.git" target="_blank" rel="noopener">https://github.com/simple0426/tomcat-java-demo.git</a></li>
<li>在镜像仓库新建镜像，配置自动化构建关联到代码仓库(具体关联到Dockerfile所在目录)</li>
<li>只要Dockerfile所在仓库有代码变动，镜像仓库就会自动构建新的镜像</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像仓库-harbor</title>
    <url>/blog/2018/03/20/%E5%AE%B9%E5%99%A8%E5%8C%96/docker/docker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-harbor/</url>
    <content><![CDATA[<h1 id="harbor介绍"><a href="#harbor介绍" class="headerlink" title="harbor介绍"></a>harbor介绍</h1><ul>
<li>镜像的存储harbor使用的是官方的docker registry服务去完成；至于registry是用本地存储或者云存储都是可以的，harbor的功能是在此之上提供用户权限管理、镜像复制等功能</li>
<li>harbor镜像的复制是通过docker registry 的API去拷贝</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://goharbor.io/docs/2.0.0/install-config/" target="_blank" rel="noopener">安装</a></h1><ul>
<li>安装前置条件<ul>
<li>2核CPU/4GB内存/40GB磁盘</li>
<li>docker-engine 17.06.0-ce+ or higher</li>
<li>docker-compose 1.18.0 or higher</li>
</ul>
</li>
<li><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">下载离线安装包</a></li>
<li>参数配置(harbor.yml)<ul>
<li>hostname: 对外发布的主机名</li>
<li>harbor_admin_password：web管理界面的密码【默认：admin/Harbor12345】</li>
<li>database：本地数据库密码<ul>
<li>password: root123</li>
</ul>
</li>
<li>data_volume: 镜像等数据的在宿主机上的位置，默认/data</li>
<li>log.location：日志在宿主机上的位置，默认/var/log/harbor</li>
</ul>
</li>
<li>hostname配置要点<ul>
<li>当配置hostname为内网地址时，虽然登陆地址可以通过地址映射使用外网地址；但是认证时，服务端回传客户端的认证地址，依然是内网地址造成无法登陆认证。</li>
<li>当配置hostname为外网地址时，由于外网带宽限制，内网服务器不能高速的进行镜像传输</li>
<li>当配置hostname为域名时，采用dns分离解析，内网dns解析使用自定义dns并解析为内网地址，外网dns解析使用公网dns并解析为公网ip。</li>
</ul>
</li>
<li>harbor安装<ul>
<li>包装命令：sudo ./install.sh</li>
</ul>
</li>
<li>web访问：<a href="http://ip:80" target="_blank" rel="noopener">http://ip:80</a></li>
</ul>
<h2 id="https设置"><a href="#https设置" class="headerlink" title="https设置"></a><a href="https://goharbor.io/docs/2.0.0/install-config/configure-https/" target="_blank" rel="noopener">https设置</a></h2><blockquote>
<p>参考官方配置，暂时不要使用cfssl工具（无法兼容X509 v3 extension特性）</p>
</blockquote>
<ul>
<li>使用公有证书或自签名证书</li>
<li>harbor.yml中设置<ul>
<li>hostname：设置域名或ip地址</li>
<li>certificate、private_key：设置证书和秘钥的路径</li>
</ul>
</li>
<li>重新部署harbor<ul>
<li>关闭服务：docker-compose down</li>
<li>重新部署：./install.sh</li>
</ul>
</li>
<li>客户端设置<ul>
<li>如果使用公有证书，客户端无需设置</li>
<li>如果使用自签名证书，将ca根证书放入如下位置：/etc/docker/certs.d/myregistry:5000/ca.crt<ul>
<li>myregistry为harbor主机的ip地址或域名，如果使用非443端口则要添加端口信息</li>
<li>ca.crt为根证书且名称必须是这样</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重新设置"><a href="#重新设置" class="headerlink" title="重新设置"></a>重新设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">vim harbor.yml</span><br><span class="line">prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h1 id="harbor服务控制"><a href="#harbor服务控制" class="headerlink" title="harbor服务控制"></a>harbor服务控制</h1><h2 id="容器控制"><a href="#容器控制" class="headerlink" title="容器控制"></a>容器控制</h2><ul>
<li>docker-compose up -d 创建和启动容器【后台】</li>
<li>docker-compose down 停止和删除容器</li>
<li>docker-compose start 启动容器及服务</li>
<li>docker-compose stop 停止容器及服务</li>
</ul>
<h2 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h2><ul>
<li>harbor-core：配置管理中心</li>
<li>harbor-db：pg数据库</li>
<li>harbor-jobservice：负责镜像复制</li>
<li>harbor-log：记录操作日志</li>
<li>harbor-portal：web管理页面和API</li>
<li>nginx：前端代理，负责前端页面和镜像上传、下载转发</li>
<li>redis：会话</li>
<li>registryctl：镜像存储</li>
</ul>
<h1 id="harbor管理"><a href="#harbor管理" class="headerlink" title="harbor管理"></a>harbor管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li>项目中的角色：<ul>
<li>访客(guest)：对项目只读</li>
<li>开发者(developer)：对项目有读写权限</li>
<li>维护者(master)：高于开发者的权限，同时拥有权限：扫描镜像、查看复制任务、删除镜像</li>
<li>项目管理员（projectadmin）：用户新建项目时，默认具有的权限；项目管理员可以添加或删除项目成员</li>
</ul>
</li>
<li>系统级别角色<ul>
<li>系统管理员（sysadmin）：具有最高权限</li>
<li>匿名用户（anonymous）：未登录的用户；默认，只能对公开项目有读权限</li>
</ul>
</li>
</ul>
<h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><ul>
<li>【http模式】客户端添加不安全的私有镜像库地址(/etc/docker/daemon.json)：insecure-registries</li>
<li>添加客户端认证：docker login -u username -p password reg.mydomain.com</li>
<li>上传镜像<ul>
<li>docker tag SOURCE_IMAGE[:TAG] harbor.zj-hf.cn/mytest/IMAGE[:TAG]</li>
<li>docker push harbor.zj-hf.cn/mytest/IMAGE[:TAG]</li>
</ul>
</li>
<li>下载镜像：docker pull harbor.zj-hf.cn/mytest/registry:latest</li>
<li>删除镜像<ul>
<li>web界面删除镜像</li>
<li>设置垃圾清理（Garbage Collection）：删除文件系统上的数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络</title>
    <url>/blog/2019/12/02/%E5%AE%B9%E5%99%A8%E5%8C%96/docker/docker%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="docker网络实现"><a href="#docker网络实现" class="headerlink" title="docker网络实现"></a>docker网络实现</h1><ul>
<li>网络命名空间(netns(net namespace))：linux在网络栈中引入网络名称空间，将独立的网络协议栈隔离到不同的名称空间中，彼此无法通信；docker利用linux的这一特性，实现了容器的网络隔离</li>
<li>veth(virtual ethernet)：虚拟以太网卡，和物理网卡类似，用于不同命名空间的网络通信(例如，利用veth连接容器和宿主机)</li>
<li><p>网桥：网桥是一个二层网络设备，实现类似交换机那样的多对多通信（多个veth在同一个网桥中，实现多个容器间通信）</p>
</li>
<li><p>iptables/netfilter：docker使用netfilter实现容器网络转发，即不同命名空间的流量转发</p>
</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/docekr-bridge.jpg" alt></p>
<ul>
<li>每个容器通过veth(虚拟以太网链接对)和宿主机连通</li>
<li>多个veth包含在一个bridge(桥接网络)中，因此多个容器可以互通</li>
<li>桥接网卡(一般为docker0)和宿主机出口(例如eth0)通过iptables的nat转换，从而可以让容器连接互联网</li>
</ul>
<h2 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h2><ul>
<li>bridge：实现网桥功能</li>
<li>overlay：使用隧道方式连接不同宿主机上的容器</li>
<li>none：容器绑定此网络后，除了回环接口外，容器没有其他网络地址</li>
<li>host：容器绑定此网络后，容器直接使用宿主机的所有网络地址</li>
</ul>
<h2 id="跨主机容器互联"><a href="#跨主机容器互联" class="headerlink" title="跨主机容器互联"></a>跨主机容器互联</h2><ul>
<li><p>路由方式(underlay)：直接在宿主机配置到目标容器的路由</p>
<blockquote>
<p>阿里云ecs需要在vpc上添加静态路由</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 案例</span><br><span class="line">  - 主机192.168.99.101  docker容器网络172.18.0.1/16</span><br><span class="line">  - 主机192.168.99.102  docker容器网络172.17.0.1/16</span><br><span class="line">* 操作：</span><br><span class="line">  - 101主机：route add -net 172.17.0.0/16 gw 192.168.99.102</span><br><span class="line">  - 102主机：route add -net 172.18.0.0/16 gw 192.168.99.101</span><br></pre></td></tr></table></figure>
</li>
<li><p>隧道方式(overlay)：使用隧道方式连接不同宿主机上的容器，docker也支持overlay网络</p>
</li>
</ul>
<h1 id="linux网络命名空间"><a href="#linux网络命名空间" class="headerlink" title="linux网络命名空间"></a>linux网络命名空间</h1><h2 id="命名空间管理"><a href="#命名空间管理" class="headerlink" title="命名空间管理"></a>命名空间管理</h2><ul>
<li>查看命名空间：ip netns list</li>
<li>添加命名空间：ip netns add test</li>
<li>删除命名空间：ip netns delete test</li>
</ul>
<h2 id="网络接口配置"><a href="#网络接口配置" class="headerlink" title="网络接口配置"></a>网络接口配置</h2><ul>
<li>添加接口(一次添加网络互通的链接对(即两个接口))：ip link add veth-test1 type veth peer name veth-test2</li>
<li>将链接对的两端分配到命名空间中<ul>
<li>ip link set veth-test1 netns test1</li>
<li>ip link set veth-test2 netns test2</li>
</ul>
</li>
<li>添加ip地址：<ul>
<li>ip netns exec test1 ip addr add 192.168.100.1/24 dev veth-test1</li>
<li>ip netns exec test2 ip addr add 192.168.100.2/24 dev veth-test2</li>
</ul>
</li>
<li>启动接口<ul>
<li>ip netns exec test1 ip link set dev veth-test1 up</li>
<li>ip netns exec test2 ip link set dev veth-test2 up</li>
</ul>
</li>
</ul>
<h2 id="状态查询"><a href="#状态查询" class="headerlink" title="状态查询"></a>状态查询</h2><ul>
<li>查看端口状态：ip netns exec test2/test1 ip link </li>
<li>查看ip地址：ip netns exec test2 ip addr</li>
<li>网络测试(test1中ping test2)：ip netns exec test1 ping 192.168.100.2</li>
</ul>
<h1 id="docker网络管理-network命令"><a href="#docker网络管理-network命令" class="headerlink" title="docker网络管理-network命令"></a>docker网络管理-network命令</h1><ul>
<li>查看docker管理的网络列表(网卡)：docker network ls</li>
<li>查看网卡详情(容器、veth对等)：docker network inspect 4c44ab01e956</li>
</ul>
<h2 id="bridge类型"><a href="#bridge类型" class="headerlink" title="bridge类型"></a>bridge类型</h2><ul>
<li>创建桥接网卡：docker network create<ul>
<li>范例(指定网卡名称)：docker network create -d bridge my-bridge</li>
<li>范例(指定网络地址)：docker network create –subnet 192.168.200.0/24 –gateway 192.168.200.1 my-bridge</li>
</ul>
</li>
<li>创建容器并连接指定网络：docker run –network<ul>
<li>范例：docker run -idt –name test3 –network my-bridge busybox:latest /bin/sh -c “while true;do sleep 3600;done”</li>
</ul>
</li>
<li>已存在的容器连接指定网络：docker network connect my-bridge test1</li>
</ul>
<h2 id="overlay类型"><a href="#overlay类型" class="headerlink" title="overlay类型"></a>overlay类型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>使用etcd分布式存储，docker创建的overlay网络可以实现跨主机容器互联</li>
<li>以下操作都是在双机(192.168.2.151,192.168.2.152)上运行，且需要先安装并配置etcd</li>
</ul>
<h3 id="安装并配置etcd"><a href="#安装并配置etcd" class="headerlink" title="安装并配置etcd"></a>安装并配置etcd</h3><ul>
<li><p>版本：注意etcd和docker engine版本兼容问题【如：docker engine 19.03.5和 flannel v0.11版本不支持etcd v3.4.3版本，但支持3.3.x系列】</p>
</li>
<li><p>下载并解压：<a href="https://github.com/etcd-io/etcd/releases" target="_blank" rel="noopener">https://github.com/etcd-io/etcd/releases</a></p>
</li>
<li><p>配置并启动：etcd –config-file etcd.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 节点名称</span><br><span class="line">name: &quot;node1&quot;</span><br><span class="line"># 存储位置</span><br><span class="line">data-dir: &quot;/home/etcd&quot;</span><br><span class="line"># 集群通信端口[本机]</span><br><span class="line">listen-peer-urls: &quot;http://192.168.2.151:2380&quot;</span><br><span class="line"># 集群服务端口[本机]</span><br><span class="line">listen-client-urls: &quot;http://192.168.2.151:2379,http://127.0.0.1:2379&quot;</span><br><span class="line"># 初始化时,告知其他节点本地集群通信端口[本机]</span><br><span class="line">initial-advertise-peer-urls: &quot;http://192.168.2.151:2380&quot;</span><br><span class="line"># 初始化时，发布的服务端口[本机]</span><br><span class="line">advertise-client-urls: &quot;http://192.168.2.151:2379&quot;</span><br><span class="line"># 新建集群</span><br><span class="line">initial-cluster-state: &quot;new&quot;</span><br><span class="line"># 集群标识</span><br><span class="line">initial-cluster-token: &quot;etcd-cluster&quot;</span><br><span class="line"># 集群节点</span><br><span class="line">initial-cluster: &quot;node1=http://192.168.2.151:2380,node2=http://192.168.2.152:2380&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>管理命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 集群状态查看：ETCDCTL_API=3 etcdctl --endpoints=192.168.2.151:2379,192.168.2.152:2379 endpoint status/health</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="docker-engine配置调整"><a href="#docker-engine配置调整" class="headerlink" title="docker-engine配置调整"></a>docker-engine配置调整</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https://2x97hcl1.mirror.aliyuncs.com&quot;],</span><br><span class="line">    &quot;host&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;],</span><br><span class="line">    &quot;cluster-advertise&quot;: &quot;192.168.2.151:2375&quot;,</span><br><span class="line">    &quot;cluster-store&quot;: &quot;etcd://192.168.2.151:2379&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立并使用overlay网络"><a href="#建立并使用overlay网络" class="headerlink" title="建立并使用overlay网络"></a>建立并使用overlay网络</h3><ul>
<li>创建网络：docker network create -d overlay demo</li>
<li>查看网络：docker network ls</li>
<li>在两台宿主机使用此网络启动：docker run -d –name test2/test1 –network demo busybox sh -c “while true;do sleep 3600;done”</li>
<li>在两个容器内ping测试：docker exec -it test1/test2 /bin/sh</li>
<li>在etcd中查看网络信息：etcdctl ls /docker</li>
</ul>
<h1 id="网桥管理工具-brctl"><a href="#网桥管理工具-brctl" class="headerlink" title="网桥管理工具-brctl"></a>网桥管理工具-brctl</h1><ul>
<li>软件安装：bridge-utils【centos】</li>
<li>查看桥接网卡包含的容器链接对(veth)：brctl show </li>
<li>添加桥接网卡<ul>
<li>brctl addbr bridge0</li>
<li>ip addr add 172.19.0.1/24 dev bridge0</li>
<li>ip link set dev bridge0 up</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>overlay</tag>
        <tag>网络命名空间</tag>
        <tag>bridge</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s实施-kubeadm方式部署</title>
    <url>/blog/2020/03/11/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-kubeadm%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="kubeadm介绍"><a href="#kubeadm介绍" class="headerlink" title="kubeadm介绍"></a><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">kubeadm介绍</a></h1><p>kubeadm是kubernetes集群的全生命周期管理工具，可实现：集群部署、升级、降级、拆除<br>kubeadm仅关心集群的初始化并启动集群，只安装必需的组件(dns)，其他的组件（dashboard、ingress、flannel）则需要管理员自行部署  </p>
<ul>
<li>kubeadm init：集群初始化，核心功能是部署master节点的各个组件(kube-api-server/kube-controller-manager/kube-scheduler)</li>
<li>kubeadm join：将节点加入集群</li>
<li>kubeadm token：集群构建后管理加入集群的token</li>
<li>kubeadm reset：删除集群构建过程中产生的文件，恢复到未创建集群的状态</li>
</ul>
<h1 id="部署要求"><a href="#部署要求" class="headerlink" title="部署要求"></a><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">部署要求</a></h1><blockquote>
<p>部署实践：<a href="https://gitee.com/simple0426/kubeadm-k8s.git" target="_blank" rel="noopener">https://gitee.com/simple0426/kubeadm-k8s.git</a></p>
</blockquote>
<ul>
<li>主机数：3个及以上</li>
<li>os：Ubuntu 16.04+、CentOS 7</li>
<li>内存：2G以上</li>
<li>cpu：2核以上</li>
<li>网络：主机互联、且可以连接公网（下载镜像）</li>
<li>主机名、MAC地址唯一，在hosts中做手动解析</li>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports" target="_blank" rel="noopener">个别端口放开</a></li>
<li><p>关闭swap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i &apos;/swap/s/^/#/&apos; /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ntp</span><br><span class="line">ntpdate times.aliyun.com</span><br><span class="line">systemctl start ntpd</span><br><span class="line">systemctl enable ntpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙、selinux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl disable iptables</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &apos;s/=enforcing/=disabled/g&apos; /etc/selinux/config</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用ipvs模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipvs_mods_dir=&quot;/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs&quot;</span><br><span class="line">for i in $(ls $ipvs_mods_dir|grep -o &quot;^[^.]*&quot;);do</span><br><span class="line">/sbin/modinfo -F filename $i &amp;&gt; /dev/null</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">/sbin/modprobe $i</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>iptables设置：可以查看网桥流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul>
<li>master、node都操作</li>
<li><p>为保证兼容性，使用<a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/#docker" target="_blank" rel="noopener">k8s推荐docker版本</a></p>
</li>
<li><p>根据kubeadm要求配置启动参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot; : [&quot;https://2x97hcl1.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装kubelet-kubeadm-kubectl"><a href="#安装kubelet-kubeadm-kubectl" class="headerlink" title="安装kubelet/kubeadm/kubectl"></a><a href="https://developer.aliyun.com/mirror/kubernetes" target="_blank" rel="noopener">安装kubelet/kubeadm/kubectl</a></h2><ul>
<li><p>master node、worker node都操作</p>
</li>
<li><p>此处的kubelet、kubeadm、kubectl需要与下文中kubernetes版本保持一致；由于阿里镜像源滞后，所以需要测试镜像源是否包含指定版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.19.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定版本安装：<code>yum install kubelet-1.19.6 kubeadm-1.19.6 kubectl-1.19.6 -y</code></p>
</li>
<li><p>kubelet开机启动：<code>systemctl enable kubelet</code></p>
</li>
</ul>
<h2 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h2><blockquote>
<p>master操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.19.6 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--apiserver-advertise-address=192.168.31.201 \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--ignore-preflight-errors=NumCPU</span><br></pre></td></tr></table></figure>
<h2 id="根据init结果提示操作"><a href="#根据init结果提示操作" class="headerlink" title="根据init结果提示操作"></a>根据init结果提示操作</h2><ul>
<li><p>配置kubectl【master】</p>
</li>
<li><p>安装网络插件【master】</p>
<ul>
<li><p>下载资源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -LO https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>kube-flannel.yml文件修改</p>
<ul>
<li>pod网络设置(net-conf.json)</li>
<li>镜像地址修改：quay.mirrors.ustc.edu.cn</li>
<li>主机间通信接口设置(假设eth1为主机间通信接口：<code>--iface=eth1</code>)</li>
</ul>
</li>
<li><p>应用资源文件：kubectl apply -f kube-flannel.yml</p>
</li>
<li><p>bug修复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由kubeadm安装的1.17~1.18版本k8s集群使用flannel插件有bug，会造成访问service的地址长时间无响应，需要执行命令修复此问题：</span><br><span class="line">ethtool --offload flannel.1 rx off tx off</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>允许master部署负载【master】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用kubeadm join命令将node加入集群【node】</p>
</li>
</ul>
<h1 id="kubeadm管理"><a href="#kubeadm管理" class="headerlink" title="kubeadm管理"></a>kubeadm管理</h1><h2 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h2><ul>
<li>master节点执行：<ul>
<li><code>kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets</code></li>
<li><code>kubectl delete node &lt;node name&gt;</code></li>
</ul>
</li>
<li>被移除节点执行：kubeadm reset</li>
<li>被移除节点删除iptables：<code>iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</code></li>
<li>被移除节点删除ipvs：ipvsadm -C</li>
</ul>
<h2 id="join认证信息"><a href="#join认证信息" class="headerlink" title="join认证信息"></a>join认证信息</h2><ul>
<li>token：默认24小时过期<ul>
<li>查看：<code>kubeadm token list</code></li>
<li>产生新的：<code>kubeadm token create --print-join-command</code></li>
</ul>
</li>
<li>cert-hash查看<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &apos;s/^.* //&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h2><ul>
<li>查看证书过期时间(默认1年)：<code>kubeadm alpha certs check-expiration</code></li>
<li>证书续签(默认1年)：<code>kubeadm alpha certs renew all</code><ul>
<li>续签后使用证书的组件重启：kubelet/kube-proxy/apiserver/scheduler/control-manager</li>
</ul>
</li>
</ul>
<h1 id="附加组件部署"><a href="#附加组件部署" class="headerlink" title="附加组件部署"></a>附加组件部署</h1><h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><ul>
<li><p>下载资源文件：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -Lo kube-dashboard.yaml https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源文件修改</p>
<ul>
<li>将dashboard的访问端口暴露在宿主机上：containers–》ports–》hostPort: 8443/8000</li>
<li>dashboard部署在node02上：nodeSelector–》<code>kubernetes.io/hostname: &quot;node02&quot;</code></li>
</ul>
</li>
<li><p><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md" target="_blank" rel="noopener">建立管理员</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录token获取</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o go-template=&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>web访问：<a href="https://192.168.31.202:8443/" target="_blank" rel="noopener">https://192.168.31.202:8443/</a></p>
</li>
</ul>
<h2 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h2><ul>
<li><p>下载资源文件：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -Lo ingress-nginx.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>pod及service修改配置</p>
<ul>
<li>ingress部署在node02上：nodeSelector–》<code>kubernetes.io/hostname: &quot;node02&quot;</code></li>
<li>修改nginx-ingress-controller镜像地址：registry.cn-hangzhou.aliyuncs.com/simple00426/nginx-ingress-controller:0.44.0</li>
<li>将ingress的访问端口暴露在宿主机上：Service–》nodePort：30080/30443</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s实施-二进制方式部署</title>
    <url>/blog/2020/07/12/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="重度参考"><a href="#重度参考" class="headerlink" title="重度参考"></a>重度参考</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/VYtyTU9_Dw9M5oHtvRfseA" target="_blank" rel="noopener">部署一套完整的Kubernetes高可用集群（上）</a></li>
<li><a href="https://mp.weixin.qq.com/s/F9BC6GALHiWBK5dmUnqepA" target="_blank" rel="noopener">​部署一套完整的Kubernetes高可用集群（下）</a></li>
</ul>
<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><ul>
<li>主机数：4台以上</li>
<li>操作系统： CentOS7.x-86_x64 </li>
<li>软件版本：<ul>
<li>docker：19.03</li>
<li>kubernetes：1.18</li>
</ul>
</li>
<li>硬件要求：2核2G以上</li>
<li>网络：主机间互联、且可以连接公网（下载容器镜像）</li>
<li>主机名、MAC地址唯一，在hosts中做手动解析</li>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports" target="_blank" rel="noopener">个别端口放开</a></li>
<li><p>关闭swap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i &apos;/swap/s/^/#/&apos; /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间同步</p>
<blockquote>
<p>所有主机时间和互联网时间都需要同步，否则使用证书进行连接认证时会出错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y ntp</span><br><span class="line">ntpdate times.aliyun.com</span><br><span class="line">systemctl start ntpd</span><br><span class="line">systemctl enable ntpd</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>关闭防火墙、selinux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl disable iptables</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &apos;s/=enforcing/=disabled/g&apos; /etc/selinux/config</span><br></pre></td></tr></table></figure>
</li>
<li><p>iptables设置：可以查看网桥流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul>
<li><p>使用阿里云镜像源，采用yum方式安装</p>
</li>
<li><p>配置docker-engine</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot; : [&quot;https://2x97hcl1.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker启动并设置开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="架构规划"><a href="#架构规划" class="headerlink" title="架构规划"></a>架构规划</h2><table>
<thead>
<tr>
<th>角色</th>
<th>ip</th>
<th>服务组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>master1(node/LB-master)</td>
<td>192.168.31.211/192.168.31.216(vip)</td>
<td>apiserver、scheduler、controller-manager、kubelet、kube-proxy、etcd、nginx、keepalived</td>
</tr>
<tr>
<td>node1</td>
<td>192.168.31.212</td>
<td>kubelet、kube-proxy、etcd</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.31.213</td>
<td>kubelet、kube-proxy、etcd</td>
</tr>
<tr>
<td>master2(node/LB-backup)</td>
<td>192.168.31.214</td>
<td>apiserver、scheduler、controller-manager、kubelet、kube-proxy、nginx、keepalived</td>
</tr>
</tbody>
</table>
<ul>
<li>master节点部署master组件（apiserver、scheduler、controller-manager）和node（kubelet、kube-proxy）组件，所以工作负载也可以在master上运行</li>
<li>etcd部署在3个节点上（211/212/213）</li>
<li>k8s集群和etcd使用两套证书(即2个CA)</li>
<li>先实现单master架构，后扩容为多master架构</li>
<li>高可用架构采用nginx+keepalived实现，nginx和keepalived也部署在master节点</li>
</ul>
<h1 id="部署etcd集群"><a href="#部署etcd集群" class="headerlink" title="部署etcd集群"></a>部署etcd集群</h1><h2 id="生成etcd证书"><a href="#生成etcd证书" class="headerlink" title="生成etcd证书"></a>生成etcd证书</h2><h3 id="下载cfssl工具"><a href="#下载cfssl工具" class="headerlink" title="下载cfssl工具"></a>下载cfssl工具</h3><p>cfssl是一个开源的证书管理工具，使用json生成证书文件，以下使用master作为操作主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64</span><br><span class="line">mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line">mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<h3 id="制作ca根证书"><a href="#制作ca根证书" class="headerlink" title="制作ca根证书"></a>制作ca根证书</h3><ul>
<li><p>创建工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/tls/&#123;etcd,k8s&#125; -p</span><br><span class="line">cd ~/tls/etcd/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ca配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;www&quot;: &#123;</span><br><span class="line">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">         &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;etcd CA&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;Beijing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用cfssl工具生成ca证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls ca*.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用ca证书签发etcd证书"><a href="#使用ca证书签发etcd证书" class="headerlink" title="使用ca证书签发etcd证书"></a>使用ca证书签发etcd证书</h3><ul>
<li><p>创建etcd证书请求文件【hosts字段包含集群的所有节点，可以预留几个ip用于后期集群扩容】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; server-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">    &quot;192.168.31.211&quot;,</span><br><span class="line">    &quot;192.168.31.212&quot;,</span><br><span class="line">    &quot;192.168.31.213&quot;,</span><br><span class="line">    &quot;192.168.31.214&quot;,</span><br><span class="line">    &quot;192.168.31.215&quot;,</span><br><span class="line">    &quot;192.168.31.216&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>制作证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br><span class="line">ls server*.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="部署etcd集群-1"><a href="#部署etcd集群-1" class="headerlink" title="部署etcd集群"></a>部署etcd集群</h2><ul>
<li><p>下载二进制文件：<a href="https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz" target="_blank" rel="noopener">https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</a> </p>
</li>
<li><p>创建工作目录并解压二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /opt/etcd/&#123;bin,cfg,ssl&#125; -p</span><br><span class="line">tar zxvf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">mv etcd-v3.4.9-linux-amd64/&#123;etcd,etcdctl&#125; /opt/etcd/bin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建etcd配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF</span><br><span class="line">ETCD_NAME=&quot;etcd-1&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.31.211:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.31.211:2379&quot;</span><br><span class="line">#[Clustering]</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.31.211:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.31.211:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.31.211:2380,etcd-2=https://192.168.31.212:2380,etcd-3=https://192.168.31.213:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>ETCD_NAME：节点名称，集群中唯一</li>
<li>ETCD_DATA_DIR：集群数据目录</li>
<li>ETCD_LISTEN_PEER_URLS：集群通信时的本机地址</li>
<li>ETCD_LISTEN_CLIENT_URLS：本节点提供的客户端服务地址</li>
<li>ETCD_INITIAL_ADVERTISE_PEER_URLS：集群初始化时，通告其他节点本机的通信地址</li>
<li>ETCD_ADVERTISE_CLIENT_URLS：集群初始化时，通告其他节点本机服务地址</li>
<li>ETCD_INITIAL_CLUSTER：集群节点</li>
<li>ETCD_INITIAL_CLUSTER_TOKEN：集群初始化时的认证token</li>
<li>ETCD_INITIAL_CLUSTER_STATE：节点加入的集群的状态；NEW为新集群；EXISTING表示加入已有集群</li>
</ul>
</li>
<li><p>systemd管理etcd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/opt/etcd/cfg/etcd.conf</span><br><span class="line">ExecStart=/opt/etcd/bin/etcd \</span><br><span class="line">--cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--peer-cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--peer-key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--logger=zap</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制证书到配置文件中的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~/tls/etcd/ca*.pem ~/tls/etcd/server*.pem /opt/etcd/ssl/</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动并设置开机启动【第一台etcd启动时会挂起，只需查看日志和进程是否存在即可】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable etcd</span><br><span class="line">systemctl start etcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制文件到其他节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r /opt/etcd/ root@192.168.31.212:/opt</span><br><span class="line">scp -r /opt/etcd/ root@192.168.31.213:/opt</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.31.212:/usr/lib/systemd/system</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.31.213:/usr/lib/systemd/system</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改节点2和节点3的配置文件【etcd.conf】，启动服务并设置开机启动</p>
</li>
</ul>
<h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3</span><br><span class="line">/opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=&quot;https://192.168.31.211:2379,https://192.168.31.212:2379,https://192.168.31.213:2379&quot; endpoint health</span><br></pre></td></tr></table></figure>
<h1 id="master节点部署"><a href="#master节点部署" class="headerlink" title="master节点部署"></a>master节点部署</h1><h2 id="生成kube-apiserver证书"><a href="#生成kube-apiserver证书" class="headerlink" title="生成kube-apiserver证书"></a>生成kube-apiserver证书</h2><ul>
<li><p>创建ca证书配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">         &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成ca证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls ca*.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建kube-apiserver证书请求【hosts中的ip为所有master/LB/VIP ip,为了后期扩容可以预留几个ip】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd TLS/k8s</span><br><span class="line">cat &gt; server-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">      &quot;10.0.0.1&quot;,</span><br><span class="line">      &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;192.168.31.211&quot;,</span><br><span class="line">      &quot;192.168.31.212&quot;,</span><br><span class="line">      &quot;192.168.31.213&quot;,</span><br><span class="line">      &quot;192.168.31.214&quot;,</span><br><span class="line">      &quot;192.168.31.215&quot;,</span><br><span class="line">      &quot;192.168.31.216&quot;,</span><br><span class="line">      &quot;kubernetes&quot;,</span><br><span class="line">      &quot;kubernetes.default&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成kube-apiserver证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br><span class="line">ls server*.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="下载并解压二进制文件"><a href="#下载并解压二进制文件" class="headerlink" title="下载并解压二进制文件"></a>下载并解压二进制文件</h2><ul>
<li><p><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md" target="_blank" rel="noopener">下载</a>服务端二进制文件：kubernetes-server-linux-amd64.tar.gz</p>
</li>
<li><p>解压二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;</span><br><span class="line">tar xzf kubernetes-server-linux-amd64.tar.gz</span><br><span class="line">cd kubernetes/server/bin/</span><br><span class="line">cp kube-apiserver kube-controller-manager kube-scheduler /opt/kubernetes/bin/</span><br><span class="line">cp kubectl /usr/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="apiserver部署"><a href="#apiserver部署" class="headerlink" title="apiserver部署"></a>apiserver部署</h2><ul>
<li><p>创建apiserver配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; EOF</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--etcd-servers=https://192.168.31.211:2379,https://192.168.31.212:2379,https://192.168.31.213:2379 \\</span><br><span class="line">--bind-address=192.168.31.211 \\</span><br><span class="line">--secure-port=6443 \\</span><br><span class="line">--advertise-address=192.168.31.211 \\</span><br><span class="line">--allow-privileged=true \\</span><br><span class="line">--service-cluster-ip-range=10.0.0.0/24 \\</span><br><span class="line">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\</span><br><span class="line">--authorization-mode=RBAC,Node \\</span><br><span class="line">--enable-bootstrap-token-auth=true \\</span><br><span class="line">--token-auth-file=/opt/kubernetes/cfg/token.csv \\</span><br><span class="line">--service-node-port-range=30000-32767 \\</span><br><span class="line">--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\</span><br><span class="line">--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\</span><br><span class="line">--tls-cert-file=/opt/kubernetes/ssl/server.pem  \\</span><br><span class="line">--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\</span><br><span class="line">--client-ca-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">--etcd-cafile=/opt/etcd/ssl/ca.pem \\</span><br><span class="line">--etcd-certfile=/opt/etcd/ssl/server.pem \\</span><br><span class="line">--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\</span><br><span class="line">--audit-log-maxage=30 \\</span><br><span class="line">--audit-log-maxbackup=3 \\</span><br><span class="line">--audit-log-maxsize=100 \\</span><br><span class="line">--audit-log-path=/opt/kubernetes/logs/k8s-audit.log&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>–logtostderr=false：启用日志</li>
<li>–v=2：日志级别</li>
<li>–log-dir：日志目录</li>
<li>–etcd-servers：etcd集群地址</li>
<li>–bind-address：服务监听地址</li>
<li>–secure-port：https端口</li>
<li>–advertise-address：集群通告地址</li>
<li>–allow-privileged：允许开启特权容器</li>
<li>–service-cluster-ip-range：service虚拟ip地址段</li>
<li>–enable-admission-plugins：开启准入控制插件</li>
<li>–authorization-mode：授权模式，开启RBAC授权和Node自管理</li>
<li>–enable-bootstrap-token-auth：开启kubelet的bootstrap机制</li>
<li>–token-auth-file： bootstrap token文件 </li>
<li>–service-node-port-range：service的Nodeport端口设置范围</li>
<li>–kubelet-client-*： apiserver访问kubelet客户端的证书 </li>
<li>–tls-cert-*：apiserver的https证书</li>
<li>–client-ca-file：客户端证书的ca证书</li>
<li>–service-account-key-file：ca证书的key，用于验证ServiceAccount的tokens</li>
<li>–etcd-*：etcd集群证书配置</li>
<li>–audit-log：审计日志配置</li>
</ul>
</li>
<li><p>复制api-server证书到配置文件中的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~/tls/k8s/ca*.pem ~/tls/k8s/server*.pem /opt/kubernetes/ssl/</span><br></pre></td></tr></table></figure>
</li>
<li><p>bootstrap token文件制作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; EOF</span><br><span class="line">c47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,&quot;system:node-bootstrapper&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>文件格式：token，用户名，uid，用户组</p>
<p>token生成方式：<code>22972cc804fc8612da9f3c1fc597ac67</code></p>
</li>
<li><p>systemd管理kube-apiserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-apiserver \$KUBE_APISERVER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl enable kube-apiserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>授权kubelet-bootstrap用户允许请求证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="controller-manager部署"><a href="#controller-manager部署" class="headerlink" title="controller-manager部署"></a>controller-manager部署</h2><ul>
<li><p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; EOF</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--leader-elect=true \\</span><br><span class="line">--master=127.0.0.1:8080 \\</span><br><span class="line">--bind-address=127.0.0.1 \\</span><br><span class="line">--allocate-node-cidrs=true \\</span><br><span class="line">--cluster-cidr=10.244.0.0/16 \\</span><br><span class="line">--service-cluster-ip-range=10.0.0.0/24 \\</span><br><span class="line">--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem  \\</span><br><span class="line">--root-ca-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">--experimental-cluster-signing-duration=87600h0m0s&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>–leader-elect：启动多个controller时自动举行选举形成高可用</li>
<li>–master：通过本地非安全端口连接apiserver</li>
<li>–bind-address：绑定地址</li>
<li>–allocate-node-cidrs：允许每个node在pod地址段中划分一个子网</li>
<li>–cluster-cidr：pod地址段</li>
<li>–service-cluster-ip-range：service地址段</li>
<li>–cluster-signing-*：可以为集群范围组件签发证书的ca证书【如kubelet】</li>
<li>–root-ca-file：用于验证ServiceAccount token的ca证书</li>
<li>–service-account-private-key-file：用于验证ServiceAccount token的ca证书的key</li>
<li>–experimental-cluster-signing-duration：集群范围签发证书的有效期</li>
</ul>
</li>
<li><p>systemd管理controller-manager</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-controller-manager \$KUBE_CONTROLLER_MANAGER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl enable kube-controller-manager</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="scheduler部署"><a href="#scheduler部署" class="headerlink" title="scheduler部署"></a>scheduler部署</h2><ul>
<li><p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; EOF</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--logtostderr=false \</span><br><span class="line">--v=2 \</span><br><span class="line">--log-dir=/opt/kubernetes/logs \</span><br><span class="line">--leader-elect \</span><br><span class="line">--master=127.0.0.1:8080 \</span><br><span class="line">--bind-address=127.0.0.1&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>systemd管理scheduler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-scheduler \$KUBE_SCHEDULER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl enable kube-scheduler</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看组件状态"><a href="#查看组件状态" class="headerlink" title="查看组件状态"></a>查看组件状态</h2><p>kubectl get cs</p>
<h1 id="node节点部署"><a href="#node节点部署" class="headerlink" title="node节点部署"></a>node节点部署</h1><h2 id="创建目录并复制二进制文件"><a href="#创建目录并复制二进制文件" class="headerlink" title="创建目录并复制二进制文件"></a>创建目录并复制二进制文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125; </span><br><span class="line">cd kubernetes/server/bin</span><br><span class="line">cp kubelet kube-proxy /opt/kubernetes/bin   # 本地拷贝</span><br></pre></td></tr></table></figure>
<h2 id="部署kubelet"><a href="#部署kubelet" class="headerlink" title="部署kubelet"></a>部署kubelet</h2><ul>
<li><p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; EOF</span><br><span class="line">KUBELET_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--hostname-override=node1 \\</span><br><span class="line">--network-plugin=cni \\</span><br><span class="line">--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\</span><br><span class="line">--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\</span><br><span class="line">--config=/opt/kubernetes/cfg/kubelet-config.yml \\</span><br><span class="line">--cert-dir=/opt/kubernetes/ssl \\</span><br><span class="line">--pod-infra-container-image=registry.aliyuncs.com/google_containers/pause-amd64:3.0&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>–hostname-override：在集群中的名称，集群中唯一</li>
<li>–network-plugin：启用cni网络插件</li>
<li>–kubeconfig：bootstrap认证后由集群生产的连接apiserver配置文件</li>
<li>–bootstrap-kubeconfig：首次启动(bootstrap)连接apiserver的配置文件</li>
<li>–config：配置参数文件</li>
<li>–cert-dir：kubelet证书生成目录</li>
<li>–pod-infra-container-image：管理pod网络的容器镜像地址</li>
</ul>
</li>
<li><p>配置参数文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10250</span><br><span class="line">readOnlyPort: 10255</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.0.0.2</span><br><span class="line">clusterDomain: cluster.local </span><br><span class="line">failSwapOn: false</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 2m0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /opt/kubernetes/ssl/ca.pem </span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 5m0s</span><br><span class="line">    cacheUnauthorizedTTL: 30s</span><br><span class="line">evictionHard:</span><br><span class="line">  imagefs.available: 15%</span><br><span class="line">  memory.available: 100Mi</span><br><span class="line">  nodefs.available: 10%</span><br><span class="line">  nodefs.inodesFree: 5%</span><br><span class="line">maxOpenFiles: 1000000</span><br><span class="line">maxPods: 110</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li><p>cgroupDriver：docker的cgroups驱动，默认cgroupfs，需要和docker-engin的配置一致</p>
</li>
<li><p>clusterDNS：集群dns地址，后续安装的dns插件使用</p>
</li>
<li><p>其他预留资源选项【给系统和 k8s组件预留资源】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-system-reserved=cpu=200m,memory=250Mi --kube-reserved=cpu=200m,memory=250Mi \</span><br><span class="line">--eviction-hard=memory.available&lt;1Gi,nodefs.available&lt;1Gi,imagefs.available&lt;1Gi \</span><br><span class="line">--eviction-minimum-reclaim=memory.available=500Mi,nodefs.available=500Mi,imagefs.available=1Gi \</span><br><span class="line">--node-status-update-frequency=10s \</span><br><span class="line">--eviction-pressure-transition-period=180s</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>生成bootstrap.kubeconfig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KUBE_APISERVER=&quot;https://192.168.31.211:6443&quot;</span><br><span class="line">TOKEN=&quot;22972cc804fc8612da9f3c1fc597ac67&quot; #与/opt/kubernetes/cfg/token.csv中一样</span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config set-credentials &quot;kubelet-bootstrap&quot; \</span><br><span class="line">  --token=$&#123;TOKEN&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=&quot;kubelet-bootstrap&quot; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制证书到配置文件中的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp bootstrap.kubeconfig /opt/kubernetes/cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>systemd管理kubelet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">After=docker.service</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
</li>
<li><p>批准kubelet申请加入集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br><span class="line">kubectl certificate approve node-csr-MQkj9DZylo2JcofJKBAcM_Aye5jL2oWJfpBdptpW03o</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="部署kube-proxy"><a href="#部署kube-proxy" class="headerlink" title="部署kube-proxy"></a>部署kube-proxy</h2><ul>
<li><p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; EOF</span><br><span class="line">KUBE_PROXY_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--config=/opt/kubernetes/cfg/kube-proxy-config.yml&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置参数文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">bindAddress: 0.0.0.0</span><br><span class="line">metricsBindAddress: 0.0.0.0:10249</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig</span><br><span class="line">hostnameOverride: node1</span><br><span class="line">clusterCIDR: 10.0.0.0/24</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成kube-proxy.kubeconfig</p>
<ul>
<li><p>创建证书请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; kube-proxy-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">ls kube-proxy*.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于证书生成kubeconfig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config set-credentials kube-proxy \</span><br><span class="line">  --client-certificate=./kube-proxy.pem \</span><br><span class="line">  --client-key=./kube-proxy-key.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-proxy \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>将证书复制到配置文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp kube-proxy.kubeconfig /opt/kubernetes/cfg/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>systemd管理kube-proxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Proxy</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl enable kube-proxy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="部署cni网络"><a href="#部署cni网络" class="headerlink" title="部署cni网络"></a>部署cni网络</h2><ul>
<li><p><a href="https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz" target="_blank" rel="noopener">下载cni插件</a>，并将二进制执行文件移动到默认工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /opt/cni/bin -p</span><br><span class="line">tar zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署cni网络插件，比如<a href="https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml" target="_blank" rel="noopener">flannel</a>，资源文件修改如下</p>
<ul>
<li>pod网络修改(net-conf.json)</li>
<li>镜像地址修改</li>
<li>主机间通信节点设置：–iface=eth1</li>
</ul>
</li>
<li><p>网络插件部署好后node即为Ready状态</p>
</li>
</ul>
<h2 id="授权apiserver访问kubelet"><a href="#授权apiserver访问kubelet" class="headerlink" title="授权apiserver访问kubelet"></a>授权apiserver访问kubelet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; apiserver-to-kubelet-rbac.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - nodes/proxy</span><br><span class="line">      - nodes/stats</span><br><span class="line">      - nodes/log</span><br><span class="line">      - nodes/spec</span><br><span class="line">      - nodes/metrics</span><br><span class="line">      - pods/log</span><br><span class="line">    verbs:</span><br><span class="line">      - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-apiserver</span><br><span class="line">  namespace: &quot;&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">subjects:</span><br><span class="line">  - apiGroup: rbac.authorization.k8s.io</span><br><span class="line">    kind: User</span><br><span class="line">    name: kubernetes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">kubectl apply -f apiserver-to-kubelet-rbac.yaml</span><br></pre></td></tr></table></figure>
<h2 id="新增node节点"><a href="#新增node节点" class="headerlink" title="新增node节点"></a>新增node节点</h2><ul>
<li><p>将master上的worker配置文件复制到新增节点上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r /opt/&#123;kubernetes,cni&#125; root@192.168.31.212:/opt</span><br><span class="line">scp -r /opt/&#123;kubernetes,cni&#125; root@192.168.31.213:/opt</span><br><span class="line">scp /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.31.212:/usr/lib/systemd/system</span><br><span class="line">scp /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.31.213:/usr/lib/systemd/system</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除kubelet证书和kubelet.kubeconfig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f /opt/kubernetes/cfg/kubelet.kubeconfig </span><br><span class="line">rm -f /opt/kubernetes/ssl/kubelet*</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主机名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/opt/kubernetes/cfg/kubelet.conf </span><br><span class="line">/opt/kubernetes/cfg/kube-proxy-config.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl enable kube-proxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master节点批准新node申请的证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br><span class="line">kubectl certificate approve node-csr-JjEj_4TxUHtHYpwZcEIYhcdZd-ykNafmUlrGFxHxN2E</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看节点状态：<code>kubectl get node</code></p>
</li>
</ul>
<h1 id="插件部署"><a href="#插件部署" class="headerlink" title="插件部署"></a>插件部署</h1><h2 id="dashboard部署"><a href="#dashboard部署" class="headerlink" title="dashboard部署"></a>dashboard部署</h2><ul>
<li><p><a href="https://github.com/kubernetes/dashboard/blob/master/aio/deploy/recommended.yaml" target="_blank" rel="noopener">下载dashboard资源</a>并修改</p>
<ul>
<li>将dashboard的访问端口暴露在宿主机上：containers–》ports–》hostPort: 8443 </li>
<li>dashboard部署在node02上：nodeName: node2</li>
</ul>
</li>
<li><p>建立dashboard用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录token获取：<code>kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;{print $1}&#39;)</code></p>
</li>
<li><p>web访问： <a href="https://192.168.31.212:8443/" target="_blank" rel="noopener">https://192.168.31.212:8443/</a> </p>
</li>
</ul>
<h2 id="CoreDNS部署"><a href="#CoreDNS部署" class="headerlink" title="CoreDNS部署"></a>CoreDNS部署</h2><ul>
<li><p><a href="https://github.com/coredns/deployment/tree/master/kubernetes" target="_blank" rel="noopener">下载资源文件</a>:</p>
<ul>
<li>文件1：<a href="https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed" target="_blank" rel="noopener">https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed</a></li>
<li>文件2：<a href="https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh" target="_blank" rel="noopener">https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh</a></li>
</ul>
</li>
<li><p>执行：<code>bash deploy.sh -r 10.0.0.0/24 -i 10.0.0.2 |kubectl apply -f -</code></p>
<ul>
<li>-r：指定service地址段</li>
<li>-i：指定dns pod的ip</li>
</ul>
</li>
<li>测试：<code>kubectl run -it --rm dns-test --image=busybox:1.28.4 sh</code><ul>
<li>nslookup kubernetes</li>
</ul>
</li>
</ul>
<h1 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h1><ul>
<li>数据存储etcd：采用3节点组建etcd集群</li>
<li>控制节点<ul>
<li>controller-manager、scheduler组件通过自身的选举机制实现高可用【同一时间只有一个组件在工作】</li>
<li>apiserver：通过使用nginx+keepalived实现2个以上的apiserver组件的高可用和负载均衡</li>
</ul>
</li>
<li>公有云一般不支持keepalived，可以使用它们的负载均衡产品（内网免费）</li>
</ul>
<h2 id="部署新增master节点的组件"><a href="#部署新增master节点的组件" class="headerlink" title="部署新增master节点的组件"></a>部署新增master节点的组件</h2><ul>
<li><p>将master1上的文件复制到master2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r /opt/&#123;etcd,cni,kubernetes&#125; root@192.168.31.214:/opt</span><br><span class="line">scp /usr/lib/systemd/system/kube* root@192.168.31.214:/usr/lib/systemd/system</span><br><span class="line">scp /usr/bin/kubectl root@192.168.31.214:/usr/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除kubelet证书文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f /opt/kubernetes/cfg/kubelet.kubeconfig</span><br><span class="line">rm -f /opt/kubernetes/ssl/kubelet*</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件中的主机名和ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">/opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">/opt/kubernetes/cfg/kube-proxy-config.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl enable kube-controller-manager</span><br><span class="line">systemctl enable kube-scheduler</span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl enable kube-proxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看组件状态：<code>kubectl get cs</code></p>
</li>
<li><p>批准新增节点kubelet证书请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br><span class="line">kubectl certificate approve node-csr-vHlBaG92ISuIJqPlyisvVsVE12hA8DTCvuuBTFhSkH0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="部署nginx-keepalived"><a href="#部署nginx-keepalived" class="headerlink" title="部署nginx+keepalived"></a>部署nginx+keepalived</h2><ul>
<li><p>安装软件（主/备）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install nginx keepalived -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx配置文件(主/备)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/nginx/nginx.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 四层负载均衡，为两台Master apiserver组件提供负载均衡</span><br><span class="line">stream &#123;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/k8s-access.log  main;</span><br><span class="line"></span><br><span class="line">    upstream k8s-apiserver &#123;</span><br><span class="line">       server 192.168.31.211:6443;   # Master1 APISERVER IP:PORT</span><br><span class="line">       server 192.168.31.214:6443;   # Master2 APISERVER IP:PORT</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">       listen 16443;</span><br><span class="line">       proxy_pass k8s-apiserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>keepalived配置文件(主/备)</p>
<blockquote>
<p>主备router_id、state、priority不同</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/keepalived/keepalived.conf &lt;&lt; EOF</span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id NGINX_MASTER</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_nginx.sh&quot;</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth1   #虚拟ip绑定及心跳检测通信接口</span><br><span class="line">    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的</span><br><span class="line">    priority 100    # 优先级，备服务器设置 90</span><br><span class="line">    advert_int 1    # 指定VRRP 心跳包通告间隔时间，默认1秒</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    # 虚拟IP（VIP）</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.31.216/24</span><br><span class="line">    &#125;</span><br><span class="line">    # 根据脚本执行结果判断是否执行故障转移【0为正常，非0为不正常】</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查nginx状态脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/keepalived/check_nginx.sh  &lt;&lt; &quot;EOF&quot;</span><br><span class="line">#!/bin/bash</span><br><span class="line">count=$(ps -ef |grep nginx |egrep -cv &quot;grep|$$&quot;)</span><br><span class="line"></span><br><span class="line">if [ &quot;$count&quot; -eq 0 ];then</span><br><span class="line">    exit 1</span><br><span class="line">else</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line">EOF</span><br><span class="line">chmod +x /etc/keepalived/check_nginx.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl start keepalived</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl enable keepalived</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测keepalived工作状态（接口是否绑定vip）：<code>ip a</code></p>
</li>
<li><p>nginx+keepalived高可用测试：<code>pkill nginx</code>执行后查看vip是否绑定到了备机上</p>
</li>
<li><p>使用vip进行负载均衡功能测试：<code>curl -k https://192.168.31.211:16443/version</code> </p>
</li>
</ul>
<h2 id="修改node组件连接地址"><a href="#修改node组件连接地址" class="headerlink" title="修改node组件连接地址"></a>修改node组件连接地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/192.168.31.211:6443/192.168.31.216:16443/g&apos; /opt/kubernetes/cfg/&#123;kubelet.kubeconfig,kube-proxy.kubeconfig&#125;</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl restart kube-proxy</span><br></pre></td></tr></table></figure>
<h1 id="制作kubectl使用的kubeconfig文件"><a href="#制作kubectl使用的kubeconfig文件" class="headerlink" title="制作kubectl使用的kubeconfig文件"></a>制作kubectl使用的kubeconfig文件</h1><blockquote>
<p>基于kube-dashboard的admin-user</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --embed-certs=true --server=&quot;https://192.168.31.216:16443&quot; --certificate-authority=/opt/kubernetes/ssl/ca.pem --kubeconfig=./kubeconfig</span><br><span class="line">ADMIN_TOKEN=$(kubectl get secret $(kubectl get secret -n kubernetes-dashboard|awk &apos;/admin-user/&#123;print $1&#125;&apos;) -n kubernetes-dashboard -o jsonpath=&#123;.data.token&#125;|base64 -d)</span><br><span class="line">kubectl config set-credentials kubernetes-dashboard:admin-user --token=$&#123;ADMIN_TOKEN&#125; --kubeconfig=./kubeconfig</span><br><span class="line">kubectl config set-context admin-user@kubernetes --cluster=kubernetes --user=kubernetes-dashboard:admin-user --kubeconfig=./kubeconfig</span><br><span class="line">kubectl config use-context admin-user@kubernetes --kubeconfig=./kubeconfig</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>k8s实施-容器技术落地方案</title>
    <url>/blog/2020/08/06/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="容器平台分层架构"><a href="#容器平台分层架构" class="headerlink" title="容器平台分层架构"></a>容器平台分层架构</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/containers-scheme.jpg" alt></p>
<ul>
<li>基础设施层-IaaS(openstack/公有云)：服务器、网络、存储、数据库</li>
<li>容器引擎层：docker、harbor(镜像仓库)</li>
<li>容器编排层：kubernetes</li>
<li>访问和工具层-PaaS：web控制台、CICD、监控、日志</li>
</ul>
<h1 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul>
<li>服务器类型：物理机、虚拟机</li>
<li>节点管理【ssd、GPU】<ul>
<li>定义节点标签；pod使用亲和性调度</li>
<li>定义节点污点；pod使用容忍度调度</li>
</ul>
</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>主流方案-ceph<ul>
<li>对象存储：类似oss，程序直接调用</li>
<li>文件存储：类似nfs，直接挂载使用</li>
<li>块存储：类似硬盘、分区，需要格式化为特定文件系统后才可以使用</li>
</ul>
</li>
<li>其他方案：glusterfs、fastdfs</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>方案<ul>
<li>calico：纯三层网络方案</li>
<li>flannel</li>
</ul>
</li>
<li>calico<ul>
<li>支持k8s的网络策略(ACL)</li>
<li>支持k8s集群与外部通信<ul>
<li>实现微服务注册中心(consul/zookeeper)中集群内外不同服务的互通</li>
<li>代替kube-proxy，使用自有的负载均衡(如nginx)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul>
<li>主流方案-harbor：支持权限管理、日志审计等功能</li>
<li>其他方案：nexus</li>
</ul>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>主流方案：prometheus+grafana</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>filebeat + kafka/redis + logstash + elasticsearch + kibana</p>
<h2 id="CICD流程"><a href="#CICD流程" class="headerlink" title="CICD流程"></a>CICD流程</h2><ul>
<li>主流：jenkins</li>
<li>其他方案：gitlab ci</li>
</ul>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><ul>
<li>命名空间：资源隔离</li>
<li>权限控制：RBAC、网络策略</li>
<li>降低使用难度：操作简化、web界面管理等</li>
</ul>
<h1 id="资源规划"><a href="#资源规划" class="headerlink" title="资源规划"></a>资源规划</h1><h2 id="硬件选择-通用"><a href="#硬件选择-通用" class="headerlink" title="硬件选择-通用"></a>硬件选择-通用</h2><table>
<thead>
<tr>
<th>环境</th>
<th>节点类型</th>
<th>配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>实验环境</td>
<td>master/node</td>
<td>2C/2G+</td>
</tr>
<tr>
<td>测试环境</td>
<td>master</td>
<td>2C/4G/40G</td>
</tr>
<tr>
<td>-</td>
<td>node</td>
<td>4C/8G/40G</td>
</tr>
<tr>
<td>生产环境</td>
<td>master</td>
<td>4C/8G/100G</td>
</tr>
<tr>
<td>-</td>
<td>node</td>
<td>8C/64G/500G</td>
</tr>
</tbody>
</table>
<h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><ul>
<li><p>应用占用资源(cpu/内存)：应用数量*每个应用的副本数*每个应用占用的cpu/内存资源+20%预留冗余(业务+故障飘逸)</p>
</li>
<li><p>系统保留资源(cpu/内存、kubelet设置)：操作系统保留资源+k8s组件保留</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-system-reserved=cpu=200m,memory=250Mi --kube-reserved=cpu=200m,memory=250Mi \</span><br><span class="line">--eviction-hard=memory.available&lt;1Gi,nodefs.available&lt;1Gi,imagefs.available&lt;1Gi \</span><br><span class="line">--eviction-minimum-reclaim=memory.available=500Mi,nodefs.available=500Mi,imagefs.available=1Gi \</span><br><span class="line">--node-status-update-frequency=10s \</span><br><span class="line">--eviction-pressure-transition-period=180s</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地硬盘</p>
<ul>
<li>worker节点容量：临时存储(emptyDir/hostpath)+镜像文件+系统组件日志</li>
<li>master节点：由于保留系统元数据(etcd)，需要使用ssd提高系统性能</li>
</ul>
</li>
</ul>
<h2 id="k8s最大限额"><a href="#k8s最大限额" class="headerlink" title="k8s最大限额"></a>k8s最大限额</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 v1.18 版本中， Kubernetes 支持的最大节点数为 5000。更具体地说，我们支持满足以下所有条件的配置：</span><br><span class="line">节点数不超过 5000</span><br><span class="line">Pod 总数不超过 150000</span><br><span class="line">容器总数不超过 300000</span><br><span class="line">每个节点的 pod 数量不超过 100</span><br></pre></td></tr></table></figure>
<h1 id="集群部署方式"><a href="#集群部署方式" class="headerlink" title="集群部署方式"></a>集群部署方式</h1><ul>
<li><a href="[https://simple0426.gitee.io/2020/07/12/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/](https://simple0426.gitee.io/2020/07/12/容器化/kubernetes/kubernetes-二进制方式部署/">手动二进制</a>) ：手动分组件一步一步搭建集群；可用于学习ks8集群运行细节、也可用于生产环境</li>
<li><a href="https://www.rancher.cn/" target="_blank" rel="noopener">rancher</a>：企业级开源kubernetes管理平台</li>
<li>使用自动化工具搭建k8s集群<ul>
<li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">kubeadm</a>：官方维护，一键部署k8s集群；一般用于测试环境和学习</li>
<li>ansible手动：使用ansible编写自动化部署<ul>
<li>阿良范例：<a href="https://github.com/lizhenliang/ansible-install-k8s" target="_blank" rel="noopener">https://github.com/lizhenliang/ansible-install-k8s</a></li>
</ul>
</li>
<li>kubespray：官方维护，基于ansible编写的部署程序<ul>
<li>github：<a href="https://github.com/kubernetes-sigs/kubespray" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray</a></li>
<li>web：<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubespray/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/production-environment/tools/kubespray/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="集群高可用"><a href="#集群高可用" class="headerlink" title="集群高可用"></a>集群高可用</h1><ul>
<li>etcd高可用：推荐3、5个节点部署</li>
<li>apiserver(无状态http服务)：部署多个实例后，使用lvs/haproxy/nginx + keepalived做前端代理</li>
<li>scheduler、controller-manager：使用自身–leader-elect参数实现高可用【同一时间只有一个组件在使用】</li>
<li>CoreDNS：扩展pod副本数</li>
</ul>
<h1 id="数据备份-etcd"><a href="#数据备份-etcd" class="headerlink" title="数据备份-etcd"></a>数据备份-etcd</h1><h2 id="kubeadm部署集群"><a href="#kubeadm部署集群" class="headerlink" title="kubeadm部署集群"></a>kubeadm部署集群</h2><ul>
<li><p>定期备份etcd数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">snapshot save snap.db \</span><br><span class="line">--endpoints=https://127.0.0.1:2379 \</span><br><span class="line">--cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障时：暂停kube-apiserver和etcd容器</p>
<blockquote>
<p>这两个组件是kubelet管理的静态pod，相关配置参数：–pod-manifest-path=Directory</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /etc/kubernetes/manifests/&#123;kube-apiserver.yaml,etcd.yaml&#125; /etc/kubernetes</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障时：转储当前etcd数据：<code>mv /var/lib/etcd/ /var/lib/etcd.bak</code></p>
</li>
<li><p>恢复备份数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">snapshot restore snap.db \</span><br><span class="line">--data-dir=/var/lib/etcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动apiserver和etcd容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /etc/kubernetes/&#123;kube-apiserver.yaml,etcd.yaml&#125; /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二进制部署集群"><a href="#二进制部署集群" class="headerlink" title="二进制部署集群"></a>二进制部署集群</h2><ul>
<li><p>定期备份etcd数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">snapshot save snap.db \</span><br><span class="line">--endpoints=https://192.168.31.211:2379 \</span><br><span class="line">--cacert=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--cert=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key=/opt/etcd/ssl/server-key.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障时：暂停apiserver和etcd集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop kube-apiserver</span><br><span class="line">systemctl stop etcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>转储故障时的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /var/lib/etcd/default.etcd /var/lib/etcd/default.etcd.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>在etcd的每个节点恢复数据【修改name和peer-urls为本机信息】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snap.db \</span><br><span class="line">--name etcd-3 \</span><br><span class="line">--initial-cluster=&quot;etcd-1=https://192.168.31.211:2380,etcd-2=https://192.168.31.212:2380,etcd-3=https://192.168.31.213:2380&quot; \</span><br><span class="line">--initial-cluster-token=etcd-cluster \</span><br><span class="line">--initial-advertise-peer-urls=https://192.168.31.213:2380 \</span><br><span class="line">--data-dir=/var/lib/etcd/default.etcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动etcd和apiserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start etcd</span><br><span class="line">systemctl start kube-apiserver</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="常见问题与调试"><a href="#常见问题与调试" class="headerlink" title="常见问题与调试"></a>常见问题与调试</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>网络通信</li>
<li>tls证书：<ul>
<li>服务器时间不同步</li>
<li>证书中hosts字段包含所有k8s集群master和etcd节点ip</li>
</ul>
</li>
<li>rbac权限<ul>
<li>pod连接apiserver使用serviceaccount</li>
<li>组件(kubelet/kube-proxy/kubectl)连接apiserver使用kubeconfig</li>
</ul>
</li>
<li>镜像仓库认证<ul>
<li>使用kubectl命令创建dockerregistry类型secret(区分命名空间)，在serviceaccount或pod中引用</li>
<li>使用harbor自签tls证书，需要在每个客户端放置ca证书【/etc/docker/certs.d/myregistry:5000/ca.crt】</li>
</ul>
</li>
</ul>
<h2 id="pod启动异常"><a href="#pod启动异常" class="headerlink" title="pod启动异常"></a>pod启动异常</h2><ul>
<li>查看k8s组件日志</li>
<li>describe查看pod调度情况</li>
<li>logs查看pod运行日志</li>
</ul>
<h3 id="k8s-event"><a href="#k8s-event" class="headerlink" title="k8s event"></a>k8s event</h3><ul>
<li><p>全部事件查看：kubectl get event</p>
</li>
<li><p>学习参考：<a href="http://www.voidcn.com/article/p-qxvgcuct-bvb.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-qxvgcuct-bvb.html</a></p>
</li>
<li>保留时间(kube-apiserver)： –event-ttl  【默认保留一小时】</li>
<li>k8s事件报警插件kube-eventer：<a href="https://github.com/AliyunContainerService/kube-eventer" target="_blank" rel="noopener">https://github.com/AliyunContainerService/kube-eventer</a></li>
</ul>
<h2 id="无法通过service访问应用"><a href="#无法通过service访问应用" class="headerlink" title="无法通过service访问应用"></a>无法通过service访问应用</h2><ul>
<li>service无法关联pod(get endpoint无信息)：service标签设置是否正确</li>
<li>无法通过clusterIP访问pod：kube-proxy是否运行正常并生成相应的iptables/ipvs规则</li>
<li>无法通过service名称访问pod：CoreDNS插件是否运行正常</li>
<li>无法通过podIP访问pod<ul>
<li>网络是否互通，cni插件是否正常</li>
<li>pod是否启动(describe)</li>
<li>应用是否正常(logs)</li>
</ul>
</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="DNS名称解析"><a href="#DNS名称解析" class="headerlink" title="DNS名称解析"></a>DNS名称解析</h2><ul>
<li>可以配置cluster-proportional-autoscaler，根据node数量和vCore自动扩展副本数</li>
<li>容器内打开nscd(镜像缓存服务)，可大幅提高解析性能</li>
<li>禁止生产使用alpine作为基础镜像【可能出现dns解析异常】</li>
</ul>
<h2 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h2><ul>
<li>HPA：pod副本数伸缩</li>
<li>CA：集群node节点数伸缩</li>
</ul>
<h2 id="ingress-controller"><a href="#ingress-controller" class="headerlink" title="ingress controller"></a>ingress controller</h2><p>ingress controller单独worker部署(污点)增加转发能力</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>apiserver访问限制、操作审计</li>
<li>k8s事件信息归档、报警</li>
</ul>
<h1 id="公有云部署k8s"><a href="#公有云部署k8s" class="headerlink" title="公有云部署k8s"></a><a href="https://tech.souyunku.com/?p=22239" target="_blank" rel="noopener">公有云部署k8s</a></h1><ul>
<li><p>阿里云ecs不支持keepalived vip,只能只用SLB来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、 阿里云不能使用vip,要用vip只能走slb</span><br><span class="line">2、 slb已经没有免费的了,都要收费,包括内网slb</span><br><span class="line">3、 不支持手动指定slb的IP地址,所以之前生成的api证书之类的重新弄吧</span><br><span class="line">4、 要反代https(apiserver),只能用slb的四层反代</span><br><span class="line">5、 slb四层TCP反代(7443),不能直接反代到服务提供者上(即apiserver:6443)</span><br><span class="line">6、 只能将 tcp反代,先代理到另一个ecs上,ecs再用nginx之类代理到apiserver</span><br><span class="line">7、 即slb(tcp:7443)–&gt;nginx(tcp:7443)–&gt;apiserver(https:6443)</span><br><span class="line">(nginx和apiserver不能是同一个机器)</span><br></pre></td></tr></table></figure>
</li>
<li><p>阿里云ecs不支持flannel的gw模式【阿里云使用SDN网络，ECS之间、ECS访问其他网络都依靠交换机绑定的路由表】</p>
<ul>
<li>使用gw模式，但是在阿里云的路由表中添加到各容器网段的路由</li>
<li>使用vxlan模式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>技术栈</tag>
        <tag>方案</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s实施-微服务与SpringCloud容器化</title>
    <url>/blog/2020/09/16/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8ESpringCloud%E5%AE%B9%E5%99%A8%E5%8C%96/</url>
    <content><![CDATA[<h1 id="运维角度看微服务"><a href="#运维角度看微服务" class="headerlink" title="运维角度看微服务"></a>运维角度看微服务</h1><h2 id="单体应用vs微服务"><a href="#单体应用vs微服务" class="headerlink" title="单体应用vs微服务"></a>单体应用vs微服务</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/microservice.png" alt></p>
<p><strong>单体应用</strong>：将全部的功能在一个应用中实现，优缺点如下：</p>
<ul>
<li>优点：易于部署和测试</li>
<li>缺点：<ul>
<li>代码量膨胀，难以维护【服务之间耦合性太高，单个应用变动可能引起其他服务不可用】</li>
<li>构建和部署成本大【编译时间随代码量增加而增加、单个功能更新需要重新部署整个应用】</li>
<li>扩展困难</li>
</ul>
</li>
</ul>
<p><strong>微服务</strong>：是一种设计风格，将不同的功能拆分到不同的应用中实现，不同的子应用通过REST api进行通信；必备组件包括：</p>
<ul>
<li>注册中心：微服务的服务发现、负载均衡实现</li>
<li>API Gateway：微服务的访问入口</li>
</ul>
<h2 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h2><ul>
<li>服务组件化：每个服务独立开发，减少应用间的依赖关系，有效避免了一个服务的修改造成其他服务不可用。</li>
<li>技术栈灵活：约定通信方式后(RPC、RESTapi)，不同的功能可以使用不同的语言开发</li>
<li>独立数据：每个微服务可以有独立的基本组件，例如数据库、缓存等。</li>
<li>独立部署：每个微服务独立部署，加快构建和部署速度</li>
<li>扩展性强：每个微服务可以部署多个实例，并且有负载均衡能力</li>
</ul>
<h2 id="微服务难点和不足"><a href="#微服务难点和不足" class="headerlink" title="微服务难点和不足"></a>微服务难点和不足</h2><ul>
<li>架构复杂性和沟通成本：每个功能的完成，都需要多个组件的系统工作；组件之间的协同工作需要整体的架构设计、接口和文档的标准化等工作</li>
<li>数据一致性：多个组件间事务性操作(订单、支付、库存等)需要确保数据的一致性</li>
<li>运维成本：随着组件的增多，服务的部署、配置、监控、日志等微服务的治理工作量也随之增多，要求的自动化程度、专业技能也随之增强</li>
</ul>
<h2 id="java微服务框架"><a href="#java微服务框架" class="headerlink" title="java微服务框架"></a>java微服务框架</h2><p>spring boot：微服务开发框架</p>
<ul>
<li>dubbo：微服务治理框架</li>
<li>spring cloud：基于spring boot的完整微服务解决方案</li>
</ul>
<h1 id="K8S中部署微服务"><a href="#K8S中部署微服务" class="headerlink" title="K8S中部署微服务"></a>K8S中部署微服务</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/microservice-1.png" alt></p>
<h2 id="微服务架构理解"><a href="#微服务架构理解" class="headerlink" title="微服务架构理解"></a>微服务架构理解</h2><ul>
<li>微服务间如何通信？REST API，RPC，MQ</li>
<li>微服务如何发现彼此？注册中心</li>
<li>组件之间怎么个调用关系？</li>
<li>哪个服务作为整个网站入口？前后端分离</li>
<li>哪些微服务需要提供外部访问入口？前端、微服务网关</li>
<li><p>微服务怎么部署？更新？扩容？</p>
<ul>
<li>部署：kubectl apply、helm install【jenkins】</li>
<li>更新：kubectl set image</li>
<li>扩容：kubectl scale</li>
</ul>
</li>
<li><p>区分有状态应用与无状态应用：有状态一般部署在虚拟机、无状态部署在k8s中</p>
<ul>
<li>应用服务：订单、商品、库存、支付</li>
<li>数据库/存储：数据库、redis、MQ、分布式存储</li>
</ul>
</li>
</ul>
<h2 id="为什么要用注册中心"><a href="#为什么要用注册中心" class="headerlink" title="为什么要用注册中心"></a>为什么要用注册中心</h2><p>微服务太多面临的问题：</p>
<ul>
<li>怎么记录一个微服务多个副本接口地址？</li>
<li>怎么实现一个微服务多个副本负载均衡？</li>
<li>怎么判断一个微服务副本是否可用？</li>
</ul>
<p>主流注册中心：Eureka(spring cloud)，Nacos(alibaba)，Consul</p>
<h2 id="容器交付流程"><a href="#容器交付流程" class="headerlink" title="容器交付流程"></a>容器交付流程</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/microservice-cicd.png" alt></p>
<h2 id="在K8s部署项目流程"><a href="#在K8s部署项目流程" class="headerlink" title="在K8s部署项目流程"></a>在K8s部署项目流程</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/microservice-k8s.png" alt></p>
<h1 id="微服务范例-Spring-Cloud"><a href="#微服务范例-Spring-Cloud" class="headerlink" title="微服务范例-Spring Cloud"></a>微服务范例-Spring Cloud</h1><p>具体步骤：</p>
<p>前置条件：在K8s中部署MySQL数据库、编译主机安装maven环境、启动harbor服务<br>第一步：熟悉Spring Cloud微服务项目<br>第二步：源代码编译构建<br>第三步：构建项目镜像并推送到镜像仓库<br>第四步：K8s服务编排<br>第五步：在K8s中部署注册中心(Eureka集群)<br>第六步：部署微服务业务程序（product、stock、order）<br>第七步：部署微服务网关服务（gateway）<br>第八步：部署微服务前端（portal）<br>第九步：微服务对外发布<br>第十步：微服务升级与扩容</p>
<p><strong>自动化构建说明</strong>：使用项目中的脚本docker_build.sh可以完成2~9部操作</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul>
<li><p>helm安装mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add microsoft http://mirror.azure.cn/kubernetes/charts/</span><br><span class="line">helm repo update</span><br><span class="line">helm install db --set persistence.storageClass=&quot;example-nfs&quot; microsoft/mysql</span><br><span class="line">helm status db</span><br></pre></td></tr></table></figure>
</li>
<li><p>maven环境设置【编译项目的主机】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装maven</span><br><span class="line">yum install java-1.8.0-openjdk maven</span><br><span class="line"></span><br><span class="line">2. 设置maven源</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line"> &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line"> &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line"> &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line"> &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="熟悉Spring-Cloud微服务项目"><a href="#熟悉Spring-Cloud微服务项目" class="headerlink" title="熟悉Spring Cloud微服务项目"></a>熟悉Spring Cloud微服务项目</h2><ul>
<li><p>项目地址：<a href="https://github.com/simple0426/simple-microservice.git" target="_blank" rel="noopener">https://github.com/simple0426/simple-microservice.git</a></p>
</li>
<li><p>代码分支说明：</p>
<ul>
<li>dev3 增加K8S资源编排【k8s/*.yaml】</li>
<li>dev4 增加微服务链路监控【*/pinpoint-agent】</li>
<li>master 最终上线</li>
</ul>
</li>
<li>项目说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. k8s部署使用dev3分支</span><br><span class="line">2. 导入db目录下数据库文件到自己的MySQL服务器，操作如下</span><br><span class="line">3. 修改连接数据库配置（xxx-service/src/main/resources/application-fat.yml）</span><br><span class="line">4. 修改前端页面连接网关地址（portal-service/src/main/resources/static/js/productList.js和orderList.js）【默认：gateway.ctnrs.com】</span><br><span class="line">5. 修改k8s/docker_build.sh中的harbor信息</span><br></pre></td></tr></table></figure>
<ul>
<li>连接mysql并导入sql文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mysql</span><br><span class="line">MYSQL_HOST=$(kubectl get svc|awk &apos;/db-mysql/&#123;print $3&#125;&apos;)</span><br><span class="line">MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default db-mysql -o jsonpath=&quot;&#123;.data.mysql-root-password&#125;&quot; | base64 --decode; echo)</span><br><span class="line">mysql -h$MYSQL_HOST -P3306 -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; &lt; order.sql </span><br><span class="line">mysql -h$MYSQL_HOST -P3306 -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; &lt; product.sql </span><br><span class="line">mysql -h$MYSQL_HOST -P3306 -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; &lt; order.sql</span><br></pre></td></tr></table></figure>
<h2 id="源代码编译构建"><a href="#源代码编译构建" class="headerlink" title="源代码编译构建"></a>源代码编译构建</h2><p>编译【由于项目bug，不能针对单个微服务打包，所以需要在项目根目录下操作】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<h2 id="构建项目镜像并推送到镜像仓库"><a href="#构建项目镜像并推送到镜像仓库" class="headerlink" title="构建项目镜像并推送到镜像仓库"></a>构建项目镜像并推送到镜像仓库</h2><ul>
<li>Dockerfile</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8-jdk-alpine</span><br><span class="line">LABEL maintainer lizhenliang/www.ctnrs.com</span><br><span class="line">RUN  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">COPY ./target/eureka-service.jar ./</span><br><span class="line">EXPOSE 8888</span><br><span class="line">CMD java -jar -Deureka.instance.hostname=$&#123;MY_POD_NAME&#125;.eureka.ms /eureka-service.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>build &amp;&amp; push</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t $&#123;image_name&#125; .</span><br><span class="line">docker push $&#123;image_name&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K8s服务编排"><a href="#K8s服务编排" class="headerlink" title="K8s服务编排"></a>K8s服务编排</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/microservice-k8s-1.png" alt></p>
<ul>
<li>前端portal、微服务网关gateway需要使用ingress对外暴露，以方便用户访问</li>
<li>业务服务(product、stock、order)只需使用deployment部署pod，通过注册中心(Eureka)进行服务发现和负载均衡</li>
<li>注册中心使用statefulset进行部署</li>
</ul>
<h2 id="部署Erureka集群"><a href="#部署Erureka集群" class="headerlink" title="部署Erureka集群"></a>部署Erureka集群</h2><ul>
<li><p>Erureka集群实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. pod设置变量【Deployment】</span><br><span class="line">env:</span><br><span class="line">  - name: MY_POD_NAME</span><br><span class="line">    valueFrom:</span><br><span class="line">      fieldRef:</span><br><span class="line">        fieldPath: metadata.name</span><br><span class="line"></span><br><span class="line">2. 程序启动时引用变量【Dockerfile】</span><br><span class="line">CMD java -jar -Deureka.instance.hostname=$&#123;MY_POD_NAME&#125;.eureka.ms /eureka-service.jar</span><br><span class="line"></span><br><span class="line">3. 程序中设置集群信息【eureka-service/src/main/resources/application-fat.yml】</span><br><span class="line">defaultZone: http://eureka-0.eureka.ms:$&#123;server.port&#125;/eureka/,http://eureka-1.eureka.ms:$&#123;server.port&#125;/eureka/,http://eureka-2.eureka.m</span><br><span class="line">s:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Erureka web访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看访问地址</span><br><span class="line">kubectl get ingress -n ms</span><br><span class="line"></span><br><span class="line">2. windows主机hosts设置</span><br><span class="line">192.168.31.202 eureka.ctnrs.com</span><br><span class="line"></span><br><span class="line">3. web浏览器访问</span><br><span class="line">http://eureka.ctnrs.com/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="在K8s中部署微服务"><a href="#在K8s中部署微服务" class="headerlink" title="在K8s中部署微服务"></a>在K8s中部署微服务</h2><blockquote>
<p>eureka客户端设置【prefer-ip-address: true】使微服务以pod的ip注册</p>
</blockquote>
<ul>
<li>部署业务程序（product、stock、order）</li>
<li>部署网关（gateway）</li>
<li>部署前端（portal）</li>
</ul>
<h2 id="微服务升级与扩容"><a href="#微服务升级与扩容" class="headerlink" title="微服务升级与扩容"></a>微服务升级与扩容</h2><ul>
<li>微服务升级：对要升级的微服务进行上述步骤打包镜像:版本，替代运行的镜像</li>
<li>微服务扩容：对Pod扩容副本数</li>
</ul>
<h1 id="K8S部署实践"><a href="#K8S部署实践" class="headerlink" title="K8S部署实践"></a>K8S部署实践</h1><h2 id="JVM内存限制"><a href="#JVM内存限制" class="headerlink" title="JVM内存限制"></a>JVM内存限制</h2><blockquote>
<p>参考1：<a href="https://blog.csdn.net/gBbQRglVIr3dYi82/article/details/82754927" target="_blank" rel="noopener">https://blog.csdn.net/gBbQRglVIr3dYi82/article/details/82754927</a></p>
<p>参考2：<a href="https://www.oracle.com/java/technologies/javase/8u191-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/8u191-relnotes.html</a></p>
<p>参考3：<a href="https://www.cnblogs.com/xiaoqi/p/container-jvm.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoqi/p/container-jvm.html</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. java 5/6/7/8u131-</span><br><span class="line">设置-Xmx</span><br><span class="line"></span><br><span class="line">2. java 8u131+和java9+</span><br><span class="line">设置-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</span><br><span class="line"></span><br><span class="line">3.java 8u191+和java10+</span><br><span class="line">UseContainerSupport默认开启，可以感知容器内存和cpu限制；同时设置-XX:MaxRAMPercentage=75.0，这样为其他进程（debug、监控）留下足够的内存空间</span><br></pre></td></tr></table></figure>
<h2 id="滚动更新-高可用"><a href="#滚动更新-高可用" class="headerlink" title="滚动更新-高可用"></a>滚动更新-高可用</h2><p>滚动更新是默认发布策略，当配置健康检查时，滚动更新会根据Probe状态来决定是否继续更新以及是否允许接<br>入流量，这样在整个滚动更新过程中可保持始终会有可用的Pod存在，达到平滑升级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readinessProbe:</span><br><span class="line">  tcpSocket:</span><br><span class="line">    port: 9999</span><br><span class="line">  initialDelaySeconds: 60</span><br><span class="line">  periodSeconds: 10</span><br><span class="line">livenessProbe:</span><br><span class="line">  tcpSocket:</span><br><span class="line">    port: 9999</span><br><span class="line">  initialDelaySeconds: 60</span><br><span class="line">  periodSeconds: 10</span><br></pre></td></tr></table></figure>
<h2 id="滚动更新-pod删除"><a href="#滚动更新-pod删除" class="headerlink" title="滚动更新-pod删除"></a>滚动更新-pod删除</h2><p>滚动更新触发，Pod在删除过程中，有些节点kube-proxy还没来得及同步iptables规则，从而部分流量请求到Terminating的Pod上，导致请求出错。<br>解决办法：配置preStop回调，在容器终止前优雅暂停5秒，给kube-proxy多预留一点时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  preStop:</span><br><span class="line">    exec:</span><br><span class="line">      command:</span><br><span class="line">      - sh</span><br><span class="line">      - -c</span><br><span class="line">      - &quot;sleep 5&quot;</span><br></pre></td></tr></table></figure>
<h1 id="微服务链路监控-APM"><a href="#微服务链路监控-APM" class="headerlink" title="微服务链路监控-APM"></a>微服务链路监控-APM</h1><h2 id="全链路监控是什么"><a href="#全链路监控是什么" class="headerlink" title="全链路监控是什么"></a>全链路监控是什么</h2><p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。这些服务可能用不同编程语言开发，不同团队开发，可能部署很多副本。因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。全链路监控组件就在这样的问题背景下产生了。</p>
<p>全链路性能监控 从整体维度到局部维度展示各项指标，将跨应用的所有调用链性能信息集中展现，可方便度量整体和局部性能，并且方便找到故障产生的源头，生产上可极大缩短故障排除时间。</p>
<h2 id="全链路监控解决的问题"><a href="#全链路监控解决的问题" class="headerlink" title="全链路监控解决的问题"></a>全链路监控解决的问题</h2><ul>
<li>请求链路追踪：通过分析服务调用关系，绘制运行时拓扑信息，可视化展示</li>
<li>调用情况衡量：各个调用环节的性能分析，例如吞吐量、响应时间、错误次数</li>
<li>容量规划参考：扩容/缩容、服务降级、流量控制</li>
<li>运行情况反馈：告警，通过调用链结合业务日志快速定位错误信息</li>
</ul>
<h2 id="全链路监控组件选择"><a href="#全链路监控组件选择" class="headerlink" title="全链路监控组件选择"></a>全链路监控组件选择</h2><p>全链路监控系统有很多，应从这几方面选择：</p>
<ul>
<li>探针的性能消耗<br>APM组件服务的影响应该做到足够小，数据分析要快，性能占用小。</li>
<li>代码的侵入性<br>即也作为业务组件，应当尽可能少入侵或者无入侵其他业务系统，<br>对于使用方透明，减少开发人员的负担。</li>
<li>监控维度<br>分析的维度尽可能多。</li>
<li>可扩展性<br>一个优秀的调用跟踪系统必须支持分布式部署，具备良好的可扩展<br>性【服务端分布式部署】。能够支持的组件越多当然越好。</li>
</ul>
<p>常用APM组件：zipkin、skywalking、pinpoint</p>
<h2 id="Pinpoint介绍"><a href="#Pinpoint介绍" class="headerlink" title="Pinpoint介绍"></a>Pinpoint介绍</h2><p>Pinpoint是一个APM（应用程序性能管理）工具，适用于用Java/PHP编写的大型分布式系统。</p>
<p>可以监控的信息如下：</p>
<ul>
<li>服务器地图（ServerMap）通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会 展示这个模块的详情，比如它当前的状态和请求数量。</li>
<li>实时活动线程图 （Realtime Active Thread Chart） ：实时监控应用内部的活动线程。</li>
<li>请求/响应分布图（ Request/Response Scatter Chart ） ：长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看 更多的详细信息。</li>
<li>调用栈（ CallStack ）：在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。</li>
<li>检查器（ Inspector ） ：查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。</li>
</ul>
<h2 id="Pinpoint服务端部署"><a href="#Pinpoint服务端部署" class="headerlink" title="Pinpoint服务端部署"></a>Pinpoint服务端部署</h2><ul>
<li><p>docker方式部署：<a href="https://github.com/naver/pinpoint-docker" target="_blank" rel="noopener">https://github.com/naver/pinpoint-docker</a></p>
<blockquote>
<p>启动时会在本地构建镜像(docker-compose build)，构建过程中会从github拉取各组件的tar包，</p>
<p>所以构建过程很慢</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/naver/pinpoint-docker.git</span><br><span class="line">cd pinpoint-docker</span><br><span class="line">docker-compose pull &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署完成后包含的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pinpoint-agent            # pinpoint agent组件（为应用程序范例提供agent程序） </span><br><span class="line">pinpoint-collector        # 收集agent的数据                   </span><br><span class="line">pinpoint-docker_zoo1_1    </span><br><span class="line">pinpoint-docker_zoo2_1    </span><br><span class="line">pinpoint-docker_zoo3_1    </span><br><span class="line">pinpoint-flink-jobmanager </span><br><span class="line">pinpoint-flink-taskmanager                          </span><br><span class="line">pinpoint-hbase             # 保存指标数据                            </span><br><span class="line">pinpoint-mysql             # 保存web页面数据</span><br><span class="line">pinpoint-quickstart        # 应用程序范例，通过共享存储挂载agent组件</span><br><span class="line">pinpoint-web               # 服务端web界面</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 应用程序范例：http://xxxx:8000</span><br><span class="line">* pinpoint服务端web界面：http://xxxx:8079</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Pinpoint-Agent部署"><a href="#Pinpoint-Agent部署" class="headerlink" title="Pinpoint Agent部署"></a><a href="https://pinpoint-apm.github.io/pinpoint/installation.html#5-pinpoint-agent" target="_blank" rel="noopener">Pinpoint Agent部署</a></h2><ul>
<li><p>pinpoint agent程序供给</p>
<ul>
<li><p>程序获取：</p>
<ul>
<li>pinpoint web界面右侧【设置】–》installation–》Download Link</li>
<li>实际地址：<code>https://github.com/naver/pinpoint/releases/download/v2.1.0/pinpoint-agent-2.1.0.tar.gz</code></li>
</ul>
</li>
<li><p>程序设置【v2.1.0】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* pinpoint-root.config</span><br><span class="line">pinpoint.profiler.profiles.active=release # 设置加载的环境</span><br><span class="line"># 其他为全局配置，环境级别的配置会覆盖同名条目信息</span><br><span class="line"></span><br><span class="line">* profiles/release/pinpoint.config        # release环境设置</span><br><span class="line">profiler.transport.module=GRPC            # agent与server以grpc方式通信</span><br><span class="line">profiler.transport.grpc.collector.ip=192.168.31.250      # server地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>agent程序位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 通过initContainer方式将pinpoint agent程序复制到共享目录供应用程序使用</span><br><span class="line">2. 启动一个job或pod，将pinpoint agent程序挂载到集群存储中，其他pod挂载这个存储</span><br><span class="line">3. 制作镜像Dockerfile时，将pinpoint agent程序复制到镜像中</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用程序启动时加载pinpoint agent</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tomcat设置：</span><br><span class="line">#catalina.sh</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.agentId=$AGENT_ID&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.applicationName=$APPLICATION_NAME&quot;</span><br><span class="line"></span><br><span class="line">jar设置：</span><br><span class="line">java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=$AGENT_ID</span><br><span class="line">-Dpinpoint.applicationName=$APPLICATION_NAME xxx.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloud</tag>
        <tag>APM</tag>
        <tag>Pinpoint</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s实施-项目部署流程.md</title>
    <url>/blog/2020/07/29/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="运维架构"><a href="#运维架构" class="headerlink" title="运维架构"></a>运维架构</h1><p>传统部署方式</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/deploy-os.jpg" alt></p>
<p>k8s部署方式</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/deploy-k8s.jpg" alt></p>
<h1 id="k8s部署流程"><a href="#k8s部署流程" class="headerlink" title="k8s部署流程"></a>k8s部署流程</h1><ol>
<li>制作镜像</li>
<li>控制器管理pod</li>
<li>pod数据持久化</li>
<li>暴露、发布应用：service、ingress</li>
<li>监控、日志：prometheus+granfa、elk</li>
</ol>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><ul>
<li>镜像分类<ul>
<li>基础镜像：ubuntu、centos</li>
<li>环境镜像：程序运行环境，如：java、python、php、tomat</li>
<li>项目镜像：代码打包进环境镜像</li>
</ul>
</li>
<li>制作镜像<ul>
<li>编写Dockerfile</li>
<li>build构建</li>
<li>推送到镜像仓库</li>
</ul>
</li>
</ul>
<h2 id="pod控制器"><a href="#pod控制器" class="headerlink" title="pod控制器"></a>pod控制器</h2><ul>
<li>Deployment：无状态部署，如web、微服务、API</li>
<li>Statefulset：有状态部署，例如数据库集群、zk、etcd</li>
<li>Daemonset：守护进程部署，例如监控agent、日志agent</li>
<li>job&amp;cronjob：批处理，例如数据库备份、邮件通知</li>
</ul>
<h2 id="pod数据持久化"><a href="#pod数据持久化" class="headerlink" title="pod数据持久化"></a>pod数据持久化</h2><ul>
<li>初始化数据、配置文件</li>
<li>临时数据：临时缓存、多个容器共享数据</li>
<li>业务数据：运行过程中产生的数据</li>
</ul>
<h2 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h2><ul>
<li>内部暴露：service</li>
<li>外部暴露：ingress、集群外的nginx/haproxy</li>
</ul>
<h1 id="部署范例-wordpress"><a href="#部署范例-wordpress" class="headerlink" title="部署范例-wordpress"></a>部署范例-wordpress</h1><p>wordpress需要同时用到nginx和php-fpm进行解析，所以采用一个pod中包含nginx和php(也包含wordpress源码)两个容器的方式在k8s中部署；根据使用的php镜像不同，可分两种形式部署：</p>
<ul>
<li>直接使用docker hub中的wordpress[wordpress:fpm]镜像<ul>
<li>此种方式可以直接将wordpress的运行目录[/var/www/html]通过共享存储的形式挂载到nginx容器</li>
</ul>
</li>
<li>下载wordpress源码，将源码打包进[php:fpm]镜像【以下也为此种形式部署】<ul>
<li>此种方式在包含源码php-fpm镜像启动容器后(postStart)，需要将源码复制到共享存储，然后nginx容器将项目发布出去</li>
</ul>
</li>
</ul>
<h2 id="下载并解压wordpress"><a href="#下载并解压wordpress" class="headerlink" title="下载并解压wordpress"></a>下载并解压wordpress</h2><p>修改wp-config.php中的数据库配置，范例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ** MySQL 设置 - 具体信息来自您正在使用的主机 ** //</span><br><span class="line">/** WordPress数据库的名称 */</span><br><span class="line">define( &apos;DB_NAME&apos;, &apos;wp&apos; );</span><br><span class="line"></span><br><span class="line">/** MySQL数据库用户名 */</span><br><span class="line">define( &apos;DB_USER&apos;, &apos;root&apos; );</span><br><span class="line"></span><br><span class="line">/** MySQL数据库密码 */</span><br><span class="line">define( &apos;DB_PASSWORD&apos;, &apos;QMnY1CjjOm&apos; );</span><br><span class="line"></span><br><span class="line">/** MySQL主机 */</span><br><span class="line">define( &apos;DB_HOST&apos;, &apos;java-demo-db-mysql.default&apos; );</span><br></pre></td></tr></table></figure>
<h2 id="制作镜像-1"><a href="#制作镜像-1" class="headerlink" title="制作镜像"></a>制作镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM php:5.6.36-fpm</span><br><span class="line">RUN docker-php-ext-install mysqli pdo pdo_mysql</span><br><span class="line">COPY wordpress /app</span><br></pre></td></tr></table></figure>
<p>docker build -t ‘wordpress:v3’ .</p>
<h2 id="创建资源文件"><a href="#创建资源文件" class="headerlink" title="创建资源文件"></a>创建资源文件</h2><ul>
<li><p>namespace</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: php</span><br></pre></td></tr></table></figure>
</li>
<li><p>configmap【配置nginx访问php-fpm】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-conf</span><br><span class="line">  namespace: php</span><br><span class="line">data:</span><br><span class="line">  default.conf: |</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen  [::]:80;</span><br><span class="line">        server_name _;</span><br><span class="line">        root /var/www/html;</span><br><span class="line">        index index.php index.html;</span><br><span class="line">        location / &#123;</span><br><span class="line">          try_files $uri $uri/ /index.php =404;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root  /var/www/html;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>deployment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: php-demo</span><br><span class="line">  namespace: php</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      project: www</span><br><span class="line">      app: php-demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: www</span><br><span class="line">        app: php-demo</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: &quot;node01&quot;</span><br><span class="line">      volumes:</span><br><span class="line">      - name: app-volume</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      - name: config-volume</span><br><span class="line">        configMap:</span><br><span class="line">          name: nginx-conf</span><br><span class="line">          items:</span><br><span class="line">          - key: default.conf</span><br><span class="line">            path: default.conf</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx </span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 256Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 512Mi</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /var/www/html</span><br><span class="line">          name: app-volume   </span><br><span class="line">        - mountPath: /etc/nginx/conf.d</span><br><span class="line">          name: config-volume</span><br><span class="line">      - name: wordpress </span><br><span class="line">        image: wordpress:v3</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9000</span><br><span class="line">          name: web</span><br><span class="line">          protocol: TCP       </span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 256Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 512Mi</span><br><span class="line">        lifecycle:</span><br><span class="line">          postStart:</span><br><span class="line">            exec:</span><br><span class="line">              command: [&quot;sh&quot;, &quot;-c&quot;, &quot;cp -a /app/* /var/www/html&quot;]</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /var/www/html</span><br><span class="line">          name: app-volume</span><br></pre></td></tr></table></figure>
</li>
<li><p>service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: php-demo </span><br><span class="line">  namespace: php</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    project: www</span><br><span class="line">    app: php-demo</span><br><span class="line">  ports:</span><br><span class="line">  - name: web</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">#  type: NodePort</span><br></pre></td></tr></table></figure>
</li>
<li><p>ingress</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: php-demo </span><br><span class="line">  namespace: php</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    - host: php.ctnrs.com</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">        - path: /</span><br><span class="line">          backend:</span><br><span class="line">            serviceName: php-demo </span><br><span class="line">            servicePort: 80</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装及访问"><a href="#安装及访问" class="headerlink" title="安装及访问"></a>安装及访问</h2><p>  <a href="http://php.ctnrs.com" target="_blank" rel="noopener">http://php.ctnrs.com</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s实施-构建基于jenkins的发布平台</title>
    <url>/blog/2020/08/03/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/k8s%E5%AE%9E%E6%96%BD-%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8Ejenkins%E7%9A%84%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h1 id="发布流程设计"><a href="#发布流程设计" class="headerlink" title="发布流程设计"></a>发布流程设计</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s-cicd.png" alt></p>
<ol>
<li>开发人员从镜像仓库harbor中拉取基础镜像，对应用进行容器化开发</li>
<li>开发人员提交代码到代码仓库gitlab中</li>
<li>gitlab收到代码提交请求后通过webhook方式触发jenkins</li>
<li>jenkins收到请求后对代码进行打包，生产可执行程序(如，marven打包)</li>
<li>打包完成后，基于dockerfile生成docker images</li>
<li>docker images产生后上传到镜像仓库harbor</li>
<li>通过jenkins的pipeline在kubernetes的测试、生产环境拉取镜像、部署应用</li>
</ol>
<h1 id="构建基础环境"><a href="#构建基础环境" class="headerlink" title="构建基础环境"></a>构建基础环境</h1><ul>
<li>k8s(ingress controller、storage class)</li>
<li>helm v3【helm方式部署k8s服务】</li>
<li>gitlab</li>
<li>jenkins</li>
<li>harbor，并启用chart存储功能</li>
<li>mysql（微服务数据库）</li>
<li>eureka（微服务注册中心）</li>
</ul>
<h1 id="jenkins-master部署"><a href="#jenkins-master部署" class="headerlink" title="jenkins master部署"></a>jenkins master部署</h1><h2 id="在k8s中部署jenkins"><a href="#在k8s中部署jenkins" class="headerlink" title="在k8s中部署jenkins"></a>在k8s中部署jenkins</h2><ul>
<li>自定义资源文件方式：<a href="https://github.com/simple0426/sysadm/tree/master/kubernetes/jenkins" target="_blank" rel="noopener">https://github.com/simple0426/sysadm/tree/master/kubernetes/jenkins</a></li>
<li>helm安装方式：helm search repo jenkins</li>
</ul>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><blockquote>
<p>修改使用国内镜像地址后重启jenkins【删除pod】</p>
<p>安装插件后重启jenkins，使部分插件生效(如kubernetes插件)</p>
</blockquote>
<ul>
<li><a href="https://plugins.jenkins.io/git" target="_blank" rel="noopener">Git</a>：拉取代码</li>
<li><a href="https://plugins.jenkins.io/git-parameter" target="_blank" rel="noopener">Git Parameter</a>：git参数化构建，支持在项目中使用分支、tag、revision拉取代码</li>
<li><a href="https://plugins.jenkins.io/workflow-aggregator" target="_blank" rel="noopener">Pipeline</a>：流水线</li>
<li><a href="https://plugins.jenkins.io/kubernetes" target="_blank" rel="noopener">Kubernetes</a>：在k8s中动态创建agent</li>
<li><a href="https://plugins.jenkins.io/config-file-provider" target="_blank" rel="noopener">Config File Provider</a>：支持在web界面加载配置文件，并传递给job workspace</li>
<li><a href="https://plugins.jenkins.io/extended-choice-parameter" target="_blank" rel="noopener">Extended Choice Parameter</a>：支持多项选择【内置choice插件只支持单选】</li>
</ul>
<h2 id="jenkins设置"><a href="#jenkins设置" class="headerlink" title="jenkins设置"></a>jenkins设置</h2><ul>
<li><p>Credentials中新建</p>
<ul>
<li>连接gitlab的认证信息</li>
<li>连接harbor的认证信息</li>
</ul>
</li>
<li><p>Config File Management（config provider插件功能）中新增kubeconfig文件</p>
</li>
</ul>
<h1 id="在k8s中动态创建agent"><a href="#在k8s中动态创建agent" class="headerlink" title="在k8s中动态创建agent"></a>在k8s中动态创建agent</h1><ul>
<li><p>插件：<a href="https://plugins.jenkins.io/kubernetes" target="_blank" rel="noopener">Kubernetes</a></p>
</li>
<li><p>jenkins master：可以运行在k8s内，也可以运行在k8s外</p>
</li>
</ul>
<h2 id="kubernetes插件配置"><a href="#kubernetes插件配置" class="headerlink" title="kubernetes插件配置"></a>kubernetes插件配置</h2><ul>
<li>配置位置：manage nodes and clouds==》kubernetes</li>
<li>配置选项：根据jenkins-master的部署位置不同，有如下方式：</li>
</ul>
<h3 id="jenkins-master部署在k8s集群中"><a href="#jenkins-master部署在k8s集群中" class="headerlink" title="jenkins-master部署在k8s集群中"></a>jenkins-master部署在k8s集群中</h3><ul>
<li>名称：任意值，用于区分不同的k8s集群</li>
<li>Kubernetes地址：kubernetes service的地址，例如：<a href="https://kubernetes.default" target="_blank" rel="noopener">https://kubernetes.default</a></li>
<li>Kubernetes 命名空间：代理pod的运行的命名空间</li>
<li>jenkins地址：jenkins的service地址，例如：<a href="http://jenkins.ops" target="_blank" rel="noopener">http://jenkins.ops</a></li>
</ul>
<h3 id="jenkins-master部署在k8s集群外"><a href="#jenkins-master部署在k8s集群外" class="headerlink" title="jenkins-master部署在k8s集群外"></a>jenkins-master部署在k8s集群外</h3><ul>
<li><p>名称：任意值，用于区分不同的k8s集群</p>
</li>
<li><p>Kubernetes地址：k8s集群外部地址，例如：<a href="https://192.168.31.201:6443" target="_blank" rel="noopener">https://192.168.31.201:6443</a></p>
</li>
<li><p>Kubernetes 服务证书 key：kubernetes ca证书，例如：/etc/kubernetes/pki/ca.crt</p>
</li>
<li><p>Kubernetes 命名空间：代理pod的运行的命名空间</p>
</li>
<li><p>凭据(credential)：</p>
<ul>
<li><p>设置证书为 secret text类型</p>
</li>
<li><p>凭据的值为在k8s集群中创建的代理pod运行时使用的serviceaccount的token</p>
</li>
<li><p>token获取（代理pod-RBAC设置）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建pod服务账号</span><br><span class="line">kubectl create serviceaccount jenkins-slave -n ops </span><br><span class="line"># 给pod服务账号绑定权限</span><br><span class="line">kubectl create clusterrolebinding jenkins-slave --clusterrole cluster-admin --serviceaccount=ops:jenkins-slave </span><br><span class="line"># 获取pod服务账号的token</span><br><span class="line">kubectl describe secret -n ops $(kubectl get secret -n ops|awk &apos;/jenkins-slave/&#123;print $1&#125;&apos;)|awk &apos;/^token/&#123;print $2&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Jenkins 地址：jenkins的web接口地址，例如：<a href="http://192.168.31.250:7080/" target="_blank" rel="noopener">http://192.168.31.250:7080/</a></p>
</li>
</ul>
<h2 id="自定义agent镜像"><a href="#自定义agent镜像" class="headerlink" title="自定义agent镜像"></a>自定义agent镜像</h2><p>agent pod中默认包含一个jnlp的容器用于和jenkins master通信，可以增加一个容器用于执行特定的任务 </p>
<p>此处即为增加特定任务镜像，包含的工具如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 项目构建：maven、jdk</span><br><span class="line">2. 镜像构建：docker build/push【docker通过在pod中挂载宿主机docker的二进制、socket完成】</span><br><span class="line">3. 资源文件部署：kubectl、helm</span><br></pre></td></tr></table></figure>
<p>此处将镜像设置为公开镜像，方便动态创建pod时无需认证即可拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">LABEL maintainer perfect_0426@qq.com</span><br><span class="line">RUN rm -rf /etc/yum.repos.d/* &amp;&amp; \</span><br><span class="line">    curl -Lo /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \</span><br><span class="line">    curl -Lo /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo &amp;&amp; \</span><br><span class="line">    sed -i -e &apos;/mirrors.cloud.aliyuncs.com/d&apos; -e &apos;/mirrors.aliyuncs.com/d&apos; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; yum makecache &amp;&amp; \ </span><br><span class="line">    yum install -y java-1.8.0-openjdk maven curl git libtool-ltdl-devel &amp;&amp; \ </span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    rm -rf /var/cache/yum/* &amp;&amp; \</span><br><span class="line">    mkdir -p /usr/share/jenkins</span><br><span class="line">COPY settings.xml /etc/maven/settings.xml</span><br><span class="line">COPY kubectl helm /usr/bin/</span><br></pre></td></tr></table></figure>
<h1 id="部署k8s中的服务-kubectl"><a href="#部署k8s中的服务-kubectl" class="headerlink" title="部署k8s中的服务-kubectl"></a>部署k8s中的服务-kubectl</h1><p>项目地址：<a href="https://github.com/simple0426/tomcat-java-demo，需要注意的内容如下：" target="_blank" rel="noopener">https://github.com/simple0426/tomcat-java-demo，需要注意的内容如下：</a></p>
<ul>
<li>部署所需资源文件在k8s-yaml目录</li>
<li>需要保证有相关的命名空间【dev、test、prod】</li>
<li>部署的命名空间中含有连接harbor的secret信息</li>
<li>将ingress域名配置到主机hosts中</li>
</ul>
<p>部署所需Jenkinsfile如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // harbor地址</span><br><span class="line">def registry = &quot;www.unlazy.cn&quot;</span><br><span class="line">// gitlab地址</span><br><span class="line">def git_url = &quot;http://192.168.31.250:9080&quot; </span><br><span class="line">// 项目分组</span><br><span class="line">def project = &quot;test&quot;</span><br><span class="line">// 项目名称</span><br><span class="line">def app_name = &quot;tomcat-java-demo&quot;</span><br><span class="line">// 项目打包生成的镜像，BUILD_NUMBER为jenkins的内置变量，表示构建序列号</span><br><span class="line">def image_name = &quot;$&#123;registry&#125;/$&#123;project&#125;/$&#123;app_name&#125;:$&#123;BUILD_NUMBER&#125;&quot;</span><br><span class="line">// 项目git地址</span><br><span class="line">def git_address = &quot;$&#123;git_url&#125;/$&#123;project&#125;/$&#123;app_name&#125;.git&quot;</span><br><span class="line">// 部署deployment时需要使用的dockerregistry类型secret</span><br><span class="line">def k8s_dockerregistry_secret = &quot;registry-pull-secret&quot;</span><br><span class="line">// docker命令推送镜像使用的用户名和密码信息</span><br><span class="line">def dockerregistry_auth = &quot;3e8f2333-99a6-4367-8cf4-9b4bd5c2317f&quot;</span><br><span class="line">// 拉取git项目的用户名和密码信息</span><br><span class="line">def git_auth = &quot;e4cf739c-9ede-4469-822b-7e58d97c1869&quot;</span><br><span class="line">// 执行kubectl命令使用的kubeconfig文件</span><br><span class="line">def k8s_kubeconfig = &quot;35c55219-287f-41b9-b77b-2c4abaace04e&quot;</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    // 此处使用k8s的动态agent执行构建任务</span><br><span class="line">    kubernetes &#123;</span><br><span class="line">        yaml &quot;&quot;&quot;</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">spec:</span><br><span class="line">  containers: #特定任务容器</span><br><span class="line">  - name: maven</span><br><span class="line">    image: www.unlazy.cn/library/maven-kubectl:v1</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    command:</span><br><span class="line">    - sleep</span><br><span class="line">    args:</span><br><span class="line">    - infinity</span><br><span class="line">    volumeMounts: #容器内可以执行docker命令用于镜像构建</span><br><span class="line">      - name: docker-cmd</span><br><span class="line">        mountPath: /usr/bin/docker</span><br><span class="line">      - name: docker-sock</span><br><span class="line">        mountPath: /var/run/docker.sock</span><br><span class="line">      - name: maven-cache</span><br><span class="line">        mountPath: /root/.m2</span><br><span class="line">  volumes:</span><br><span class="line">    - name: docker-cmd</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /usr/bin/docker</span><br><span class="line">    - name: docker-sock</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /var/run/docker.sock</span><br><span class="line">    - name: maven-cache</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /tmp/m2</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        defaultContainer &apos;maven&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 参数化构建</span><br><span class="line">    parameters &#123;    </span><br><span class="line">        gitParameter branch: &apos;&apos;, branchFilter: &apos;.*&apos;, defaultValue: &apos;master&apos;, description: &apos;选择发布的分支&apos;, name: &apos;Branch&apos;, quickFilterEnabled: false, selectedValue: &apos;NONE&apos;, sortMode: &apos;NONE&apos;, tagFilter: &apos;*&apos;, type: &apos;PT_BRANCH&apos;</span><br><span class="line">        choice (choices: [&apos;1&apos;, &apos;3&apos;, &apos;5&apos;, &apos;7&apos;], description: &apos;副本数&apos;, name: &apos;ReplicaCount&apos;)</span><br><span class="line">        choice (choices: [&apos;dev&apos;,&apos;test&apos;,&apos;prod&apos;], description: &apos;命名空间&apos;, name: &apos;Namespace&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;拉取代码&apos;)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([$class: &apos;GitSCM&apos;, </span><br><span class="line">                branches: [[name: &quot;$&#123;params.Branch&#125;&quot;]], </span><br><span class="line">                doGenerateSubmoduleConfigurations: false, </span><br><span class="line">                extensions: [], submoduleCfg: [], </span><br><span class="line">                userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_address&#125;&quot;]]</span><br><span class="line">                ])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;代码编译&apos;)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh &quot;&quot;&quot;</span><br><span class="line">                mvn clean package -Dmaven.test.skip=true</span><br><span class="line">                &quot;&quot;&quot; </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;构建镜像&apos;)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: &quot;$&#123;dockerregistry_auth&#125;&quot;, passwordVariable: &apos;password&apos;, usernameVariable: &apos;username&apos;)]) &#123;</span><br><span class="line">                sh &quot;&quot;&quot;</span><br><span class="line">                  echo &apos;</span><br><span class="line">                    FROM tomcat:8.5.57</span><br><span class="line">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">                  &apos; &gt; Dockerfile</span><br><span class="line">                  docker build -t $&#123;image_name&#125; .</span><br><span class="line">                  docker login -u $&#123;username&#125; -p &apos;$&#123;password&#125;&apos; $&#123;registry&#125;</span><br><span class="line">                  docker push $&#123;image_name&#125;</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;部署到K8S平台&apos;)&#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              configFileProvider([configFile(fileId: &quot;$&#123;k8s_kubeconfig&#125;&quot;, targetLocation: &quot;admin.kubeconfig&quot;)])&#123;</span><br><span class="line">                sh &quot;&quot;&quot;</span><br><span class="line">                  sed -i &apos;s#IMAGE_NAME#$&#123;image_name&#125;#&apos; k8s-yaml/deployment.yaml</span><br><span class="line">                  sed -i &apos;s#SECRET_NAME#$&#123;k8s_dockerregistry_secret&#125;#&apos; k8s-yaml/deployment.yaml</span><br><span class="line">                  sed -i &apos;s#REPLICAS#$&#123;ReplicaCount&#125;#&apos; k8s-yaml/deployment.yaml</span><br><span class="line">                  kubectl apply -f k8s-yaml/ -n $&#123;Namespace&#125; --kubeconfig=admin.kubeconfig</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="部署k8s中的微服务-helm"><a href="#部署k8s中的微服务-helm" class="headerlink" title="部署k8s中的微服务-helm"></a>部署k8s中的微服务-helm</h1><h2 id="微服务部署要点"><a href="#微服务部署要点" class="headerlink" title="微服务部署要点"></a>微服务部署要点</h2><p>k8s中不同微服务的不同点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 命名空间</span><br><span class="line">2. 服务名称</span><br><span class="line">3. 服务端口</span><br><span class="line">4. 标签</span><br><span class="line">5. 镜像地址</span><br><span class="line">6. ingress域名</span><br><span class="line">7. 代码地址</span><br><span class="line">8. 副本数</span><br><span class="line">9. 环境变量</span><br></pre></td></tr></table></figure>
<p>通过模板参数化适配不同微服务</p>
<ul>
<li>jenkins创建的pipeline，能够接收参数匹配多个项目</li>
<li>helm创建的chart模板，可以接收自定义变量匹配多个项目</li>
</ul>
<h2 id="Jenkinsfile部署"><a href="#Jenkinsfile部署" class="headerlink" title="Jenkinsfile部署"></a>Jenkinsfile部署</h2><p>项目地址：<a href="https://github.com/simple0426/simple-microservice，需要注意的内容如下" target="_blank" rel="noopener">https://github.com/simple0426/simple-microservice，需要注意的内容如下</a></p>
<ul>
<li>在harbor的chartmuseum中导入模板ms：<a href="https://github.com/simple0426/simple-microservice/tree/dev3/ms" target="_blank" rel="noopener">https://github.com/simple0426/simple-microservice/tree/dev3/ms</a></li>
<li>需要先部署数据库、注册中心Eureka；此处的jenkins只负责gateway、order、portal、product、stock项目部署</li>
<li>将ingress域名配置到主机hosts中</li>
</ul>
<p>部署项目的Jenkinsfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env groovy</span><br><span class="line">// 所需插件: Git Parameter/Git/Pipeline/Config File Provider/kubernetes/Extended Choice Parameter</span><br><span class="line">// 公共</span><br><span class="line">def registry = &quot;www.unlazy.cn&quot;</span><br><span class="line">def git_url = &quot;http://192.168.31.250:9080&quot; </span><br><span class="line">// 项目</span><br><span class="line">def project = &quot;microservice&quot;</span><br><span class="line">def app_name = &quot;microservice&quot;</span><br><span class="line"></span><br><span class="line">def git_address = &quot;$&#123;git_url&#125;/$&#123;project&#125;/$&#123;app_name&#125;.git&quot;</span><br><span class="line">def gateway_domain_name = &quot;gateway.ctnrs.com&quot;</span><br><span class="line">def portal_domain_name = &quot;portal.ctnrs.com&quot;</span><br><span class="line">// 认证</span><br><span class="line">def image_pull_secret = &quot;registry-pull-secret&quot;</span><br><span class="line">def harbor_registry_auth = &quot;d0d9b572-80e3-4347-a627-0486038b99f9&quot;</span><br><span class="line">def git_auth = &quot;32c9f547-1a26-4fbc-9e30-617e217334b6&quot;</span><br><span class="line">// ConfigFileProvider ID</span><br><span class="line">def k8s_auth = &quot;9b502bf9-4d4d-405d-8559-8f9c691e072e&quot;</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    // 此处使用k8s的动态agent执行构建任务</span><br><span class="line">    kubernetes &#123;</span><br><span class="line">        yaml &quot;&quot;&quot;</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">spec:</span><br><span class="line">  containers: #特定任务容器</span><br><span class="line">  - name: maven</span><br><span class="line">    image: www.unlazy.cn/library/agent-k8s:v1</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    command:</span><br><span class="line">    - sleep</span><br><span class="line">    args:</span><br><span class="line">    - infinity</span><br><span class="line">    volumeMounts: #容器内可以执行docker命令用于镜像构建</span><br><span class="line">      - name: docker-cmd</span><br><span class="line">        mountPath: /usr/bin/docker</span><br><span class="line">      - name: docker-sock</span><br><span class="line">        mountPath: /var/run/docker.sock</span><br><span class="line">      - name: maven-cache</span><br><span class="line">        mountPath: /root/.m2</span><br><span class="line">  volumes:</span><br><span class="line">    - name: docker-cmd</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /usr/bin/docker</span><br><span class="line">    - name: docker-sock</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /var/run/docker.sock</span><br><span class="line">    - name: maven-cache</span><br><span class="line">      hostPath:</span><br><span class="line">        path: /tmp/m2</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        defaultContainer &apos;maven&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        gitParameter branch: &apos;&apos;, branchFilter: &apos;.*&apos;, defaultValue: &apos;master&apos;, description: &apos;选择发布的分支&apos;, name: &apos;Branch&apos;, quickFilterEnabled: false, selectedValue: &apos;NONE&apos;, sortMode: &apos;NONE&apos;, tagFilter: &apos;*&apos;, type: &apos;PT_BRANCH&apos;        </span><br><span class="line">        extendedChoice defaultValue: &apos;none&apos;, description: &apos;选择发布的微服务&apos;, \</span><br><span class="line">          multiSelectDelimiter: &apos;,&apos;, name: &apos;Service&apos;, type: &apos;PT_CHECKBOX&apos;, \</span><br><span class="line">          value: &apos;gateway-service:9999,portal-service:8080,product-service:8010,order-service:8020,stock-service:8030&apos;</span><br><span class="line">        choice (choices: [&apos;ms&apos;, &apos;demo&apos;], description: &apos;部署模板&apos;, name: &apos;Template&apos;)</span><br><span class="line">        choice (choices: [&apos;1&apos;, &apos;3&apos;, &apos;5&apos;, &apos;7&apos;], description: &apos;副本数&apos;, name: &apos;ReplicaCount&apos;)</span><br><span class="line">        choice (choices: [&apos;ms&apos;], description: &apos;命名空间&apos;, name: &apos;Namespace&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;拉取代码&apos;)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([$class: &apos;GitSCM&apos;, </span><br><span class="line">                branches: [[name: &quot;$&#123;params.Branch&#125;&quot;]], </span><br><span class="line">                doGenerateSubmoduleConfigurations: false, </span><br><span class="line">                extensions: [], submoduleCfg: [], </span><br><span class="line">                userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_address&#125;&quot;]]</span><br><span class="line">                ])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;代码编译&apos;) &#123;</span><br><span class="line">            // 编译指定服务</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &quot;&quot;&quot;</span><br><span class="line">                  mvn clean package -Dmaven.test.skip=true</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;构建镜像&apos;) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_registry_auth&#125;&quot;, passwordVariable: &apos;password&apos;, usernameVariable: &apos;username&apos;)]) &#123;</span><br><span class="line">                sh &quot;&quot;&quot;</span><br><span class="line">                 docker login -u $&#123;username&#125; -p &apos;$&#123;password&#125;&apos; $&#123;registry&#125;</span><br><span class="line">                 for service in \$(echo $&#123;Service&#125; |sed &apos;s/,/ /g&apos;); do</span><br><span class="line">                    service_name=\$&#123;service%:*&#125;</span><br><span class="line">                    image_name=$&#123;registry&#125;/$&#123;project&#125;/\$&#123;service_name&#125;:$&#123;BUILD_NUMBER&#125;</span><br><span class="line">                    cd \$&#123;service_name&#125;</span><br><span class="line">                    if ls |grep biz &amp;&gt;/dev/null; then</span><br><span class="line">                        cd \$&#123;service_name&#125;-biz</span><br><span class="line">                    fi</span><br><span class="line">                    docker build -t \$&#123;image_name&#125; .</span><br><span class="line">                    docker push \$&#123;image_name&#125;</span><br><span class="line">                    cd $&#123;WORKSPACE&#125;</span><br><span class="line">                  done</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">                configFileProvider([configFile(fileId: &quot;$&#123;k8s_auth&#125;&quot;, targetLocation: &quot;admin.kubeconfig&quot;)])&#123;</span><br><span class="line">                    sh &quot;&quot;&quot;</span><br><span class="line">                    # 添加镜像拉取认证</span><br><span class="line">                    kubectl create secret docker-registry $&#123;image_pull_secret&#125; --docker-username=$&#123;username&#125; --docker-password=$&#123;password&#125; --docker-server=$&#123;registry&#125; -n $&#123;Namespace&#125; --kubeconfig admin.kubeconfig |true</span><br><span class="line">                    # 添加私有chart仓库</span><br><span class="line">                    helm repo add  --username $&#123;username&#125; --password $&#123;password&#125; myrepo https://$&#123;registry&#125;/chartrepo/$&#123;project&#125;</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Helm部署到K8S&apos;) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              sh &quot;&quot;&quot;</span><br><span class="line">              common_args=&quot;-n $&#123;Namespace&#125; --kubeconfig admin.kubeconfig&quot;</span><br><span class="line">              </span><br><span class="line">              for service in  \$(echo $&#123;Service&#125; |sed &apos;s/,/ /g&apos;); do</span><br><span class="line">                service_name=\$&#123;service%:*&#125;</span><br><span class="line">                service_port=\$&#123;service#*:&#125;</span><br><span class="line">                image=$&#123;registry&#125;/$&#123;project&#125;/\$&#123;service_name&#125;</span><br><span class="line">                tag=$&#123;BUILD_NUMBER&#125;</span><br><span class="line">                helm_args=&quot;\$&#123;service_name&#125; --set image.repository=\$&#123;image&#125; --set image.tag=\$&#123;tag&#125; --set replicaCount=$&#123;replicaCount&#125; --set imagePullSecrets[0].name=$&#123;image_pull_secret&#125; --set service.targetPort=\$&#123;service_port&#125; myrepo/$&#123;Template&#125;&quot;</span><br><span class="line"></span><br><span class="line">                # 判断是否为新部署</span><br><span class="line">                if helm history \$&#123;service_name&#125; \$&#123;common_args&#125; &amp;&gt;/dev/null;then</span><br><span class="line">                  action=upgrade</span><br><span class="line">                else</span><br><span class="line">                  action=install</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                # 针对服务启用ingress</span><br><span class="line">                if [ \$&#123;service_name&#125; == &quot;gateway-service&quot; ]; then</span><br><span class="line">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \</span><br><span class="line">                  --set ingress.enabled=true \</span><br><span class="line">                  --set ingress.host=$&#123;gateway_domain_name&#125; \</span><br><span class="line">                   \$&#123;common_args&#125;</span><br><span class="line">                elif [ \$&#123;service_name&#125; == &quot;portal-service&quot; ]; then</span><br><span class="line">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \</span><br><span class="line">                  --set ingress.enabled=true \</span><br><span class="line">                  --set ingress.host=$&#123;portal_domain_name&#125; \</span><br><span class="line">                   \$&#123;common_args&#125;</span><br><span class="line">                else</span><br><span class="line">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \$&#123;common_args&#125;</span><br><span class="line">                fi</span><br><span class="line">              done</span><br><span class="line">              # 查看Pod状态</span><br><span class="line">              sleep 10</span><br><span class="line">              kubectl get pods \$&#123;common_args&#125;</span><br><span class="line">              &quot;&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet认证-TLS-Bootstrapping</title>
    <url>/blog/2020/08/11/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubelet%E8%AE%A4%E8%AF%81-TLS-Bootstrapping/</url>
    <content><![CDATA[<h1 id="TLS-Bootstrapping简介"><a href="#TLS-Bootstrapping简介" class="headerlink" title="TLS-Bootstrapping简介"></a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">TLS-Bootstrapping</a>简介</h1><p>新的工作节点加入集群时需要配置相关的私钥和证书，可以由管理员手动配置，也可以让kubelet自行生成相关的私钥和证书<br>但是集群规模扩大后，手动配置会增加管理员工作量，kubelet自动配置则会降低PKI本身的优势<br>结合这两种方式，kubernetes提出了新方案(TLS Bootstrapping)：由kubelet自行生成私钥和证书签名请求<br>然后向集群的证书签署进程(CA)发起请求，获取的证书和已有的私钥文件共同存储于kubelet客户端以用于后续的通信<br>但是，这样一来就认证和非认证的kubelet客户端都会发起证书签名请求，为了控制仅那些认证的客户端可以发起请求，就需要使用令牌机制(bootstrap token)来确认认证的客户端<br>APIserver使用基于认证令牌对“system:bootstrappers”组内用户完成认证<br>controller-manager会用到这个组的默认审批控制器来决定是否颁发证书，它依赖于由管理员将此token绑定于合适的RBAC策略，以限制其仅用于签证操作  </p>
<h1 id="apiserver"><a href="#apiserver" class="headerlink" title="apiserver"></a>apiserver</h1><ul>
<li><p>配置项 </p>
<ul>
<li>–enable-bootstrap-token-auth：开启bootstrap认证</li>
<li>–token-auth-file：bootstrap token文件</li>
<li>–client-ca-file=FILENAME：开启客户端证书认证，指定客户端证书的根证书机构（ca证书）</li>
<li>–tls-cert-file</li>
<li>–tls-private-key-file：如果apiserver开启https服务，则需要指定私钥和证书【由ca颁发的证书】</li>
</ul>
</li>
<li><p>token文件范例：<code>02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&quot;system:bootstrappers&quot;</code></p>
</li>
<li><p>授权kubelet可以创建证书签名请求</p>
<ul>
<li><p>基于kubelet-bootstrap用户</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于system:bootstrappers组</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># enable bootstrapping nodes to create CSR</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: create-csrs-for-bootstrapping</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: system:bootstrappers</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:node-bootstrapper</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller-manager"></a>controller-manager</h1><ul>
<li><p>配置项</p>
<ul>
<li>–cluster-signing-cert-file</li>
<li>–cluster-signing-key-file：用于颁发集群范围内证书的ca证书</li>
<li>–root-ca-file：根ca证书，此根证书颁发机构将包含在服务帐户的令牌密钥中</li>
</ul>
</li>
<li><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#approval" target="_blank" rel="noopener">批准kubelet证书请求</a></p>
<ul>
<li><p>手动批准证书签名请求</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br><span class="line">kubectl certificate approve &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动批准首次申请证书的 CSR 请求(基于[system:bootstrappers]组用户)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Approve all CSRs for the group &quot;system:bootstrappers&quot;</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: auto-approve-csrs-for-group</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: system:bootstrappers</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动批准kubelet客户端证书续签</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Approve renewal CSRs for the group &quot;system:nodes&quot;</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: auto-approve-renewals-for-nodes</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: system:nodes</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动批准kubelet服务端证书续签(kubelet暴露https接口作为服务端)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding node-server-auto-renew-crt --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeserver --group=system:nodes</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h1><ul>
<li>配置项<ul>
<li>–bootstrap-kubeconfig：bootstrap的kubeconfig配置，主要包含bootstrap token</li>
<li>–kubeconfig：kubelet和apiserver通信的kubeconfig配置</li>
<li>–cert-dir：bootstrap获取的证书和原有的私钥文件的存储位置</li>
<li>–rotate-certificates：允许kubelet客户端证书过期前发起续签请求</li>
<li>–rotate-server-certificates：允许kubelet作为服务端，在其证书过期前发起续签请求</li>
</ul>
</li>
<li>配置bootstrap-kubeconfig<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server=&apos;https://my.server.example.com:6443&apos; --certificate-authority=/var/lib/kubernetes/ca.pem</span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d</span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap</span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="kubelet证书续签-kubeadm范例"><a href="#kubelet证书续签-kubeadm范例" class="headerlink" title="kubelet证书续签-kubeadm范例"></a>kubelet证书续签-kubeadm范例</h1><ul>
<li><p>kube-controller-manager组件【/etc/kubernetes/manifests/kube-controller-manager.yaml】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--experimental-cluster-signing-duration=87600h0m0s  #kubelet证书有效期</span><br><span class="line">--feature-gates=RotateKubeletServerCertificate=true #默认设置，启用服务端证书轮转</span><br><span class="line">--feature-gates=RotateKubeletClientCertificate=true #默认设置，启用客户端证书轮转</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubelet组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerTLSBootstrap: true #开启kubelet服务端证书续签</span><br><span class="line">rotateCertificates: true #默认设置，开启kubelet客户端证书续签</span><br></pre></td></tr></table></figure>
</li>
<li><p>rbac设置【clusterrolebinding】</p>
<ul>
<li>kubeadm:kubelet-bootstrap【默认】：授权kubelet可以创建证书签名请求</li>
<li>kubeadm:node-autoapprove-bootstrap【默认】：自动批准首次申请证书的 CSR 请求</li>
<li>kubeadm:node-autoapprove-certificate-rotation【默认】：自动批准kubelet客户端证书续签</li>
<li><code>kubectl create clusterrolebinding node-server-auto-renew-crt --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeserver --group=system:nodes</code>：自动批准kubelet服务端证书续签</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>TLS-Bootstrapping</tag>
        <tag>证书续签</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-pod控制器</title>
    <url>/blog/2020/02/24/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-pod%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="pod控制器"><a href="#pod控制器" class="headerlink" title="pod控制器"></a>pod控制器</h1><h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><ul>
<li>自主式pod被调度到节点后，由kubelet负责容器的存活性；<ul>
<li>容器主进程崩溃后，kubelet自动重启相应的容器；</li>
<li>非主进程崩溃类型的容器错误，需要用户自定义存活性探测(liveness probe),以便kubelet可以探测到此类故障</li>
</ul>
</li>
<li>pod意外删除或节点故障，需要节点以外的pod控制器负责其重建</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>pod控制器由master的kube-controller-manager组件提供，确保各资源的当前状态(status)匹配用户期望的状态(spec)</li>
<li>常见控制器(workload)：ReplicationController、Replicaset、Deployment、Daemonset、Job、CronJob、Statefulset</li>
</ul>
<h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><ul>
<li>selector：标签选择器</li>
<li>replicas：期望的副本数量；scale命令支持对Deployment, ReplicaSet, Replication Controller, or StatefulSet进行扩容、缩容</li>
<li>template：pod模板</li>
<li>minReadySeconds：新建pod等待多久才会将其视为就绪可用</li>
</ul>
<h1 id="Replicaset"><a href="#Replicaset" class="headerlink" title="Replicaset"></a>Replicaset</h1><p>它是新版本的ReplicationController，相较于RC，它支持基于集合的标签选择器(set-based)</p>
<h2 id="与自主式pod区别"><a href="#与自主式pod区别" class="headerlink" title="与自主式pod区别"></a>与自主式pod区别</h2><ul>
<li>确保pod资源对象数量符合期望值</li>
<li>确保pod健康运行(节点故障时被调度到其他节点运行)</li>
<li>弹性伸缩</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: rs-example</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2 #副本数</span><br><span class="line">  selector: #pod模板选择器，包含mathLabels和matchExpressions两种</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: rs-demo</span><br><span class="line">  template: # pod模板</span><br><span class="line">    metadata:</span><br><span class="line">      labels: #模板标签</span><br><span class="line">        app: rs-demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp</span><br><span class="line">        image: ikubernetes/myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br></pre></td></tr></table></figure>
<h2 id="变更操作"><a href="#变更操作" class="headerlink" title="变更操作"></a>变更操作</h2><blockquote>
<p>均可以通过修改资源文件，使用命令kubectl apply/replace应用修改</p>
</blockquote>
<ul>
<li>副本数量<ul>
<li>影响：可以随时修改，并能实时生效</li>
<li>命令：<code>kubectl scale  rs rs-example --replicas=5 --current-replicas=3</code></li>
</ul>
</li>
<li>标签选择器【一般不操作】<ul>
<li>影响：修改后，可能会影响控制器和pod对象的映射关系，使pod对象不受控制器管理</li>
<li>命令：<code>kubectl label pod rs-example-5s745 app= --overwrite</code></li>
</ul>
</li>
<li>pod模板<ul>
<li>影响：修改后，仅对新建的pod副本有影响</li>
<li>修改镜像文件命令：<code>kubectl set image rs rs-example  myapp=ikubernetes/myapp:v2</code></li>
</ul>
</li>
</ul>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s-deployment.jpg" alt></p>
<ul>
<li>Deployment构建于replicaset之上，大部分功能由replicaset控制器实现，Deployment管理不同版本的replicaset</li>
<li>相较于Replicaset，新增的功能有：<ul>
<li>可以查看Deployment对象的升级过程</li>
<li>可以保存对Deployment的每一次修改，出现问题时可以执行回滚操作</li>
<li>可以随时暂停和启动更新</li>
<li>多种自动更新方案<ul>
<li>Recreate：全面停止、删除旧的pod后用新版本替代</li>
<li>RollingUpdate：滚动更新，逐步替换旧的pod至新版本</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关键配置项"><a href="#关键配置项" class="headerlink" title="关键配置项"></a>关键配置项</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec字段</span><br><span class="line">  - revisionHistoryLimit: 保留历史revision数量</span><br><span class="line">  - progressDeadlineSeconds: 判断Deployment status condition为failed的最大时间</span><br><span class="line">strategy:</span><br><span class="line">  rollingUpdate:</span><br><span class="line">    maxSurge: 25% 升级过程中最多存在多少个超过期望数量的pod</span><br><span class="line">    maxUnavailable: 25% 升级过程中最多有多少个pod不可用</span><br><span class="line">  type: RollingUpdate【升级策略】</span><br></pre></td></tr></table></figure>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1 </span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:       #Deployment元信息</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3       #期望的pod数量</span><br><span class="line">  selector:         #pod选择器</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:      #pod模板</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.12.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<h2 id="变更操作-1"><a href="#变更操作-1" class="headerlink" title="变更操作"></a>变更操作</h2><ul>
<li>滚动更新镜像：<code>kubectl set image deployment nginx-deployment nginx=nginx:1.13</code></li>
<li>金丝雀部署：<ol>
<li>设置maxSurge=1，maxUnavailable确保升级过程中仅生成一个新的pod</li>
<li>在升级镜像之后，暂停更新：<code>kubectl set image deployment nginx-deployment nginx=nginx:1.13 &amp;&amp; kubectl rollout pause deploy nginx-deployment</code></li>
<li>通过service或ingress及相关策略路由将一部分流量导入新的pod进行验证</li>
<li>验证通过后恢复滚动升级：<code>kubectl rollout resume deploy nginx-deployment</code></li>
</ol>
</li>
<li>查看滚动更新状态:<code>kubectl rollout status deploy nginx-deployment</code></li>
<li>回滚镜像到上一版本：<code>kubectl rollout undo deployment nginx-deployment</code></li>
<li>扩容缩容：<code>kubectl scale --replicas=2 deployment/nginx-deployment</code></li>
</ul>
<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p>相当于linux系统下的一次性任务at</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>创建一定数量的pod，并保证可以成功地运行终止</li>
<li>跟踪pod状态，并根据重试策略进行失败重试</li>
<li>确定依赖关系，保证任务依次执行</li>
<li>控制任务并发度</li>
</ul>
<h2 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h2><ul>
<li><p>一次性任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job #job类型</span><br><span class="line">metadata: #元信息</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template: #pod模板</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi</span><br><span class="line">        image: perl:slim</span><br><span class="line">        command: [&quot;perl&quot;, &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]</span><br><span class="line">      restartPolicy: Never # 重试策略，其他类型为：Onfailure、Always</span><br><span class="line">  backoffLimit: 4 #重试次数</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: paral</span><br><span class="line">spec:</span><br><span class="line">  completions: 8 #执行的pod总数</span><br><span class="line">  parallelism: 2 #并行执行的pod数</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: param </span><br><span class="line">        image: ubuntu</span><br><span class="line">        command: [&quot;/bin/sh&quot;]</span><br><span class="line">        args: [&quot;-c&quot;, &quot;sleep 30; date&quot;]</span><br><span class="line">      restartPolicy: OnFailure #失败重启</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h1><p>周期性任务,相当于linux中的crontab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  schedule: &quot;*/1 * * * *&quot; #周期参数，与crontab相同</span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - date; echo Hello from the kubernetes cluster</span><br><span class="line">          restartPolicy: OnFailure</span><br><span class="line">  startingDeadlineSeconds: 10 #最长启动时间</span><br><span class="line">  concurrencyPolicy: Allow #是否允许并行运行(解决情况：任务的执行时间超过周期间隔)</span><br><span class="line">  successfulJobsHistoryLimit: 3 #允许留存的成功job数</span><br></pre></td></tr></table></figure>
<h1 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h1><p>相当于linux的守护进程，例如supervisor</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>保证集群中的每个节点都运行一个相同的pod</li>
<li>节点加入或删除时，节点部署或删除对应的pod</li>
<li>应用场景<ul>
<li>集群存储进程：glusterd，ceph</li>
<li>日志收集进程：fluentd，logstash</li>
<li>节点状态监控进程</li>
</ul>
</li>
</ul>
<h2 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h2><ul>
<li><p>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: fluentd-elasticsearch</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: fluentd-logging</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: fluentd-elasticsearch</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: fluentd-elasticsearch</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: fluentd-elasticsearch</span><br><span class="line">        image: fluent/fluentd:v1.4-1</span><br><span class="line">        resources: #资源设置</span><br><span class="line">          limits:</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m #相当于0.1cpu</span><br><span class="line">            memory: 200Mi</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新镜像：kubectl set image ds/fluentd-elasticsearch fluentd-elasticsearch=fluent/fluentd:v1.4</p>
</li>
<li>回滚：kubectl rollout undo ds/fluentd-elasticsearch</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>Deployment</tag>
        <tag>Job</tag>
        <tag>CronJob</tag>
        <tag>DaemonSet</tag>
        <tag>Replicaset</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-pod资源调度</title>
    <url>/blog/2020/03/24/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-pod%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="创建pod流程"><a href="#创建pod流程" class="headerlink" title="创建pod流程"></a>创建pod流程</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s-module-interact.jpg" alt></p>
<ul>
<li>用户通过UI或CLI提交一个pod给API Server进行部署</li>
<li>API Server将信息写入etcd存储</li>
<li>Scheduler通过API Server的watch或notification机制获取这个信息</li>
<li>Scheduler通过资源使用情况进行调度决策(pod在哪个节点部署)，并把决策信息返回给API server</li>
<li>API server将决策结果写入etcd</li>
<li>API server通知相应的节点进行pod部署</li>
<li>相应节点的kubelet得到通知后，调用container runtime启动容器、调度存储插件配置存储、调度网络插件配置网络</li>
</ul>
<h1 id="pod调度器"><a href="#pod调度器" class="headerlink" title="pod调度器"></a>pod调度器</h1><ul>
<li>apiserver接收用户创建pod对象请求后，调度器会从集群中选择一个可用的最佳节点来运行它  </li>
<li>kube-scheduler是默认的调度器  </li>
<li>用户也可以自定义调度器插件，并在定义pod对象时通过spec.schedulerName指定</li>
</ul>
<h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><ul>
<li><a href="#节点过滤规则">预选</a>：基于过滤条件，过滤可行的节点</li>
<li><a href="#优先级排序规则">优选</a>：基于不同的度量因子对可行的节点进行优先级排序</li>
<li>选择：选择优先级最高的节点来运行pod对象</li>
</ul>
<h2 id="影响调度因素"><a href="#影响调度因素" class="headerlink" title="影响调度因素"></a>影响调度因素</h2><ul>
<li>单个pod或所有pod的资源要求：cpu、内存等资源要求</li>
<li>硬件、软件、策略约束：pod只能运行在特定节点；pod对特定硬件的要求（SSD、GPU）</li>
<li>亲和性、反亲和性要求</li>
<li>数据存储位置：某些存储卷只能某些区域加载使用</li>
<li>工作负载间的相互干扰</li>
</ul>
<h2 id="节点过滤规则"><a href="#节点过滤规则" class="headerlink" title="节点过滤规则"></a>节点过滤规则</h2><ul>
<li>PodFitsHostPorts：检查节点端口是否满足pod需求</li>
<li>PodFitsHost：检查节点主机名（hostname）是佛满足pod需求</li>
<li>PodFitsResources：检查节点是否有可用资源（cpu、内存）满足pod需求</li>
<li>PodMatchNodeSelector：检查pod的节点选择器是否匹配节点标签</li>
<li>NoVolumeZoneConflict：在给定区域(zone)上，检查pod要求的存储卷在节点上是否可用</li>
<li>NoDiskConflict：在给定的节点上，检查pod要求的存储卷是否可用；如果这个节点已经挂载了卷，其他使用这个卷的pod不能调度到这个节点上</li>
<li>MaxCSIVolumeCount:单个节点最多可以挂载多少个CSI存储卷</li>
<li>CheckNodeMemoryPressure：检测节点内存压力</li>
<li>CheckNodePIDPressure：检测节点PID压力</li>
<li>CheckNodeDiskPressure：检测节点磁盘压力（文件系统满或接近满）</li>
<li>CheckNodeCondition：检测节点在下列情况是否可用<ul>
<li>文件系统满</li>
<li>网络不可达</li>
<li>kubelet还没准备好调度pod</li>
</ul>
</li>
<li>PodToleratesNodeTaints:检测pod的容忍度是否可以容忍节点的污点</li>
<li>CheckVolumeBinding：检查节点上已绑定或未绑定的PVC是否满足pod对存储的需求</li>
</ul>
<h2 id="优先级排序规则"><a href="#优先级排序规则" class="headerlink" title="优先级排序规则"></a>优先级排序规则</h2><ul>
<li>SelectorSpreadPriority：是否可以将service、statefulset、replicaset所属的pod对象扩展到尽可能多的节点</li>
<li>InterPodAffinityPriority：遍历pod对象的亲和性条目，并将那些能够匹配到给定节点的条目的权重相加，结果值越大的节点得分越高</li>
<li>LeastRequestedPriority：request越少得分越高，比较倾向于让pod分配到空闲的机器上</li>
<li>MostRequestedPriority：request越多得分越高，比较倾向于尽量压慢一台机器，避免过多碎片化</li>
<li>RequestedToCapacityRatioPriority：按照请求和容量的比例记分</li>
<li>BalancedResourceAllocation：cpu、内存使用更均衡的节点得分更高</li>
<li>NodePreferAvoidPodsPriority：根据节点是否设置了注解【scheduler.alpha.kubernetes.io/preferAvoidPods】；使用这个选项，可以标识哪些pod不能运行在同一个节点上</li>
<li>NodeAffinityPriority：使用基于【PreferredDuringSchedulingIgnoredDuringExecution】的节点亲和性偏好进行优先级排序；匹配的条目越多，权重越高，得分也越高</li>
<li>TaintTolerationPriority：根据节点上无法容忍的污点数量对节点进行排序 </li>
<li>ImageLocalityPriority：节点上存在pod对象要求的镜像时，得分高</li>
<li>ServiceSpreadingPriority：service的pod可以尽可能多的部署在不同节点</li>
<li>CalculateAntiAffinityPriorityMap：计算pod的反亲和性优先级</li>
<li>EqualPriorityMap：给所有的节点相同的权重</li>
</ul>
<h1 id="节点选择-nodeName"><a href="#节点选择-nodeName" class="headerlink" title="节点选择-nodeName"></a>节点选择-nodeName</h1><ul>
<li>位置：spec.nodeName</li>
<li>功能：以下两者功能相同<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodeName: minikube</span><br><span class="line">nodeSelector:</span><br><span class="line">  - kubernetes.io/hostname=minikube</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="节点选择器-nodeSelector"><a href="#节点选择器-nodeSelector" class="headerlink" title="节点选择器-nodeSelector"></a>节点选择器-nodeSelector</h1><p>将pod调度至特定节点运行</p>
<h2 id="节点标签定义"><a href="#节点标签定义" class="headerlink" title="节点标签定义"></a>节点标签定义</h2><ul>
<li>定义：kubectl label nodes minikube minikube=yes</li>
<li>查看：kubectl get node –show-labels</li>
</ul>
<h2 id="内置节点标签"><a href="#内置节点标签" class="headerlink" title="内置节点标签"></a><a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#built-in-node-labels" target="_blank" rel="noopener">内置节点标签</a></h2><ul>
<li>kubernetes.io/os=linux：操作系统类型</li>
<li>kubernetes.io/hostname=minikube：节点主机名</li>
</ul>
<h2 id="pod定义nodeSelector"><a href="#pod定义nodeSelector" class="headerlink" title="pod定义nodeSelector"></a>pod定义nodeSelector</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    hostname: node2</span><br></pre></td></tr></table></figure>
<h1 id="节点亲和调度"><a href="#节点亲和调度" class="headerlink" title="节点亲和调度"></a>节点亲和调度</h1><p>通过在节点定义标签，在pod对象上指定标签选择器来确定pod的运行位置</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>硬亲和性（required）：pod对象调度时必须满足的规则，不满足时pod处于pending状态</li>
<li>软亲和性（preferred）：pod对象调度时应当遵守的规则</li>
</ul>
<p>注意事项：IgnoredDuringExecution，在基于节点亲和性完成pod调度后，节点标签变更也不会将pod对象从节点移出，它只对新建的pod对象生效。</p>
<h2 id="硬亲和性"><a href="#硬亲和性" class="headerlink" title="硬亲和性"></a>硬亲和性</h2><p>将pod调度到拥有zone标签且其值为foo的节点上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values: [&quot;foo&quot;]</span><br></pre></td></tr></table></figure></p>
<h2 id="软亲和性"><a href="#软亲和性" class="headerlink" title="软亲和性"></a>软亲和性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 60</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">            - key: zone</span><br><span class="line">              operator: In</span><br><span class="line">              values: [&quot;foo&quot;]</span><br><span class="line">      - weight: 30</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">            - key: ssd</span><br><span class="line">              operator: Exists</span><br><span class="line">              values: []</span><br></pre></td></tr></table></figure>
<h1 id="pod资源亲和调度"><a href="#pod资源亲和调度" class="headerlink" title="pod资源亲和调度"></a>pod资源亲和调度</h1><ul>
<li>亲和性：基于某些需求，需要把某些pod资源部署在相近的位置，此时这些pod资源间具有亲和性(affinity)  </li>
<li>反亲和性：相反，需要把一些pod隔离开分散部署，此时这些资源具有反亲和性(anti-affinity)  </li>
</ul>
<p>先使用标签选择器选出与之关联的pod对象，然后基于某种关系(topologyKey)将部署的pod和已存在的pod进行相近部署或分散部署</p>
<h2 id="硬亲和性-1"><a href="#硬亲和性-1" class="headerlink" title="硬亲和性"></a>硬亲和性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">            - key: app</span><br><span class="line">              operator: In</span><br><span class="line">              values: [&quot;cirros&quot;]</span><br><span class="line">        topologyKey: kubernetes.io/hostname</span><br></pre></td></tr></table></figure>
<h2 id="软亲和性-1"><a href="#软亲和性-1" class="headerlink" title="软亲和性"></a>软亲和性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 80</span><br><span class="line">        podAffinityTerm:</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">              - key: app</span><br><span class="line">                operator: In</span><br><span class="line">                values: [&quot;cache&quot;]</span><br><span class="line">          topologyKey: zone</span><br><span class="line">      - weight: 20</span><br><span class="line">        podAffinityTerm:</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">              - key: app</span><br><span class="line">                operator: In</span><br><span class="line">                values: [&quot;db&quot;]</span><br><span class="line">          topologyKey: zone</span><br></pre></td></tr></table></figure>
<h2 id="反亲和性"><a href="#反亲和性" class="headerlink" title="反亲和性"></a>反亲和性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">            - key: app</span><br><span class="line">              operator: In</span><br><span class="line">              values: [&quot;myapp&quot;]</span><br><span class="line">        topologyKey: kubernetes.io/hostname</span><br></pre></td></tr></table></figure>
<h1 id="污点和容忍度"><a href="#污点和容忍度" class="headerlink" title="污点和容忍度"></a>污点和容忍度</h1><ul>
<li>污点（taint）：是定义在节点上的键值对，用于让节点拒绝将pod部署于其上，除非该pod对象具有接纳该污点的容忍度</li>
<li>容忍度（toleration）：是定义在pod对象之上的键值对，用于配置其可以容忍的节点污点，而且调度器仅能将pod对象调度至能容忍该污点的节点上</li>
</ul>
<h2 id="污点和容忍度语法"><a href="#污点和容忍度语法" class="headerlink" title="污点和容忍度语法"></a>污点和容忍度语法</h2><ul>
<li>污点定义在节点node.spec，容忍度定义在pod的pod.spec</li>
<li>他们都是键值对型数据，语法：key=value:effect</li>
<li>effect定义对pod对象的排斥等级<ul>
<li>NoSchedule：不能容忍此污点的pod对象不能调度到此节点</li>
<li>PreferNoSchedule：不能容忍此污点的pod对象可以调度到此节点</li>
<li>NoExecute：不能容忍此污点的pod对象不能调度到此节点，pod对象的容忍度或节点的污点变动时，pod对象将被驱逐</li>
</ul>
</li>
<li>pod定义容忍度，支持两种操作符（operator）<ul>
<li>Equal：容忍度和污点在key、value、effect完全相同</li>
<li>Exists：容忍度和污点在key、effect完全匹配，容忍度中的value字段要使用空值</li>
</ul>
</li>
<li>一个节点可以有多个污点，一个pod对象也可以有多个容忍度</li>
</ul>
<h2 id="管理节点的污点"><a href="#管理节点的污点" class="headerlink" title="管理节点的污点"></a>管理节点的污点</h2><ul>
<li>添加污点：kubectl taint node node1 node-type=prod:NoSchedule</li>
<li>查看污点：kubectl describe node node01|grep -i taint</li>
<li>删除key的不同effect：kubectl taint node node1 node-type:PreferNoSchedule-</li>
<li>删除key：kubectl taint node node1 node-type-</li>
</ul>
<h2 id="pod对象容忍度"><a href="#pod对象容忍度" class="headerlink" title="pod对象容忍度"></a>pod对象容忍度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  tolerations:</span><br><span class="line">  - key: &quot;key1&quot;</span><br><span class="line">    operator: &quot;Equal&quot;</span><br><span class="line">    value: &quot;value1&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">  - key: &quot;key1&quot;</span><br><span class="line">    operator: &quot;Exists&quot;</span><br><span class="line">    effect: &quot;NoExecute&quot;</span><br><span class="line">    tolerationSeconds: 3600</span><br></pre></td></tr></table></figure>
<h2 id="问题节点标识"><a href="#问题节点标识" class="headerlink" title="问题节点标识"></a>问题节点标识</h2><p>当节点出现问题时，节点控制器自动为节点添加污点信息，使用NoExecute标识</p>
<ul>
<li>node.kubernetes.io/not-ready：节点进入“NotReady”状态时被自动添加</li>
<li>node.kubernetes.io/unreachable：节点进入“NotReachable”状态时被自动添加</li>
<li>node.kubernetes.io/out-of-disk：节点进入“OutOfDisk”状态时被自动添加</li>
<li>node.kubernetes.io/memory-pressure：节点内存压力</li>
<li>node.kubernetes.io/disk-pressure：节点磁盘压力</li>
<li>node.kubernetes.io/network-unavailable：节点网络不可达</li>
<li>node.kubernetes.io/unschedulable：节点不可调度</li>
<li>node.cloudprovider.kubernetes.io/uninitialized：kubelet由外部云环境启动时，它将自动为节点添加此污点；待到云控制器管理器中的控制器初始化此节点时再将其删除</li>
</ul>
<h1 id="pod优先级和抢占"><a href="#pod优先级和抢占" class="headerlink" title="pod优先级和抢占"></a>pod优先级和抢占</h1><p><a href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/" target="_blank" rel="noopener">待续</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>污点</tag>
        <tag>容忍度</tag>
        <tag>亲和性</tag>
        <tag>反亲和性</tag>
        <tag>nodeSelector</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-pod对象管理</title>
    <url>/blog/2020/02/24/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-pod%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="容器与pod"><a href="#容器与pod" class="headerlink" title="容器与pod"></a>容器与pod</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li>容器的本质是一个进程，是一个视图被隔离、资源受限制的进程</li>
<li>容器里pid=1的进程就是应用本身</li>
<li>管理虚拟机就是管理基础设施(操作系统)，管理容器就是管理应用本身(进程)</li>
<li>kubernetes相当于云时代的操作系统，容器镜像相当于操作系统的软件安装包</li>
</ul>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ul>
<li>容器设计本身就是一种“单进程”模型；可以运行多个进程，但是不便于直接管理<ul>
<li>如果需要运行多进程，则pid=1的进程要具有管理其他进程的能力(systemd)</li>
<li>也可以直接运行systemd，由systemd管理多进程；但是，此时：【容器管理】=【管理systemd】!=【直接管理应用本身】</li>
</ul>
</li>
<li>作为类比，容器相当于进程(linux中的线程)，pod相当于进程组(linux进程，包含至少一个线程)</li>
<li>在k8s中，pod是一个逻辑单位，它包含多个相互协作的容器，共享某些资源(volume/网络)<ul>
<li>pod是资源分配单位【类比，进程是操作系统资源分配的单位】</li>
<li>pod也是原子调度单位</li>
</ul>
</li>
<li>pod与多容器<ul>
<li>如果只是亲密关系，可以通过调度器让俩个应用部署在同一台宿主机上</li>
<li>如果是超亲密关系(比如：产生日志的应用和写日志的应用)，则需要将多个应用定义在一个pod中<ul>
<li>会发生直接的文件交互</li>
<li>使用localhost或socket进行本地通信</li>
<li>会发生频繁的RPC调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pod实现"><a href="#pod实现" class="headerlink" title="pod实现"></a>pod实现</h2><h3 id="网络实现"><a href="#网络实现" class="headerlink" title="网络实现"></a>网络实现</h3><ul>
<li>启动一个infra container容器，pod里的其他容器通过join namespace的方式加入infra container的network namespace中</li>
<li>pod的网络地址即是infra的地址</li>
<li>pod的生命周期也即infra的生命周期</li>
</ul>
<h3 id="存储实现"><a href="#存储实现" class="headerlink" title="存储实现"></a>存储实现</h3><p>在pod级别创建volume，然后pod内的所有容器挂载这个volume</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: two-containers</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  volumes:</span><br><span class="line">  - name: shared-data</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /data</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: shared-data</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  - name: debian-container</span><br><span class="line">    image: debian</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: shared-data</span><br><span class="line">      mountPath: /pod-data</span><br><span class="line">    command: [&quot;/bin/sh&quot;]</span><br><span class="line">    args: [&quot;-c&quot;, &quot;echo Hello from the debian container &gt; /pod-data/index.html&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="容器设计模式"><a href="#容器设计模式" class="headerlink" title="容器设计模式"></a>容器设计模式</h3><ul>
<li>sidecar：在pod里定义一些专门的容器，来执行主业务容器所需要的辅助工作</li>
<li>通过sidecar方式，可以实现功能的解耦和重用</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>日志收集(log)</li>
<li>Debug应用(debug)</li>
<li>容器代理(proxy)：单独写一个proxy用来处理对外部集群的交互，比如envoy</li>
<li>适配器(adapter)：单独写一个应用用来处理URL变更、数据格式变更的操作，以完成对现有业务的兼容</li>
</ul>
<h4 id="应用范例-war包部署"><a href="#应用范例-war包部署" class="headerlink" title="应用范例-war包部署"></a>应用范例-war包部署</h4><ul>
<li>其他部署方式<ul>
<li>【<strong>常用</strong>】使用环境镜像(tomcat镜像)，将war包打包进镜像中制作成项目镜像</li>
<li>【<em>不常用、实验</em>】使用环境镜像(tomcat镜像)，在容器运行时将war包挂载到容器内；<strong>但，此时则需要单独维护war包和一个分布式文件系统</strong></li>
</ul>
</li>
<li>sidecar方式【<em>不常用、实验</em>】-initContainer<ul>
<li>先启动一个initContainer，将war包拷贝到共享目录</li>
<li>再启动container，这个容器启动tomcat(共享目录webapps中包含war包)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: javaweb-2</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - image: resouer/sample:v2</span><br><span class="line">    name: war</span><br><span class="line">    command: [&quot;cp&quot;, &quot;/sample.war&quot;, &quot;/app&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /app</span><br><span class="line">      name: app-volume</span><br><span class="line">  containers:</span><br><span class="line">  - image: resouer/tomcat:7.0</span><br><span class="line">    name: tomcat</span><br><span class="line">    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;/root/apache-tomcat-7.0.42-v2/bin/start.sh&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /root/apache-tomcat-7.0.42-v2/webapps</span><br><span class="line">      name: app-volume</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      hostPort: 8001</span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pod容器定义"><a href="#pod容器定义" class="headerlink" title="pod容器定义"></a>pod容器定义</h1><p>spec.containers</p>
<h2 id="镜像-images"><a href="#镜像-images" class="headerlink" title="镜像-images"></a>镜像-images</h2><ul>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pod</span><br><span class="line">spec:</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: aliyun-simple</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx #容器名称</span><br><span class="line">    images: nginx:latest #镜像名称</span><br><span class="line">    imagePullPolicy: Always</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置选项</p>
<ul>
<li>仓库认证：imagePullSecrets【参见secret章节】</li>
<li>镜像获取策略：imagePullPolicy<ul>
<li>Always：镜像版本为latest或本地不存在的镜像则从远端仓库拉取</li>
<li>IfNotPresent：本地镜像不存在则从远端仓库拉取</li>
<li>Never：禁止从远端仓库拉取镜像，只使用本地镜像  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="端口-ports"><a href="#端口-ports" class="headerlink" title="端口-ports"></a>端口-ports</h2><ul>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    images: ikubernetes/myapp:v1</span><br><span class="line">    ports:</span><br><span class="line">    - name: http #端口名称</span><br><span class="line">      containerPort: 80 #指向容器监听的端口</span><br><span class="line">      protocol: TCP #端口协议类型</span><br><span class="line">      hostPort: 8000</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明：端口设置仅为说明性内容；为端口设置名称，方便被service调用</p>
</li>
<li>设置选项<ul>
<li>hostPort：将节点端口映射到容器端口</li>
<li>hostIP：节点端口绑定的ip【默认为0.0.0.0，一般不设置】</li>
</ul>
</li>
<li>注意事项：hostPort和service下的NodePort区别<ul>
<li>hostPort在pod下设置，只绑定到pod所在节点</li>
<li>NodePort在service下设置，绑定到所有节点</li>
</ul>
</li>
</ul>
<h2 id="自定义命令-command"><a href="#自定义命令-command" class="headerlink" title="自定义命令-command"></a>自定义命令-command</h2><ul>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: alpine:latest</span><br><span class="line">    command: [&quot;/bin/sh&quot;] #命令</span><br><span class="line">    args: [&quot;-c&quot;, &quot;while true;do sleep 30;done&quot;] #参数</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：查看镜像默认运行的命令</p>
<ul>
<li>cmd方式：<code>docker inspect nginx:1.13 -f {\{\.Config.Cmd}\}</code></li>
<li>entrypoint方式：<code>docker inspect nginx:1.13 -f {\{\.Config.Entrypoint}\}</code></li>
</ul>
</li>
<li>设置选项：命令和参数<ul>
<li>command：同时覆盖Dockerfile中的entrypoint和cmd</li>
<li>args：给command或Dockerfile中的entrypoint提供参数</li>
</ul>
</li>
</ul>
<h2 id="环境变量-env"><a href="#环境变量-env" class="headerlink" title="环境变量-env"></a>环境变量-env</h2><ul>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-env</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: filebeat</span><br><span class="line">    image: ikubernetes/filebeat:5.6.5-alpine</span><br><span class="line">    command: [&quot;echo&quot;]</span><br><span class="line">    args: [&quot;$(HOSTNAME)&quot;]</span><br><span class="line">    env:</span><br><span class="line">    - name: HOSTNAME</span><br><span class="line">      valueFrom:</span><br><span class="line">        fieldRef:</span><br><span class="line">          fieldPath: spec.nodeName</span><br><span class="line">    - name: REDIS_HOST #变量名称</span><br><span class="line">      value: db.ilinux.io:6379 #变量值</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明：向pod传递变量有两种方式：env和envFrom</p>
<ul>
<li>env<ul>
<li>value：自定义变量</li>
<li>valueFrom：读取pod环境变量<ul>
<li>configMapKeyRef</li>
<li>secretKeyRef</li>
<li>fieldRef：【metadata.name, metadata.namespace,metadata.labels, metadata.annotations, spec.nodeName,spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs】</li>
<li>resourceFieldRef：【limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu,requests.memory and requests.ephemeral-storage】</li>
</ul>
</li>
</ul>
</li>
<li>envFrom【从ConfigMap和secret获取值】<ul>
<li>configMapRef</li>
<li>secretRef</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用节点网络-hostNetwork"><a href="#使用节点网络-hostNetwork" class="headerlink" title="使用节点网络-hostNetwork"></a>使用节点网络-hostNetwork</h2><ul>
<li><p>范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-network</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br><span class="line">  hostNetwork: true #共享节点网络</span><br><span class="line">  hostPID: true #共享节点PID</span><br><span class="line">  hostIPC: true #共享节点IPC</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明:默认情况下，pod的所有容器会建立一个独立的网络名称空间；但是一些特殊的pod需要运行在节点的网络名称空间下，执行系统级的任务</p>
</li>
<li>应用范例：<ul>
<li>使用kubeadm部署的kube-controller-manager、kube-apiserver、kube-scheduler、kube-proxy组件</li>
<li>flannel网络部署</li>
</ul>
</li>
<li>其他选项<ul>
<li>hostPID: 共享节点PID</li>
<li>hostIPC: 共享节点IPC</li>
</ul>
</li>
</ul>
<h2 id="安全上下文-securityContext"><a href="#安全上下文-securityContext" class="headerlink" title="安全上下文-securityContext"></a>安全上下文-securityContext</h2><p>securityContext主要用于容器运行时的安全管控，类似linux的selinux、sudo等内容，通过限制容器的行为，从而保障系统和其他容器的安全</p>
<h3 id="选项位置"><a href="#选项位置" class="headerlink" title="选项位置"></a>选项位置</h3><ul>
<li>容器级别的securityContext：对指定容器生效</li>
<li>pod级别的securityContext：对指定pod中的所有容器有效</li>
<li>Pod Security Policies(PSP)：对集群内的所有pod有效</li>
</ul>
<h3 id="选项类别"><a href="#选项类别" class="headerlink" title="选项类别"></a>选项类别</h3><ul>
<li>根据用户id和组id控制访问对象</li>
<li>基于selinux的安全标签</li>
<li>以特权或非特权方式运行(privileged)</li>
<li>是否能够权限升级(allowPrivilegeEscalation)</li>
<li>通过Linux Capablities为其提供部分特权</li>
<li>基于seccomp过滤进程可以操作的系统调用</li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><blockquote>
<p>以uid为1000的非特权用户运行容器，并禁止提权</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-with-securitycontext</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: busybox</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;sleep 86400&quot;]</span><br><span class="line">      securityContext: #容器级别securitycontext</span><br><span class="line">        runAsNonRoot: true</span><br><span class="line">        runAsUser: 1000</span><br><span class="line">        allowPrivilegeEscalation: false</span><br></pre></td></tr></table></figure>
<h1 id="pod状态和重启"><a href="#pod状态和重启" class="headerlink" title="pod状态和重启"></a>pod状态和重启</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul>
<li>pending：api server创建了pod资源对象，但尚未被调度完成；或者处于拉取镜像的过程中</li>
<li>running：pod已被调度到某节点，并且所有容器都被kubelet创建完成</li>
<li>succeeded：pod中的所有容器已成功终止并且不会被重启</li>
<li>failed：所有容器都已被终止，但至少有一个容器终止失败</li>
<li>unknown：api server无法获取pod的正常状态信息，通常是由api无法与kubelet通信所致</li>
</ul>
<h2 id="pod异常状态诊断"><a href="#pod异常状态诊断" class="headerlink" title="pod异常状态诊断"></a>pod异常状态诊断</h2><ul>
<li>pod停留在pending状态：pending表示调度器没有介入，使用【kubectl describe pod】命令查看事件排查，通常和资源使用有关</li>
<li>pod停留在waiting状态：pod拉取镜像失败</li>
<li>pod不断被拉起且可以看到crashing：pod已被调度，但是启动失败；通常是由于配置、权限造成，需要查看pod日志【kubectl logs pod】</li>
<li>pod处于running但是没有正常工作：通常时由于部分字段拼写错误造成的，可以通过校验部署来排查【kubectl apply –validate -f pod.yml】</li>
<li>service无法正常工作：在排除网络插件自身的问题外，最有可能是label配置有问题，可以通过查看endpoint的方式进行查看</li>
</ul>
<h2 id="重启策略-restartPolicy"><a href="#重启策略-restartPolicy" class="headerlink" title="重启策略-restartPolicy"></a>重启策略-restartPolicy</h2><blockquote>
<p>重启策略适用于所有容器(包含initContainer)<br>首次需要重启时立即重启，后续重启操作时延为10/20/40/80/160/300，最大时延为300</p>
</blockquote>
<ul>
<li>Always：pod对象终止就将其重启，此为默认值</li>
<li>OnFailure：仅在pod对象出错时才将其重启</li>
<li>Never：从不重启</li>
</ul>
<h1 id="全生命周期操作"><a href="#全生命周期操作" class="headerlink" title="全生命周期操作"></a>全生命周期操作</h1><h2 id="包含操作"><a href="#包含操作" class="headerlink" title="包含操作"></a>包含操作</h2><ul>
<li>运行初始化容器(init container)</li>
<li>创建主容器(main container)【必须】</li>
<li>容器启动检查(startup probe)</li>
<li>容器启动后钩子(post start hook)</li>
<li>容器就绪型检查(readiness probe)</li>
<li>容器存活性检查(liveness probe)</li>
<li>容器终止前钩子(pre stop hook)</li>
</ul>
<h2 id="初始化容器-initContainer"><a href="#初始化容器-initContainer" class="headerlink" title="初始化容器-initContainer"></a>初始化容器-initContainer</h2><p>可用于普通containers启动前的初始化或前置条件检验(如检测网络连通性)</p>
<h3 id="与普通containers区别"><a href="#与普通containers区别" class="headerlink" title="与普通containers区别"></a>与普通containers区别</h3><ul>
<li>initContainer会先于普通containers启动执行，所有initContainer执行成功后，普通containers才会被启动</li>
<li>pod中多个initContainer之间是按定义顺序依次启动执行，而pod中多个普通containers时并行启动的</li>
<li>initContainer执行成功就退出，而普通containers可能会一直执行或重启</li>
</ul>
<h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">    - name: init-something</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 10&quot;]</span><br><span class="line">  containers:</span><br><span class="line">    - name: myapp-container</span><br><span class="line">      image: ikubernetes/myapp:v1</span><br></pre></td></tr></table></figure>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li>生命周期节点<ul>
<li>postStart：容器建立后立即运行的功能，但是k8s无法保证它一定运行在entrypoint之前</li>
<li>preStop：容器终止前执行的功能，此操作完成前阻塞删除容器的操作</li>
</ul>
</li>
<li>实现方式：<ul>
<li>exec：执行用户定义的命令</li>
<li>http：向指定url发起http请求</li>
</ul>
</li>
</ul>
<h3 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: lifecycle-demo-container</span><br><span class="line">      image: ikubernetes/myapp:v1</span><br><span class="line">      lifecycle: #定义钩子函数</span><br><span class="line">        postStart: #容器启动后执行</span><br><span class="line">          exec: #执行用户自定义命令</span><br><span class="line">            command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo &apos;lifecycle hooks handler&apos; &gt; /usr/share/nginx/html/test.html&quot;]</span><br><span class="line">        preStop: #容器终止前执行</span><br><span class="line">          httpGet: #发起http请求</span><br><span class="line">            host: blog.csdn.net</span><br><span class="line">            path: zhangmingli_summer/article/details/82145852</span><br><span class="line">            port: 443</span><br></pre></td></tr></table></figure>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><h3 id="检查种类"><a href="#检查种类" class="headerlink" title="检查种类"></a>检查种类</h3><ul>
<li>livenessProbe(存活性检查)：检查容器是否处于running状态，检测不通过时根据重启策略(restartPolicy)确定是否重启</li>
<li>readinessProbe(就绪性检查)：判断容器是否准备就绪，可以对外提供服务；未通过时，会将此pod从endpoint(如service对象)中移除，直到pod就绪</li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes" target="_blank" rel="noopener">startupProbe</a>(启动检查)：判断容器是否启动完成</li>
</ul>
<h3 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h3><ul>
<li>exec：执行用户自定义命令<ul>
<li>命令参数：command</li>
<li>注意事项：exec检查会消耗容器资源，所以需要检查命令简单、轻量</li>
</ul>
</li>
<li>httpGet：向指定url发起get请求，响应码2xx、3xx为成功<ul>
<li>命令参数：<ul>
<li>host：请求主机，默认pod ip</li>
<li>port：端口，必选字段</li>
<li>httpHeaders：自定义header信息</li>
<li>path：请求的http资源url</li>
<li>scheme：连接协议，HTTP/HTTPS,默认HTTP</li>
</ul>
</li>
<li>注意事项：在多层架构中，只能针对当前服务层进行检查(其他两种方式也一样)；如果后端服务不可用，会造成pod一次次重启，直到后端服务可用</li>
</ul>
</li>
<li>tcpSocket：与容器tcp端口建立连接，端口打开即为成功<ul>
<li>命令参数：<ul>
<li>host：请求主机，默认pod ip</li>
<li>port：端口，必选字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="通用检查属性"><a href="#通用检查属性" class="headerlink" title="通用检查属性"></a>通用检查属性</h3><ul>
<li>initialDelaySeconds：容器启动多长时间后进行首次检查，默认0s</li>
<li>timeoutSeconds：检查超时时间，默认1s</li>
<li>periodSeconds：检查频率，默认间隔10s，最小1s</li>
<li>successThreshold：处于失败状态时，多少次成功才认为是成功；默认1，最小1</li>
<li>failureThreshold：处于成功状态时，多少次失败才认为是失败；默认3，最小1</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>调大判断的阈值(超时、次数等)，防止容器压力过大时出现误判</li>
<li>exec执行shell脚本时，在容器内执行的时间会比较长(可以使用go等编译型语言执行)</li>
<li>使用tcpSocket时遇到TLS，需要判断业务层是否有影响</li>
</ul>
<h3 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h3><ul>
<li><p>readinessProbe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: readiness-exec</span><br><span class="line">  labels:</span><br><span class="line">    test: readiness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: readiness-exec-demo</span><br><span class="line">      image: busybox</span><br><span class="line">      args: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true;do rm -f /tmp/ready;sleep 30;touch /tmp/ready;sleep 300;done&quot;]</span><br><span class="line">      readinessProbe:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;test&quot;, &quot;-e&quot;, &quot;/tmp/ready&quot;]</span><br><span class="line">        initialDelaySeconds: 5</span><br><span class="line">        periodSeconds: 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>livenessProbe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: liveness-http</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: liveness-http-container</span><br><span class="line">      image: nginx:1.12-alpine</span><br><span class="line">      ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">      lifecycle:</span><br><span class="line">        postStart:</span><br><span class="line">          exec:</span><br><span class="line">            command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Healthy &gt; /usr/share/nginx/html/Healthz&quot;]</span><br><span class="line">      livenessProbe:</span><br><span class="line">        httpGet:</span><br><span class="line">          path: /Healthz</span><br><span class="line">          port: http</span><br><span class="line">          scheme: HTTP</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="资源需求和限制"><a href="#资源需求和限制" class="headerlink" title="资源需求和限制"></a>资源需求和限制</h1><ul>
<li>cpu：单位：millicore(1core=1000millicore)；例如：500m相当于0.5个核心</li>
<li>memory：单位：Bytes，与日常使用单位相同；例如：300M</li>
<li>ephemeral(临时存储)：单位：Byte</li>
<li>自定义资源：配置时必须为整数</li>
<li>范例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: wp</span><br><span class="line">    image: wordpress</span><br><span class="line">    resources:</span><br><span class="line">      requests: #请求的资源</span><br><span class="line">        memory: 64Mi</span><br><span class="line">        cpu: 250m</span><br><span class="line">        ephemeral-storage: 2Gi</span><br><span class="line">      limits: # 最多可以使用的资源</span><br><span class="line">        memory: 128Mi</span><br><span class="line">        cpu: 500m</span><br><span class="line">        ephemeral-storage: 4Gi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="pod服务-QOS"><a href="#pod服务-QOS" class="headerlink" title="pod服务-QOS"></a>pod服务-QOS</h2><p>依据容器对cpu、memory资源的request/limits需求，pod服务质量分为</p>
<ul>
<li>Guaranteed:<ul>
<li>每个容器都为cpu设置了具有相同值的requests、limits属性</li>
<li>每个容器都为memory设置了具有相同值的requests、limits属性</li>
</ul>
</li>
<li>Burstable：至少一个容器设置了cpu或memory的requests属性，但不满足Guaranteed的要求</li>
<li>BestEffort：没有为pod中的任何一个容器设置requests、limits属性</li>
</ul>
<p>当节点上的memory资源不足时，将依据BestEffort、Burstable、Guaranteed的优先级顺序驱逐pod</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>初始化容器</tag>
        <tag>钩子函数</tag>
        <tag>健康检查</tag>
        <tag>资源</tag>
        <tag>pod定义</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-service和ingress</title>
    <url>/blog/2020/03/06/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-service%E5%92%8Cingress/</url>
    <content><![CDATA[<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><ul>
<li>服务发现：在pod的弹性伸缩变化过程中，保持外部访问入口不变</li>
<li>负载均衡：定义访问pod资源的策略</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul>
<li>服务发现：service定义一个访问入口(service_name、clusterIP)，并基于标签选择器选择一组pod</li>
<li>负载均衡：kube-proxy根据service和pod的映射关系(endpoints)，在节点上创建相应的iptables或ipvs规则</li>
</ul>
<h2 id="服务发现的实现"><a href="#服务发现的实现" class="headerlink" title="服务发现的实现"></a>服务发现的实现</h2><ul>
<li>环境变量方式：在创建pod对象时，kubelet将活动的service对象的一系列环境变量注入到pod中【缺点：仅有那些与创建的pod对象处于同一名称空间且事先存在的service对象才会以环境变量方式注入】</li>
<li>DNS方式(例如<a href="https://github.com/coredns/deployment/tree/master/kubernetes" target="_blank" rel="noopener">CoreDNS</a>)：集群中的DNS服务会为每个创建的service对象生成相应的解析记录(服务名称：service_name.namespace_name.svc.domain_name)<ul>
<li>拥有ClusterIP的service：A记录【服务名称映射clusterIP】</li>
<li>Headless类型service(无ClusterIP)：A记录【服务名称映射endpointIP】</li>
<li>ExternalName类型service：CNAME记录【服务名称映射externalName】</li>
</ul>
</li>
</ul>
<h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>iptables：使用灵活、功能强大；但是规则更新和匹配时间随条目数的增加而线性增加</li>
<li>ipvs：工作在内核态，性能更优异；支持丰富的调度算法</li>
</ul>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul>
<li><p>配置：kube-proxy配置–proxy-mode</p>
</li>
<li><p>kubeadm方式部署集群kube-proxy变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 编辑kube-proxy configmap配置：kubectl edit cm kube-proxy -n kube-system </span><br><span class="line">2. 重启kube-proxy pod【删除pod后自动重建】</span><br><span class="line">4. 查看pod日志</span><br></pre></td></tr></table></figure>
</li>
<li><p>ipvs配置查看</p>
<ul>
<li>配置条目：ipvsadm -Ln</li>
<li>使用网卡：kube-ipvs0</li>
</ul>
</li>
</ul>
<h1 id="service类型"><a href="#service类型" class="headerlink" title="service类型"></a>service类型</h1><ul>
<li>ClusterIP：默认的service类型，提供的ip只可以在集群内部访问</li>
<li>NodePort：建构于clusterIP类型之上，在节点绑定端口，可以在集群外部访问；实现方式：【NodePort==》ClusterIP:port】</li>
<li>LoadBalancer：建构于NodePort类型之上，指向云厂商设置的负载均衡设备(如阿里云SLB)，可以在集群外部访问；实现方式：【LoadBalancer==》NodePort==》ClusterIP】</li>
<li>ExternalName：不是定义k8s集群提供的服务，而是把集群外部的某服务以CNAME记录的方式映射到集群内，从而让集群内的pod资源能够访问外部的service;externlName只能是外部服务的域名(不能是ip)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-svc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: redis.example.com</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 6379</span><br><span class="line">      targetPort: 6379</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="service语法范例"><a href="#service语法范例" class="headerlink" title="service语法范例"></a>service语法范例</h1><ul>
<li><p>service部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 31222             #服务端口：ClusterIP</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80          #pod/容器端口</span><br><span class="line">    nodePort: 32222         #节点端口【不设置或设置为0，系统自动配置】</span><br><span class="line">  selector:                 #选择的pod</span><br><span class="line">    app: nginx</span><br><span class="line">  type: NodePort            #端口类型</span><br><span class="line">  # clusterIP: None</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关deployment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1 </span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:       #Deployment元信息</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3       #期望的pod数量</span><br><span class="line">  selector:         #pod选择器</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:         #pod模板</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.12.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="service与ingress对比"><a href="#service与ingress对比" class="headerlink" title="service与ingress对比"></a>service与ingress对比</h1><ul>
<li><p>service：工作于传输层(TCP)，构建于pod资源之上</p>
<ul>
<li>基于netfilter之上进行的四层调度，如iptables、ipvs</li>
<li>支持调度http、mysql等应用层服务</li>
</ul>
</li>
<li><p>Ingress：工作于应用层(HTTP/HTTPS)，构建于service资源之上</p>
<ul>
<li>可以实现基于URL的请求调度机制</li>
<li>支持https证书</li>
<li>支持对后端服务器进行健康检查</li>
</ul>
</li>
</ul>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><ul>
<li>实质：将访问指定主机名或URL路径的请求转发到特定service资源的规则</li>
<li>实现：实现Ingress规则的组件就是Ingress Controller</li>
</ul>
<h1 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress-Controller"></a>Ingress-Controller</h1><ul>
<li>与k8s核心组件关系：Ingress Controller不是集群kube-controller-manager的一部分，它是k8s集群的一个组件(类似于CoreDNS)，需要单独部署</li>
<li>本质：Ingress控制器本身也是作为一个pod资源在集群中运行，它可以由deployment或daemonset创建；由于需要接入外部流量，还需要为其创建相关的NodePort或LoadBalancer类型的Service资源对象</li>
<li>实现原理：Ingress控制器基于Ingress定义的规则将流量转发到service对应的后端pod上，service对象仅仅用于辅助Ingress识别pod对象；这种转发机制会绕过service资源，从而省去了kube-proxy实现的端口代理开销</li>
<li>实现软件：Ingress控制器可以由任何实现反向代理(HTTP/HTTPS)的软件实现，如nginx、traefik、Istio<ul>
<li><a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" rel="noopener">ingress-nginx</a>：<ul>
<li><a href="https://github.com/kubernetes/ingress-nginx/blob/master/deploy/static/provider/baremetal/deploy.yaml" target="_blank" rel="noopener">资源文件</a></li>
<li>资源文件修改<ul>
<li>镜像地址修改：registry.cn-hangzhou.aliyuncs.com/simple00426/nginx-ingress-controller:0.34.0</li>
<li>控制器类型修改(确保controller高可用及知晓部署节点)，可选方式例如：Deployment(默认)、DaemonSet</li>
<li>网络及端口设置(将ingress的访问入口暴露给集群外部)，可选方式例如：hostNetwork、hostPort、NodePort(默认)</li>
</ul>
</li>
</ul>
</li>
<li>traefik-1.7<ul>
<li><a href="https://github.com/containous/traefik/tree/v1.7/examples/k8s" target="_blank" rel="noopener">官方安装</a></li>
<li><a href="https://github.com/simple0426/kubernetes-vagrant-centos-cluster/tree/master/addon/traefik-ingress" target="_blank" rel="noopener">第三方安装</a></li>
<li><a href="https://blog.51cto.com/m51cto/2328921" target="_blank" rel="noopener">traefik配置https</a></li>
</ul>
</li>
<li>Istio：服务治理</li>
</ul>
</li>
</ul>
<h1 id="Ingress语法范例"><a href="#Ingress语法范例" class="headerlink" title="Ingress语法范例"></a>Ingress语法范例</h1><h2 id="基于域名的虚拟主机"><a href="#基于域名的虚拟主机" class="headerlink" title="基于域名的虚拟主机"></a>基于域名的虚拟主机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># traefik.jimmysong.io==》traefik-ingress-service:8080</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: traefik-ingress</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  rules: #转发规则定义</span><br><span class="line">  - host: traefik.jimmysong.io #匹配的主机名【不支持ip、端口形式；字段留空表示所有主机名】</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: / </span><br><span class="line">        backend:      #处理请求的后端</span><br><span class="line">          serviceName: traefik-ingress-service    #后端服务名</span><br><span class="line">          servicePort: 8080  #后端服务端口</span><br></pre></td></tr></table></figure>
<h2 id="基于URL路径-rewrite"><a href="#基于URL路径-rewrite" class="headerlink" title="基于URL路径-rewrite"></a>基于URL路径-rewrite</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># myapp.abc.com/tomcat==》tomcat-service:38080</span><br><span class="line"># myapp.abc.com/nginx==&gt;nginx-service:31222</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: traefik-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    traefik.ingress.kubernetes.io/rewrite-target: /</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: myapp.abc.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /tomcat</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: tomcat-service</span><br><span class="line">          servicePort: 38080</span><br><span class="line">      - path: /nginx</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: nginx-service</span><br><span class="line">          servicePort: 31222</span><br></pre></td></tr></table></figure>
<h2 id="HTTPS设置"><a href="#HTTPS设置" class="headerlink" title="HTTPS设置"></a>HTTPS设置</h2><ul>
<li>创建自签名证书<ul>
<li>openssl genrsa -out tls.key 2048</li>
<li>openssl req -new -x509 -key tls.key -out tls.crt -subj /C=CN/ST=Beijing/L=Beijing/O=DevOps/CN=test.abc.com -days 3650</li>
</ul>
</li>
<li>将证书放入k8s的secret中：kubectl create secret tls tomcat-ingress-secret –cert=tls.crt –key=tls.key -n testing</li>
<li>在ingress中设置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Ingress</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat</span><br><span class="line">  namespace: testing</span><br><span class="line">spec:</span><br><span class="line">  tls: #包含支持https的对象</span><br><span class="line">  - hosts:</span><br><span class="line">    - test.abc.com #使用证书的主机名列表</span><br><span class="line">    secretName: tomcat-ingress-secret #基于证书创建的secret对象名称</span><br><span class="line">  rules:</span><br><span class="line">  - host: test.abc.com </span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path:</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: tomcat-svc</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="个性化设置-annotation"><a href="#个性化设置-annotation" class="headerlink" title="个性化设置-annotation"></a>个性化设置-<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/" target="_blank" rel="noopener">annotation</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Ingress</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-https</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: &quot;nginx&quot; #部署多种ingress控制器时选择使用</span><br><span class="line">    nginx.ingress.kubernetes.io/ssl-redirect: &apos;true&apos;</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: &quot;600&quot;</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: &quot;600&quot;</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: &quot;600&quot;</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-body-size: &quot;10m&quot;</span><br></pre></td></tr></table></figure>
<h1 id="ingress-controller高可用"><a href="#ingress-controller高可用" class="headerlink" title="ingress-controller高可用"></a>ingress-controller高可用</h1><ul>
<li>选用daemonset或deployment在多个节点部署多个pod</li>
<li>通过标签/标签选择器、污点/容忍度选定特定的几个节点方便前端代理</li>
<li>前端代理使用nginx+keepalived</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>service</tag>
        <tag>ingress</tag>
        <tag>服务发现</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-入门基础</title>
    <url>/blog/2018/04/03/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="容器平台分层架构"><a href="#容器平台分层架构" class="headerlink" title="容器平台分层架构"></a>容器平台分层架构</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/containers-scheme.jpg" alt></p>
<ul>
<li>基础设施层-IaaS(openstack/公有云)：服务器、网络、存储、数据库</li>
<li>容器引擎层：docker、harbor(镜像仓库)</li>
<li>容器编排层：kubernetes</li>
<li>访问和工具层-PaaS：web控制台、CICD、监控、日志</li>
</ul>
<h1 id="官方文档使用"><a href="#官方文档使用" class="headerlink" title="官方文档使用"></a><a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">官方文档使用</a></h1><ul>
<li>概念</li>
<li>任务：具体的任务</li>
<li>教程：有状态应用案例、无状态应用案例、CICD pipeline</li>
<li>参考：API、kubectl、k8s组件二进制命令</li>
</ul>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><ul>
<li>自动装箱：构建于容器技术之上，基于资源依赖和其他约束性自动完成程序部署；通过调度机制，提升节点资源利用率</li>
<li>自我修复：支持容器故障后自动重启，节点故障后重新调度容器</li>
<li>服务发现、负载均衡：通过使用DNS插件为系统内置服务发现功能，它为每个service配置DNS名称；而service通过iptables或ipvs内建了负载均衡机制</li>
<li>应用的发布、回滚：支持自动滚动更新，保证服务可用性；在出现故障时，支持回滚操作</li>
<li>水平扩展：支持通过命令、UI或HPA方式完成扩容、缩容等弹性伸缩</li>
<li>秘钥和配置管理：通过ConfigMap实现配置管理，使用secret保证数据安全性</li>
<li>存储编排：支持pod对象按需挂载不同类型的存储系统，例如：本地存储(hostpath)、云存储(oss)、网络存储(glusterfs)</li>
<li>批量执行任务</li>
</ul>
<h1 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语"></a>概念术语</h1><h2 id="Name和NameSpace"><a href="#Name和NameSpace" class="headerlink" title="Name和NameSpace"></a>Name和NameSpace</h2><ul>
<li>name是资源对象的标识，作用域为namespace</li>
<li>namespace：用于限定资源的作用域<ul>
<li>用于集群内部的逻辑隔离（资源对象名称隔离）</li>
<li>不能隔离不同名称空间的pod间通信，这是网络策略(network policy)的功能</li>
<li>默认名称空间为default</li>
</ul>
</li>
</ul>
<h2 id="Label和Selector"><a href="#Label和Selector" class="headerlink" title="Label和Selector"></a>Label和Selector</h2><ul>
<li>label：用于资源分类的key-value对，用来过滤和选择资源</li>
<li>selector：根据标签(label)选择和过滤资源的一种机制</li>
</ul>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ul>
<li>具有相同namespace的一组容器的集合体</li>
<li>是k8s中最小任务调度单元</li>
<li>一个pod里的所有容器共享部分资源(volumes/网络)</li>
</ul>
<h2 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h2><ul>
<li>pod控制器是工作负载类控制器，用于部署和管理pod对象</li>
<li>工作负载类控制器包括：ReplicaSet、Deployment、StatefulSet、DaemonSet、job等</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul>
<li>建立在pod对象之上的资源抽象，通过标签选择器选定一组pod，并为这组pod对象定义一个统一且固定的访问入口【集群ip或DNS名称】</li>
<li>实现方式<ul>
<li>ClusterIP</li>
<li>NodePort</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
</li>
</ul>
<h1 id="架构和功能组件"><a href="#架构和功能组件" class="headerlink" title="架构和功能组件"></a>架构和功能组件</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s%E6%9E%B6%E6%9E%84.png" alt></p>
<h2 id="集群存储-etcd"><a href="#集群存储-etcd" class="headerlink" title="集群存储-etcd"></a>集群存储-etcd</h2><p>etcd是一个分布式配置存储服务，用于保存资源的定义和状态；<strong>它不属于kubernetes集群本身</strong></p>
<h2 id="master组件"><a href="#master组件" class="headerlink" title="master组件"></a>master组件</h2><ul>
<li>apiserver：是kubernetes系统的入口，封装了对资源对象的增删改查操作，以restful接口的形式提供给外部和内部使用。它维护的rest对象持久化到etcd中</li>
<li>scheduler：负责集群资源调度，根据预定的调度策略将pod调度到相应的机器上</li>
<li>controller-manager：确保各资源的当前状态(status)可以匹配用户期望的状态(spec)；实现此功能的操作有：故障检测、自动扩展、滚动更新等；实现此功能的控制器有：各类pod控制器，endpoint控制器、ServiceAccount控制器、node控制器等</li>
</ul>
<h2 id="node组件"><a href="#node组件" class="headerlink" title="node组件"></a>node组件</h2><ul>
<li>kublet：<ul>
<li>从apiserver接收关于pod对象的配置信息，并确保他们处于期望的状态</li>
<li>在APIServer注册当前节点，并汇报当前节点的资源使用情况</li>
<li>通过存储插件、网络插件，管理Volume(CVI)和网络(CNI)。</li>
</ul>
</li>
<li>kube-proxy：按需为service对象生成相应的iptables或ipvs规则，从而将访问service的流量转发到相应的pod对象</li>
<li>container runtime(容器运行环境)：负责镜像管理以及容器的真正运行(CRI)，比如docker</li>
</ul>
<h2 id="核心附件"><a href="#核心附件" class="headerlink" title="核心附件"></a>核心附件</h2><ul>
<li>DNS组件(CoreDNS)：为集群提供服务注册和服务发现的动态名称解析服务</li>
<li>UI组件(Kubernetes-dashboard)：为集群提供web页面管理功能</li>
<li>监控组件：收集容器和节点的状态信息<ul>
<li>早期使用heapster</li>
<li>现在使用metrics server+prometheus</li>
</ul>
</li>
<li>IngressController：在service之上，为集群提供7层代理；实现项目:nginx、traefik</li>
</ul>
<h1 id="集群部署方式"><a href="#集群部署方式" class="headerlink" title="集群部署方式"></a>集群部署方式</h1><ul>
<li><a href="#minikube">minikube方式</a>【<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/" target="_blank" rel="noopener">官方</a>】</li>
<li><a href="https://github.com/kubernetes/kubernetes/releases" target="_blank" rel="noopener">二进制手动方式</a>：k8s核心组件以守护进程方式运行在节点上</li>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">kubeadm工具部署</a>：除了kubelet和docker之外其他组件(etcd/api/scheduler/controller-manager)都以静态pod方式运行在master节点上</li>
</ul>
<h1 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a><a href="https://minikube.sigs.k8s.io/" target="_blank" rel="noopener">minikube</a></h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul>
<li><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">下载安装minikube</a><ul>
<li>minikube是类似于vagrant的工具，需要借助本地虚拟化的支持（hyper-v、virtualbox）</li>
</ul>
</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-windows" target="_blank" rel="noopener">下载安装kubectl</a></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>minikube命令和minikube项目存储位置(MINIKUBE_HOME，也即.minikube的上级目录)应该在同一分区上(例如都在c盘或d盘),否则minikube启动会找不到minikube的iso文件</li>
<li>默认项目存储位置(MINIKUBE_HOME)在用户家目录(如C:\Users\simple)，可以设置MINIKUBE_HOME变量改变</li>
<li>项目启动时会下载minikube的iso文件、kubectl、kubelet、kubeadm等组件，它们都是从<a href="https://storage.googleapis.com" target="_blank" rel="noopener">境外</a>下载的，为了快速下载，应该在23点之后进行首次下载并缓存</li>
</ul>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><ul>
<li>启动命令：<code>minikube start --image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --registry-mirror=https://2x97hcl1.mirror.aliyuncs.com --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.7.3.iso</code><ul>
<li>start其他配置选项<ul>
<li><code>--cpus=2</code>：为minikube虚拟机配置的cpu数量</li>
<li><code>--disk-size=20000mb</code>：为minikube虚拟机配置的磁盘大小</li>
<li><code>--memory=2000mb</code>：为minikube虚拟机分配的内存</li>
<li><code>--kubernetes-version=v1.16.2</code>：minikube使用的kubernetes版本</li>
</ul>
</li>
</ul>
</li>
<li>停止命令：minikube stop</li>
<li>web界面使用：minikube dashboard</li>
<li>集群信息查看：kubectl config view、kubectl cluster-info</li>
</ul>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><ul>
<li>部署：kubectl apply -f <a href="https://k8s.io/examples/application/deployment.yaml" target="_blank" rel="noopener">https://k8s.io/examples/application/deployment.yaml</a></li>
<li>升级镜像：kubectl apply -f <a href="https://k8s.io/examples/application/deployment-update.yaml" target="_blank" rel="noopener">https://k8s.io/examples/application/deployment-update.yaml</a></li>
<li>扩容：kubectl apply -f <a href="https://k8s.io/examples/application/deployment-scale.yaml" target="_blank" rel="noopener">https://k8s.io/examples/application/deployment-scale.yaml</a></li>
</ul>
<h2 id="集群运维"><a href="#集群运维" class="headerlink" title="集群运维"></a>集群运维</h2><ul>
<li><code>kubect get node</code>：查看节点状态</li>
<li><code>kubectl get --watch deployments</code>：持续查看deployments信息</li>
<li><code>kubectl describe deployment</code>：显示deployments详情</li>
<li><code>kubectl delete deployment nginx-deployment</code>：删除deployment</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-statefulset控制器</title>
    <url>/blog/2020/03/18/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-statefulset%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="有无状态"><a href="#有无状态" class="headerlink" title="有无状态"></a>有无状态</h1><ul>
<li>分类标准：应用程序在和其他用户、设备、程序通信时，根据是否需要记录相关状态信息以用于下次通信，可以将程序分类如下：<ul>
<li>有状态应用(stateful)：需要记录信息</li>
<li>无状态应用(stateless)：无需记录</li>
</ul>
</li>
<li>控制器<ul>
<li>无状态控制器：replicaset，多个pod使用共享的存储卷(ReadWriteMany，ReadMany)</li>
<li>有状态控制器：statefulset，每个pod使用专用的存储卷(ReadWriteOnce)</li>
</ul>
</li>
<li>状态和存储交叉组合<ul>
<li>需要读写磁盘的有状态应用：支持事务功能的RDBMS；各种分布式存储系统（redis cluster、mongodb、zookeeper）</li>
<li>需要读写磁盘的无状态应用：具有幂等性的文件上传服务；从外部存储加载静态资源以响应用户请求的web服务</li>
<li>无磁盘访问的无状态应用：地理坐标转换器</li>
<li>无磁盘访问的有状态应用：电子商城中的购物车系统</li>
</ul>
</li>
</ul>
<h1 id="statefulset介绍"><a href="#statefulset介绍" class="headerlink" title="statefulset介绍"></a>statefulset介绍</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>稳定且唯一的网络标识符：pod名称</li>
<li>稳定且持久的存储：基于动态或静态的pvc</li>
<li>有序的部署和终止：基于索引号从前往后部署，基于索引号从后往前终止</li>
<li>有序的自动滚动更新：基于索引号从后往前更新</li>
</ul>
<h2 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h2><ul>
<li>service对象：Headless Service（为pod资源生成DNS记录）<ul>
<li>设置：【clusterIp:None】</li>
<li>实现：不为service对象创建clusterIP，DNS服务直接将service_name解析为后端各pod对象的名称和ip，客户端直接通过pod名称或ip访问pod</li>
<li>解析记录：【<em>service-name</em>===&gt;<em>statefulset-name-{index}</em>.<em>service-name</em>.<em>namespace-name</em>.svc.<em>domain-name</em>】</li>
</ul>
</li>
<li>StatefulSet对象：管控pod资源<ul>
<li>serviceName：关联headless service</li>
<li>volumeClaimTemplates：为pod资源提供专用且固定的存储</li>
</ul>
</li>
</ul>
<h1 id="statefulset创建"><a href="#statefulset创建" class="headerlink" title="statefulset创建"></a>statefulset创建</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-svc</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp-svc</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: myapp-pod</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp</span><br><span class="line">spec:</span><br><span class="line">  updateStrategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      partition: 2</span><br><span class="line">  serviceName: myapp-svc</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: myapp</span><br><span class="line">          image: ikubernetes/myapp:v5</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">              name: web</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: myappdata</span><br><span class="line">              mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">    - metadata:</span><br><span class="line">        name: myappdata</span><br><span class="line">      spec:</span><br><span class="line">        accessModes: [&quot;ReadWriteOnce&quot;]</span><br><span class="line">        storageClassName: &quot;glusterfs&quot;</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            storage: 2Gi</span><br></pre></td></tr></table></figure>
<h1 id="statefulset管理"><a href="#statefulset管理" class="headerlink" title="statefulset管理"></a>statefulset管理</h1><h2 id="扩容缩容"><a href="#扩容缩容" class="headerlink" title="扩容缩容"></a>扩容缩容</h2><blockquote>
<p>支持扩容缩容，但具体的实现机制依赖于应用本身</p>
</blockquote>
<p><code>kubectl scale statefulset myapp --replicas=4</code></p>
<h2 id="镜像更新"><a href="#镜像更新" class="headerlink" title="镜像更新"></a>镜像更新</h2><blockquote>
<p>支持滚动更新</p>
</blockquote>
<ul>
<li>更新策略：<ul>
<li>OnDelete：删除pod才会触发重建更新</li>
<li>RollingUpdate：滚动更新，默认的更新策略<ul>
<li>默认的滚动更新方式</li>
<li>分区更新(partition)：只有大于索引号(partition)的pod资源才会被滚动更新；若给定的分区号大于副本数量，则所有的pod资源均不会被更新</li>
</ul>
</li>
</ul>
</li>
<li>命令：<ul>
<li>查看镜像信息：<code>kubectl get pod -o custom-columns=NAME:metadata.name,IMAGE:spec.containers[0].image</code></li>
<li>更新镜像：<code>kubectl set image statefulset myapp myapp=ikubernetes/myapp:v6</code></li>
<li>更新状态查询：<code>kubectl rollout status statefulset myapp</code></li>
</ul>
</li>
<li>实践<ul>
<li>暂存更新操作：将分区号(partition)设置为和副本数(replicas)一样大，此后所有的更新操作都将暂停</li>
<li>金丝雀部署：调整分区号至小于副本数，不断“放出金丝雀”，触发更新操作</li>
</ul>
</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>不同的有状态应用的运维操作过程差别巨大，statefulset本身无法提供通用管理机制<br>现实中的各种有状态应用通常是使用专门的自定义控制器专门封装特定的运维操作流程<br>这些自定义控制器有时被统一称为operator  </p>
<h2 id="范例-etcd"><a href="#范例-etcd" class="headerlink" title="范例-etcd"></a>范例-etcd</h2><ul>
<li>官方operator：<a href="https://github.com/coreos/etcd-operator" target="_blank" rel="noopener">https://github.com/coreos/etcd-operator</a></li>
<li>第三方制作：<a href="https://github.com/simple0426/k8s-statefulset" target="_blank" rel="noopener">https://github.com/simple0426/k8s-statefulset</a></li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>StatefulSet</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-弹性伸缩</title>
    <url>/blog/2020/08/12/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h1><p>集群的容量能够及时响应业务的负载需求</p>
<h2 id="业务负载类型"><a href="#业务负载类型" class="headerlink" title="业务负载类型"></a>业务负载类型</h2><ul>
<li>在线负载类：微服务、API、网站</li>
<li>离线业务：离线计算、大数据、机器学习</li>
<li>定时任务：定时批量任务</li>
</ul>
<p>在线负载类对弹性伸缩的弹出时间敏感；离线业务对价格敏感；定时任务对调度敏感</p>
<p>本章中的弹性伸缩主要针对在线负载类业务。</p>
<h2 id="弹性伸缩维度"><a href="#弹性伸缩维度" class="headerlink" title="弹性伸缩维度"></a>弹性伸缩维度</h2><ul>
<li>CA(cluster autoscaler)：node个数扩容、缩容；使用cluster-autoscaler组件，一般为云厂商对接实现节点增加或删除</li>
<li>HPA(Horizontal Pod Autoscaler)：pod个数自动扩容、缩容；kubernetes内置组件实现；pod需要设置requests、limits信息</li>
<li>VPA(Vertical Pod AutoScaler)：pod配置(requests/limits)自动扩容、缩容；使用addon-resizer组件<ul>
<li>主要针对大型单体应用</li>
<li>在pod中不设置requests、limits信息，由vpa控制器管理pod的配置</li>
</ul>
</li>
</ul>
<h2 id="缩容问题-pod终止"><a href="#缩容问题-pod终止" class="headerlink" title="缩容问题-pod终止"></a>缩容问题-pod终止</h2><ul>
<li>核心：pod优雅停机</li>
<li>解决：pod中定义prestop钩子</li>
<li>范例：如果我的tomcat里面跑的订单业务，数据要求不丢失。当我的tomcat正在做一个批量操作，耗时5分钟，怎么保证缩容的时候，实现等待这个批量操作和其他数据流量操作完成后在缩容呢？<ul>
<li>prestop查询执行结果，保证任务执行完</li>
<li>prestop查询apiserver或服务注册中心：当前pod是不是已下线？下线了就关闭pod；未下线就进入查询循环继续等待</li>
<li>执行的任务要实现事务回滚或重复执行要幂等</li>
</ul>
</li>
</ul>
<h1 id="节点伸缩-CA"><a href="#节点伸缩-CA" class="headerlink" title="节点伸缩-CA"></a>节点伸缩-CA</h1><h2 id="扩容node-步骤"><a href="#扩容node-步骤" class="headerlink" title="扩容node-步骤"></a>扩容node-步骤</h2><ul>
<li>观察到node内存、cpu不足或pod因为资源不足处于pending状态<ul>
<li>手动查看node资源分配情况：kubectl describe node k8s-master1</li>
</ul>
</li>
<li>新建虚拟机</li>
<li>在虚拟机上部署kubelet等组件并加入集群</li>
</ul>
<h2 id="扩容node-ansible"><a href="#扩容node-ansible" class="headerlink" title="扩容node-ansible"></a>扩容node-ansible</h2><ul>
<li><p>范例：<a href="https://github.com/lizhenliang/ansible-install-k8s/blob/master/add-node.yml" target="_blank" rel="noopener">https://github.com/lizhenliang/ansible-install-k8s/blob/master/add-node.yml</a></p>
</li>
<li><p>自动签发kubelet证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: auto-approve-csrs-for-group</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: system:bootstrappers</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="缩容node-手动实现"><a href="#缩容node-手动实现" class="headerlink" title="缩容node-手动实现"></a>缩容node-手动实现</h2><ul>
<li>标记节点不可调度：kubectl cordon k8s-node3</li>
<li>驱逐节点上的pod：kubectl drain k8s-node3 –ignore-daemonsets</li>
<li>从集群删除节点：kubectl delete node k8s-node3</li>
</ul>
<h2 id="node禁用和启用"><a href="#node禁用和启用" class="headerlink" title="node禁用和启用"></a><a href="https://blog.csdn.net/chuxiong5717/article/details/100827916" target="_blank" rel="noopener">node禁用和启用</a></h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ol>
<li>驱逐节点上的pod，由其他节点重建(针对replicaset)</li>
<li>从master节点删除该node，master与node相互不可见，并失去对node的控制</li>
</ol>
<p>恢复节点调度操作（基于node的自注册功能）：进入node节点，重启kubelet：systemctl restart kubelet</p>
<h3 id="drain"><a href="#drain" class="headerlink" title="drain"></a>drain</h3><ol>
<li>驱逐节点上的pod，由其他节点重建(针对replicaset)</li>
<li>将节点标记为<strong>SchedulingDisabled</strong>【不可调度】</li>
</ol>
<p>恢复节点调度操作：kubectl uncordon node_name</p>
<h3 id="cordon"><a href="#cordon" class="headerlink" title="cordon"></a>cordon</h3><ul>
<li>将节点标记为<strong>SchedulingDisabled</strong>【不可调度】</li>
</ul>
<p>新创建的pod不会调度到该节点；该节点原有的pod不受影响，仍然可以对外提供服务</p>
<p>恢复节点调度操作：kubectl uncordon node_name</p>
<h1 id="pod伸缩-HPA"><a href="#pod伸缩-HPA" class="headerlink" title="pod伸缩-HPA"></a>pod伸缩-HPA</h1><h2 id="HPA简介"><a href="#HPA简介" class="headerlink" title="HPA简介"></a>HPA简介</h2><ul>
<li><p>原理：HPA控制器从支持的<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-metrics-apis" target="_blank" rel="noopener">指标API</a>(例如Metrics server)中获取指标数据(例如：内存/cpu)，然后基于用户的自定义规则进行pod副本数的增减</p>
</li>
<li><p>弹性伸缩冷却周期设置（kube-controller-manager组件启动参数设置）：</p>
<ul>
<li>扩容冷却周期(默认3分钟)：–horizontal-pod-autoscaler-upscale-delay </li>
<li>缩容冷却周期(默认5分钟)：–horizontal-pod-autoscaler-downscale-delay </li>
</ul>
</li>
<li><p>HPA共有三个版本：autoscaling/v1只支持基于CPU的弹性伸缩；autoscaling/v2beta1增加对自定义指标的支持；autoscaling/v2beta2额外增加了对外部指标的支持。而这些版本的变化正是kubernetes社区对监控和监控指标的认识转变，从早期Heapster到Metrics Server再到将指标边界进行划分。</p>
</li>
</ul>
<h2 id="HPA版本"><a href="#HPA版本" class="headerlink" title="HPA版本"></a>HPA版本</h2><ul>
<li>autoscaling/v1：只支持cpu选项；由<a href="https://github.com/kubernetes-incubator/metrics-server" target="_blank" rel="noopener">Metrics Server</a>提供资源指标API(metrics.k8s.io)</li>
<li>autoscaling/v2beta1：除了支持资源指标(CPU/内存)外，也支持<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md" target="_blank" rel="noopener">自定义指标</a>(custom.metrics.k8s.io)<ul>
<li>自定义指标：可以引用Kubernetes对象（或其组）和度量名称</li>
<li>自定义指标由指标数据采集器的适配器提供，如<a href="https://github.com/directxman12/k8s-prometheus-adapter" target="_blank" rel="noopener">Prometheus Adapter</a></li>
<li>内存使用：由于各个语言都有自己的内存管理机制，采集到的数据和真实的数据不一定一致，所以不推荐使用内存进行伸缩设置</li>
</ul>
</li>
<li><p>autoscaling/v2beta2：相对于v2beta1额外增加<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/external-metrics-api.md" target="_blank" rel="noopener">外部指标</a>(external.metrics.k8s.io)支持</p>
<ul>
<li>设计目标<ul>
<li>支持基于CPU百分比的伸缩</li>
<li>支持关于pod任意指标数据的伸缩</li>
<li>支持基于kubernetes对象相关任意指标数据的伸缩</li>
<li>在单个hpa中实现对多个指标数据的扩展</li>
</ul>
</li>
<li><p>外部指标：与自定义指标功能类似，并基于自定义指标进行功能扩展</p>
</li>
<li><p>外部指标由指标数据采集器的适配器提供，如<a href="https://github.com/directxman12/k8s-prometheus-adapter" target="_blank" rel="noopener">Prometheus Adapter</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="范例-autoscaling-v1"><a href="#范例-autoscaling-v1" class="headerlink" title="范例-autoscaling/v1"></a>范例-autoscaling/v1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 5</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: web</span><br><span class="line">  targetCPUUtilizationPercentage: 60</span><br></pre></td></tr></table></figure>
<ul>
<li>minReplicas、maxReplicas：伸缩最小、最大副本数</li>
<li>scaleTargetRef：伸缩的对象；和scale命令伸缩对象一致，包括：Deployment, ReplicaSet, Replication Controller, or StatefulSet</li>
<li>targetCPUUtilizationPercentage：cpu使用率百分比；示例中农，cpu使用率超过60%即开始扩容</li>
</ul>
<h2 id="范例-autoscaling-v2beta2"><a href="#范例-autoscaling-v2beta2" class="headerlink" title="范例-autoscaling/v2beta2"></a>范例-autoscaling/v2beta2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: autoscaling/v2beta2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: php-apache</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  metrics:</span><br><span class="line">  - type: Resource</span><br><span class="line">    resource:</span><br><span class="line">      name: cpu</span><br><span class="line">      target:</span><br><span class="line">        type: Utilization</span><br><span class="line">        averageUtilization: 50</span><br><span class="line">  - type: Pods</span><br><span class="line">    pods:</span><br><span class="line">      metric:</span><br><span class="line">        name: packets-per-second</span><br><span class="line">      target:</span><br><span class="line">        type: AverageValue</span><br><span class="line">        averageValue: 1k</span><br><span class="line">  - type: Object</span><br><span class="line">    object:</span><br><span class="line">      metric:</span><br><span class="line">        name: requests-per-second</span><br><span class="line">      describedObject:</span><br><span class="line">        apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">        kind: Ingress</span><br><span class="line">        name: main-route</span><br><span class="line">      target:</span><br><span class="line">        type: Value</span><br><span class="line">        value: 10k</span><br><span class="line">  - type: External</span><br><span class="line">    external:</span><br><span class="line">      metric:</span><br><span class="line">        name: queue_messages_ready</span><br><span class="line">        selector: &quot;queue=worker_tasks&quot;</span><br><span class="line">      target:</span><br><span class="line">        type: AverageValue</span><br><span class="line">        averageValue: 30</span><br></pre></td></tr></table></figure>
<p>metrics：用于副本数计算的指标，包含类型如下：</p>
<ul>
<li>Resource：当前伸缩对象下每个pod的cpu和memory指标，只支持Utilization和AverageValue类型的目标值</li>
<li>Pods：当前伸缩对象下每个pod的相关指标，数据由第三方adapter提供，只允许AverageValue类型的目标值</li>
<li>Object：k8s资源对象的指标，数据由第三方adapter提供，只支持Value和AverageValue类型的目标值</li>
<li>External：k8s集群外部的指标，数据由第三方的adapter提供，只支持Value和AverageValue类型的目标值</li>
</ul>
<h1 id="HPA范例-基于CPU指标"><a href="#HPA范例-基于CPU指标" class="headerlink" title="HPA范例-基于CPU指标"></a>HPA范例-基于CPU指标</h1><h2 id="部署metrics-server"><a href="#部署metrics-server" class="headerlink" title="部署metrics-server"></a>部署metrics-server</h2><p>metrics server提供基于资源指标伸缩的API(metrics.k8s.io)</p>
<p>metrics server项目地址：<a href="https://github.com/kubernetes-incubator/metrics-server" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/metrics-server</a></p>
<h2 id="基于CPU指标实践"><a href="#基于CPU指标实践" class="headerlink" title="基于CPU指标实践"></a>基于CPU指标实践</h2><h3 id="部署pod"><a href="#部署pod" class="headerlink" title="部署pod"></a>部署pod</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: java-demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: java-demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: lizhenliang/java-demo</span><br><span class="line">        name: java</span><br><span class="line">        resources: </span><br><span class="line">           requests:</span><br><span class="line">             memory: &quot;300Mi&quot;</span><br><span class="line">             cpu: &quot;250m&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: java-demo</span><br></pre></td></tr></table></figure>
<h3 id="创建HPA"><a href="#创建HPA" class="headerlink" title="创建HPA"></a>创建HPA</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 5</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: web</span><br><span class="line">  targetCPUUtilizationPercentage: 60</span><br></pre></td></tr></table></figure>
<h3 id="压测与查看"><a href="#压测与查看" class="headerlink" title="压测与查看"></a>压测与查看</h3><ul>
<li><p>开始压测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">ab -c 1000 -n 100000  http://10.1.206.176/ #10.0.0.147为ClusterIP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-c 并发数 -n 请求总数</p>
</blockquote>
</li>
<li><p>观察扩容缩容情况【压测完成后，过5分钟(缩容冷却周期)后开始缩容】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get hpa</span><br><span class="line">kubectl top pods</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HPA范例-基于prometheus自定义指标"><a href="#HPA范例-基于prometheus自定义指标" class="headerlink" title="HPA范例-基于prometheus自定义指标"></a>HPA范例-基于prometheus自定义指标</h1><p>基于资源指标（cpu、内存）进行pod伸缩，使用metrics-server就可以(metrics.k8s.io)；但是如果想使用自定义指标：如请求qps/5xx错误数实现HPA，就需要部署单独的适配器来支持自定义指标(custom.metrics.k8s.io)；目前比较成熟的是 Prometheus Custom Metrics，由prometheus提供自定义指标，再利用k8s-prometheus-adpater将指标数据聚合到APIServer，以此实现和核心指标(metrics server)同样的效果</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/hpa-custom-metrics.png" alt></p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/hpa-metrics-all.png" style="zoom:200%;"></p>
<h2 id="部署prometheus"><a href="#部署prometheus" class="headerlink" title="部署prometheus"></a>部署prometheus</h2><p>可以只部署prometheus-server和客户端组件【提供数据给HPA决策使用】</p>
<p>分组件部署范例：<a href="https://github.com/simple0426/sysadm/tree/master/kubernetes/prometheus" target="_blank" rel="noopener">https://github.com/simple0426/sysadm/tree/master/kubernetes/prometheus</a></p>
<h2 id="部署Custom-Metrics-Adapter"><a href="#部署Custom-Metrics-Adapter" class="headerlink" title="部署Custom Metrics Adapter"></a>部署Custom Metrics Adapter</h2><p>由于prometheus采集到的数据和k8s数据格式不兼容，因此不能直接给k8s用；此时需要使用一个适配器(k8s-prometheus-adpater)将prometheus的数据格式转换为k8s API可以识别的格式；转换后，因为是自定义API，所以还需要kubernetes aggregator在主APIServer中注册【API Server开启聚合层支持】</p>
<p>k8s-prometheus-adpater项目：<a href="https://github.com/DirectXMan12/k8s-prometheus-adapter" target="_blank" rel="noopener">https://github.com/DirectXMan12/k8s-prometheus-adapter</a></p>
<p>直接使用helm charts进行安装(指定prometheus地址)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">helm repo update</span><br><span class="line">helm search repo prometheus-adapter</span><br><span class="line">helm install prometheus-adapter stable/prometheus-adapter --namespace ops --set prometheus.url=http://prometheus.ops,prometheus.port=9090</span><br></pre></td></tr></table></figure>
<p>查看安装结果，是否已注册到APIServer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get apiservices |grep custom </span><br><span class="line">kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1</span><br></pre></td></tr></table></figure>
<h2 id="基于QPS指标实践"><a href="#基于QPS指标实践" class="headerlink" title="基于QPS指标实践"></a>基于QPS指标实践</h2><blockquote>
<p>QPS获取方式</p>
<ul>
<li>从日志中获取</li>
<li>从代理或负载均衡器处获取【external指标】，如nginx+lua、haproxy</li>
<li>程序自身统计【pod指标】，以下实践案例即为程序自身提供指标数据</li>
</ul>
</blockquote>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><blockquote>
<p>pod中添加注解(annotations)允许prometheus采集数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: metrics-app</span><br><span class="line">  name: metrics-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: metrics-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: metrics-app</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">        prometheus.io/port: &quot;80&quot;</span><br><span class="line">        prometheus.io/path: &quot;/metrics&quot;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: lizhenliang/metrics-app</span><br><span class="line">        name: metrics-app</span><br><span class="line">        ports:</span><br><span class="line">        - name: web</span><br><span class="line">          containerPort: 80</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 200m</span><br><span class="line">            memory: 256Mi</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 3</span><br><span class="line">          periodSeconds: 5</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 3</span><br><span class="line">          periodSeconds: 5</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: metrics-app</span><br><span class="line">  labels:</span><br><span class="line">    app: metrics-app</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: web</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: metrics-app</span><br></pre></td></tr></table></figure>
<p>metrics-app暴露了一个prometheus格式指标接口(<a href="http://URL/metrics)，可以通过service看到" target="_blank" rel="noopener">http://URL/metrics)，可以通过service看到</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl 10.0.0.159/metrics</span><br><span class="line"># HELP http_requests_total The amount of requests in total</span><br><span class="line"># TYPE http_requests_total counter</span><br><span class="line">http_requests_total 72</span><br><span class="line"># HELP http_requests_per_second The amount of requests per second the latest ten seconds</span><br><span class="line"># TYPE http_requests_per_second gauge</span><br><span class="line">http_requests_per_second 0.5</span><br></pre></td></tr></table></figure>
<h3 id="定义适配器规则获取特定指标"><a href="#定义适配器规则获取特定指标" class="headerlink" title="定义适配器规则获取特定指标"></a>定义适配器规则获取特定指标</h3><p>规则范例：<a href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md" target="_blank" rel="noopener">https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md</a></p>
<p>编辑prometheus-adapter的配置文件添加规则(重建prometheus-adapter使配置生效)：<code>kubectl edit cm prometheus-adapter -n ops</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    meta.helm.sh/release-name: prometheus-adapter</span><br><span class="line">    meta.helm.sh/release-namespace: ops</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-adapter</span><br><span class="line">    app.kubernetes.io/managed-by: Helm</span><br><span class="line">    chart: prometheus-adapter-2.5.0</span><br><span class="line">    heritage: Helm</span><br><span class="line">    release: prometheus-adapter</span><br><span class="line">data:</span><br><span class="line">  config.yaml: |</span><br><span class="line">    rules:</span><br><span class="line">    - seriesQuery: &apos;http_requests_total&#123;kubernetes_namespace!=&quot;&quot;,kubernetes_pod_name!=&quot;&quot;&#125;&apos;</span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          kubernetes_namespace: &#123;resource: &quot;namespace&quot;&#125;</span><br><span class="line">          kubernetes_pod_name: &#123;resource: &quot;pod&quot;&#125;</span><br><span class="line">      name:</span><br><span class="line">        matches: &quot;^(.*)_total&quot;</span><br><span class="line">        as: &quot;$&#123;1&#125;_per_second&quot;</span><br><span class="line">      metricsQuery: &apos;sum(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[2m])) by (&lt;&lt;.GroupBy&gt;&gt;)&apos;</span><br></pre></td></tr></table></figure>
<p>以上规则表示：2min内pod的http_requests_total增长速率(以namespace、pod分类计算)</p>
<ul>
<li>seriesQuery：获取原始的指标数据(promQL语法)；此处为：从prometheus中获取所有namespace、pod下的http_requests_total指标</li>
<li>resources：将prometheus中的标签名称格式统一，以反映为对应的k8s资源(kubectl api-resources)；此处为：kubernetes_namespace转换为namespace，kubernetes_pod_name转换为pod</li>
<li>name：设置可用于hpa的度量指标名称；此处重命名获取的度量指标名称：http_requests_total重命名为http_requests_per_second</li>
<li>metricsQuery：度量指标计算(promQL语法)；此处等同于【<code>sum(rate(http_requests_total{kubernetes_namespace!=&quot;&quot;,kubernetes_pod_name!=&quot;&quot;}[2m])) by (kubernetes_namespace,kubernetes_pod_name)</code>】</li>
</ul>
<p>从api中查询prometheus-adapter获取的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get --raw &quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests_per_second&quot;</span><br></pre></td></tr></table></figure>
<h3 id="创建HPA-1"><a href="#创建HPA-1" class="headerlink" title="创建HPA"></a>创建HPA</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">piVersion: autoscaling/v2beta2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: metrics-app-hpa </span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: metrics-app</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  metrics:</span><br><span class="line">  - type: Pods</span><br><span class="line">    pods:</span><br><span class="line">      metric:</span><br><span class="line">        name: http_requests_per_second</span><br><span class="line">      target:</span><br><span class="line">        type: AverageValue # 获取指标数据后，取多个pod速率的平均值。</span><br><span class="line">        averageValue: 800m   # 800m 即0.8个/秒</span><br></pre></td></tr></table></figure>
<h3 id="压测和查看"><a href="#压测和查看" class="headerlink" title="压测和查看"></a>压测和查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab -n 100000 -c 100 http://10.0.0.159/metrics</span><br><span class="line">kubectl get hpa metrics-app-hpa</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>弹性伸缩</tag>
        <tag>HPA</tag>
        <tag>drain</tag>
        <tag>cordon</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-包管理器helm</title>
    <url>/blog/2020/03/08/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8helm/</url>
    <content><![CDATA[<h1 id="helm简介"><a href="#helm简介" class="headerlink" title="helm简介"></a><a href="https://helm.sh/" target="_blank" rel="noopener">helm简介</a></h1><ul>
<li><p>优点</p>
<ul>
<li>能够管理复杂的程序结构，将各种配置文件(service/deployment/configmap)作为整体管理</li>
<li>使用模板后，资源文件可以复用、分享</li>
<li>可以支持应用级别的版本管理：更新、回滚</li>
</ul>
</li>
<li><p>核心概念</p>
<ul>
<li>helm：helm二进制管理工具，主要用于k8s应用的创建、打包、发布、管理；类似linux上的apt/yum工具</li>
<li>Chart：描述一个应用的所有k8s资源文件集合；相当于linux中的的rpm、deb包</li>
<li>Release：Chart的部署实体，chart被部署后会生成一个对应的Release；相当于linux中的服务进程</li>
<li>【v2版本】Tiller server：它是运行于k8s集群中的应用；helm的服务端程序，接收helm客户端请求，与kubernetes API Server交互，完成以下任务：<ul>
<li>监听来自helm客户端的请求</li>
<li>安装应用，合并charts和Config为一个Release</li>
<li>跟踪Release状态</li>
<li>升级或卸载Release</li>
</ul>
</li>
</ul>
</li>
<li><p>helm版本对比：</p>
<ul>
<li>v2：有服务端tiller组件，使用自定义RBAC进行认证授权；Release名称不支持名称空间，全局唯一</li>
<li>v3：无服务端组件，使用kubeconfig方式进行认证授权；Release名称可以在不同名称空间重用</li>
</ul>
</li>
<li><p>helm下载：</p>
<ul>
<li>官方版本信息：<a href="https://github.com/helm/helm/tags" target="_blank" rel="noopener">https://github.com/helm/helm/tags</a></li>
<li>国内下载地址：<a href="https://mirrors.huaweicloud.com/helm/" target="_blank" rel="noopener">https://mirrors.huaweicloud.com/helm/</a></li>
</ul>
</li>
</ul>
<h2 id="v2版本服务端安装"><a href="#v2版本服务端安装" class="headerlink" title="v2版本服务端安装"></a>v2版本服务端安装</h2><ul>
<li>rbac配置<ul>
<li><code>kubectl create serviceaccount --namespace kube-system tiller</code></li>
<li><code>kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller</code></li>
</ul>
</li>
<li>初始化安装tiller server：<code>helm init --service-account tiller --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.14.1 --stable-repo-url https://apphub.aliyuncs.com --debug</code></li>
<li>卸载：<ul>
<li><code>kubectl delete deploy tiller-deploy -n kube-system</code></li>
<li><code>helm reset</code></li>
</ul>
</li>
</ul>
<h2 id="helm命令"><a href="#helm命令" class="headerlink" title="helm命令"></a>helm命令</h2><blockquote>
<p>读取本地的kubeconfig用于k8s集群认证</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>详解</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>completion</td>
<td>命令行补全</td>
<td>source &lt;(helm completion bash)</td>
</tr>
<tr>
<td>env</td>
<td>显示配置、数据、插件、仓库、缓存等位置</td>
<td>helm env</td>
</tr>
<tr>
<td>plugin</td>
<td>chart插件管理</td>
<td>helm plugin install <a href="https://github.com/chartmuseum/helm-push" target="_blank" rel="noopener">https://github.com/chartmuseum/helm-push</a></td>
</tr>
</tbody>
</table>
<h1 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h1><h2 id="chart管理"><a href="#chart管理" class="headerlink" title="chart管理"></a>chart管理</h2><ul>
<li>下载chart(当前目录)：helm pull apphub/nginx      </li>
<li>查看chart内容：helm show all/chart/readme/values redis</li>
<li>管理chart依赖：helm dependency<ul>
<li>查看依赖：helm dependency list mychart</li>
<li>下载依赖：helm dependency update mychart</li>
</ul>
</li>
</ul>
<h2 id="release管理"><a href="#release管理" class="headerlink" title="release管理"></a>release管理</h2><ul>
<li>查看运行中的release列表：helm list</li>
<li>安装release：helm install redis apphub/redis</li>
<li>升级release：helm upgrade web1 –set image.tag=”1.19” mychart</li>
<li>卸载release：helm uninstall</li>
<li>查看release部署历史：helm history web1</li>
<li>回滚到上一版本：helm rollback web1</li>
<li>查看release详情：helm get  all/hooks/manifest/notes/values</li>
<li>查看release信息：helm status nginx</li>
</ul>
<h2 id="安装和升级参数"><a href="#安装和升级参数" class="headerlink" title="安装和升级参数"></a>安装和升级参数</h2><ul>
<li><p>使用方式：helm install/upgrade</p>
<ul>
<li>命令行传参(–set)：helm install db –set persistence.storageClass=”example-nfs” microsoft/mysql</li>
<li><p>配置文件方式(-f)：helm install db -f mysql.yaml microsoft/mysql</p>
<blockquote>
<p>可以使用show values获取chart默认值文件后修改：helm show values apphub/nginx &gt; nginx.yaml</p>
</blockquote>
</li>
</ul>
</li>
<li><p>文件与命令使用形式对照</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>yaml</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>name:value</td>
<td>–set name=value</td>
</tr>
<tr>
<td>name:<br>-a<br>-b<br>-c</td>
<td>–set name={a,b,c}</td>
</tr>
<tr>
<td>servers:<br>-port:80</td>
<td>–set servers[0].port=80</td>
</tr>
<tr>
<td>image:<br>tag:”1.16”</td>
<td>–set image.tag=”1.16”</td>
</tr>
</tbody>
</table>
<h1 id="chart仓库管理"><a href="#chart仓库管理" class="headerlink" title="chart仓库管理"></a>chart仓库管理</h1><h2 id="公有hub"><a href="#公有hub" class="headerlink" title="公有hub"></a>公有hub</h2><blockquote>
<p>可使用web搜索</p>
</blockquote>
<ul>
<li>官方：<a href="https://hub.helm.sh/" target="_blank" rel="noopener">https://hub.helm.sh/</a><ul>
<li>代码地址(开发者)：<a href="https://github.com/helm/charts" target="_blank" rel="noopener">https://github.com/helm/charts</a></li>
<li>charts仓库：<ul>
<li>stable：<code>https://kubernetes-charts.storage.googleapis.com</code></li>
<li>incubator：<code>https://kubernetes-charts-incubator.storage.googleapis.com</code></li>
</ul>
</li>
<li>微软镜像charts仓库【适合国内】<ul>
<li>stable：<code>http://mirror.azure.cn/kubernetes/charts/</code></li>
<li>incubator：<code>http://mirror.azure.cn/kubernetes/charts-incubator/</code></li>
</ul>
</li>
</ul>
</li>
<li>kubeapps：<a href="https://hub.kubeapps.com/" target="_blank" rel="noopener">https://hub.kubeapps.com/</a><ul>
<li>代码地址(开发者)：<a href="https://github.com/kubeapps/kubeapps" target="_blank" rel="noopener">https://github.com/kubeapps/kubeapps</a></li>
<li>charts仓库：<code>https://charts.bitnami.com/bitnami</code></li>
</ul>
</li>
<li>阿里云：<a href="https://developer.aliyun.com/hub/" target="_blank" rel="noopener">https://developer.aliyun.com/hub/</a><ul>
<li>代码地址(开发者)：<a href="https://github.com/cloudnativeapp/charts" target="_blank" rel="noopener">https://github.com/cloudnativeapp/charts</a></li>
<li>charts仓库：<code>https://apphub.aliyuncs.com</code>【适合国内】</li>
</ul>
</li>
</ul>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><ul>
<li>显示仓库列表：helm repo list</li>
<li>添加仓库：helm repo add name <em>URL</em></li>
<li>更新仓库元数据：helm repo update</li>
<li>删除仓库：helm repo remove name</li>
<li>搜索仓库：helm search repo _chart_name_</li>
<li>搜索hub：helm search hub _chart_name_ <ul>
<li>–endpoint 指定要搜索的hub地址（默认官方）</li>
<li>可以搜索由<a href="https://github.com/helm/monocular" target="_blank" rel="noopener">Monocular</a>渲染的charts hub</li>
</ul>
</li>
</ul>
<h2 id="charts仓库-原生实现"><a href="#charts仓库-原生实现" class="headerlink" title="charts仓库-原生实现"></a>charts仓库-原生实现</h2><ul>
<li><p>创建索引文件：helm repo index my-repo –url <a href="http://49.232.17.71:8900" target="_blank" rel="noopener">http://49.232.17.71:8900</a></p>
<ul>
<li>my-repo为多个chart压缩包所在目录</li>
<li>url为helm下载chart使用的主机地址</li>
</ul>
</li>
<li><p>将chart压缩包目录(包含索引文件和chart压缩包)使用web服务发布出去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name=chart-repo --restart=always \</span><br><span class="line">-v $(pwd)/my-repo:/usr/share/nginx/html \</span><br><span class="line">-v $(pwd)/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-p 8900:80 nginx</span><br></pre></td></tr></table></figure>
<p>可以在nginx配置文件中开启文件目录索引，这样使用者就可以在web界面查看charts仓库包含的chart</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoindex on;</span><br><span class="line">autoindex_exact_size off;</span><br><span class="line">autoindex_localtime on;</span><br><span class="line">charset utf-8;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="chart仓库-ChartMuseum"><a href="#chart仓库-ChartMuseum" class="headerlink" title="chart仓库-ChartMuseum"></a>chart仓库-<a href="https://github.com/helm/chartmuseum" target="_blank" rel="noopener">ChartMuseum</a></h1><blockquote>
<p>此处使用在harbor中集成的chartmuseum仓库</p>
</blockquote>
<h2 id="harbor启用chartmuseum功能"><a href="#harbor启用chartmuseum功能" class="headerlink" title="harbor启用chartmuseum功能"></a>harbor启用chartmuseum功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ./install.sh --with-chartmuseum</span><br></pre></td></tr></table></figure>
<h2 id="helm添加chartmuseum仓库"><a href="#helm添加chartmuseum仓库" class="headerlink" title="helm添加chartmuseum仓库"></a><a href="https://goharbor.io/docs/2.0.0/working-with-projects/working-with-images/managing-helm-charts/#working-with-chartmuseum-via-the-helm-cli" target="_blank" rel="noopener">helm添加chartmuseum仓库</a></h2><ul>
<li><p>不指定项目名称：将charts推送到library项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add --ca-file ca.crt --username=admin --password=Passw0rd myrepo https://xx.xx.xx.xx/chartrepo</span><br></pre></td></tr></table></figure>
<ul>
<li>–ca-file：指定自签名ca证书</li>
<li>–username/–password：指定harbor认证信息</li>
<li><strong>chartrepo</strong>为harbor的chartmuseum接口</li>
</ul>
</li>
<li><p>指定项目名称：将charts推送到指定项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add --ca-file ca.crt --username=admin --password=Passw0rd myrepo https://xx.xx.xx.xx/chartrepo/myproject</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装helm-push插件"><a href="#安装helm-push插件" class="headerlink" title="安装helm-push插件"></a>安装<a href="https://github.com/chartmuseum/helm-push" target="_blank" rel="noopener">helm-push插件</a></h2><ul>
<li><p>在线方式：helm plugin命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm plugin install https://github.com/chartmuseum/helm-push</span><br></pre></td></tr></table></figure>
</li>
<li><p>离线方式：下载二进制文件并放在合适的位置</p>
<ul>
<li>helm env：查看插件默认位置，如：HELM_PLUGINS=”/root/.local/share/helm/plugins”</li>
<li>创建默认位置目录：mkdir -p /root/.local/share/helm/plugins/helm-push</li>
<li><a href="https://github.com/chartmuseum/helm-push/releases" target="_blank" rel="noopener">下载二进制文件</a>并解压，最终目录结构如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins/</span><br><span class="line">└── helm-push</span><br><span class="line">    ├── bin</span><br><span class="line">    │   └── helmpush</span><br><span class="line">    ├── LICENSE</span><br><span class="line">    └── plugin.yaml</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="push推送charts到chartmuseum"><a href="#push推送charts到chartmuseum" class="headerlink" title="push推送charts到chartmuseum"></a>push推送charts到chartmuseum</h2><ul>
<li>push .tgz压缩包：helm push mychart-0.1.0.tgz myrepo</li>
<li>push chart目录：helm push mychart myrepo</li>
<li><em>push参数</em>：<ul>
<li>–username/–password：认证信息</li>
<li>–ca-file=ca.crt：指定自签ca证书</li>
<li>–force/-f：强制推送【覆盖】</li>
<li>–version：自定义版本<ul>
<li>latest：helm push –version=”latest” mychart myrepo </li>
<li>git版本：<code>helm push mychart/ --version=&quot;$(git log -1 --pretty=format:%h)&quot; chartmuseum</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="从chartmuseum安装charts"><a href="#从chartmuseum安装charts" class="headerlink" title="从chartmuseum安装charts"></a>从chartmuseum安装charts</h2><ul>
<li>本地更新chart仓库：helm repo update</li>
<li>搜索charts：helm search repo mychart</li>
<li>安装charts：helm install web myrepo/library/mychart<ul>
<li>–version：自定义版本</li>
</ul>
</li>
</ul>
<h1 id="chart模板语法"><a href="#chart模板语法" class="headerlink" title="chart模板语法"></a><a href="https://helm.sh/docs/chart_template_guide/" target="_blank" rel="noopener">chart模板语法</a></h1><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><blockquote>
<p>内置值始终以大写字母开头</p>
</blockquote>
<ul>
<li><p><code>.Release.*</code>：引用Release中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123; .Release.Namespace &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.Values.*</code>：引用values.yaml文件中的内容、命令行安装/升级Release时-f/–set设置的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Values.image.repository &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--set image.repository=&quot;tomcat&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.Chart.*</code>：引用Chart.yaml文件中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125; #chart名称和版本</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.Capabilitie.*</code>：获取k8s信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Capabilities.KubeVersion &#125;&#125; #k8s版本</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.Template.*</code>：模板信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Template.Name &#125;&#125; #当前模板文件路径</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数和管道"><a href="#函数和管道" class="headerlink" title="函数和管道"></a><a href="https://helm.sh/docs/chart_template_guide/function_list/" target="_blank" rel="noopener">函数和管道</a></h2><ul>
<li><p>quote：将变量值加双引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; quote .Values.image.repository &#125;&#125; #函数形式</span><br><span class="line">&#123;&#123; .Values.image.repository|quote &#125;&#125; #管道形式</span><br></pre></td></tr></table></figure>
</li>
<li><p>repeat：重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Template.Name|repeat 4 &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>default：设置默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Template.Name1|default &quot;test&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>indent：缩进，左边空出空格【nindent，创建新行并缩进】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toppings: |</span><br><span class="line">&#123;&#123;- range .Values.pizzaToppings &#125;&#125;</span><br><span class="line">&#123;&#123; indent 2 .|title &#125;&#125;</span><br><span class="line">&#123;&#123;- end&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toYaml：将当前变量值(字典)转换为yaml格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values文件定义</span><br><span class="line"># test1: &#123;&quot;a1&quot;: &quot;cest&quot;, &quot;b1&quot;: &quot;dfsdfs&quot;&#125;</span><br><span class="line">test1:</span><br><span class="line">  a1: cest</span><br><span class="line">  b1: dfsdfs</span><br><span class="line"></span><br><span class="line">引用：</span><br><span class="line">  test_dict:</span><br><span class="line">  &#123;&#123;- toYaml .Values.test1|nindent 4 &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><p>if-else：本例中同时在左括号旁边使用短横线来消除语句左边的空白</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- if .Values.resources &#125;&#125;</span><br><span class="line">resources:</span><br><span class="line">&#123;&#123;- toYaml .Values.resources|nindent 10&#125;&#125;</span><br><span class="line">&#123;&#123;- else &#125;&#125;</span><br><span class="line">resources: &#123;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>with：限制变量作用域范围【本例中限定在Chart文件中，可以直接使用Name(等效于全局使用.Chart.Name)】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- with .Chart &#125;&#125;</span><br><span class="line">name: &#123;&#123;  .Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>range：循环【循环values文件中pizzaToppings】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toppings: |</span><br><span class="line">  &#123;&#123;- range .Values.pizzaToppings &#125;&#125;</span><br><span class="line">  - &#123;&#123; .|title|quote &#125;&#125;</span><br><span class="line">  &#123;&#123;- end&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><ul>
<li><p>with中引用当前作用域以外的变量值(如：内置变量)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- $relname := .Release.Name -&#125;&#125; #定义变量$relname</span><br><span class="line">&#123;&#123;- with .Chart &#125;&#125;</span><br><span class="line">name: &#123;&#123;  .Name &#125;&#125;</span><br><span class="line">relname: &#123;&#123; $relname &#125;&#125; #引用变量</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环列表产生索引和变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toppings: |</span><br><span class="line">&#123;&#123;- range $index,$value := .Values.pizzaToppings &#125;&#125;</span><br><span class="line">  &#123;&#123; $index &#125;&#125;: &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环字典产生key和value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- range $key,$val := .Values.service &#125;&#125;</span><br><span class="line">&#123;&#123; $key &#125;&#125;: &#123;&#123; $val|quote &#125;&#125;</span><br><span class="line">&#123;&#123;- end&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命名模板"><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h2><ul>
<li><p>define：</p>
<ul>
<li><p>在_helpers.tpl中定义命名模板【下划线开始的文件都不是k8s资源清单，可以定义模板】</p>
</li>
<li><p>模板名称定义规范：chart_name.func_name，以chart名称为前缀</p>
</li>
<li><p>模板功能注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;/*公共标签*/&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now|htmlDate &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">    version: &#123;&#123; .Chart.Version &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.app&quot; &#125;&#125;</span><br><span class="line">app_name: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">app_version: &quot;&#123;&#123; .Chart.Version &#125;&#125;&quot;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>template：引用子模板内容【使用点定义子模板可以继承当前模板内容，默认子模板没有作用域】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  &#123;&#123;- template &quot;mychart.labels&quot; . &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>include：引用子模板并调用函数进行格式化处理【相比template更推荐使用】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">&#123;&#123;- include &quot;mychart.app&quot; .|indent 4 &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="chart开发"><a href="#chart开发" class="headerlink" title="chart开发"></a>chart开发</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>创建一个chart：helm create mychart </li>
<li>检查chart语法：helm lint mychart</li>
<li>渲染模板并输出：helm template sample mychart</li>
<li>打包chart为压缩包：helm package mychart</li>
<li>推送chart到chartmuseum【安装push插件】：helm push mychart myrepo</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="chart目录结构"><a href="#chart目录结构" class="headerlink" title="chart目录结构"></a><a href="https://helm.sh/docs/topics/charts/#the-chartyaml-file" target="_blank" rel="noopener">chart目录结构</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── LICENSE # 许可证信息【可选】</span><br><span class="line">├── README.md # README文件【可选】</span><br><span class="line">├── Chart.yaml  # chart的元数据信息，包括名字、描述信息、版本、依赖等</span><br><span class="line">├── charts/  # 当前chart依赖的其他chart文件</span><br><span class="line">│   └── mysql-6.8.0.tgz</span><br><span class="line">├── crds/ # 自定义资源</span><br><span class="line">├── templates/  # 模板文件，用于生成kubernetes资源</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl  # 模板助手，会在模板文件中定义可公用的子模板</span><br><span class="line">│   ├── hpa.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt # 使用帮助文件；helm install部署后或helm status会显示此信息</span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   └── service.yaml</span><br><span class="line">└── values.yaml   # chart默认配置文件(模板文件中变量的值)，install/upgrade -f/--set会覆盖其中的值</span><br></pre></td></tr></table></figure>
<h3 id="Chart-yaml"><a href="#Chart-yaml" class="headerlink" title="Chart.yaml"></a>Chart.yaml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: chart API版本 (必选项)</span><br><span class="line">name: chart名称 (必选项)</span><br><span class="line">version: chart项目版本 (必选项)</span><br><span class="line">kubeVersion: 支持的k8s版本(可选项)</span><br><span class="line">description: 项目描述信息 (可选项)</span><br><span class="line">type: chart类型 (可选项)</span><br><span class="line">keywords:</span><br><span class="line">  - 项目涉及的关键词 (可选项)</span><br><span class="line">home: 项目主页 (可选项)</span><br><span class="line">sources:</span><br><span class="line">  - 项目源代码 (可选项)</span><br><span class="line">dependencies: # 项目依赖的其他chart (可选项)</span><br><span class="line">  - name: chart名称 (如nginx)</span><br><span class="line">    version: chart版本 (&quot;1.2.3&quot;)</span><br><span class="line">    repository: 仓库地址 (&quot;https://example.com/charts&quot;) 或仓库别名 (&quot;@repo-name&quot;)</span><br><span class="line">    condition、tags、enabled: (可选项) 综合逻辑启用或停止此依赖</span><br><span class="line">    alias: (可选项) chart别名，在多次使用chart依赖时可用</span><br><span class="line">maintainers: # 项目维护信息(可选项)</span><br><span class="line">  - name: </span><br><span class="line">    email: </span><br><span class="line">    url:</span><br><span class="line">icon: 项目图标url (可选项).</span><br><span class="line">appVersion: 应用版本信息 【比如redis、nginx的版本】(可选项)</span><br><span class="line">deprecated: 是否被遗弃(可选项, boolean)</span><br><span class="line">annotations:</span><br><span class="line">  注解信息 (可选项).</span><br></pre></td></tr></table></figure>
<ul>
<li>apiVersion版本（v1到v2）<ul>
<li>v1的依赖定义使用requirements.yaml文件，v2的依赖使用chart.yaml文件中的dependencies字段</li>
<li>v2增加type字段，描述chart类型</li>
</ul>
</li>
<li>type：chart类型<ul>
<li>application：这是一个应用，可以直接部署为Release</li>
<li>library：这是一个库，只能被application依赖使用</li>
</ul>
</li>
</ul>
<h2 id="常用参数化字段"><a href="#常用参数化字段" class="headerlink" title="常用参数化字段"></a>常用参数化字段</h2><ul>
<li>镜像</li>
<li>标签</li>
<li>端口</li>
<li>资源限制</li>
<li>环境变量</li>
<li>副本数</li>
<li>k8s资源名称</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>helm</tag>
        <tag>charts</tag>
        <tag>chartmuseum</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-网络模型和策略控制</title>
    <url>/blog/2020/03/03/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%AD%96%E7%95%A5%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="kubernetes网络模型"><a href="#kubernetes网络模型" class="headerlink" title="kubernetes网络模型"></a>kubernetes网络模型</h1><p>kubernetes要求所有的网络插件必须满足以下要求</p>
<ul>
<li>一个pod一个ip</li>
<li>所有pod可以和任意其他pod通信，无需使用NAT映射</li>
<li>所有节点可以与所有pod直接通信，无需使用NAT映射</li>
<li>pod内部获取到的IP地址和与其他pod或节点通信时使用的IP地址相同</li>
</ul>
<h2 id="k8s网络应用场景"><a href="#k8s网络应用场景" class="headerlink" title="k8s网络应用场景"></a>k8s网络应用场景</h2><ul>
<li>pod内不同容器间：同一个pod内的所有容器共享同一个网络命名空间，由构建pod对象的infra containers提供；<strong>由linux的网络命名空间这一特性实现</strong></li>
<li>pod之间通信：<ul>
<li>同主机：<ul>
<li>【flannel】多个veth设备对包含在一个网桥中，通过桥接方式连接多个pod；<strong>使用docker网络模型</strong></li>
<li>【calico】将访问本机特定pod ip的数据包转发给设备对cali*，访问本机pod网段的其他数据包丢弃(blackhole)</li>
</ul>
</li>
<li>跨主机：通过路由(underlay)或隧道(overlay)方式连接不同主机pod；<strong>由网络插件(CNI)提供的功能实现</strong></li>
</ul>
</li>
<li>pod与service通信：k8s将service的cluster-ip到pod-ip的映射转换为相应节点的iptables、ipvs规则，从而实现service到pod的通信；<strong>由k8s的kube-proxy组件实现</strong></li>
<li>互联网访问service：<strong>由k8s的kube-proxy组件实现</strong>，根据访问类型不一样实现机制不同</li>
<li>pod访问互联网：<strong>使用docker的网络模型</strong><ul>
<li>每个容器通过veth设备对和宿主机连通</li>
<li>桥接网卡(flannel)或veth设备对cali(calico)和宿主机出口(例如eth0)通过iptables的nat转换，从而可以让容器连接互联网</li>
</ul>
</li>
</ul>
<h2 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h2><p>CNI（Container Network Interface，容器网络接口)：是一个容器网络规范；kubernetes网络就是采用这个CNI规范，CNI实现依赖两种插件：</p>
<ul>
<li>一种是基础功能插件：负责容器连接到主机</li>
<li>一种是IPAM类插件：负责配置容器网络命名空间的网络</li>
</ul>
<p>项目地址：<a href="https://github.com/containernetworking/cni" target="_blank" rel="noopener">https://github.com/containernetworking/cni</a></p>
<p>pod网络创建流程</p>
<ul>
<li>kubelet与docker通信（/var/run/docker.sock）</li>
<li>调用dockershim创建一个infra容器</li>
<li>调用CNI插件为infra容器配置网络</li>
</ul>
<h2 id="启用CNI功能"><a href="#启用CNI功能" class="headerlink" title="启用CNI功能"></a>启用CNI功能</h2><ul>
<li><p>安装基础功能插件：用于容器连接主机</p>
<ul>
<li><p>二进制方式：<a href="https://github.com/containernetworking/plugins/releases" target="_blank" rel="noopener">https://github.com/containernetworking/plugins/releases</a></p>
</li>
<li><p>yum方式：kubernetes-cni</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">yum clean all</span><br><span class="line">yum install kubernetes-cni -y</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>插件默认目录位置</p>
<ul>
<li>二进制文件目录：/opt/cni/bin</li>
<li>配置文件目录：/etc/cni/net.d【ipam类插件(calico、flannel)启动后会在目录下生成插件的配置文件】</li>
</ul>
</li>
<li><p>kubelet启用cni设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--network-plugin=cni \</span><br><span class="line">--cni-conf-dir=/etc/cni/net.d \</span><br><span class="line">--cni-bin-dir=/opt/cni/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见CNI插件"><a href="#常见CNI插件" class="headerlink" title="常见CNI插件"></a>常见CNI插件</h2><blockquote>
<p>IPAM类插件：负责配置容器网络命名空间的网络</p>
</blockquote>
<ul>
<li>flannel：一个为kubernetes提供overlay(叠加网络)的插件，它基于linux tun/tap，使用udp封装ip报文来创建叠加网络，并借助etcd维护网络分配情况；不支持网络策略</li>
<li>calico：一个基于BGP的三层网络插件，并且支持网络策略(network policy)实现访问控制；它在每台机器上运行一个vRouter，利用Linux内核来转发网络数据包，并借助iptables实现防火墙功能</li>
<li>canal：包含flannel和calico功能的插件，支持网络策略</li>
<li>weavenet：多主机容器网络方案，采用UDP封装实现L2 Overlay，支持用户态(慢，可加密)/内核态(快，不能加密)两种方式</li>
<li>kube-router：kubernetes提供的网络解决方案，采用BGP提供网络直连，集成基于LVS的负载均衡能力；支持网络策略</li>
</ul>
<h1 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h1><p>Flannel是CoreOS维护的一个网络组件，Flannel为每个Pod提供全局唯一的IP，Flannel使用ETCD来存储Pod子网与Node IP之间的关系。flanneld守护进程在每台主机上运行，并负责维护ETCD信息和路由数据包。</p>
<p>项目地址：<a href="https://github.com/coreos/flannel" target="_blank" rel="noopener">https://github.com/coreos/flannel</a></p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ul>
<li>udp：性能较低，是flannel的早期实现方式，仅适用于vxlan和host-gw不可用的情况【已废弃】</li>
<li>vxlan：overlay网络(隧道)方案；使用内核vxlan模块封装报文</li>
<li>host-gw：underlay(路由)网络方案；Node节点把自己的网络接口当做pod的网关使用；flannel通过在各个节点的agent，将容器网络信息刷新到主机路由表上，这样一来所有的主机都有整个容器网络的路由数据了。但是，要求所有节点处于同一个二层网络</li>
<li>Directrouting(vxlan+host-gw)：vxlan的直接路由模式，兼具vxlan和host-gw的优势，既保证了传输性能，又具备了跨二层网络转发报文的能力</li>
</ul>
<p>公有云VPC：Alivpc、AWSvpc、Alloc、GCE</p>
<h3 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h3><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/flanneld-vxlan.png" alt></p>
<ul>
<li>vxlan模式特点：<ul>
<li>支持宿主机3层通信（不同子网）；只需宿主机网络互通，不需要单独配置到容器网络的路由</li>
<li>传输过程中需要封包、解包，有性能开销</li>
</ul>
</li>
<li>跨主机pod通信实现：</li>
</ul>
<ol>
<li><p>容器到宿主机网桥cni0【同主机不同pod通过cni0网桥通信】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">容器的网关就是宿主机上的网桥cni0</span><br></pre></td></tr></table></figure>
</li>
<li><p>网桥cni0到隧道接口flannel.1</p>
</li>
<li><p>本地flannel.1到目标flannel.1，通信实现如下：</p>
<ol>
<li>获取目标flannel.1 ip地址：ip route</li>
<li>根据flannel.1ip地址获取flannel.1 mac地址：ip neigh show dev flannel.1</li>
<li>根据flannel.1 mac地址获取flannel.1 所在宿主机ip：bridge fdb show dev flannel.1</li>
<li>根据flannel.1宿主机ip地址获取flannel.1所在宿主机mac地址：arp -a</li>
</ol>
</li>
</ol>
<h3 id="Host-GW模式"><a href="#Host-GW模式" class="headerlink" title="Host-GW模式"></a>Host-GW模式</h3><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/flanneld-hostgw.png" alt></p>
<ul>
<li><p>host-gw模式：</p>
<ul>
<li>要求宿主机2层通信（相同子网，宿主机可以直接通过mac地址通信），否则需要在路由器配置到容器网络的静态路由</li>
<li>不存在封包、解包过程，传输更高效</li>
</ul>
</li>
<li><p>跨主机pod通信：host-gw模式相比vxlan简单了许多， 直接在主机添加路由，将目的主机当做网关，直接路由原始封包。</p>
</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="k8s资源清单方式"><a href="#k8s资源清单方式" class="headerlink" title="k8s资源清单方式"></a>k8s资源清单方式</h3><ul>
<li><p>下载资源清单：<a href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" target="_blank" rel="noopener">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></p>
</li>
<li><p>配置调整</p>
<ul>
<li><p>网络设置(net-conf.json)</p>
<ul>
<li>配置pod地址段，与controller-manager中的cluster-cidr配置一致</li>
<li>配置工作模式：<code>&quot;Backend&quot;:{&quot;Type&quot;:&quot;VxLAN&quot;, &quot;Directrouting&quot;: true}</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宿主机间的通信接口设置(kube-flannel–&gt;DaemonSet)：<code>--iface=eth1</code></p>
</li>
<li><p>镜像地址修改</p>
</li>
</ul>
</li>
<li><p>应用资源文件</p>
</li>
</ul>
<h3 id="手动etcd方式"><a href="#手动etcd方式" class="headerlink" title="手动etcd方式"></a>手动etcd方式</h3><ul>
<li>安装并配置etcd</li>
<li>etcd中创建flannel网络配置<ol>
<li>etcdctl mkdir /kube-centos/network</li>
<li>etcdctl mk /kube-centos/network/config ‘{“Network”:”172.33.0.0/16”,”SubnetLen”:24,”Backend”:{“Type”:”host-gw”}}’</li>
<li>参数详解：<ul>
<li>Network：全局使用CIDR格式ipv4网络</li>
<li>SubnetLen：节点使用的子网的掩码</li>
<li>Backend：flannel要使用的后端类型</li>
</ul>
</li>
</ol>
</li>
<li>安装flannel</li>
<li><p>flannel服务配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://172.17.8.101:2379&quot;</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/kube-centos/network&quot;</span><br><span class="line">FLANNEL_OPTIONS=&quot;-iface=eth1&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动flannel</p>
</li>
</ul>
<h1 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h1><p>calico是一个纯三层的数据中心网络方案，calico支持广泛的平台，包含kubernetes、OpenStack</p>
<p>calico在每一个计算节点利用linux kernel实现了一个高效的虚拟路由器(vRouter)来负责数据转发，而每个vRouter通过BGP协议负责把自己运行的workload的路由信息向整个calico网络内传播</p>
<p>calico项目还实现了kubernetes网络策略，提供了ACL功能</p>
<p>calico通过两种方式进行数据包转发</p>
<ul>
<li>路由模式：BGP，动态路由协议，适合大规模网络</li>
<li>隧道模式：IP-IP</li>
</ul>
<h2 id="calico架构组件"><a href="#calico架构组件" class="headerlink" title="calico架构组件"></a><a href="https://docs.projectcalico.org/reference/architecture/overview" target="_blank" rel="noopener">calico架构组件</a></h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/calico.png" alt></p>
<ul>
<li>Felix：在每个节点运行，负责维护宿主机上路由规则和ACL规则</li>
<li>Etcd：分布式键值存储，保存Calico的策略和网络配置状态。</li>
<li>BGP Client(BIRD)：BGP客户端，负责分发路由信息到整个calico网络</li>
<li>BGP Route Reflector (BIRD)：可选的BGP路由反射器，为了实现更高的规模，集中管理路由信息</li>
</ul>
<h2 id="calico部署"><a href="#calico部署" class="headerlink" title="calico部署"></a><a href="https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises" target="_blank" rel="noopener">calico部署</a></h2><ul>
<li><p>资源下载：</p>
<ul>
<li><p>k8s-api存储方式：<code>curl https://docs.projectcalico.org/manifests/calico.yaml -O</code></p>
</li>
<li><p>etcd存储方式：<code>curl https://docs.projectcalico.org/manifests/calico-etcd.yaml -O</code></p>
</li>
</ul>
</li>
<li><p><a href="https://docs.projectcalico.org/getting-started/kubernetes/installation/config-options" target="_blank" rel="noopener">自定义配置</a>：</p>
<ul>
<li><p><a href="https://docs.projectcalico.org/networking/ip-autodetection#change-the-autodetection-method" target="_blank" rel="noopener">使用指定的网卡用于宿主机间通信</a>【DaemonSet/calico-node==&gt;containers/env】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: IP_AUTODETECTION_METHOD</span><br><span class="line">  value: &quot;interface=eth1&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>配置pod地址段：CALICO_IPV4POOL_CIDR【kubeadm安装的集群可以自动检测】</p>
</li>
<li><p>工作模式：CALICO_IPV4POOL_IPIP</p>
<ul>
<li>IPIP：Always【默认】<ul>
<li>BGP：Never </li>
<li>IPIP兼容BGP：CrossSubnet【同一子网使用BGP，跨子网使用IPIP】</li>
</ul>
</li>
</ul>
</li>
<li><p>配置etcd信息（secret、ConfigMap）</p>
</li>
</ul>
<h2 id="calico管理工具"><a href="#calico管理工具" class="headerlink" title="calico管理工具"></a><a href="https://docs.projectcalico.org/getting-started/clis/calicoctl/" target="_blank" rel="noopener">calico管理工具</a></h2><ul>
<li><p>二进制下载地址：<a href="https://github.com/projectcalico/calicoctl/releases" target="_blank" rel="noopener">https://github.com/projectcalico/calicoctl/releases</a></p>
</li>
<li><p><a href="https://docs.projectcalico.org/getting-started/clis/calicoctl/configure/" target="_blank" rel="noopener">配置文件</a>：/etc/calico/calicoctl.cfg</p>
<ul>
<li><p>使用独立etcd存储的calico集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: CalicoAPIConfig</span><br><span class="line">metadata:</span><br><span class="line">spec:</span><br><span class="line">  datastoreType: etcdv3</span><br><span class="line">  etcdEndpoints: https://etcd1:2379,https://etcd2:2379,https://etcd3:2379</span><br><span class="line">  etcdKeyFile: /etc/calico/key.pem</span><br><span class="line">  etcdCertFile: /etc/calico/cert.pem</span><br><span class="line">  etcdCACertFile: /etc/calico/ca.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用k8s-api存储的calico集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: CalicoAPIConfig</span><br><span class="line">metadata:</span><br><span class="line">spec:</span><br><span class="line">  datastoreType: &quot;kubernetes&quot;</span><br><span class="line">  kubeconfig: &quot;/root/.kube/config&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>管理命令</p>
<ul>
<li>查看calico节点状态：calicoctl node status</li>
</ul>
</li>
</ul>
<h2 id="BGP模式"><a href="#BGP模式" class="headerlink" title="BGP模式"></a>BGP模式</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/calico-bgp.png" alt></p>
<p>pod1访问pod2流程：</p>
<ol>
<li><p>数据包从容器1的eth0到达veth pair另一端cali34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置宿主机的接口cali34开启proxy_arp功能，此后这一接口会响应所有arp请求</span><br><span class="line">从而将容器发送到默认网关169.254.1.1的流量送达宿主机的cali34接口【告诉容器，我有169.254.1.1这个ip】</span><br></pre></td></tr></table></figure>
</li>
<li><p>宿主机根据路由规则，将数据包转发给下一条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.244.186.192/26 via 192.168.31.203 dev eth1 proto bird            # 到达其他pod网段的数据包(每个宿主机一个pod子网段)：下一跳为其他宿主机ip、本地出口为eth1</span><br><span class="line">blackhole 10.244.196.128/26 proto bird        # 到达本机pod网段的数据包，如果没有更高优先级路由，数据包直接丢弃</span><br><span class="line">10.244.196.129 dev calie8e9a5cf531 scope link   # 目的为本机pod网段特定ip的数据包，交给指定的cali网卡</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据包到达node2，根据路由规则将数据包转发给cali设备</p>
</li>
</ol>
<h2 id="BGP-RR模式"><a href="#BGP-RR模式" class="headerlink" title="BGP-RR模式"></a>BGP-RR模式</h2><p><a href="https://docs.projectcalico.org/master/networking/bgp" target="_blank" rel="noopener">https://docs.projectcalico.org/master/networking/bgp</a> </p>
<p>Calico 维护的网络在默认是（Node-to-Node Mesh）全互联模式，Calico集群中的节点之间都会相互建立连接，用于路由交换。但是随着集群规模的扩大，mesh模式将形成一个巨大服务网格，连接数成倍增加。</p>
<p>这时就需要使用 Route Reflector（路由器反射）模式解决这个问题。</p>
<p>确定一个或多个Calico节点充当路由反射器，让其他节点从这个RR节点获取路由信息。</p>
<ul>
<li><p>关闭BGP node-to-node模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> cat &lt;&lt; EOF | calicoctl create -f -</span><br><span class="line"> apiVersion: projectcalico.org/v3</span><br><span class="line"> kind: BGPConfiguration</span><br><span class="line"> metadata:</span><br><span class="line">   name: default</span><br><span class="line"> spec:</span><br><span class="line">   logSeverityScreen: Info</span><br><span class="line">   nodeToNodeMeshEnabled: false  </span><br><span class="line">   asNumber: 64512</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>asNumber可以通过获取：calicoctl get node -o wide</p>
</li>
<li><p>配置指定节点为充当路由反射器</p>
<ul>
<li><p>节点添加标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl label node node02 route-reflector=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置路由器反射器节点routeReflectorClusterID【一般为未使用过的ip地址】</p>
<blockquote>
<p>calicoctl get node node02 -o yaml &gt; rr.yaml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  bgp:</span><br><span class="line">    routeReflectorClusterID: 244.0.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用标签选择器将路由反射器节点与其他非路由反射器节点配置为对等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF | calicoctl create -f -</span><br><span class="line">kind: BGPPeer</span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">metadata:</span><br><span class="line">  name: peer-with-route-reflectors</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector: all()</span><br><span class="line">  peerSelector: route-reflector == &apos;true&apos;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看bgp连接状态【只能检查本地代理与反射器的连接关系】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calicoctl node status</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="IP-IP模式"><a href="#IP-IP模式" class="headerlink" title="IP-IP模式"></a>IP-IP模式</h2><p>和flannel的host-gw一样，bgp模式也要求宿主机二层互联。为了解除这个限制，calico和flannel一样也引入隧道模式(overlay),使用ipip封装数据包。</p>
<p>在不支持ip-ip封装的网络环境，也支持<a href="https://docs.projectcalico.org/getting-started/kubernetes/installation/config-options#switching-from-ip-in-ip-to-vxlan" target="_blank" rel="noopener">vxlan封装</a></p>
<h3 id="ipip部署"><a href="#ipip部署" class="headerlink" title="ipip部署"></a>ipip部署</h3><p>将bgp模式修改为ipip模式：</p>
<blockquote>
<p>由于calico 3.15.2 有<a href="https://github.com/projectcalico/libcalico-go/pull/1277" target="_blank" rel="noopener">bug</a>，如果使用calicoctl方式会有下列错误：</p>
<p>Partial success: applied the first 1 out of 1 ‘IPPool’ resources:<br>Hit error: FelixConfiguration.crd.projectcalico.org “default” is invalid: spec.bpfLogLevel: Required value</p>
<p>所以依然使用kubectl delete/apply方式修改calico.yaml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># calicoctl get ipPool default-ipv4-ippool -o yaml &gt; ipip.yaml</span><br><span class="line"># vi ipip.yaml</span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: IPPool</span><br><span class="line">metadata:</span><br><span class="line">  name: default-ipv4-ippool</span><br><span class="line">spec:</span><br><span class="line">  blockSize: 26</span><br><span class="line">  cidr: 10.244.0.0/16</span><br><span class="line">  ipipMode: Always</span><br><span class="line">  natOutgoing: true</span><br><span class="line">  nodeSelector: all()</span><br><span class="line">  vxlanMode: Never</span><br><span class="line"></span><br><span class="line"># calicoctl apply -f ipip.yaml</span><br><span class="line"># calicoctl get ippool -o wide</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理示意图如下：</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/calico-ipip.png" alt></p>
<p>pod1访问pod2流程</p>
<ol>
<li><p>数据包从容器1的eth0到达veth pair另一端cali34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置宿主机的接口cali34开启proxy_arp功能，此后这一接口会响应所有arp请求</span><br><span class="line">从而将容器发送到默认网关169.254.1.1的流量送达宿主机的cali34接口【告诉容器，我有169.254.1.1这个ip】</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据包根据本地路由规则发送给下一跳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.244.140.64/26 via 192.168.31.202 dev tunl0 proto bird onlink  # 到达其他pod子网段的流量：目的为对端宿主机ip、本地出口为隧道接口tunl0</span><br><span class="line">blackhole 10.244.196.128/26 proto bird # 到达本机pod网段的数据包，如果没有更高优先级路由，数据包直接丢弃</span><br><span class="line">10.244.196.130 dev calie8e9a5cf531 scope link # 目的为本机pod网段特定ip的数据包，交给指定的cali网卡</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>通过隧道方式传输的数据包，借助物理网卡到达目的主机node2【只要宿主机网络可达，不需要是同一子网】</li>
</ol>
<h1 id="CNI插件选择"><a href="#CNI插件选择" class="headerlink" title="CNI插件选择"></a>CNI插件选择</h1><p>考虑因素如下：</p>
<ul>
<li>网络性能：路由模式只支持二层网络，隧道模式有性能损耗</li>
<li>服务器规模：小于50台，选用flannel；数百台使用calico</li>
<li>策略控制：是否需要pod ACL，只有calico实现了网络策略控制</li>
<li>网络环境限制：是否支持bgp、vxlan、ipip等协议</li>
<li>维护能力：使用bgp、calico等需要深厚的网络知识</li>
</ul>
<h2 id="切换flannel到calico"><a href="#切换flannel到calico" class="headerlink" title="切换flannel到calico"></a>切换flannel到calico</h2><ul>
<li><p>删除flannel资源配置：kubectl delete -f kube-flannel.yml</p>
</li>
<li><p>删除配置生成的文件</p>
<ul>
<li>/var/run/flannel、/run/flannel</li>
</ul>
</li>
<li><p>/etc/cni/net.d/10-flannel.conflist</p>
</li>
<li><p>删除在宿主机生成的路由、网卡信息</p>
<ul>
<li><p>删除路由信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip route</span><br><span class="line">ip route del 10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink</span><br><span class="line">ip route del 10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink</span><br><span class="line">ip route del 10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>删除网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip link delete cni0 </span><br><span class="line">ip link delete flannel.1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>部署calico资源文件：kubectl apply -f calico.yml</p>
</li>
<li><p>重建应用pod【过滤使用宿主机网络的pod】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -A -o wide|grep -v &quot;192.168.31&quot;|awk &apos;system(&quot;kubectl delete pod &quot;$2&quot; -n &quot;$1&quot;&quot;)&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="切换calico到flannel"><a href="#切换calico到flannel" class="headerlink" title="切换calico到flannel"></a>切换calico到flannel</h2><ul>
<li><p>删除calico资源配置：kubectl delete -f calico.yml</p>
</li>
<li><p>删除配置生成的文件:</p>
<ul>
<li>/etc/cni/net.d/10-calico.conflist</li>
<li>rm -rf /var/run/calico</li>
</ul>
</li>
<li><p>删除在宿主机生成的路由、网卡信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip link delete tunl0</span><br><span class="line">ifconfig tunl0 down</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署flannel资源文件：kubectl delete -f kube-flannel.yml</p>
</li>
<li><p>重建应用pod【过滤使用宿主机网络的pod】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -A -o wide|grep -v &quot;192.168.31&quot;|awk &apos;system(&quot;kubectl delete pod &quot;$2&quot; -n &quot;$1&quot;&quot;)&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="k8s集群和外部连通"><a href="#k8s集群和外部连通" class="headerlink" title="k8s集群和外部连通"></a>k8s集群和外部连通</h1><p>业务需求：</p>
<ul>
<li>原有虚拟机上的业务与k8s集群中的pod/service通信</li>
<li>办公网的开发、运维等人员和远程k8s集群中的pod/service通信</li>
</ul>
<p>业务实现：</p>
<ul>
<li><p>方案一：选取k8s集群中的一个节点专门用于流量转发(设置污点禁止其他pod调度)，在路由器配置静态路由，将访问pod/service的流量转发到此节点</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/office-to-k8s.png" alt></p>
</li>
<li><p>方案二：通过k8s集群的路由反射器(calico/BGP-RR)和办公网的路由器进行BGP路由交互，从而使办公网感知pod/service网络的存在</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s-to-switch.png" alt></p>
</li>
</ul>
<h1 id="网络策略-组件部署"><a href="#网络策略-组件部署" class="headerlink" title="网络策略-组件部署"></a>网络策略-组件部署</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>由于calico实现了网络策略功能，在综合calico(pod间访问控制)和flannel(pod间通信)的优点后，可以采用如下部署方式实现网络策略控制 (不含calico单独部署)  </p>
<ul>
<li><a href="#canal部署">只部署canal</a>【canal是一个整合了flannel和calico的综合项目，其中calico用于策略控制、flannel用于网络通信】</li>
<li><a href="#flannel和calico协同部署">协同部署</a>flannel实现网络功能、部署calico实现访问控制功能</li>
</ul>
<h2 id="部署要求"><a href="#部署要求" class="headerlink" title="部署要求"></a>部署要求</h2><ul>
<li>flannel的后端必须是vxlan模型【host-gw、vxlan-Directrouting均不行】</li>
<li>kubelet必须开启cni支持：–network-plugin=cni</li>
<li>kube-controller-manager开启配置：<code>-cluster-cidr=&lt;your-pod-cidr&gt;</code>和–allocate-node-cidrs=true</li>
<li>其他要求：<a href="https://docs.projectcalico.org/getting-started/kubernetes/requirements" target="_blank" rel="noopener">官网</a></li>
</ul>
<h2 id="canal部署"><a href="#canal部署" class="headerlink" title="canal部署"></a><a href="https://docs.projectcalico.org/getting-started/kubernetes/installation/flannel" target="_blank" rel="noopener">canal部署</a></h2><ul>
<li>下载清单文件<ul>
<li>etcd存储：curl <a href="https://docs.projectcalico.org/manifests/canal-etcd.yaml" target="_blank" rel="noopener">https://docs.projectcalico.org/manifests/canal-etcd.yaml</a> -O</li>
<li>k8s存储：curl <a href="https://docs.projectcalico.org/manifests/canal.yaml" target="_blank" rel="noopener">https://docs.projectcalico.org/manifests/canal.yaml</a> -O</li>
</ul>
</li>
<li><p>更改配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POD_CIDR=&quot;&lt;your-pod-cidr&gt;&quot;</span><br><span class="line">sed -i -e &quot;s?10.244.0.0/16?$POD_CIDR?g&quot; canal.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行清单创建资源：kubectl apply -f canal.yaml</p>
</li>
</ul>
<h2 id="flannel和calico协同部署"><a href="#flannel和calico协同部署" class="headerlink" title="flannel和calico协同部署"></a>flannel和calico协同部署</h2><h3 id="flannel部署"><a href="#flannel部署" class="headerlink" title="flannel部署"></a><a href="https://github.com/coreos/flannel" target="_blank" rel="noopener">flannel部署</a></h3><ul>
<li>下载清单文件：curl <a href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" target="_blank" rel="noopener">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a> -o</li>
<li>配置调整<ul>
<li>网络设置(net-conf.json)</li>
<li>主机间的内部通信端口设置(kube-flannel–&gt;DaemonSet)：–iface=eth1</li>
</ul>
</li>
<li>执行清单创建资源：kubectl apply -f kube-flannel.yml</li>
</ul>
<h3 id="calico部署-1"><a href="#calico部署-1" class="headerlink" title="calico部署"></a><a href="https://docs.projectcalico.org/getting-started/kubernetes/installation/other" target="_blank" rel="noopener">calico部署</a></h3><ul>
<li>下载清单文件：curl <a href="https://docs.projectcalico.org/manifests/calico-policy-only.yaml" target="_blank" rel="noopener">https://docs.projectcalico.org/manifests/calico-policy-only.yaml</a> -O</li>
<li><p>更改配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POD_CIDR=&quot;&lt;your-pod-cidr&gt;&quot;</span><br><span class="line">sed -i -e &quot;s?192.168.0.0/16?$POD_CIDR?g&quot; calico.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行清单创建资源：kubectl apply -f calico.yaml</p>
</li>
</ul>
<h1 id="网络策略-语法"><a href="#网络策略-语法" class="headerlink" title="网络策略-语法"></a>网络策略-语法</h1><p>控制pod到pod、node、外接网络的访问限制，包含流入(Ingress)和流出(Egress)两个方向的控制规则，场景需求如下：</p>
<ul>
<li>应用程序间的访问控制，例如允许微服务A访问微服务B，微服务C不能访问微服务A</li>
<li>不同环境间的隔离，例如开发、测试环境不能相互访问</li>
<li>pod暴露在外部时，设置pod访问白名单</li>
</ul>
<h2 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h2><ul>
<li>默认情况下，所有pod处于非隔离状态，所有方向的流量都可以自由流动</li>
<li>一旦有策略应用于pod，那么相关方向所有未明确声明允许的流量都将被拒绝</li>
<li>如果在policyTypes中定义了生效规则(Ingress/Egress)：<ul>
<li>spec定义了空值【<code>{}</code>】表示不限制相关方向的访问</li>
<li>spec中没有定义相应的Ingress或Egress规则，则表示拒绝相关方向上的一切流量。范例如下【定义默认规则】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: deny-all-traffic</span><br><span class="line">  namespace: testing</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;       # 所有pod</span><br><span class="line">  policyTypes:          # 进口、出口流量都管控；没有定义出站(Egress)详细规则，则拒绝所有出站流量</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  Ingress:              # 定义了入站规则，但是为空，表示允许所有入站流量</span><br><span class="line">  - &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><ul>
<li>podSelector：通过pod选择器选定的一组pod资源，它是规则生效的对象<ul>
<li>matchLabel、matchExpression</li>
</ul>
</li>
<li>Egress：出站规则<ul>
<li>to：目标对象</li>
<li>ports：目标对象端口</li>
</ul>
</li>
<li>Ingress：入站规则<ul>
<li>from：源对象</li>
<li>ports：本地pod资源端口</li>
</ul>
</li>
<li>ports：tcp或udp端口<ul>
<li>protocol：默认tcp</li>
<li>port：端口</li>
</ul>
</li>
<li>to/from：目标对象或源对象<ul>
<li>ipBlock：IP地址块</li>
<li>namespaceSelector：名称空间选择器，如果不设置表示当前名称空间</li>
<li>podSelector：pod选择器</li>
</ul>
</li>
</ul>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-myapp-ingress</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:              # 选择策略生效目标</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">  policyTypes: [&apos;Ingress&apos;]  # 策略管控的流量方向，此处为入站流量(Ingress)</span><br><span class="line">  ingress:</span><br><span class="line">  - from:                 # 入站来源</span><br><span class="line">    - ipBlock:            # ip选择</span><br><span class="line">        cidr: 10.244.0.0/16</span><br><span class="line">        except:           # 排除部分选项</span><br><span class="line">        - 10.244.3.0/24</span><br><span class="line">    - podSelector:        # 标签选择</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: myapp</span><br><span class="line">    ports:                # 目标端口</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br></pre></td></tr></table></figure>
<ul>
<li>from:入站流量来源<ul>
<li>多个项目之间为“逻辑或”关系</li>
<li>若未设置此字段或字段为空，则允许一切来源</li>
<li>如果设置至少一个值，则设置的值为白名单，只有名单中的地址的流量才被放行</li>
</ul>
</li>
<li>ports：入站流量的目标端口，其他说明如上</li>
<li>from和ports之间为“逻辑与”关系；仅定义from隐含本地pod资源的所有端口；仅定义ports隐含所有来源；两者都定义则精确匹配来源及目标端口</li>
</ul>
<h2 id="Egress"><a href="#Egress" class="headerlink" title="Egress"></a>Egress</h2><p>对于具有app=tomcat标签的对象，它到【app=nginx】对象80端口的流量被放行<br>到【app=mysql】对象3306端口的流量也被放行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-tomcat-egress</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tomcat</span><br><span class="line">  policyTypes: [&quot;Egress&quot;]</span><br><span class="line">  egress:</span><br><span class="line">  - to:</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">  - to:</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: mysql</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 3306</span><br></pre></td></tr></table></figure>
<h2 id="名称空间隔离"><a href="#名称空间隔离" class="headerlink" title="名称空间隔离"></a>名称空间隔离</h2><p>允许当前名称空间内部各pod之间，以及当前名称空间与kube-system名称空间内各pod的通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: namespace-deny-all</span><br><span class="line">  name: testing</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes: [&quot;Ingress&quot;, &quot;Egress&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: namespace-allow</span><br><span class="line">  name: testing</span><br><span class="line">spec:</span><br><span class="line">  policyTypes: [&quot;Ingress&quot;, &quot;Egress&quot;]</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchExpressions:</span><br><span class="line">        - key: name</span><br><span class="line">          operator: In</span><br><span class="line">          values: [&quot;testing&quot;, &quot;kube-system&quot;]</span><br><span class="line">  Egress:</span><br><span class="line">  - to:</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchExpressions:</span><br><span class="line">        - key: name</span><br><span class="line">          operator: In</span><br><span class="line">          values: [&quot;testing&quot;, &quot;kube-system&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="网络策略-应用范例"><a href="#网络策略-应用范例" class="headerlink" title="网络策略-应用范例"></a>网络策略-应用范例</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><ul>
<li>testing名称空间下运行app=nginx和app=myapp两个应用</li>
<li>myapp仅允许来自nginx访问其TCP/80端口，但可以向nginx的所有端口发出出站流量</li>
<li>nginx允许所有源站点访问其TCP/80端口，并能向任意端点发出出站流量</li>
<li>myapp和nginx都可以与kube-system名称空间内的任意pod通信</li>
</ul>
<h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><ul>
<li>myapp：<code>kubectl run myapp --image=ikubernetes/myapp:v1 --replicas=1 --namespace=testing --port 80 --expose --labels app=myapp</code></li>
<li>nginx：<code>kubectl run nginx --image=nginx:alpine --replicas=1 --namespace=testing --port 80 --expose --labels app=nginx</code></li>
<li>为kube-system添加标签：<code>kubectl label namespace kube-system ns=kube-system</code></li>
<li>调试客户端：<code>kubectl run debug --namespace=default --rm -it --image=nicolaka/netshoot -- sh</code></li>
</ul>
<h2 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-policy             # myapp策略</span><br><span class="line">  namespace: testing</span><br><span class="line">spec:</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">  ingress:</span><br><span class="line">  - from:                     # 允许来自nginx访问其80端口</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - port: 80</span><br><span class="line">  - from:                    # 允许来自kube-system的pod访问</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          ns: kube-system</span><br><span class="line">  egress:</span><br><span class="line">  - to:                      # 允许访问nginx的所有端口</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: nginx</span><br><span class="line">  - to:                      # 允许访问kube-system的pod</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          ns: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-policy             # nginx策略</span><br><span class="line">  namespace: testing</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  ingress:</span><br><span class="line">  - ports:                       # 允许所有源站点访问80端口</span><br><span class="line">    - port: 80</span><br><span class="line">  - from:                        # 允许来自kube-system访问</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          ns: kube-system</span><br><span class="line">  egress: </span><br><span class="line">  - &#123;&#125;                           # 出口流量不限制</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>cni</tag>
        <tag>flannel</tag>
        <tag>calico</tag>
        <tag>网络策略</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-存储和持久化</title>
    <url>/blog/2020/02/24/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E5%AD%98%E5%82%A8%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="持久化设置"><a href="#持久化设置" class="headerlink" title="持久化设置"></a>持久化设置</h1><ul>
<li>pod级别设置卷类型(volumes类型)：spec.volumes</li>
<li>容器级别使用卷：spec.containers.volumeMounts</li>
</ul>
<h1 id="volumes类型"><a href="#volumes类型" class="headerlink" title="volumes类型"></a><a href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes" target="_blank" rel="noopener">volumes类型</a></h1><h2 id="内置存储类"><a href="#内置存储类" class="headerlink" title="内置存储类"></a>内置存储类</h2><blockquote>
<p>可以直接在pod的volumes中引用</p>
</blockquote>
<ul>
<li>本地存储：emptyDir、hostpath、local</li>
<li>网络存储：nfs、rbd、cephfs、glusterfs</li>
<li>云存储：awsElasticBlockStorage、gcePersistentDisk、azureDisk</li>
<li>配置存储：secret、ConfigMap、downwardAPI</li>
</ul>
<h2 id="持久化存储-pv-pvc"><a href="#持久化存储-pv-pvc" class="headerlink" title="持久化存储-pv/pvc"></a>持久化存储-pv/pvc</h2><ul>
<li>出现背景：屏蔽后端存储实现的细节，使用人员只需要声明存储需求</li>
<li>实现方式<ul>
<li>pv(persistent volumes)：包含后端存储实现的细节(存储类型、访问路径、认证信息等)，使得存储作为集群中的资源管理。有两种类型的pv实现：<ul>
<li>静态：建立容量大小固定的存储卷</li>
<li>动态：只创建与特定存储后端关联存储类(storageclass)，有需求到来时(pvc)，再建立特定的存储卷(pv)</li>
</ul>
</li>
<li>pvc(persistent volume claim)：包含使用者对存储的需求声明(size/accessmode)</li>
</ul>
</li>
</ul>
<h2 id="存储插件"><a href="#存储插件" class="headerlink" title="存储插件"></a>存储插件</h2><blockquote>
<p>k8s核心代码外存储实现，一般为云厂商对接k8s存储的实现形式；这些插件最终都要通过volume或pv/pvc的方式接入k8s集群</p>
</blockquote>
<ul>
<li>flexvolume：存在于csi之前，使用命令行exec模式与存储驱动交互；flexvolume的存储驱动(存储系统的二进制管理命令)必须在每个节点安装；pod通过k8s核心代码内的flexvolume插件(运行于k8s的专有pod)与FlexVolume的存储驱动交互</li>
<li>CSI(container storage interface)：为容器编排系统(如k8s)定义了一个存储接口，从而可以将任意的存储系统暴露给容器负载(pod)；csi卷类型不支持直接从pod引用，必须从PersistentVolumeClaim对象引用</li>
</ul>
<h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><h2 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h2><ul>
<li><p>用途</p>
<ul>
<li>用于同一个pod内的多个容器间文件的共享</li>
<li>做为容器数据的临时存储目录用于数据缓存系统</li>
</ul>
</li>
<li><p>范例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">piVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-emptydir-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: write</span><br><span class="line">    image: centos</span><br><span class="line">    command: [&quot;bash&quot;, &quot;-c&quot;, &quot;for i in &#123;1..100&#125;;do echo $i &gt;&gt; /data/hello;sleep 1;done&quot;]</span><br><span class="line">    volumeMounts: #容器加载volume</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">  - name: read</span><br><span class="line">    image: centos</span><br><span class="line">    command: [&quot;bash&quot;, &quot;-c&quot;, &quot;tail -f /data/hello&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">  volumes: # pod级别定义volumes</span><br><span class="line">  - name: data</span><br><span class="line">    emptyDir: &#123;&#125; #emptydir类型的volume与pod生命周期相同</span><br></pre></td></tr></table></figure>
<h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><ul>
<li><p>用途</p>
<ul>
<li>将节点的文件或目录挂载到pod中，独立于pod的生命周期</li>
<li>一般适用于管理任务的pod(如daemonset)，它运行于集群中的每个工作节点，负责收集工作节点系统级的相关数据</li>
</ul>
</li>
<li><p>范例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-hostpath</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: filebeat</span><br><span class="line">    image: ikubernetes/filebeat:5.6.7-alpine</span><br><span class="line">    env:</span><br><span class="line">    - name: REDIS_HOST</span><br><span class="line">      value: 192.168.2.124</span><br><span class="line">    - name: LOG_LEVEL</span><br><span class="line">      value: info</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: varlog</span><br><span class="line">      mountPath: /var/log</span><br><span class="line">    - name: socket</span><br><span class="line">      mountPath: /var/run/docker.sock</span><br><span class="line">    - name: var-lib-docker-containers</span><br><span class="line">      mountPath: /var/lib/docker/containers</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: varlog</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /var/log</span><br><span class="line">  - name: var-lib-docker-containers</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /var/lib/docker/containers</span><br><span class="line">  - name: socket</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /var/run/docker.sock</span><br></pre></td></tr></table></figure>
<h1 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h1><h2 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a><a href="#nfs-server">nfs</a></h2><p>此处直接在pod中以volume形式挂载nfs</p>
<h3 id="pod使用"><a href="#pod使用" class="headerlink" title="pod使用"></a>pod使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: nfs-server</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nfs-server</span><br><span class="line">        nfs:</span><br><span class="line">          path: /</span><br><span class="line">          server: 192.168.31.203</span><br></pre></td></tr></table></figure>
<h3 id="客户端http访问"><a href="#客户端http访问" class="headerlink" title="客户端http访问"></a>客户端http访问</h3><ul>
<li>先在共享目录建立index.html文件</li>
<li>curl <em>port-ip</em></li>
</ul>
<h1 id="持久化存储-pv-pvc-1"><a href="#持久化存储-pv-pvc-1" class="headerlink" title="持久化存储-pv/pvc"></a>持久化存储-pv/pvc</h1><h2 id="pv静态供给"><a href="#pv静态供给" class="headerlink" title="pv静态供给"></a><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">pv静态供给</a></h2><p>此处使用nfs创建静态存储卷</p>
<h3 id="pv创建"><a href="#pv创建" class="headerlink" title="pv创建"></a><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes" target="_blank" rel="noopener">pv创建</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv01</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Recycle</span><br><span class="line">  nfs:</span><br><span class="line">    path: /pv01</span><br><span class="line">    server: 192.168.31.203</span><br></pre></td></tr></table></figure>
<ul>
<li>capacity：pv存储空间</li>
<li>accessModes：访问模式<ul>
<li>ReadWriteOnce：单节点读写：数据独立，一般为块设备</li>
<li>ReadOnlyMany：多节点读</li>
<li>ReadWriteMany：多节点读写，数据共享，一般是文件系统</li>
</ul>
</li>
<li>persistentVolumeReclaimPolicy：pv空间被释放时的数据处理机制<ul>
<li>Retain：默认，保留pv和数据</li>
<li>Recycle：保留pv，删除数据（目前仅nfs、hostpath支持）</li>
<li>Delete：删除pv和数据，仅部分云端存储支持</li>
</ul>
</li>
<li>volumeMode：卷模型，当做块设备还是文件系统，默认文件系统(Filesystem)</li>
<li>storageClassName：当前pv所属的StorageClass名称</li>
<li>mountOptions：挂载选项</li>
</ul>
<h3 id="pvc创建"><a href="#pvc创建" class="headerlink" title="pvc创建"></a><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank" rel="noopener">pvc创建</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 6Gi</span><br></pre></td></tr></table></figure>
<ul>
<li>accessModes：访问模式</li>
<li>resources：申请资源</li>
<li>selector：查询volume标签用于绑定</li>
<li>storageClassName：要求绑定的存储类</li>
<li>volumeMode：卷模型，当做块设备还是文件系统，默认文件系统(Filesystem)</li>
<li>volumeName：用于直接指定要绑定的pv的卷名</li>
</ul>
<h3 id="pv与pvc的匹配因素"><a href="#pv与pvc的匹配因素" class="headerlink" title="pv与pvc的匹配因素"></a>pv与pvc的匹配因素</h3><ul>
<li>容量大小：pv&gt;=pvc，且两者容量接近</li>
<li>访问模式</li>
</ul>
<h3 id="pod使用-1"><a href="#pod使用-1" class="headerlink" title="pod使用"></a>pod使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- name: nfs-server</span><br><span class="line">  persistentVolumeClaim:</span><br><span class="line">    claimName: pvc-2</span><br></pre></td></tr></table></figure>
<h2 id="pv动态供给"><a href="#pv动态供给" class="headerlink" title="pv动态供给"></a><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">pv动态供给</a></h2><h3 id="存储类插件"><a href="#存储类插件" class="headerlink" title="存储类插件"></a>存储类插件</h3><ul>
<li>官方内置支持的存储类：<a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></li>
<li>社区实现的存储类：<a href="https://github.com/kubernetes-incubator/external-storage" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/external-storage</a><ul>
<li>nfs：映射本地目录，建立nfs服务端，并提供nfs实现的存储类</li>
<li>nfs-client：挂载已存在的nfs服务器提供存储类</li>
</ul>
</li>
</ul>
<h3 id="storageclass创建"><a href="#storageclass创建" class="headerlink" title="storageclass创建"></a>storageclass创建</h3><ul>
<li><p>可以使用<a href="https://github.com/kubernetes-retired/external-storage/tree/master/nfs/deploy/kubernetes" target="_blank" rel="noopener">nfs</a>中的【class.yaml、deployment.yaml、rbac.yaml】文件创建nfs存储类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -LO https://raw.githubusercontent.com/kubernetes-retired/external-storage/master/nfs/deploy/kubernetes/deployment.yaml</span><br><span class="line">curl -LO https://raw.githubusercontent.com/kubernetes-retired/external-storage/master/nfs/deploy/kubernetes/rbac.yaml</span><br><span class="line">curl -LO https://raw.githubusercontent.com/kubernetes-retired/external-storage/master/nfs/deploy/kubernetes/class.yaml</span><br></pre></td></tr></table></figure>
<p>修改deployment</p>
<ul>
<li>image：registry.cn-hangzhou.aliyuncs.com/simple00426/nfs-provisioner:latest</li>
<li>hostPath：/tmp/nfs-provisioner</li>
</ul>
</li>
<li><p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/change-default-storage-class/" target="_blank" rel="noopener">集群设置默认存储类</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass &lt;your-class-name&gt; -p &apos;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储类创建范例-阿里云nas</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: alicloud-nas-subpath</span><br><span class="line">mountOptions:</span><br><span class="line">- nolock,tcp,noresvport</span><br><span class="line">- vers=3</span><br><span class="line">parameters:</span><br><span class="line">  volumeAs: subpath</span><br><span class="line">  server: &quot;xxxxxxx.cn-hangzhou.nas.aliyuncs.com:/k8s/&quot;</span><br><span class="line">provisioner: nasplugin.csi.alibabacloud.com</span><br><span class="line">reclaimPolicy: Retain</span><br></pre></td></tr></table></figure>
<ul>
<li>provisioner:提供存储资源的存储系统</li>
<li>parameters：存储类使用参数描述要关联的存储卷</li>
<li>reclaimPolicy：动态创建pv的回收策略，默认delete，可选retain</li>
<li>mountOptions：pv挂载选项</li>
<li>volumeBindingMode：如何给pvc完成供给和绑定</li>
</ul>
</li>
</ul>
<h3 id="pvc创建-1"><a href="#pvc创建-1" class="headerlink" title="pvc创建"></a>pvc创建</h3><p>和pv静态供给使用的pvc基本一致，增加参数：storageClassName</p>
<h2 id="pv删除"><a href="#pv删除" class="headerlink" title="pv删除"></a>pv删除</h2><ul>
<li>删除pv的步骤：删除pod==》删除pvc==》删除pv</li>
<li>无法删除pv的处理：<code>kubectl patch pv xxx -p &#39;{&quot;metadata&quot;:{&quot;finalizers&quot;:null}}&#39;</code></li>
</ul>
<h1 id="存储插件-oss使用"><a href="#存储插件-oss使用" class="headerlink" title="存储插件-oss使用"></a>存储插件-oss使用</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>将oss部署到kubernetes集群中有两种方式【以下均以flexvolume为例】：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/134903.html" target="_blank" rel="noopener">CSI</a></li>
<li>flexvolume：<ul>
<li>使用前需要先安装<a href="https://help.aliyun.com/document_detail/86785.html#title-36d-7xb-uaa" target="_blank" rel="noopener">插件</a>，且需要注意：<ul>
<li>使用flexvolume需要kubelet关闭–enable-controller-attach-detach选项</li>
<li>在kube-system用户空间中部署flexvolume</li>
</ul>
</li>
<li>oss目前只支持静态存储卷，oss静态存储卷有两种使用方式<ul>
<li><a href="#flexvolume方式使用oss">使用pv/pvc</a></li>
<li><a href="https://help.aliyun.com/document_detail/130911.html#title-a30-0jw-3t9" target="_blank" rel="noopener">直接使用volume方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pv创建-1"><a href="#pv创建-1" class="headerlink" title="pv创建"></a><a href="https://help.aliyun.com/document_detail/130911.html#title-3r5-zwg-j87" target="_blank" rel="noopener">pv创建</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-oss</span><br><span class="line">spec:</span><br><span class="line">  capacity: </span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes: </span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  storageClassName: oss</span><br><span class="line">  flexVolume:</span><br><span class="line">    driver: &quot;alicloud/oss&quot;</span><br><span class="line">    options:</span><br><span class="line">      bucket: &quot;docker&quot;</span><br><span class="line">      url: &quot;oss-cn-hangzhou.aliyuncs.com&quot;</span><br><span class="line">      akId: ***</span><br><span class="line">      akSecret: ***</span><br><span class="line">      otherOpts: &quot;-o max_stat_cache_size=0 -o allow_other&quot;</span><br></pre></td></tr></table></figure>
<h2 id="pvc创建-2"><a href="#pvc创建-2" class="headerlink" title="pvc创建"></a>pvc创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-oss</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: oss</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br></pre></td></tr></table></figure>
<h2 id="pod使用-2"><a href="#pod使用-2" class="headerlink" title="pod使用"></a>pod使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- name: pvc-oss</span><br><span class="line">  persistentVolumeClaim:</span><br><span class="line">    claimName: pvc-oss</span><br></pre></td></tr></table></figure>
<h1 id="命令行使用oss的方式-ossfs"><a href="#命令行使用oss的方式-ossfs" class="headerlink" title="命令行使用oss的方式-ossfs"></a>命令行使用oss的方式-ossfs</h1><ul>
<li>此时oss作为共享存储直接挂载到操作系统(类似nfs)</li>
<li><p><a href="https://help.aliyun.com/document_detail/153892.html" target="_blank" rel="noopener">ossfs安装</a></p>
</li>
<li><p>使用</p>
<ul>
<li>将认证信息存入文件（权限640）：echo ${bucket}:${access-key-id}:{access-key-secret} &gt; /etc/passwd-ossfs</li>
<li>挂载：ossfs bucket_name mount_point -ourl=endpoint</li>
</ul>
</li>
</ul>
<h1 id="nfs-server"><a href="#nfs-server" class="headerlink" title="nfs-server"></a>nfs-server</h1><h2 id="创建nfs服务器"><a href="#创建nfs服务器" class="headerlink" title="创建nfs服务器"></a>创建nfs服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir nfs</span><br><span class="line">docker run -d --name nfs --net=host --privileged -v $(pwd)/nfs:/nfsshare -e SHARED_DIRECTORY=/nfsshare itsthenetwork/nfs-server-alpine:latest</span><br></pre></td></tr></table></figure>
<h2 id="客户端挂载测试"><a href="#客户端挂载测试" class="headerlink" title="客户端挂载测试"></a>客户端挂载测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir client</span><br><span class="line">mount -v 192.168.31.203:/ client/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>volume</tag>
        <tag>oss</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-认证授权和准入控制</title>
    <url>/blog/2020/03/30/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%92%8C%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>对kubernetes安全的保护主要通过如下方式实现：</p>
<ul>
<li>认证（authentication）：验证访问者的身份(即访问对象)</li>
<li>授权（authorization）：确定认证用户的权限和可以执行的操作，如增删改查指定的资源对象</li>
<li>准入控制（admission control）：验证操作是否符合规范<ul>
<li>用默认值补足要创建的目标资源中未定义的各字段</li>
<li>检查目标namespace是否存在</li>
<li>检查是否违反系统资源限制</li>
</ul>
</li>
</ul>
<h2 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h2><ul>
<li>服务账号（service account）：用于为pod中的进程访问api server提供身份标识<ul>
<li>kubernetes管理的对象，可使用kubectl命令创建</li>
<li>隶属于名称空间级别；</li>
</ul>
</li>
<li>用户账号(user account)：校验操作者(用户)是否有权限执行相应的操作<ul>
<li>kubernetes中不存在也不会存储此类账号，但是apiserver可以从https证书的CN(用户)和O(用户组)提取信息识别用户</li>
<li>作用于系统全局</li>
</ul>
</li>
<li>用户组（group）：用户账号的逻辑集合，附加于组上的权限可由其内部的所有用户继承；以下为一些内置的组<ul>
<li>system:unauthorized：未通过认证的用户；未被任何验证机制明确拒绝的用户即为匿名用户，自动被标识为system:anonymous，并隶属于system:unauthorized组</li>
<li>system:authenticated：通过认证的用户</li>
<li>system:serviceaccounts：当前系统上所有的service account对象</li>
<li>system:serviceaccount：namespace：特定名称空间的serviceaccount对象</li>
</ul>
</li>
</ul>
<h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">认证方式</a></h2><p>api server支持同时启用多种认证机制，但至少应该分别为serviceaccount和useraccount各自启用一个认证插件<br>各种认证方式串行进行，直到一种方式认证成功；若认证失败，则返回401状态码<br>kubernetes认证插件尝试将下列属性关联到请求中：  </p>
<ul>
<li>Username：用户名，如kubernetes-admin</li>
<li>UID：确定用户唯一性ID</li>
<li>Groups：用户所属的组，用于权限指派和继承</li>
<li>Extra：键值类型字符串，用于提供认证所需额外信息</li>
</ul>
<p>APIserver支持的认证方式，如下：</p>
<ul>
<li><strong>HTTPS证书认证</strong>：证书主体(subject)中包含用户(CN)和组(O)信息，用以识别用户<ul>
<li>【–client-ca-file=SOMEFILE】：是客户端(kubectl/kubelet/kube-proxy)认证的主要形式</li>
</ul>
</li>
<li><strong>HTTP Token认证</strong>：通过一个token识别用户<ul>
<li>【–service-account-key-file)】：主要用于pod的认证；由apiserver自动启用，来验证由其签名的token；如果没有指定，则使用apiserver自己的私钥文件(–tls-*)验证token合法性</li>
<li>【–token-auth-file=SOMEFILE】：Token文件中包含token、用户及组信息；token文件定义后不可变，除非apiserver重启；token标识也可以在http的头部进行设置</li>
<li>【–enable-bootstrap-token-auth】：使用HTTP Token认证用于集群中新建节点认证过程</li>
</ul>
</li>
<li><strong>HTTP Base认证</strong>【–basic-auth-file=SOMEFILE】：使用用户名+密码形式进行认证，用户名和密码以CSV明文格式存储</li>
<li>其他认证形式<ul>
<li>openID连接令牌：OAuth2认证风格，它属于json web（JWT）类型；</li>
<li>webhook令牌：HTTP身份验证允许将服务器的URL注册为webhook，并接受带有承载令牌的POST请求进行身份验证</li>
<li>认证代理：通过从请求头的值中识别用户，如X-Remote-User【–requestheader-username-headers】</li>
</ul>
</li>
</ul>
<h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><ul>
<li>Node：基于pod资源的目标调度节点来实现对kubelet的访问控制</li>
<li>ABAC：attribute-based access control，基于属性的访问控制</li>
<li>RBAC：role-based access control，基于角色的访问控制</li>
<li>webhook：基于http回调机制通过外部REST服务检查确认用户授权的访问控制</li>
<li>AlwaysAllow(总是允许)：用于期望不希望进行授权检查</li>
<li>AlwaysDeny(总是拒绝)：仅用于测试</li>
</ul>
<h2 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do" target="_blank" rel="noopener">准入控制器</a></h2><ul>
<li>AlwaysPullImages：总是下载镜像，常用于多租户环境下确保私有镜像仅能被有权限的用户使用</li>
<li>DefaultStorageClass：为创建PVC设置一个默认的storageclass</li>
<li>DefaultTolerationSeconds：如果pod对象没有设置污点容忍期限，则在此设置默认宽容期</li>
<li>LimitRanger：pod可用资源限制</li>
<li>MutatingAdmissionWebhook：串行调用任何可能更改对象的webhook</li>
<li>NamespaceLifecycle：拒绝在不存在的名称空间创建对象，删除名称空间也会删除空间下的所有对象</li>
<li>ResourceQuota：定义名称空间内可使用的资源配额</li>
<li>serviceaccount：用于实现service account管控机制的自动化，实现创建pod对象时自动为其附加相关的service account对象（当前名称空间的default）</li>
<li>ValidatingAdmissionWebhook：并行调用匹配当前请求的所有验证类webhook，任何一个验证失败，请求即失败</li>
</ul>
<h1 id="认证对象-ServiceAccount"><a href="#认证对象-ServiceAccount" class="headerlink" title="认证对象-ServiceAccount"></a>认证对象-ServiceAccount</h1><h2 id="ServiceAccount自动化"><a href="#ServiceAccount自动化" class="headerlink" title="ServiceAccount自动化"></a>ServiceAccount自动化</h2><blockquote>
<p>创建服务账号的同时也自动创建相关的认证token</p>
</blockquote>
<p>kubernetes系统通过三个独立的组件间的相互协作完成服务账户的自动化</p>
<ul>
<li>serviceaccount控制器(controller-manager)负责管理名称空间的资源，确保每个名称空间都存在一个“default”的serviceaccount对象</li>
<li>secret控制器(controller-manager)负责监控serviceaccount对象，联动创建或删除相关的secret对象</li>
<li>serviceaccount准入控制器：在pod没有定义serviceaccount对象时将其设置为“default”，并将相关的secret对象以volume形式挂载到容器中；pod和api servcer交互时即可使用此secret进行认证</li>
</ul>
<p>服务账号自动化需要进行的设置：  </p>
<ul>
<li>api-server：–service-account-key-file</li>
<li>controller-manager：–service-account-private-key-file</li>
</ul>
<h2 id="ServiceAccount实践"><a href="#ServiceAccount实践" class="headerlink" title="ServiceAccount实践"></a>ServiceAccount实践</h2><ul>
<li>创建serviceaccount对象(相应的secret对象也会创建)：kubectl create serviceaccount sa-demo</li>
<li>调用imagePullSecret（需要事先创建用户私有仓库认证的secret对象）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: sa-demo</span><br><span class="line">imagePullSecrets:</span><br><span class="line">- name: aliyun-simple</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="User认证-HTTPS证书"><a href="#User认证-HTTPS证书" class="headerlink" title="User认证-HTTPS证书"></a>User认证-HTTPS证书</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li>服务端认证：只为服务器端配置证书，由客户端验证服务端的身份，常见场景如：为web服务配置https证书</li>
<li>双向认证：客户端和服务端需要验证对方身份【从证书中提取用户(CN)和组(O)信息】</li>
</ul>
<h2 id="k8s中应用场景"><a href="#k8s中应用场景" class="headerlink" title="k8s中应用场景"></a>k8s中应用场景</h2><blockquote>
<p>APIserver与controller-manager、scheduler一般部署在同一台主机，不需要安全认证</p>
</blockquote>
<ul>
<li>APIserver与kube-proxy、kubelet通信【双向认证制作的kubeconfig】</li>
<li>APIserver与kubelet初次使用bootstrap通信【由apiserver的明文token(bootstrap-token)制作的bootstrap.kubeconfig】</li>
<li>APIServer与pod对象【由CA签名自动生成使用service account token】</li>
<li>APIserver与集群外部【kubectl使用的kubeconfig】</li>
<li>pod对象与集群外部【服务端认证，用于pod使用ingress、service暴露后外部访问】</li>
<li>etcd存储<ul>
<li>etcd集群内各节点间【双向认证】</li>
<li>etcd服务器与客户端(k8s-apiserver)【双向认证】</li>
</ul>
</li>
</ul>
<h1 id="认证载体-kubeconfig"><a href="#认证载体-kubeconfig" class="headerlink" title="认证载体-kubeconfig"></a>认证载体-kubeconfig</h1><h2 id="kubeconfig使用"><a href="#kubeconfig使用" class="headerlink" title="kubeconfig使用"></a>kubeconfig使用</h2><ul>
<li>各类APIserver的客户端都可以使用kubeconfig形式和APIserver通信<ul>
<li>kube-proxy</li>
<li>kubelet</li>
<li>kubelet的bootstrap</li>
<li>kubectl</li>
</ul>
</li>
<li>可以使用两种认证方式制作kubeconfig：  <ul>
<li>基于ca签发的证书(cert)和私钥(key)</li>
<li>基于ca认证的token【如bootstrap token、service account token】</li>
</ul>
</li>
</ul>
<h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><ul>
<li>kubectl config view:查看文件内容</li>
<li>kubectl config set-cluster：设置clusters字段【访问APIserver的URL和集群名称】</li>
<li>kubectl config set-credentials：设置users字段【访问APIServer的用户名和认证信息】</li>
<li>kubectl config set-context：设置context字段【context由用户名和集群名称组合而成】</li>
<li>kubectl config use-context：设置要使用的context，即current-context</li>
</ul>
<h1 id="授权模式-RBAC"><a href="#授权模式-RBAC" class="headerlink" title="授权模式-RBAC"></a>授权模式-RBAC</h1><h2 id="RBAC介绍"><a href="#RBAC介绍" class="headerlink" title="RBAC介绍"></a>RBAC介绍</h2><p>基于角色的访问控制(role-based access control),将权限授予角色而非直接授予使用者<br>RBAC主要定义谁(subject)可以操作(verb)什么对象(object)，具体如下：  </p>
<ul>
<li>主体(subject)：动作的发出者，通常以“账号”为载体，包含用户账号(UserAccount)和服务账号(ServiceAccount)</li>
<li>操作(verbs)：要执行的具体操作，如创建、删除、修改、查看等；对应于kubectl命令来说，则为create、delete、apply、update、patch、edit、get等子命令</li>
<li>客体(object)：动作施加于的目标实体，包含各类资源对象和非资源型的URL</li>
</ul>
<p>RBAC包含两种类型的角色(对哪些对象可以进行怎样的操作)：Role和ClusterRole  </p>
<ul>
<li>Role：表示对哪些资源(object)可以执行的权限集合(verbs)，作用于名称空间级别</li>
<li>ClusterRole：作用于集群级别,控制Role无法生效的资源类型，如<ul>
<li>集群级别的资源：Nodes、persistvolume</li>
<li>非资源类端点(URL)：/healthz</li>
<li>作用于所有名称空间的资源</li>
</ul>
</li>
</ul>
<p>对角色授权需要用到：RoleBinding和ClusterRoleBinding  </p>
<ul>
<li>RoleBinding：将同一名称空间的Role或ClusterRole绑定到一个或一组用户上，作用域仅为同一名称空间</li>
<li>ClusterRoleBinding：将ClusterRole绑定到一个或一组用户,使用户有全部名称空间(即集群级别)的的操作权限</li>
</ul>
<h2 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h2><ul>
<li>kubectl命令方式：<code>kubectl create role service-admin --verb=&quot;*&quot; --resource=&quot;services,services/*&quot; -n testing</code></li>
<li><p>资源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: testing</span><br><span class="line">  name: pods-reader</span><br><span class="line">rules: # 定义规则</span><br><span class="line">- apiGroups: [&quot;&quot;] </span><br><span class="line">  resources: [&quot;pods&quot;, &quot;pods/log&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源文件语法：</p>
<ul>
<li>apiGroups：资源的API群组，空串标识核心群组core</li>
<li>resources：规则应用的资源类型</li>
<li>resourceNames：规则应用的资源名称，缺省则表示指定资源类型下的所有资源</li>
<li>verbs：对资源可以执行的操作：get、list、create、update、patch、watch、proxy、redirect、delete、deletecollection</li>
<li>nonResourceURLs：非资源型URL地址，仅适用于ClusterRole和ClusterRoleBinding</li>
</ul>
</li>
</ul>
<h2 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h2><ul>
<li>kubectl命令方式：<code>kubectl create rolebinding admin-service --role=service-admin --user=kube-user1 -n testing</code></li>
<li><p>资源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: resources-reader</span><br><span class="line">  namespace: testing</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: kube-user1</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pods-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源文件语法</p>
<ul>
<li>subjects:要绑定的主体<ul>
<li>kind：主体资源类型，包括：User、Group、ServiceAccount</li>
<li>apiGroup：主体所属的API群组，ServiceAccount默认为空串””，User和Group默认为“rbac.authorization.k8s.io”</li>
<li>name：主体名称</li>
<li>namespace：主体(ServiceAccount类型)所属名称空间</li>
</ul>
</li>
<li>RoleRef：引用的角色<ul>
<li>apiGroup：引用的Role或ClusterRole所属的API群组</li>
<li>kind：引用的资源类型，Role或ClusterRole</li>
<li>name：引用的资源名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h2><h3 id="集群资源"><a href="#集群资源" class="headerlink" title="集群资源"></a>集群资源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nodes-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;nodes&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="非资源型URL"><a href="#非资源型URL" class="headerlink" title="非资源型URL"></a>非资源型URL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: url-admin</span><br><span class="line">rules:</span><br><span class="line">- nonResourceURLs:</span><br><span class="line">  - /healthz</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - create</span><br></pre></td></tr></table></figure>
<h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><ul>
<li><p>父级资源:通过标签匹配资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: monitoring</span><br><span class="line">aggregationRule:</span><br><span class="line">  clusterRoleSelectors:</span><br><span class="line">  - matchLabels:</span><br><span class="line">     rbac.example.com/aggregate-to-monitoring: &quot;true&quot;</span><br><span class="line">rules: []</span><br></pre></td></tr></table></figure>
</li>
<li><p>子级资源：定义标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: monitoring-endpoints</span><br><span class="line">  labels:</span><br><span class="line">    rbac.example.com/aggregate-to-monitoring: &quot;true&quot;</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内置ClusterRole"><a href="#内置ClusterRole" class="headerlink" title="内置ClusterRole"></a>内置ClusterRole</h3><table>
<thead>
<tr>
<th>ClusterRole</th>
<th>ClusterRoleBinding</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster-admin</td>
<td>system:masters</td>
<td>授予超级管理员在任何对象上执行任何操作的权限</td>
</tr>
<tr>
<td>admin</td>
<td>None</td>
<td>以RoleBinding机制访问指定名称空间的所有资源，包括Role和RoleBinding，但不包含资源配置和名称空间本身</td>
</tr>
<tr>
<td>edit</td>
<td>None</td>
<td>允许读写访问一个名称空间内的绝大多数资源，但不允许查看或修改Role或RoleBinding</td>
</tr>
<tr>
<td>view</td>
<td>None</td>
<td>允许读取一个名称空间的绝大多数资源，但不允许查看Role或RoleBinding，以及secret资源</td>
</tr>
</tbody>
</table>
<ul>
<li>超级管理员(cluster-admin)：基于同名的ClusterRoleBinding绑定到“system:masters”组，任何属于该组的用户都有超级管理员权限  </li>
<li>自定义超级管理员的方式：<ul>
<li>创建用户证书，其中O的值为“system:masters”【用户所属组】</li>
<li>将创建的用户使用ClusterRoleBinding绑定到cluster-admin</li>
</ul>
</li>
<li>自定义管理员(admin)：<code>kubectl create rolebinding dev-admin --clusterrole=admin --user=kube-user1 -n dev</code></li>
</ul>
<h1 id="认证授权范例-user"><a href="#认证授权范例-user" class="headerlink" title="认证授权范例-user"></a>认证授权范例-user</h1><p>以kubeadm集群中新建用户aliang为例</p>
<h2 id="创建私钥和证书"><a href="#创建私钥和证书" class="headerlink" title="创建私钥和证书"></a><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" target="_blank" rel="noopener">创建私钥和证书</a></h2><ul>
<li><p>创建ca配置文件【profiles和集群名称相同】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">         &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建证书签名请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; aliang-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;aliang&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ca生成证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=/etc/kubernetes/pki/ca.crt -ca-key=/etc/kubernetes/pki/ca.key -config=ca-config.json -profile=kubernetes aliang-csr.json | cfssljson -bare aliang</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="配置kubeconfig"><a href="#配置kubeconfig" class="headerlink" title="配置kubeconfig"></a>配置kubeconfig</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --embed-certs=true --server=&quot;https://192.168.31.201:6443&quot; --certificate-authority=/etc/kubernetes/pki/ca.crt --kubeconfig=aliang.kubeconfig</span><br><span class="line">kubectl config set-credentials aliang --embed-certs=true --client-certificate=aliang.pem --client-key=aliang-key.pem --kubeconfig=aliang.kubeconfig</span><br><span class="line">kubectl config set-context aliang@kubernetes --cluster=kubernetes --user=aliang --kubeconfig=aliang.kubeconfig</span><br><span class="line">kubectl config use-context aliang@kubernetes --kubeconfig=aliang.kubeconfig</span><br></pre></td></tr></table></figure>
<h2 id="给用户aliang授权"><a href="#给用户aliang授权" class="headerlink" title="给用户aliang授权"></a>给用户aliang授权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;,&quot;services&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span><br><span class="line">---</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: aliang</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
<h2 id="kubectl命令测试"><a href="#kubectl命令测试" class="headerlink" title="kubectl命令测试"></a>kubectl命令测试</h2><blockquote>
<p>kubectl默认使用的kubeconfig文件在用户主目录下的.kube中，例如</p>
<ul>
<li>linux下：<code>/home/ceshi/.kube/config</code></li>
<li>windows下：<code>C:\Users\simple\.kube\config</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod --kubeconfig=aliang.kubeconfig</span><br><span class="line">kubectl get svc --kubeconfig=aliang.kubeconfig</span><br></pre></td></tr></table></figure>
<h1 id="认证授权范例-serviceaccount"><a href="#认证授权范例-serviceaccount" class="headerlink" title="认证授权范例-serviceaccount"></a>认证授权范例-serviceaccount</h1><p><strong>以部署kube-dashboard为例</strong></p>
<h2 id="资源文件部署"><a href="#资源文件部署" class="headerlink" title="资源文件部署"></a><a href="https://github.com/kubernetes/dashboard/blob/master/aio/deploy/recommended.yaml" target="_blank" rel="noopener">资源文件部署</a></h2><ul>
<li>使用hostPort或NodePort将访问端口暴露在宿主机</li>
<li>资源文件中也包含创建secret对象的内容【web访问所需https证书】</li>
</ul>
<h2 id="访问授权"><a href="#访问授权" class="headerlink" title="访问授权"></a>访问授权</h2><p>dashboard是部署于集群中的pod对象，访问集群中的资源需要使用ServiceAccount账户类型<br>同时这种ServiceAccount账户需要绑定集群角色(cluster-admin)，以获得对集群的相应操作权限<br>dashboard页面提供了kubeconfig和token两种访问认证方式  </p>
<ul>
<li><p>创建服务账号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
</li>
<li><p>给服务账号绑定权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="web访问"><a href="#web访问" class="headerlink" title="web访问"></a>web访问</h2><ul>
<li>使用ServiceAccount的token信息访问dashboard：<code>kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;{print $1}&#39;)</code></li>
<li>基于token信息制作kubeconfig，访问dashboard<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --embed-certs=true --server=&quot;https://172.17.8.101:6443&quot; --certificate-authority=/etc/kubernetes/ssl/ca.pem --kubeconfig=./kubeconfig</span><br><span class="line">ADMIN_TOKEN=$(kubectl get secret admin-token-l7gjt -n kube-system -o jsonpath=&#123;.data.token&#125;|base64 -d)</span><br><span class="line">kubectl config set-credentials kube-system:admin --token=$&#123;ADMIN_TOKEN&#125; --kubeconfig=./kubeconfig</span><br><span class="line">kubectl config set-context admin --cluster=kubernetes --user=kube-system:admin --kubeconfig=./kubeconfig</span><br><span class="line">kubectl config use-context kube-system:admin --kubeconfig=./kubeconfig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="https证书重建"><a href="#https证书重建" class="headerlink" title="https证书重建"></a>https证书重建</h2><blockquote>
<p>用于解决https证书错误</p>
</blockquote>
<ul>
<li>创建私钥和证书</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out certs/dashboard.key 2048</span><br><span class="line">openssl req -new -key certs/dashboard.key -out certs/dashboard.csr -subj &quot;/CN=kube-user1/O=kubernetes&quot;</span><br><span class="line">openssl x509 -req -in certs/dashboard.csr -CA /etc/kubernetes/pki/ca.pem -CAkey /etc/kubernetes/pki/ca-key.pem -CAcreateserial -out certs/dashboard.crt -days 3650</span><br></pre></td></tr></table></figure>
<ul>
<li>删除已存在的证书对象(secret):<code>kubectl delete secret kubernetes-dashboard-certs -n kube-system</code></li>
<li>创建证书对象(secret)【kubernetes-dashboard-certs】：<code>kubectl create secret generic kubernetes-dashboard-certs --from-file=certs -n kube-system</code></li>
<li>删除kubernetes-dashboard的pod，重建pod并重新加载https证书：<code>kubectl delete pods $(kubectl get pods -n kube-system|grep kubernetes-dashboard|awk &#39;{print $1}&#39;) -n kube-system</code></li>
</ul>
<h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1><h2 id="LimitRanger"><a href="#LimitRanger" class="headerlink" title="LimitRanger"></a>LimitRanger</h2><ul>
<li>支持在名称空间级别为每个资源对象指定最大、最小、默认的计算或存储资源请求和资源限制</li>
<li>支持限制容器(cpu/内存)、pod(cpu/内存)、persistvolumeclaim(存储)三种资源的用量</li>
<li>范例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: LimitRange</span><br><span class="line">metadata:</span><br><span class="line">  name: cpu-limit-range</span><br><span class="line">spec:</span><br><span class="line">  limits:</span><br><span class="line">  - default: #默认限制</span><br><span class="line">      cpu: 1000m</span><br><span class="line">    defaultRequest: #默认需求</span><br><span class="line">      cpu: 1000m</span><br><span class="line">    min: #最小可申请资源</span><br><span class="line">      cpu: 500m</span><br><span class="line">    max: #最大可申请资源</span><br><span class="line">      cpu: 2000m</span><br><span class="line">    maxLimitRequestRatio: #最大可申请资源（最小用量的倍数）</span><br><span class="line">      cpu: 4</span><br><span class="line">    type: Container #限制的资源类型</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ResourceQuota"><a href="#ResourceQuota" class="headerlink" title="ResourceQuota"></a>ResourceQuota</h2><ul>
<li>定义名称空间的对象数量，以及所有对象消耗的系统资源总量(计算及存储资源)</li>
<li>在名称空间启用cpu和内存等系统资源配额后，用户创建pod对象时必须指定资源需求或资源限制【也可以通过LimitRange控制器设置默认值】</li>
<li>资源配额仅对创建ResourceQuota对象之后创建的对象有效，对已经存在的对象不会产生任何影响</li>
<li>开启资源配额(apiserver)：【–enable-admission-plugins=ResourceQuota】</li>
</ul>
<h3 id="资源配额类型"><a href="#资源配额类型" class="headerlink" title="资源配额类型"></a>资源配额类型</h3><ul>
<li>计算资源配额<ul>
<li>limits.cpu</li>
<li>limits.memory</li>
<li>requests.cpu</li>
<li>requests.memory</li>
</ul>
</li>
<li>存储资源配额<ul>
<li>requests.storage：所有pvc存储总量</li>
<li>persistentvolumeclaims：可以申请的pvc数量</li>
<li>storage-class-name.storageclass.storage.k8s.io/requests.storage：指定类别下的pvc存储总量</li>
<li>storage-class-name.storageclass.storage.k8s.io/persistentvolumeclaims：指定类别下的pvc数量</li>
<li>requests.ephemeral-storage：所有pod可用的本地临时存储需求总量</li>
<li>limits.ephemeral-storage：所有pod可用的本地临时存储限制总量</li>
</ul>
</li>
<li>资源对象数量配额【1.9版本开始支持所有标准名称空间类型资源，形如count/resource.group】<ul>
<li>count/persistentvolumeclaims</li>
<li>count/services</li>
<li>count/secrets</li>
<li>count/configmaps</li>
<li>count/replicationcontrollers</li>
<li>count/deployments.apps</li>
<li>count/replicasets.apps</li>
<li>count/statefulsets.apps</li>
<li>count/jobs.batch</li>
<li>count/cronjobs.batch</li>
<li>count/deployments.extensions</li>
</ul>
</li>
<li>资源对象数量配额【1.9版本之前语法】<ul>
<li>configmaps    </li>
<li>persistentvolumeclaims</li>
<li>pods</li>
<li>replicationcontrollers</li>
<li>resourcequotas</li>
<li>services</li>
<li>services.loadbalancers</li>
<li>services.nodeports</li>
<li>services.nodeports</li>
</ul>
</li>
<li>自定义资源对象数量配额【1.15版本支持自定义资源，形如count/widgets.example.com】</li>
</ul>
<h3 id="资源配额适用范围"><a href="#资源配额适用范围" class="headerlink" title="资源配额适用范围"></a>资源配额适用范围</h3><ul>
<li>Terminating</li>
<li>NotTerminating</li>
<li>BestEffort</li>
<li>NotBestEffort</li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ResourceQuota</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-example</span><br><span class="line">  namespace: test</span><br><span class="line">spec:</span><br><span class="line">  hard:</span><br><span class="line">    pods: &quot;5&quot;</span><br><span class="line">    requests.cpu: &quot;1&quot;</span><br><span class="line">    requests.memory: 1Gi</span><br><span class="line">    limits.cpu: &quot;2&quot;</span><br><span class="line">    limits.memory: 2Gi</span><br><span class="line">    count/deployments.apps: &quot;1&quot;</span><br><span class="line">    count/deployments.extensions: &quot;1&quot;</span><br><span class="line">    persistentvolumeclaims: &quot;2&quot;</span><br></pre></td></tr></table></figure>
<h2 id="PodSecuritypolicy"><a href="#PodSecuritypolicy" class="headerlink" title="PodSecuritypolicy"></a>PodSecuritypolicy</h2><ul>
<li>定义：用于控制用户在配置pod资源时可以设定的特权类属性，比如<ul>
<li>是否可以使用特权容器、根名称空间、主机文件系统</li>
<li>可使用的主机网络和端口、卷类型、linux capabilities</li>
</ul>
</li>
<li>使用步骤：<ul>
<li>创建PSP对象</li>
<li>对相关的使用主体(用户、组、服务账号)进行RBAC授权<ul>
<li>将use权限授予特定的Role或ClusterRole</li>
<li>将UserAccount或ServiceAccount完成角色绑定</li>
</ul>
</li>
<li>apiserver启用PodSecuritypolicy准入控制器(–enable-admission-plugins=PodSecurityPolicy)</li>
</ul>
</li>
</ul>
<h3 id="PSP对象"><a href="#PSP对象" class="headerlink" title="PSP对象"></a>PSP对象</h3><ul>
<li><a href="https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml" target="_blank" rel="noopener">特权PSP</a></li>
<li><a href="https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml" target="_blank" rel="noopener">非特权PSP</a></li>
</ul>
<h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul>
<li><p>ClusterRole</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: &lt;role name&gt;</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&apos;policy&apos;]</span><br><span class="line">  resources: [&apos;podsecuritypolicies&apos;]</span><br><span class="line">  verbs:     [&apos;use&apos;]</span><br><span class="line">  resourceNames:</span><br><span class="line">  - &lt;list of policies to authorize&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClusterRoleBinding</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: &lt;binding name&gt;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: &lt;role name&gt;</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line"># Authorize specific service accounts:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: &lt;authorized service account name&gt;</span><br><span class="line">  namespace: &lt;authorized pod namespace&gt;</span><br><span class="line"># Authorize specific users (not recommended):</span><br><span class="line">- kind: User</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  name: &lt;authorized user name&gt;</span><br><span class="line"># Authorize all service accounts in a namespace:</span><br><span class="line">- kind: Group</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  name: system:serviceaccounts</span><br><span class="line"># Or equivalently, all authenticated users in a namespace:</span><br><span class="line">- kind: Group</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  name: system:authenticated</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubeconfig</tag>
        <tag>认证</tag>
        <tag>授权</tag>
        <tag>RBAC</tag>
        <tag>准入控制</tag>
        <tag>资源限制</tag>
        <tag>资源配额</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-监控和日志</title>
    <url>/blog/2020/03/11/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="k8s监控指标"><a href="#k8s监控指标" class="headerlink" title="k8s监控指标"></a>k8s监控指标</h1><ul>
<li>节点对象：系统指标、CPU内存及网络流量</li>
<li>k8s资源对象：k8s事件</li>
<li>容器pod对象：容器本身的系统指标，同样有CPU内存等指标</li>
<li>应用性能统计：QPS统计、jvm数据收集</li>
<li>应用业务统计</li>
</ul>
<h1 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h1><h2 id="早期方案-heapster"><a href="#早期方案-heapster" class="headerlink" title="早期方案-heapster"></a>早期方案-heapster</h2><ul>
<li><p>架构</p>
<ul>
<li>数据采集：kubelet/cadvisor</li>
<li>数据接口：heapster、kubelet、summary、prometheus</li>
<li>数据存储：inflexDB</li>
<li>数据消费：dashboard、horizontal pod autoscaler(HPA/pod弹性伸缩)、kubectl top、grafana(可视化)</li>
</ul>
</li>
<li><p>heapter缺点</p>
<ul>
<li>包含了太多的存储后端接口代码，某些代码已不再维护</li>
<li>接口格式混乱，不支持prometheus</li>
<li>仅支持以CPU为基础的弹性伸缩</li>
</ul>
</li>
</ul>
<h2 id="新一代监控方案"><a href="#新一代监控方案" class="headerlink" title="新一代监控方案"></a>新一代监控方案</h2><ul>
<li>资源指标API和自定义指标API被创建为API定义而非具体实现，他们作为聚合的API安装到kubernetes集群中，从而允许API在保持不变的情况下切换其具体的实现方案</li>
<li>通过APIServer Aggregated API注册了三种不同的metrics接口，将监控的消费能力进行标准化和解耦，从而实现了与社区的融合 </li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>API</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resources metrics</td>
<td>metrics.k8s.io</td>
<td>主要的实现为metrics-server，提供资源指标采集</td>
</tr>
<tr>
<td>Custom metrics</td>
<td>custom.metrics.k8s.io</td>
<td>主要的实现为prometheus，提供自定义指标采集</td>
</tr>
<tr>
<td>External metrics</td>
<td>external.metrics.k8s.io</td>
<td>主要的实现为云厂商的provider，提供云资源的监控指标</td>
</tr>
</tbody>
</table>
<h1 id="API聚合层"><a href="#API聚合层" class="headerlink" title="API聚合层"></a>API聚合层</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在kubernetes 1.7版本引入聚合层，允许第三方应用程序将自己注册到apiserver上，仍然通过apiserver的 HTTP URL对新的API进行访问和操作。为了实现这个机制，kubernetes在kube-apiserver服务中引入了一个API聚合层，用于将扩展的API的访问请求转发到用户服务的功能。当你访问apis/metrics.k8s.io/v1beta1的时候，实际上访问的是一个叫做kube-aggregator的代理。kube-apiserver是代理的一个后端，而Metrics server是另一个后端。通过这种方式，我们就可以很方便的扩展kubernetes的API了</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/kube-aggergation.png" alt></p>
<h2 id="功能启用"><a href="#功能启用" class="headerlink" title="功能启用"></a>功能启用</h2><p>在kube-apiserver中添加启动参数用以开启API聚合层功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--enable-aggregator-routing=true \</span><br><span class="line">--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">--requestheader-allowed-names=kubernetes \</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra- \</span><br><span class="line">--requestheader-group-headers=X-Remote-Group \</span><br><span class="line">--requestheader-username-headers=X-Remote-User \</span><br><span class="line">--proxy-client-cert-file=/opt/kubernetes/ssl/server.pem \</span><br><span class="line">--proxy-client-key-file=/opt/kubernetes/ssl/server-key.pem \</span><br></pre></td></tr></table></figure>
<p>–requestheader-allowed-names：由ca签署的客户端证书的CN名称（可以是apiserver、kube-proxy、kubectl等证书的CN名称）</p>
<h1 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>metrics server从每个节点上的kubelet(cadvisor)公开的摘要API收集指标数据，然后通过kubernetes聚合器注册在master的APIServer中</p>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/hpa-metrics-sever.png" alt></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>项目地址：<a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/metrics-server</a> </p>
<p>使用前提：API Server开启聚合层功能</p>
<p>下载资源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -Lo metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.4.1/components.yaml</span><br></pre></td></tr></table></figure>
<p>修改资源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">containers:</span><br><span class="line">- name: metrics-server</span><br><span class="line">  image: registry.cn-hangzhou.aliyuncs.com/simple00426/metrics-server-amd64:v0.4.1</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  args:  </span><br><span class="line">    - --cert-dir=/tmp</span><br><span class="line">    - --secure-port=4443</span><br><span class="line">    - --kubelet-insecure-tls</span><br><span class="line">    - --kubelet-preferred-address-types=InternalIP</span><br></pre></td></tr></table></figure>
<ul>
<li>修改镜像地址(image)：registry.cn-hangzhou.aliyuncs.com/simple00426/metrics-server-amd64:v0.4.1</li>
<li>设置容器启动参数(args)<ul>
<li><code>--kubelet-insecure-tls</code>：metrics server连接kubelet(作为服务端)时，不对kubelet证书的ca进行校验</li>
<li><code>--kubelet-preferred-address-types=InternalIP</code>：metrics server通过内部ip（kubectl describe node|grep InternalIP）访问kubelet，获取指标数据</li>
</ul>
</li>
</ul>
<p>可通过Metrics API在Kubernetes中获得资源使用率指标，例如容器CPU和内存使用率。这些度量标准既可以由用户直接访问（例如，通过使用<code>kubectl top</code>命令），也可以由集群中的控制器（例如，Horizontal Pod Autoscaler）用于进行决策。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes</span><br><span class="line">kubectl top node/pod</span><br><span class="line">kubectl get apiservice</span><br></pre></td></tr></table></figure>
<h1 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h1><h2 id="prometheus技术栈组件"><a href="#prometheus技术栈组件" class="headerlink" title="prometheus技术栈组件"></a>prometheus技术栈组件</h2><ul>
<li>prometheus server：收集、存储、查询监控指标</li>
<li>客户端组件<ul>
<li>cadvisor(kubelet)：采集容器cpu、内存使用情况；PromQL查询关键词：<code>container_</code></li>
<li>node_exporter：采集linux节点cpu、内存使用情况；PromQL查询关键词：<code>node_</code></li>
<li>kube-state-metrics：通过API Server收集资源对象的状态并生成相关的指标；PromQL查询关键词：<code>kube_</code></li>
</ul>
</li>
<li>altertmanager：<em>告警规则需要在prometheus中配置</em></li>
<li>pushgateway：用于支持短周期任务push数据的网关</li>
<li>grafana：度量指标可视化</li>
</ul>
<h2 id="k8s中部署prometheus方式"><a href="#k8s中部署prometheus方式" class="headerlink" title="k8s中部署prometheus方式"></a>k8s中部署prometheus方式</h2><ul>
<li><p>分组件部署：<a href="https://github.com/simple0426/sysadm/tree/master/kubernetes/prometheus" target="_blank" rel="noopener">https://github.com/simple0426/sysadm/tree/master/kubernetes/prometheus</a></p>
</li>
<li><p><a href="https://github.com/coreos/kube-prometheus" target="_blank" rel="noopener">kube-prometheus</a>：提供了基于prometheus operator和prometheus的完整集群监控技术栈的示例配置，包含如下</p>
<ul>
<li><a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="noopener">Prometheus Operator</a>：设置在k8s集群中运行的prometheus，以获取k8s资源对象</li>
<li>高可用<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a></li>
<li>高可用<a href="https://github.com/prometheus/alertmanager" target="_blank" rel="noopener">Alertmanager</a></li>
<li><a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener">Prometheus node-exporter</a></li>
<li><a href="https://github.com/DirectXMan12/k8s-prometheus-adapter" target="_blank" rel="noopener">Prometheus Adapter for Kubernetes Metrics APIs</a>：prometheus实现k8s资源监控(metrics-server)的适配器</li>
<li><a href="https://github.com/kubernetes/kube-state-metrics" target="_blank" rel="noopener">kube-state-metrics</a>：收集k8s资源对象的相关信息</li>
<li><a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a></li>
</ul>
</li>
<li><a href="https://github.com/helm/charts/tree/master/stable/prometheus-operator" target="_blank" rel="noopener">stable/prometheus-operator</a>：helm社区维护的prometheus监控技术栈，类似于kube-prometheus</li>
</ul>
<h2 id="kube-prometheus部署"><a href="#kube-prometheus部署" class="headerlink" title="kube-prometheus部署"></a>kube-prometheus部署</h2><ul>
<li>设置api-server开启聚合层功能：–enable-aggregator-routing=true</li>
<li>设置kubelet【/etc/sysconfig/kubelet】<ul>
<li><code>--authentication-token-webhook=true</code></li>
<li><code>--authorization-mode=Webhook</code></li>
</ul>
</li>
<li><a href="https://github.com/coreos/kube-prometheus/tree/master/manifests" target="_blank" rel="noopener">下载资源文件</a><ul>
<li><code>kubectl create -f manifests/setup</code></li>
<li><code>kubectl create -f manifests/</code></li>
</ul>
</li>
</ul>
<h1 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h1><blockquote>
<p>宿主机/k8s组件、pod标准输出日志可以通过在k8s中部署<a href="https://github.com/elastic/beats/blob/master/deploy/kubernetes/filebeat-kubernetes.yaml" target="_blank" rel="noopener">filebeat</a>收集</p>
</blockquote>
<ul>
<li>宿主机和核心组件日志，通过hostpath挂载/var/log/messages收集日志<ul>
<li>apiserver日志用来审计</li>
<li>scheduler日志可以诊断调度</li>
<li>etcd日志可以查看存储状态</li>
<li>ingress日志可以分析接入层流量</li>
</ul>
</li>
<li>应用程序日志<ul>
<li>标准输出(docker engine写日志)：/var/lib/docker/containers/<container-id>/<container-id>-json.log</container-id></container-id></li>
<li>日志文件</li>
</ul>
</li>
</ul>
<h1 id="程序日志收集"><a href="#程序日志收集" class="headerlink" title="程序日志收集"></a>程序日志收集</h1><ul>
<li><p>将pod中的日志挂载到宿主机的目录(hostPath)，然后使用filebeat收集；解决多个pod部署在同一宿主机日志混乱的方案如下</p>
<ul>
<li>【开发】在程序中根据容器名称命名日志文件名，例如/tmp/nginx-1.log、/tmp/nginx-2.log</li>
<li>【运维】在pod中的hostPath中根据容器名称，挂载到宿主机的不同目录；例如：/tmp/nginx-1/access.log、/tmp/nginx-2/access.log</li>
</ul>
</li>
<li><p>每一个pod中都部署一个日志收集容器，使用emptyDir共享日志目录让日志收集程序读取到</p>
</li>
<li>【非k8s解决方式】应用程序直接推送日志，比如推送到专用日志服务器</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>在node上部署一个日志收集程序</td>
<td>每个node仅部署一个日志收集程序；资源消耗少；对应用无侵入</td>
<td>应用程序日志如果写到标准输出和标准错误输出，那就不支持多行日志（docker使用json-log日志驱动）</td>
</tr>
<tr>
<td>pod中附加专用日志收集容器</td>
<td>低耦合</td>
<td>每个pod中都增加一个日志收集代理，增加资源消耗和运维维护成本</td>
</tr>
<tr>
<td>应用程序直接推送日志</td>
<td>无需额外工具</td>
<td>浸入应用，增加应用复杂度</td>
</tr>
</tbody>
</table>
<h1 id="日志处理方案"><a href="#日志处理方案" class="headerlink" title="日志处理方案"></a>日志处理方案</h1><blockquote>
<p><a href="https://github.com/simple0426/sysadm/tree/master/kubernetes/elk" target="_blank" rel="noopener">k8s中部署efk范例</a></p>
</blockquote>
<ul>
<li>数据采集：filebeat、fluentd</li>
<li>过滤清洗：logstash</li>
<li>消息队列：redis、kafka</li>
<li>索引存储：elasticsearch、influxDB</li>
<li>可视化分析：kibana、grafana</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
        <tag>日志</tag>
        <tag>监控</tag>
        <tag>metrics-server</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-资源管理</title>
    <url>/blog/2020/03/21/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="管理方式-API"><a href="#管理方式-API" class="headerlink" title="管理方式-API"></a>管理方式-API</h1><p>kubernetes API是管理各种资源的唯一入口，它提供了一个RESTful风格的CRUD接口，<br>用于查询和修改集群的状态，并将结果存储于etcd中。</p>
<h2 id="API设计模式"><a href="#API设计模式" class="headerlink" title="API设计模式"></a>API设计模式</h2><ul>
<li>声明式<ul>
<li>天然记录了状态</li>
<li>幂等操作，可在任意时刻反复操作</li>
<li>正常操作即巡检</li>
<li>可合并多个变更</li>
</ul>
</li>
<li>命令式<ul>
<li>如果命令没有响应，需要反复重试、记录当前的操作</li>
<li>如果多次重试、操作有可能出问题</li>
<li>需要单独的巡检操作，巡检本身也可能会有问题或带来额外影响</li>
<li>多并发操作，需要加锁处理；不仅复杂，也降低了系统执行效率</li>
</ul>
</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote>
<p>API-&gt;Controller</p>
</blockquote>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/k8s-control-circle.jpg" alt></p>
<ul>
<li>由声明式的API驱动(k8s资源对象)</li>
<li>由控制器异步地控制系统向终态趋近</li>
<li>使系统自动化和无人值守成为可能</li>
<li>便于扩展(自定义资源和控制器)</li>
</ul>
<h2 id="查看API资源"><a href="#查看API资源" class="headerlink" title="查看API资源"></a>查看API资源</h2><ul>
<li>支持的api接口版本：kubectl api-versions</li>
<li>支持的api资源信息：kubectl api-resources</li>
</ul>
<h2 id="自定义API资源"><a href="#自定义API资源" class="headerlink" title="自定义API资源"></a>自定义API资源</h2><ul>
<li>修改kubernetes源码自定义类型</li>
<li>创建自定义API server，并将其聚合至集群中</li>
<li>使用自定义资源CRD</li>
</ul>
<h2 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h2><ul>
<li>客户端命令(kubectl)：默认使用https访问接口，并且需要进行认证检查(kubeconfig)</li>
<li>http方式：为了使用通用的HTTP方式访问API接口，可以使用kubectl proxy在本地启动一个网关代理<ul>
<li>启动代理网关：kubectl proxy –port 8080</li>
<li>访问接口：curl localhost:8080/api/v1/namespaces/</li>
</ul>
</li>
<li>web界面：kubernetes dashboard</li>
</ul>
<h1 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h1><h2 id="资源对象分类"><a href="#资源对象分类" class="headerlink" title="资源对象分类"></a>资源对象分类</h2><ul>
<li>工作负载（workload）：replicaset、job、deployment、statefulset、daemonset</li>
<li>发现和负载均衡（Discovery&amp;LB）：service、endpoint、ingress</li>
<li>配置和存储（config&amp;storage）：ConfigMap、secret、volume</li>
<li>集群级别资源（cluster）：<ul>
<li>namespace</li>
<li>Node</li>
<li>Role：名称空间级别的权限集合，可被RoleBinding引用</li>
<li>ClusterRole：cluster级别的权限集合，可被RoleBinding、ClusterRoleBinding医用</li>
<li>RoleBinding：将Role或ClusterRole许可的权限绑定在一个或一组用户之上，隶属于且仅能作用于一个名称空间</li>
<li>ClusterRoleBinding：将ClusterRole许可的权限绑定在一个或一组用户之上</li>
</ul>
</li>
<li>元数据（metadata）：HPA(自动弹性伸缩)、pod模板、LimitRange(限制pod的资源使用)</li>
</ul>
<h2 id="资源对象格式"><a href="#资源对象格式" class="headerlink" title="资源对象格式"></a>资源对象格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  lables:</span><br><span class="line">    name: nginx</span><br><span class="line">spec: </span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br></pre></td></tr></table></figure>
<ul>
<li>kind：资源类型</li>
<li>apiVersion：API群组及相关的版本</li>
<li>metadata：为资源提供元数据，如名称、隶属的名称空间、标签</li>
<li>spec：用户期望的状态；资源配置详情</li>
<li>status(集群维护，用户只读)：活动对象的当前状态</li>
</ul>
<h2 id="资源对象文档"><a href="#资源对象文档" class="headerlink" title="资源对象文档"></a>资源对象文档</h2><ul>
<li>查看资源对象语法：kubectl explain resources_name.field_name</li>
</ul>
<h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><h3 id="必选字段"><a href="#必选字段" class="headerlink" title="必选字段"></a>必选字段</h3><ul>
<li>namespace：所属名称空间【默认default】</li>
<li>name：对象名称</li>
<li>uid(集群自动生成)：当前对象的唯一标识符</li>
</ul>
<h3 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h3><ul>
<li>labels：用于标识当前对象的键值对，常用作筛选条件</li>
<li>annotations：非标识性键值对，用于labels的补充</li>
</ul>
<h1 id="标签和标签选择器"><a href="#标签和标签选择器" class="headerlink" title="标签和标签选择器"></a>标签和标签选择器</h1><p>标识型的key:value元数据；可以在创建时指定，也可以通过命令随时添加到活动对象上</p>
<h2 id="标签定义语法"><a href="#标签定义语法" class="headerlink" title="标签定义语法"></a>标签定义语法</h2><ul>
<li>键由键前缀和健名组成<ul>
<li>健名最多63个字符，只能以字母和数字开头及结尾，包含字母、数字、连词符、下划线、点</li>
<li>键前缀是dns子域名格式，且不能超过253字符；省略前缀，键将被视为用户私有数据；由kubernetes系统组件或第三方组件为用户添加的键必须使用键前缀；“kubernetes.io”是系统核心组件使用的</li>
</ul>
</li>
<li>键值：和健名规则相同</li>
</ul>
<h2 id="常用标签范例"><a href="#常用标签范例" class="headerlink" title="常用标签范例"></a>常用标签范例</h2><ul>
<li>版本标签：release：stable，release：canary，release：beta</li>
<li>环境标签：environment：dev，environment：qa，environment：prod</li>
<li>应用标签：app：ui，app：as，app：pc，app：sc</li>
<li>服务分层标签：tier：frontend，tier：backend，backend：cache</li>
<li>分区标签：partition：customerA，partition：customerB</li>
<li>品控级别标签：track：daily，track：weekly</li>
</ul>
<h2 id="资源文件定义标签"><a href="#资源文件定义标签" class="headerlink" title="资源文件定义标签"></a>资源文件定义标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-label</span><br><span class="line">  labels:</span><br><span class="line">    env: qa</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br></pre></td></tr></table></figure>
<h2 id="命令行修改标签"><a href="#命令行修改标签" class="headerlink" title="命令行修改标签"></a>命令行修改标签</h2><ul>
<li>修改已存在标签：kubectl label pods/pod-label env=prod –overwrite</li>
<li>添加新标签：kubectl label pods/pod-label release=alpha</li>
<li>删除标签：kubectl label pods/pod-label release-</li>
</ul>
<h2 id="标签显示"><a href="#标签显示" class="headerlink" title="标签显示"></a>标签显示</h2><ul>
<li>显示所有标签：kubectl get pod –show-labels</li>
<li>显示特定键标签：kubectl get pod -L env,tier</li>
</ul>
<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><ul>
<li>多个选择器之间为逻辑“与”关系</li>
<li>空值的标签选择器意味着所有对象都被选中</li>
<li>空标签选择器意味着没有对象被选中</li>
</ul>
<h3 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a>选择器种类</h3><ul>
<li>等值关系，操作符：“=”，“==”，“！=”</li>
<li>集合关系，操作符：in，notin，exists(key-存在，!key-不存在)</li>
</ul>
<h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><ul>
<li>相等型：kubectl get deployment –show-labels -l env=test,env!=prod</li>
<li>集合型：kubectl get deployment –show-labels -l “Env in (test,gray)，Tie notin (front,back)，release，!release”</li>
</ul>
<h3 id="资源文件使用"><a href="#资源文件使用" class="headerlink" title="资源文件使用"></a>资源文件使用</h3><ul>
<li>matchLabels：相等型关系匹配</li>
<li>matchExpressions：集合型关系匹配<ul>
<li>key：key_name</li>
<li>operator：In、NotIn、Exists、DoesNotExist</li>
<li>values：[values1,values2…]</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector:</span><br><span class="line">  matchLables:</span><br><span class="line">    component: redis</span><br><span class="line">  matchExpressions:</span><br><span class="line">    - key: tier</span><br><span class="line">      operator: In</span><br><span class="line">      values: [cache]</span><br><span class="line">    - key: environment</span><br><span class="line">      operator: Exists</span><br><span class="line">      values:</span><br></pre></td></tr></table></figure>
<h1 id="注解-annotations"><a href="#注解-annotations" class="headerlink" title="注解-annotations"></a>注解-annotations</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它也是标识型的键值对信息，但不能用于标签及对象选择，仅用于为资源提供元数据<br>注解中的数据不受字符数量、特殊字符限制，可以是结构化(如json)也可以是非结构化数据  </p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>在为某资源引入新字段时，先以注解的方式提供；确定支持使用后，在资源中添加新字段，同时删除相关注解</li>
<li>资源的相关描述信息</li>
</ul>
<h2 id="查看注解"><a href="#查看注解" class="headerlink" title="查看注解"></a>查看注解</h2><ul>
<li>describe：kubectl describe pod storage-provisioner -n kube-system</li>
<li>get -o yaml：<code>kubectl get pod storage-provisioner -n kube-system -o yaml</code></li>
</ul>
<h2 id="命令行添加注解"><a href="#命令行添加注解" class="headerlink" title="命令行添加注解"></a>命令行添加注解</h2><p>kubectl annotate pods pod-label ilinux.io/created-by=”cluster admin”</p>
<h1 id="kubectl命令"><a href="#kubectl命令" class="headerlink" title="kubectl命令"></a>kubectl命令</h1><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>kubectl sub_command resource_type resource_name cmd_option</p>
<h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><ul>
<li>基础命令-初级<ul>
<li>create：从文件或标准输入创建资源</li>
<li>expose： 基于RC、service、deployment或pod创建service</li>
<li>run：通过创建Deployment在集群运行指定的镜像</li>
<li>set：设置指定资源的属性</li>
</ul>
</li>
<li>基础命令-中级<ul>
<li>explain：资源文档</li>
<li>get：显示一个或多个资源</li>
<li>edit：编辑集群上的资源，相当于先get后apply</li>
<li>delete：基于标准输入、文件名、资源名，或者资源标签删除资源</li>
</ul>
</li>
<li>部署命令<ul>
<li>rollout：管理资源的滚动更新</li>
<li>scale：设置资源Deployment、Replicaset、ReplicationController、Job的副本数</li>
<li>autoscale：自动设置Deployment、Replicaset、ReplicationController的副本数</li>
</ul>
</li>
<li>集群管理命令<ul>
<li>certificate：配置数字证书资源</li>
<li>cluster-info：显示集群信息</li>
<li>top：显示资源(CPU/内存/存储)使用率</li>
<li>cordon：标记节点为“不可调度”状态</li>
<li>uncordon：标记节点为“可调度”状态</li>
<li>drain：驱逐节点上的工作负载进入“维护”模式</li>
<li>taint：更新节点的污点</li>
</ul>
</li>
<li>排错和调试命令<ul>
<li>describe：显示资源或资源组详情</li>
<li>logs：显示pod内容器的日志</li>
<li>attach：挂载终端到一个运行中的容器</li>
<li>exec：在容器中执行命令</li>
<li>port-forward：转发一个或多个本地端口流量到pod</li>
<li>proxy：创建一个可以访问APIServer的代理</li>
<li>cp：在容器间复制文件和目录</li>
<li>auth：显示授权信息</li>
</ul>
</li>
<li>高级命令<ul>
<li>diff：对比活动的资源信息和将要应用的资源信息</li>
<li>apply：基于文件名或标准输入应用资源配置信息</li>
<li>patch：使用策略合并补丁更新资源的字段信息</li>
<li>replace：基于文件名或标准输入替换一个资源</li>
<li>wait：实验性功能，等待一个或多个资源的特定条件</li>
<li>convert：为不同api版本转换配置文件</li>
</ul>
</li>
<li>设置命令<ul>
<li>label：更新资源标签</li>
<li>annotate：更新资源注解</li>
<li>completion：输出指定shell的命令补全代码</li>
</ul>
</li>
<li>其他命令：<ul>
<li>api-resources：显示k8s支持的api资源</li>
<li>api-versions：显示k8s支持的api资源，以“group/version”形式</li>
<li>config：配置kubeconfig文件</li>
<li>plugin：提供和插件交互的工具</li>
<li>version：显示客户端和服务端的版本信息</li>
</ul>
</li>
</ul>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-f：指定资源文件<ul>
<li>可以读取json、yaml格式资源清单</li>
<li>指定清单文件路径、URL、目录</li>
<li>可以多次使用</li>
<li>-R递归获取多级目录清单文件</li>
</ul>
</li>
<li>-o：指定输出格式<ul>
<li>wide：宽格式显示</li>
<li>yaml、json：yaml、json格式显示资源对象</li>
<li>go-template：以自定义的go模板格式显示资源对象</li>
<li>custom-columns：自定义输出字段：<code>kubectl get pod -o custom-columns=NAME:metadata.name,IMAGE:spec.containers[0].image</code></li>
</ul>
</li>
<li>-l：通过标签过滤资源</li>
<li>-n：指定名称空间</li>
<li>-s：指定apiserver地址</li>
<li>–kubeconfig：指定kubeconfig文件【默认~/.kube/config】</li>
</ul>
<h2 id="插件-kubectl-debug"><a href="#插件-kubectl-debug" class="headerlink" title="插件-kubectl-debug"></a>插件-kubectl-debug</h2><ul>
<li><a href="https://github.com/aylei/kubectl-debug/blob/master/docs/zh-cn.md" target="_blank" rel="noopener">简介</a>:通过启动一个安装了各种排障工具的容器，来诊断目标容器</li>
<li><a href="https://github.com/aylei/kubectl-debug/releases" target="_blank" rel="noopener">安装</a></li>
<li>命令使用：<code>kubectl debug pod_name --agentless</code></li>
<li>命令参数：<ul>
<li>–fork：诊断一个处于CrashLookBackoff的pod</li>
<li>–agentless：启动无代理模式【命令使用时自动创建一个agent】</li>
<li>–image：指定使用的工具镜像【默认的镜像：nicolaka/netshoot】</li>
<li>-c container-name：指定要进入的容器内</li>
</ul>
</li>
</ul>
<h1 id="常见对象操作"><a href="#常见对象操作" class="headerlink" title="常见对象操作"></a>常见对象操作</h1><h2 id="创建资源对象"><a href="#创建资源对象" class="headerlink" title="创建资源对象"></a>创建资源对象</h2><ul>
<li>直接通过各种子命令管理资源对象：kubectl run</li>
<li>根据资源文件创建资源对象：kubectl create</li>
<li>根据声明式资源文件让kubernetes集群自动调整资源状态：kubectl apply</li>
</ul>
<h2 id="查看资源对象"><a href="#查看资源对象" class="headerlink" title="查看资源对象"></a>查看资源对象</h2><ul>
<li>get命令：kubectl get resource_type resource_name </li>
<li>describe命令：kubectl describe resource_type resource_name</li>
<li>参数：<ul>
<li>-o wide/yaml/json/custom-columns:显示格式</li>
<li>-n namespace 名称空间</li>
<li>-l key=value 指定过滤标签</li>
</ul>
</li>
</ul>
<h2 id="修改资源对象"><a href="#修改资源对象" class="headerlink" title="修改资源对象"></a>修改资源对象</h2><ul>
<li>edit: 编辑运行中的资源</li>
<li>apply：应用修改的资源文件</li>
</ul>
<h2 id="删除资源对象"><a href="#删除资源对象" class="headerlink" title="删除资源对象"></a>删除资源对象</h2><ul>
<li>delete命令:：kubectl delete resource_type resource_name</li>
</ul>
<h2 id="查看pod日志"><a href="#查看pod日志" class="headerlink" title="查看pod日志"></a>查看pod日志</h2><ul>
<li>logs命令:kubectl logs pod_id</li>
<li>参数： -c 指定容器名称</li>
</ul>
<h2 id="容器中执行命令"><a href="#容器中执行命令" class="headerlink" title="容器中执行命令"></a>容器中执行命令</h2><ul>
<li>exec命令: kubectl exec -it pod_name -c container_name /bin/bash</li>
</ul>
<h2 id="pod弹性伸缩"><a href="#pod弹性伸缩" class="headerlink" title="pod弹性伸缩"></a>pod弹性伸缩</h2><ul>
<li>scale命令: kubectl scale rc nginx –replicas=4</li>
</ul>
<h2 id="镜像升级和回滚"><a href="#镜像升级和回滚" class="headerlink" title="镜像升级和回滚"></a>镜像升级和回滚</h2><ul>
<li>查看当前版本：kubectl get deploy -o wide</li>
<li>更新镜像：kubectl set image deploy/nginx-deployment nginx=nginx:1.13</li>
<li>查看版本更新状况：kubectl rollout status deploy nginx-deployment</li>
<li>回滚到上个版本：kubectl rollout undo deploy nginx-deployment</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubectl</tag>
        <tag>标签</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes-配置管理</title>
    <url>/blog/2020/02/24/%E5%AE%B9%E5%99%A8%E5%8C%96/kubernetes/kubernetes-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>主要管理容器运行所需的配置文件、环境变量、命令行参数等可变配置</li>
<li>用于解耦容器镜像和可变配置，从而保证工作负载(pod)的可移植性</li>
</ul>
<h2 id="创建configMap"><a href="#创建configMap" class="headerlink" title="创建configMap"></a>创建configMap</h2><h3 id="清单文件方式"><a href="#清单文件方式" class="headerlink" title="清单文件方式"></a>清单文件方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: test-cfg</span><br><span class="line">  namespace: default</span><br><span class="line">data:</span><br><span class="line">  cache_host: memcached-gcxt</span><br><span class="line">  cache_port: &quot;11211&quot;</span><br><span class="line">  cache_prefix: gcxt</span><br><span class="line">  my.cnf: |</span><br><span class="line">    [mysqld]</span><br><span class="line">    log-bin = mysql-bin</span><br><span class="line">  app.properties: |</span><br><span class="line">    property.1 = value-1</span><br><span class="line">    property.2 = value-2</span><br><span class="line">    property.3 = value-3</span><br><span class="line">  cni-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;flannel&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行-文件方式"><a href="#命令行-文件方式" class="headerlink" title="命令行-文件方式"></a>命令行-文件方式</h3><ul>
<li>key是文件名，value是文件内容；可以针对单个文件或目录(目录的所有文件)</li>
<li>范例-目录：kubectl create configmap test-config –from-file=./configs</li>
<li>范例-文件：kubectl create configmap test-config2 –from-file=./configs/cache.conf</li>
</ul>
<h3 id="命令行-key-value方式"><a href="#命令行-key-value方式" class="headerlink" title="命令行-key/value方式"></a>命令行-key/value方式</h3><ul>
<li>范例：kubectl create configmap test-config3 –from-literal=name=yuanshuo –from-literal=age=23</li>
</ul>
<h2 id="使用ConfigMap"><a href="#使用ConfigMap" class="headerlink" title="使用ConfigMap"></a>使用ConfigMap</h2><ul>
<li>configMap主要被pod使用,必须在pod使用前创建ConfigMap</li>
<li>创建的pod使用envFrom读取configmap时，如果configmap中的某些key无效，则该环境变量不会注入容器，但是pod可以正常创建</li>
<li>只有通过k8s api创建的pod才能使用configmap，其他方式创建的pod(如manifest创建的static pod)不能使用configmap</li>
<li>pod只能使用在同一namespace下的ConfigMap</li>
</ul>
<p>范例使用的ConfigMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: special-config</span><br><span class="line">  namespace: default</span><br><span class="line">data:</span><br><span class="line">  special.how: very</span><br><span class="line">  special.type: charm</span><br></pre></td></tr></table></figure>
<h3 id="环境变量方式"><a href="#环境变量方式" class="headerlink" title="环境变量方式"></a>环境变量方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: special-env-pod</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-container  </span><br><span class="line">    image: busybox</span><br><span class="line">    # 使用$(VAR_NAME)方式引用变量</span><br><span class="line">    # command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(SPECIAL_TYPE)&quot;]</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(special.how)&quot;]</span><br><span class="line">    # 加载全部变量</span><br><span class="line">    envFrom: </span><br><span class="line">      - configMapRef:</span><br><span class="line">          name: special-config</span><br><span class="line">          optional: false</span><br><span class="line">    # 加载部分变量</span><br><span class="line">    # env: </span><br><span class="line">    #   - name: SPECIAL_HOW</span><br><span class="line">    #     valueFrom:</span><br><span class="line">    #       configMapKeyRef:</span><br><span class="line">    #         name: special-config</span><br><span class="line">    #         key: special.how</span><br><span class="line">    #   - name: SPECIAL_TYPE</span><br><span class="line">    #     valueFrom:</span><br><span class="line">    #       configMapKeyRef:</span><br><span class="line">    #         name: special-config</span><br><span class="line">    #         key: special.type</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
<h3 id="volume挂载方式"><a href="#volume挂载方式" class="headerlink" title="volume挂载方式"></a>volume挂载方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: spec-volume-pod</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-contaner1</span><br><span class="line">      image: busybox</span><br><span class="line">      # 文件名为key，文件内容为value</span><br><span class="line">      # command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /etc/config/special.how&quot;] </span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /etc/config/ok/special.how&quot;] </span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /etc/config </span><br><span class="line">  volumes: </span><br><span class="line">    - name: config-volume</span><br><span class="line">      configMap:</span><br><span class="line">        name: special-config</span><br><span class="line">        # 加载部分变量,只将special.how这个key挂载到/etc/config目录下的相对路径ok/special.how</span><br><span class="line">        items:</span><br><span class="line">          - key: special.how</span><br><span class="line">            path: ok/special.how </span><br><span class="line">  # 加载全部变量</span><br><span class="line">  # volumes: </span><br><span class="line">  #   - name: config-volume</span><br><span class="line">  #     configMap:</span><br><span class="line">  #       name: special-config</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
<h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>Secrete是在集群中存储密码、token等敏感信息的对象</li>
<li>secret的存储和打印格式均是base64编码的字符串，因此用户创建secret时也要提供此种编码格式的数据</li>
<li>Secret类型<ul>
<li>Opaque：一般密文类型【默认类型】</li>
<li>Kubernetes.io/service-account-token：集群身份认证【创建serviceaccount时自动创建】</li>
<li>kubernetes.io/tls：tls证书类型</li>
<li>kubernetes.io/dockerconfigjson：docker拉取私有仓库镜像时的认证信息</li>
<li>bootstrap.kubernetes.io/token：节点bootstrap初始化加入集群时的认证信息</li>
</ul>
</li>
</ul>
<h2 id="创建secret"><a href="#创建secret" class="headerlink" title="创建secret"></a>创建secret</h2><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>一般创建使用kubectl create命令创建opaque(generic)、tls、dockerregistry类型</p>
<ul>
<li>opaque-key/value形式：kubectl create secret generic mysecret –from-literal=username=hejingqi –from-literal=password=yuanshuo</li>
<li>opaque-文件形式：kubectl create secret generic ssh-key-secret –from-file=ssh-priviatekey=C:\Users\simple.ssh\gitee –from-file=ssh-publickey=C:\Users\simple.ssh\gitee.pub</li>
<li>dockerregistry创建：<code>kubectl create secret docker-registry aliyun-simple --docker-username=perfect@qq.com --docker-password=123456 --docker-server=registry.cn-hangzhou.aliyuncs.com</code></li>
<li>tls证书创建：<code>kubectl create secret tls k8s-ca --cert=&#39;ca.pem&#39; --key=&#39;ca-key.pem&#39;</code><h3 id="清单文件方式-1"><a href="#清单文件方式-1" class="headerlink" title="清单文件方式"></a>清单文件方式</h3></li>
</ul>
<p>一般用于创建opaque类型，核心参数如下：</p>
<ul>
<li>spec.data：key的value数据需要先进行base64编码</li>
<li>spec.stringData：key的value数据无需进行base64编码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret1</span><br><span class="line">  namespace: default</span><br><span class="line">type: Opaque</span><br><span class="line">stringData:</span><br><span class="line">  username: hejingqi</span><br><span class="line">  password: yuanshuo</span><br></pre></td></tr></table></figure>
<h2 id="使用secret"><a href="#使用secret" class="headerlink" title="使用secret"></a>使用secret</h2><p>和ConfigMap使用基本一致，但是由于使用环境变量方式时会存在信息泄露(容器继承、打印日志等方式)，所以基本上使用volume挂载方式</p>
<h3 id="Opaque类型"><a href="#Opaque类型" class="headerlink" title="Opaque类型"></a>Opaque类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - image: busybox</span><br><span class="line">      name: secret-container</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config&quot;]</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: ssh-key</span><br><span class="line">          mountPath: /etc/config</span><br><span class="line">          readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">    - name: ssh-key</span><br><span class="line">      secret:</span><br><span class="line">        secretName: ssh-key-secret</span><br></pre></td></tr></table></figure>
<h3 id="dockerconfigjson类型"><a href="#dockerconfigjson类型" class="headerlink" title="dockerconfigjson类型"></a>dockerconfigjson类型</h3><p>使用imagePullSecrets设置认证信息，使用方式如下：</p>
<ul>
<li>在ServiceAccount对象中定义imagePullSecrets，则所有使用该ServiceAccount的pod都能使用此认证信息</li>
<li>在pod中使用imagePullSecrets<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1 </span><br><span class="line">kind: Pod</span><br><span class="line">metadata:       </span><br><span class="line">  name: ssh-pod</span><br><span class="line">spec:</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: aliyun-simple</span><br><span class="line">  containers:</span><br><span class="line">  - name: ssh</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/simple/ubuntu14_sshd</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 22</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="应用程序动态更新配置"><a href="#应用程序动态更新配置" class="headerlink" title="应用程序动态更新配置"></a>应用程序动态更新配置</h1><blockquote>
<p>pod会周期性获取配置(configmap和secret)，但是要自行处理应用程序如何动态加载配置</p>
</blockquote>
<ul>
<li>应用程序监听本地配置文件变动，自行处理热加载</li>
<li>使用sidecar通过inotify机制监听配置文件变更，动态更新</li>
<li>与程序迭代更新一起滚动更新</li>
<li>【不使用k8s的configmap/secret】采用配置中心(如disconf、Apollo)</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>secret</tag>
        <tag>configMap</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用技巧</title>
    <url>/blog/2019/07/02/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="文件swap"><a href="#文件swap" class="headerlink" title="文件swap"></a>文件swap</h1><h2 id="创建空文件"><a href="#创建空文件" class="headerlink" title="创建空文件"></a>创建空文件</h2><ul>
<li>fallocate -l 4G /home/swapfile </li>
<li>truncate -s 4G /home/swapfile </li>
<li>dd if=/dev/zero of=/home/swapfile bs=8192 count=512k  </li>
</ul>
<h2 id="格式化与挂载"><a href="#格式化与挂载" class="headerlink" title="格式化与挂载"></a>格式化与挂载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 600 /home/swapfile</span><br><span class="line">mkswap /home/swapfile</span><br><span class="line">echo &quot;/home/swapfile none swap    sw              0       0&quot; &gt;&gt; /etc/fstab</span><br><span class="line">swapon -a</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>
<h1 id="ubuntu初始化"><a href="#ubuntu初始化" class="headerlink" title="ubuntu初始化"></a>ubuntu初始化</h1><ul>
<li>创建用户： useradd -s /bin/bash -mr -G sudo test  </li>
<li>安装常用软件： sudo apt-get install vim ntp htop tree lrzsz sysv-rc-conf -y</li>
<li>时间和时区设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service ntp start</span><br><span class="line">sysv-rc-conf ntp on</span><br><span class="line">ntpdate -u time1.aliyun.com</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure>
<ul>
<li>更改默认编辑器：update-alternatives –set editor /usr/bin/vim.basic</li>
<li>更改文件描述符大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;*   hard   nofile  65536&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &quot;*   soft   nofile  65536&quot; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<h1 id="批量删除小文件"><a href="#批量删除小文件" class="headerlink" title="批量删除小文件"></a>批量删除小文件</h1><ol>
<li>建立空目录：mkdir /tmp/blank</li>
<li>使用rsync删除： rsync –delete-before -d /tmp/blank/ /var/spool/postfix/maildrop/ </li>
<li>rsync解释：-d 只同步目录【不递归同步】 –delete-before 同步前删除相关文件</li>
</ol>
<h1 id="批量修改文件"><a href="#批量修改文件" class="headerlink" title="批量修改文件"></a>批量修改文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch &#123;a..g&#125;.html</span><br><span class="line">for file in $(ls);do mv $file $&#123;file/html/HTML&#125;;done</span><br></pre></td></tr></table></figure>
<h1 id="判断变量是否为数字"><a href="#判断变量是否为数字" class="headerlink" title="判断变量是否为数字"></a>判断变量是否为数字</h1><ul>
<li>grep过滤：<code>grep -E -w &quot;[0-9]+&quot;</code></li>
<li>expr相加：<code>expr $a + 1</code></li>
<li>变量删除：<code>${b//[0-9]/}</code></li>
</ul>
<h1 id="1-…-100求和"><a href="#1-…-100求和" class="headerlink" title="1+…+100求和"></a>1+…+100求和</h1><ul>
<li>shell下for循环：for((i=0;i&lt;=100;i++));do ((sum+=i));done;echo $sum</li>
<li>awk下for循环：awk 'BEGIN{{for(i=0;i<=100;i++)sum+=i}print sum}'< li>
<li>seq与bc：seq -s + 100|bc</li>
<li>seq与awk：seq 100|awk ‘{sum+=$0}END{print sum}’</li>
</=100;i++)sum+=i}print></li></ul>
<h1 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h1><ul>
<li>awk随机数：awk ‘BEGIN{srand();print rand()}’</li>
<li>uuid命令：uuidgen</li>
<li>md5命令：md5sum</li>
<li>openssl命令：openssl rand -base64 32</li>
</ul>
<h1 id="多主机全互联"><a href="#多主机全互联" class="headerlink" title="多主机全互联"></a><a href="https://github.com/simple0426/sysadm/tree/master/ansible/playbook/ssh_conn_all" target="_blank" rel="noopener">多主机全互联</a></h1><ol start="0">
<li><a href="https://github.com/simple0426/sysadm/blob/master/ansible/playbook/ssh_conn_all/create_user.yml" target="_blank" rel="noopener">通过root创建普通用户</a>，并把它加到sudo中；修改ansible hosts使用普通用户连接目标主机。</li>
<li>在目标主机产生秘钥： ansible all -m shell -a ‘ssh-keygen -t rsa -P “” -f ~/.ssh/id_rsa’ </li>
<li>将所有主机公钥取至本地： ansible all -m fetch -a “src=~/.ssh/id_rsa.pub dest=./tmp”  </li>
<li><a href="https://github.com/simple0426/sysadm/blob/master/ansible/playbook/ssh_conn_all/join_sshkey.py" target="_blank" rel="noopener">将所有公钥合并为一个文件</a>，并命名为authorized_keys</li>
<li>将authorized_keys传送至目标主机： ansible all -m copy -a “src=authorized_keys dest=~/.ssh/ mode=0600” </li>
<li>修改目标主机ssh客户端配置，使首次登录的用户没有yes/no的询问【可选】： ansible all -m lineinfile -a “path=/etc/ssh/ssh_config line=’\t\tStrictHostKeyChecking no’” -b </li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>swap</tag>
        <tag>ubuntu</tag>
        <tag>全互联</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令-查找替换</title>
    <url>/blog/2019/06/30/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E5%91%BD%E4%BB%A4-%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h1><ul>
<li><a href="#sed">sed</a></li>
<li><a href="#grep">grep</a></li>
<li><a href="#find">find</a></li>
<li>wc：统计字节数、字符数、单词数、行数</li>
<li><a href="#sort">sort</a></li>
</ul>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>默认以空白(空格、制表符等)为分隔符，默认以第一个字段的第一个字符排序，其他参数如下</p>
<ul>
<li>-u：删除重复的行</li>
<li>-f：忽略大小写</li>
<li>-b：忽略数据开始的空格部分</li>
<li>-r：反向排序【默认以字母从前往后排序】</li>
<li>-o：覆盖性输出【可直接覆盖源文档】</li>
<li>-n：按数字大小排序【默认从小到大】</li>
<li>-t：定义分隔符【只能使用单字符作为分隔符】</li>
<li>-k：指定开始和结束字段以及字段内的字符位置【与-t搭配使用】</li>
</ul>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>在指定的目录下搜索特定的文件，语法格式：find  path  option</p>
<h2 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h2><ul>
<li>-maxdepth n 最大查找深度【0为目录本身；1为当前目录下，依次类推；此选项需紧跟查找路径之后】</li>
<li>-name 按照文件名查找文件【iname忽略大小写】<ul>
<li>当name后使用通配符*时必须将匹配模式使用引号括起来或进行转义</li>
<li>find . -name ‘<em>.c’ -print 或 $ find . -name \</em>.c -print</li>
</ul>
</li>
<li>-size [±]n按大小匹配（大于、小于或等于n）<ul>
<li>find . -maxdepth 1 -size +5k</li>
</ul>
</li>
<li>-type c按照文件类型匹配（f、d、p、s、b、c、l）</li>
<li>-mtime [±]n按文件最后修改时间【以天计数】</li>
<li>-mmin [±]n按文件最后修改时间【以分钟计数】</li>
<li>-o 用于多个条件表达式的”或者”</li>
<li>-a 用于多个条件表达式的”同时” <ul>
<li>find / -type f -size +50k -a -size -55k 2&gt; /dev/null | xargs ls -lh | head -3</li>
<li>查找根目录下大于50k小于55k的文件</li>
</ul>
</li>
<li>! 逻辑取反<ul>
<li>find / -type f -size +50k -a ! -user root</li>
<li>查找根目录下大于50k且不属于root的文件</li>
</ul>
</li>
</ul>
<h2 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h2><h3 id="name的使用"><a href="#name的使用" class="headerlink" title="name的使用"></a>name的使用</h3><ul>
<li>表达式：find . -name *.log -mtime +60   </li>
<li>错误：paths must precede expression</li>
<li>原因：*在shell下会直接进行路径匹配</li>
<li>正确做法：find . -name ‘<em>.c’ -print 或 $ find . -name \</em>.c -print</li>
</ul>
<h3 id="与xargs的搭配"><a href="#与xargs的搭配" class="headerlink" title="与xargs的搭配"></a>与xargs的搭配</h3><p>find . -maxdepth 0 -type d -name “*8056” -mtime +119|xargs rm -rf {}</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><ul>
<li>功能：显示匹配特定模式的行</li>
<li>语法<ul>
<li>grep 选项 <code>[-e]</code> 模式匹配文本 待处理源文件</li>
<li>grep 选项  -f 模式匹配文件 待处理源文件</li>
</ul>
</li>
<li>数据源：grep可以从标准输入或文件中读取数据</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-E：使用扩展的正则表达式进行模式解析【等同于egrep，grep默认支持基本的正则】</li>
<li>-F：关闭正则表达式功能，等同于fgrep<ul>
<li>范例：<code>grep -F &quot;.*18159&quot; hosts</code>【匹配字符串<code>.*18159</code>】</li>
</ul>
</li>
<li>-e pattern：可以多次定义pattern，从而进行多次匹配</li>
<li>-f FILE：从文件中获取pattern，pattern文件每行定义一个pattern</li>
<li>-i：忽略大小写进行匹配</li>
<li>-v：反向匹配</li>
<li>-w：精确匹配单词（而不是目标的子集）</li>
<li>-x：精确匹配行（行内容完全相同）<ul>
<li>范例：<code>grep -x test1 hosts</code>【匹配行内容只有字符串”test1”内容的行】</li>
</ul>
</li>
<li>-c：显示匹配的行数</li>
<li>–color=auto：对匹配的内容突出颜色显示</li>
<li>-l：显示匹配到内容的文件名【常用于多文件搜索】</li>
<li>-q：静默输出【不输出任何内容】</li>
<li>-s：屏蔽错误输出</li>
<li>-h：匹配到内容时，行首不显示文件名【单文件默认不显示】</li>
<li>-H：匹配到内容时，行首显示文件名【多文件默认显示】</li>
<li>-n：显示行号</li>
<li>-A n：显示每个匹配行及相邻的后n行内容</li>
<li>-B n：显示每个匹配行及相邻的前n行内容</li>
<li>-C m,n：显示每个匹配行相邻的前m、后n行内容</li>
<li>-r：递归读取目录下的文件，但不包含链接</li>
<li>-R：递归读取目录下的文件，包含链接</li>
<li>–exclude=GLOB：跳过指定模式(掩码方式匹配)的文件，掩码可以是<code>* ? [..]</code>，<code>\</code>可以引用字面意思的掩码和通配符<ul>
<li>范例：<code>grep -r newpass group_vars/ --exclude=test*</code>【排除group_vars目录下test*文件】</li>
</ul>
</li>
<li>–exclude-from=FILE：跳过模式匹配文件FILE【和exclude一样，使用掩码方式】中匹配到的文件</li>
<li>–exclude-dir=DIR：从递归搜索中跳过指定模式的目录<ul>
<li>范例：<code>grep git roles/ -R --exclude-dir={bigdata,web}</code>【跳过roles目录下web、bigdata目录(忽略目录层级)】</li>
</ul>
</li>
<li>–include=GLOB：仅搜索指定模式的文件【和exclude一样，使用掩码方式】</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>0：搜索到匹配的内容</li>
<li>1：没有搜索到匹配的内容</li>
<li>2：搜索时发生错误【可使用-qs屏蔽错误及静默输出】</li>
</ul>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>含义：用于文本过滤和替换的流编辑器【输入数据源可以是文件或管道】</li>
<li>原理：sed把当前处理的行存在临时缓冲区【模式空间pattern space】中，一旦sed完成对模式空间的处理，模式空间中的行就被送到屏幕输出；行被处理完毕后，被模式空间移除，程序读入下一行进行处理</li>
<li>语法：sed <a href="命令选项">命令选项</a> ‘脚本(<a href="行选择">行选择</a>+<a href="#操作命令">操作命令</a>)’ 待操作源文件</li>
</ul>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-n 【–silent –quit】抑制模式空间(pattern space)自动输出，只显示匹配行的内容</li>
<li>-e 【–expression】script：添加命令将要执行的脚本文本【允许多次处理文本行】<ul>
<li>范例：<code>sed -e &#39;1,3d&#39; -e &#39;s/Hemenway/Jones/&#39; testfile</code>【删除1到3行后，替换Hemenway为Jones】</li>
</ul>
</li>
<li>-f 【–file】script-file：添加命令将要执行的脚本文件</li>
<li>-i<code>[suffix]</code> 【–in-place<code>[=suffix]</code>】：在模式空间中编辑文件，<ul>
<li>如果提供suffix后缀，则会使用suffix后缀对文件备份后再进行编辑</li>
</ul>
</li>
<li>-r【–regexp-extended】：在脚本中使用扩展的正则表达式</li>
<li>-u【-unbuffered】：从输入文件加载最少量的数据并更频繁地刷新输出缓冲区</li>
</ul>
<h2 id="sed脚本"><a href="#sed脚本" class="headerlink" title="sed脚本"></a>sed脚本</h2><h3 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h3><ul>
<li>没有行定位信息表示对所有输入行进行处理</li>
<li><code>!</code>用于地址【或地址范围】之后、命令之前，用于对不匹配的行进行操作</li>
<li>数字：仅匹配指定行号的内容【命令行-s选项会跨文件累加行号，此时不适用于行号匹配】</li>
<li>first~step：从first开始，每次显示第step行内容<ul>
<li>范例：sed -n 1~2p ：从第一行开始，只显示奇数行内容</li>
</ul>
</li>
<li>$：显示最后一行<ul>
<li>范例：seq 10|sed -n ‘3,$p’【显示第3行到末尾行的内容】</li>
</ul>
</li>
<li>/regexp/：匹配正则表达式匹配的行</li>
<li>\cregexpc：匹配正则表达式匹配的行：c可以是任意字符</li>
<li>以逗号分隔的2个地址【addr1,addr2】表示对2个地址之间的行进行处理<ul>
<li>addr1,addr2<ul>
<li>addr1会一直起作用，即使第addr2选择的行早于第1个</li>
<li>假如addr2是正则表达式，则不会对addr1匹配的行本身进行测试</li>
</ul>
</li>
<li>addr1,+N：将匹配addr1及以后的N行</li>
<li>addr1,~N：将匹配addr1及以后到N的倍数的行</li>
<li>0,addr1：addr1只能使用正则表达式，表示从第一行开始到匹配行的内容</li>
<li>1,addr1：addr1可以是任意形式地址，表示从第一行开始到匹配行的内容</li>
</ul>
</li>
</ul>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><blockquote>
<p><code>{ }</code>：一个命令块，命令之间以分号分隔</p>
</blockquote>
<ul>
<li>s/regexp/replacement/：使用replacement内容替换正则表达式匹配的内容，<ul>
<li>regexp分组后，replacement语句可以使用\1..\9进行分组引用【<code>sed -n &#39;/west/s/\(Charles\)/\1jingqi/p&#39; testfile</code>】</li>
<li>默认只替换第一个出现的字符串，使用g标志可对行内进行全部替换【s/regexp/replacement/g】</li>
<li>s后面的字符一定是分隔搜索字符串和替换字符串的分隔符，默认为斜杠；但是在s命令使用的情况下可以改变。不论什么字符紧跟着s命令都认为是新的分隔符。这个技术在搜索含斜杠的模板时非常有用</li>
<li>范例：sed -n ‘/west/s/Charles/jingqi/p’ testfile 【过滤包含west的行后，将Charles替换为jingqi，最后显示该行内容】</li>
</ul>
</li>
<li><code>&amp;</code>：引用替换命令【s/regexp/replacement/】中正则匹配到的部分<ul>
<li>范例：sed -n ‘/west/s/Charles/&amp;jingqi/p’ testfile 【将Charles替换为Charlesjingqi】</li>
<li>指定行注释：<code>sed -i &#39;s/restart/#&amp;/&#39; docker-compose.yml</code></li>
<li>不注释的行添加注释：<code>sed -i &#39;s/^[^#]/#&amp;/&#39; 1.txt</code></li>
</ul>
</li>
<li>a\ text 在文本行之后的新行添加内容</li>
<li>i\ text 在文本行之前的新行添加内容</li>
<li>c\ text：使用文本内容替换文本行</li>
<li>d：删除模式空间内容，开始下一个循环<ul>
<li>范例：seq 10|sed ‘3d’【删除第3行，其他行默认输出屏幕】</li>
</ul>
</li>
<li>D：如果模式空间不包含换行符，则和d一样；如果包含换行符，则删除到第一个换行符之间的内容，然后启动循环而不读取新的内容。</li>
<li>p：打印当前模式空间内容</li>
<li>P：打印模式空间第一个换行符之前的内容</li>
<li>= 打印当前行号</li>
<li>l：显示当前行内容【包含隐藏内容，如换行符】</li>
<li>l width：显示当前行内容，以指定行宽度显示【超过宽度的行被截断为新行】</li>
<li>n/N：读取或追加下一行内容到模式空间<ul>
<li>范例：<code>sed -n &#39;/^north /{n;s/central/ceshi/p}&#39; testfile</code>【定位到north 开始行的下一行，替换字符串后并显示】</li>
</ul>
</li>
<li>h/H：复制或追加模式空间内容到暂存区</li>
<li>g/G：使用暂存区内容替换模式空间内容，或在模式空间后追加暂存区内容</li>
<li>r filename：将从filename文件读取的全部行内容追加到文本行之后<ul>
<li>范例：<code>sed &#39;/^north/r update.txt&#39; testfile</code>【在以north开始的行后插入update.txt中的内容】</li>
</ul>
</li>
<li>R filename：将从filename文件读取的一行内容追加到文本行之后，每次从filename中读取的行内容为上次读取行的下一行</li>
<li>w filename：将模式空间内容写入filename文件<ul>
<li>范例：<code>sed -n &#39;/north/w newfile&#39; testfile</code>【将包含north的行写入newfile文件中，同时只显示包含north的行】</li>
</ul>
</li>
<li>W filename：将模式空间的第一行内容写入filename文件</li>
<li>x：交换模式空间和暂存区内容</li>
<li>y/source/dest/：将目标中出现的字符替换为源中存在的字符【不能使用正则表达式】</li>
<li>q：立即退出sed脚本而不处理新行，但如果没有禁用自动打印功能，则会输出模式空间内容<ul>
<li>范例：<code>sed &#39;2q&#39; testfile</code>【打印到第2行后退出脚本】</li>
</ul>
</li>
<li>Q：立即退出sed脚本而不处理新行</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>h与G：<code>sed -e &#39;/^western/h&#39; -e &#39;$G;w newfile&#39; testfile</code><ul>
<li>在第一个编辑模式中，将north开始的行从模式空间放入暂存区</li>
<li>在第二个编辑模式中，将暂存区中的内容追加到末尾行的模式空间，然后写入newfile中</li>
</ul>
</li>
<li>sed中使用shell：里层使用双引号，外层使用单引号<ul>
<li><code>sed -n &#39;/eastern/s/4.5/&#39;&quot;$(date +%F)&quot;&#39;/p&#39; testfile</code>：将4.5替换为当前时间</li>
<li><code>sed -n &#39;/eastern/s/Savage/&#39;&quot;$USER&quot;&#39;/p&#39; testfile</code>：将Savage替换为当前用户</li>
</ul>
</li>
<li>获取eth0网卡地址：<ul>
<li>sed：<code>ifconfig eth0|sed -n &#39;s/^.*addr:\(.*\)\sBcast.*$/\1/p&#39;</code></li>
<li>awk：<code>ifconfig eth0|awk -F &#39;[: ]+&#39; &#39;/inet/{print $4}&#39;</code></li>
</ul>
</li>
<li><p>文本修改：将文本中的ver版本号替换为2.0.16，filename版本号替换为2.0.17_40</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Data ver=&quot;2.0.16&quot; filenName=&quot;feng1_360_HD_2.0.15_39.apk&quot;</span><br><span class="line">Down ver=&quot;2.0.16&quot; filenName=&quot;feng2_360_HD_2.0.15_39.apk&quot;</span><br><span class="line">Data ver=&quot;2.0.14&quot; filenName=&quot;feng3_360_HD_2.0.14_38.apk&quot;</span><br><span class="line">Data ver=&quot;2.0.13&quot; filenName=&quot;feng4_360_HD_2.0.16_40.apk&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>sed方法：<code>sed -i-bak &#39;s/2.0..*\&quot; /2.0.16\&quot; /;s/HD_.*\./HD_2.0.17_40./&#39; 360test_apk.xml</code></li>
<li>awk方法：<code>awk &#39;{gsub(&quot;\&quot;2.0.[0-9][0-9]&quot;,&quot;\&quot;2.0.16&quot;);gsub(&quot;HD_2.0.1[0-9]_[0-9][0-9]&quot;, &quot;2.0.17_40&quot;);print}&#39; 360test_apk.xml</code></li>
</ul>
</li>
<li><p>文本修改：将文本1修改为文本2</p>
<ul>
<li><p>文本1：【修改前】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;Firest web&lt;/title&gt;</span><br><span class="line">&lt;body&gt;Hello the World&lt;body&gt;</span><br><span class="line">h1helloh1</span><br><span class="line">h2helloh2</span><br><span class="line">h3helloh3</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文本2：【修改前】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;Firest web&lt;/title&gt;</span><br><span class="line">&lt;body&gt;Hello the World&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;hello&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;hello&lt;/h3&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令：<code>sed &#39;s/^\(h[123]\)/&lt;\1&gt;/;s#\(h[123]\)$#&lt;/\1&gt;#&#39; test.txt</code></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>find</tag>
        <tag>sort</tag>
        <tag>grep</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统-文件管理</title>
    <url>/blog/2019/08/27/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>cat：显示文件内容<ul>
<li>-n：显示行号</li>
<li>-b：忽略空白行，显示行号</li>
<li>-A：显示所有非打印字符【比如tab、换行符等】</li>
</ul>
</li>
<li><a href="#ls">ls</a>：显示目录内容</li>
<li>ln：在文件之间建立链接<ul>
<li>无参数时建立硬链接</li>
<li>-s：建立软连接</li>
</ul>
</li>
<li>pwd：显示当前绝对路径</li>
<li>cd：切换目录</li>
<li>mv：移动或重命名文件/目录</li>
<li>rm：删除文件或目录<ul>
<li>-r：递归删除目录及其内容</li>
<li>-f：强制删除不提示</li>
</ul>
</li>
<li><a href="#cp">cp</a>：复制文件和目录</li>
<li>touch：改变文件时间戳，没有则创建</li>
<li>mkdir：创建目录<ul>
<li>-p 存在不报错，根据需要创建父目录</li>
</ul>
</li>
<li><a href="#tar">tar</a>：建立归档文件</li>
<li><a href="#zip">zip、unzip</a>：压缩文件</li>
<li><a href="#gzip">gzip、gunzip</a>：打包、压缩文件或目录</li>
<li>dos2unix/unix2dos：windows与unix文件格式转换</li>
<li>tree：树形态查看目录结构</li>
<li>file：查看文件类型【文件类型可以是：链接、二进制、可执行等】</li>
<li>stat：查看文件状态【包含属主组、权限、大小、inode、block、时间戳等】</li>
<li><a href="#dd">dd</a>：用指定大小的块复制文件</li>
<li>diff：显示两个文件之间的差异</li>
<li><a href="#du">du</a>：显示文件占用磁盘空间大小</li>
<li><a href="#df">df</a>：显示磁盘空间使用情况</li>
<li><a href="#fdisk">fdisk</a>：MBR分区工具</li>
<li><a href="#parted">parted</a>：GPT分区工具</li>
<li><a href="#mount">mount</a>：文件系统挂载</li>
<li>fsck、e2fsck：文件系统检查与修复</li>
<li>badblocks：检查磁盘是否有坏道（等同于mke2fs -c）</li>
<li>dumpe2fs：显示分区superblock和blocks group信息</li>
<li>格式化：<ul>
<li>格式化主分区(建立文件系统)-mkfs：(mkfs –t 分区类型/mkfs.分区类型)  /dev/sdb1(设备)</li>
<li>格式化交互分区(建立swap)-mkswap：mkswap  /dev/sdb5(设备)<ul>
<li>启用交互分区：swapon (-a 所有) /dev/sdb5 </li>
<li>关闭交互分区：swapoff (-a 所有) /dev/sdb5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>if=文件名：输入文件名</li>
<li>of=文件名：输出文件名</li>
<li>bs=bytes：同时设置输入/输出的块大小【默认bytes，可选单位(k)K/M/G】<ul>
<li>ibs：输入块大小</li>
<li>obs：输出块大小</li>
</ul>
</li>
<li>count=blocks：复制的块个数</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>备份磁盘：dd if=/dev/hdb of=/dev/hdd</li>
<li>备份MBR【磁盘的前512个字节】：dd if=/dev/hda of=/root/image count=1 bs=512</li>
<li>建立swap分区【使用0字符建立空文件】<ul>
<li>建立空文件：dd if=/dev/zero of=/home/swap bs=1024M count=2</li>
<li>格式化：mkswap /home/swapfile</li>
<li>挂载交互分区：swapon /home/swapfile</li>
</ul>
</li>
<li>销毁磁盘【使用随机字符覆盖数据】：dd if=/dev/urandom of=/dev/hda1</li>
<li>磁盘读速度测试：dd if=/ceshi.txt of=/dev/null bs=512 count=1000<ul>
<li>/dev/null为空设备，可以看作黑洞，向/dev/null写入的内容会被立即丢弃</li>
</ul>
</li>
<li>磁盘写速度测试：dd if=/dev/zero of=/ceshi.txt  bs=512 count=1000<ul>
<li>/dev/zero可以提供无穷无尽的0【二进制0流】</li>
</ul>
</li>
</ul>
<h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-l：以较长格式显示信息</li>
<li>-a：显示目录下的全部文件，包含以“.”开始的隐藏条目</li>
<li>-t：以最后修改时间【mtime】进行排序</li>
<li>-r：反向排序</li>
<li>-R：递归列出子目录</li>
<li>-F：在条目后加上文件类型指示符【*/=&gt;@|】<ul>
<li>“/”：目录</li>
<li>“@”：符号链接</li>
<li>“*”：可执行程序</li>
<li>“=”：套接字</li>
<li>“|”：FIFOS</li>
</ul>
</li>
<li>-i：显示inode信息</li>
<li>-d：显示目录本身而非其子目录的属性，并且不跟随符号链接</li>
<li>-s：根据文件大小排序</li>
<li>-1：每行一个文件名</li>
<li>-X：根据扩展名排序</li>
</ul>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><ul>
<li>统计文件数量：ls -lR|grep ‘^-‘|wc -l </li>
</ul>
<h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><ul>
<li>-a：复合参数，相当于-dR –preserve=all</li>
<li>-d：不跟随符号链接，保持链接属性</li>
<li>-p：保持权限、属主、时间戳</li>
<li>-r、-R：递归复制文件、目录</li>
<li>-f：强制覆盖</li>
<li>-i：覆盖操作时交互式提醒【shell下cp命令默认为cp -i】</li>
<li>-s：建立软链接</li>
<li>-l：建立硬链接</li>
</ul>
<h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><blockquote>
<p>gzip只压缩文件<br>gunzip是shell脚本（内容就是gzip -d）</p>
</blockquote>
<ul>
<li>gzip压缩或解压时，不保留源文件</li>
<li>默认，gzip压缩保持文件名和时间戳</li>
<li>-d：解压数据</li>
<li>-f：强制压缩或解压</li>
<li>-N：解压时保持原有文件名和时间戳</li>
<li>-q：取消所有警告信息</li>
<li>-r：递归的处理目录【进入目录，然后压缩或解压文件】</li>
<li>-t：检测压缩文件的完整性</li>
<li>-c：压缩内容到标准输出，或解压内容到标准输出<ul>
<li>范例：压缩并保留源文件：gzip -c 1.txt &gt; 1.gz</li>
</ul>
</li>
</ul>
<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><blockquote>
<p>打包、压缩文件或目录</p>
</blockquote>
<ul>
<li>语法：zip 选项 压缩文件名 输入路径1 输入路径2 。。。</li>
<li>压缩文件名：可以是新的或已经存在的<ul>
<li>如果是已存在的文件，zip将替换压缩文件中已存在的条目或向压缩文件中添加不存在的条目</li>
<li>压缩文件名可以不含zip后缀【默认添加】</li>
<li>范例1：持续向压缩文件添加内容：find . -maxdepth 1 -name “*.conf”|xargs -I {} zip conf {}</li>
<li>范例2：压缩当前目录：<ul>
<li>不包含隐藏内容：<code>zip aa *</code></li>
<li>包含隐藏内容：<code>zip aa * .*</code></li>
</ul>
</li>
</ul>
</li>
<li>输入路径：可以是文件或目录，同时也可以使用通配符</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-r/–recurse-paths：压缩目录下的内容</li>
<li>-P/–password password：压缩时加密【非交互式】</li>
<li>-e/–encrypt：压缩时加密【交互式】</li>
<li>-i/–include：包含某些文件<ul>
<li>范例：<code>zip -r test test -i test/*.txt</code></li>
</ul>
</li>
<li>-x/–exclude：不包含某些文件</li>
<li>-j/–junk-paths：不包含路径【默认也打包路径】</li>
<li>-m/–move：移动后打包文件【相当于删除源文档】</li>
<li>-T/–test：测试压缩包完整性</li>
<li>-q/–quiet：安静模式【shell脚本】</li>
<li>-n【0-9】：压缩级别【默认6，9表示压缩级别最高，压缩后文件最小】</li>
<li>-sf：查看压缩文件包含的文件列表</li>
</ul>
<h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><ul>
<li>-d：解压到指定目录</li>
<li>-P：使用指定密码解压</li>
<li>-q：静默模式</li>
</ul>
<h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><blockquote>
<p>打包多个文件或目录到一个归档文件</p>
</blockquote>
<ul>
<li>-c：创建新的归档文件</li>
<li>-r：向归档文件末尾添加文件</li>
<li>-t：显示归档文件包含的文件列表</li>
<li>-x：从归档文件中提取文件</li>
<li>-C：切换到目录【打包的源路径、解压的目标路径】<ul>
<li>范例：tar xzf conf.tar.gz -C ../conf/</li>
</ul>
</li>
<li>-f：指定归档文件名【其后不加其他参数名】</li>
<li>-j：使用bzip2进行文件压缩、解压工作</li>
<li>-J：使用xz进行文件压缩解压工作<ul>
<li>tar cJvf conf.xz *</li>
</ul>
</li>
<li>-g：使用gzip进行文件压缩解压工作</li>
<li>-p：保持文件属性</li>
<li>-v：显示操作过程</li>
<li>-h：跟随软链接，打包真实数据</li>
<li>-X, –exclude-from=FILE</li>
<li>–exclude=PATTERN【与rsync类似】<ul>
<li>范例：<code>tar czvf conf.tar.gz * --exclude &quot;10-*&quot;</code></li>
</ul>
</li>
</ul>
<h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><blockquote>
<p>统计文件系统的磁盘空间(block)和inode使用情况</p>
</blockquote>
<ul>
<li>-h：以可理解的换算单位输出文件系统占用磁盘情况</li>
<li>-i：显示inode使用情况</li>
<li>-t：显示指定类型文件系统使用情况【ext4、iso9660等】</li>
<li>-x：排除指定类型的文件系统</li>
<li>-T：显示文件系统类型</li>
</ul>
<h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><blockquote>
<p>统计文件占用磁盘空间大小</p>
</blockquote>
<ul>
<li>-a：显示目录下所有文件大小【默认以k为单位】</li>
<li>-s：统计目录大小</li>
<li>-h：单位换算显示：du -sh backup/</li>
</ul>
<h1 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h1><ul>
<li>fdisk -l：查看磁盘分区情况</li>
<li>fdisk /dev/sda：磁盘分区<ul>
<li>n：新建</li>
<li>p：主分区</li>
<li>t：查看分区表</li>
<li>w：将变动写入分区表</li>
<li>q：退出</li>
<li>d：删除分区</li>
</ul>
</li>
</ul>
<h1 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h1><h2 id="分区形式"><a href="#分区形式" class="headerlink" title="分区形式"></a>分区形式</h2><table>
<thead>
<tr>
<th>项目</th>
<th>MBR</th>
<th>GPT</th>
</tr>
</thead>
<tbody>
<tr>
<td>全称</td>
<td>Master boot record【主引导记录】</td>
<td>Guid partion table【全局唯一标示符分区表】</td>
</tr>
<tr>
<td>容量限制</td>
<td>磁盘或分区最大支持2T</td>
<td>大于2T</td>
</tr>
<tr>
<td>分区数</td>
<td>最多四个主分区或扩展分区</td>
<td>分区数无限制【操作系统限制】</td>
</tr>
<tr>
<td>常用命令</td>
<td>fdisk</td>
<td>parted</td>
</tr>
<tr>
<td>特点</td>
<td>Fdisk：分区后保存写入分区表</td>
<td>Parted：分区实时写入分区表</td>
</tr>
</tbody>
</table>
<h2 id="分区形式转换"><a href="#分区形式转换" class="headerlink" title="分区形式转换"></a>分区形式转换</h2><ul>
<li>转换为GPT：parted  /dev/sda mklabel gpt</li>
<li>转换为MBR：parted  /dev/sda mklabel msdos</li>
</ul>
<h2 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h2><ul>
<li>建立分区：parted /dev/sdb mkpart primary ext4 1 50【命令+磁盘+操作类型+分区类型+文件系统类型+分区起始(M为单位)+分区结束】</li>
<li>查看分区：parted –l /dev/sdb</li>
<li>删除分区：parted /dev/sdb rm 2</li>
</ul>
<h1 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h1><ul>
<li>标准语法：mount -t type -o option device dir<ul>
<li>范例：mount  -o  loop  iso文件  目录</li>
</ul>
</li>
<li>其他语法：<ul>
<li>简单语法：mount device/dir：挂载fstab已存在的设备</li>
<li>挂载目录：mount –bind olddir newdir：挂载一个目录到另一个目录</li>
<li>卸载：umount 设备/目录【在fstab中配置后也可以卸载目录】</li>
</ul>
</li>
<li>文件系统类型【-t】<ul>
<li>ext2/3/4</li>
<li>iso9660：iso文件</li>
<li>vfat：U盘</li>
<li>nfs</li>
<li>cifs：samba文件系统</li>
</ul>
</li>
<li>挂载选项【-o】<ul>
<li>rw/ro   读写、只读</li>
<li>async/sync  异步、同步</li>
<li>remount 重新挂载</li>
<li>user/password    用户名、密码</li>
<li>exec/noexec 二进制程序的可执行权限</li>
<li>suid/nosuid 二进制程序的suid权限</li>
<li>dev/nodev   设备文件的特殊属性</li>
<li>diratime/nodiratime 目录的访问时间</li>
<li>atime/noatime   文件的访问时间</li>
<li>hard/soft   硬挂载【持续呼叫至成功】软挂载【超时后呼叫挂载】</li>
<li>intr    持续挂载时允许中断</li>
<li>rsize/wsize 一次写的块大小，一次读的块大小</li>
<li>bg/fg   背景执行、前景执行</li>
</ul>
</li>
<li>自动挂载【编辑/etc/fstab】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/kernel.iso   /iso       iso9660  defaults,loop      0 0</span><br><span class="line">/dev/sdb1   /sdb/sdb1  ext4     defaults          0 0</span><br><span class="line">/dev/sdb5   swap      swap    defaults          0 0</span><br><span class="line">设备     挂载目录  文件类型  默认规则   dup转储/系统扫描（1是0非）</span><br><span class="line">设备可以是UUID(由命令blkid产生)【如UUID=8a184dfc-5944-4552-ae89-d3a050c45997】，</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统-进程管理</title>
    <url>/blog/2019/08/06/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="命令目录"><a href="#命令目录" class="headerlink" title="命令目录"></a>命令目录</h1><ul>
<li><a href="#kill">kill</a>：向进程发送信号</li>
<li>pkill、killall、pgrep：根据进程名称过滤进程id或杀死进程【可能有误、不建议使用】</li>
<li><a href="#ps">ps</a>：查看进程状态的最近一个快照</li>
<li>fuser：显示打开文件或socket的进程</li>
<li><a href="#nohup">nohup</a>：运行一个免于挂起的命令，同时输出到非tty终端</li>
<li><a href="#任务模式">jobs、fg</a></li>
<li><a href="#lsof">lsof</a>：进程打开的文件</li>
<li>top、htop：实时查看进程状态</li>
</ul>
<h1 id="进程信号"><a href="#进程信号" class="headerlink" title="进程信号"></a>进程信号</h1><ul>
<li>1(HUP)： 重启</li>
<li>2(INT) ：中断【ctrl+c】</li>
<li>3(QUIT)： 退出</li>
<li>9(KILL) ：强制终止</li>
<li>15(TERM) ：正常结束【kill默认信号】</li>
<li>17(STOP) ：停止程序运行【ctrl+z】</li>
<li>19(CONT)： 停止的程序继续运行</li>
</ul>
<h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><ul>
<li>终止进程：kill pid</li>
<li>强制终止：kill -9 pid</li>
<li>重启进程：kill -HUP pid</li>
</ul>
<h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>list open file  列出打开的文件，文件可以是普通文件、目录、链接、字符设备、块设备、FIFO设备、socket</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><blockquote>
<p>没有任何选项时，lsof默认显示所有活跃进程打开的文件</p>
</blockquote>
<ul>
<li><code>-a</code>：指明所有选项之间逻辑“与”关系【默认“或”关系】</li>
<li>-c <code>^</code> c：进程执行的命令(不)是以c开头的，c可以是正则表达式【以<code>//</code>进行包围】</li>
<li>-r t：周期性的显示输出信息【t定义时间间隔，默认15s】</li>
<li>-u <code>^</code> uid：(不)属于某个登录名或id的用户，多个用户之间逗号分隔</li>
<li>-p <code>^</code> pid：(不)属于某个进程的</li>
<li>-i 地址：选择与internet地址匹配的文件列表：<ul>
<li>地址：<code>[46][protocol][@hostname|hostaddr][:service|port]</code></li>
<li>protocol：传输层协议tcp/udp</li>
<li>hostname、hostaddr：主机名、ip地址</li>
<li>service：应用层协议(如smtp)、端口号</li>
<li>范例：lsof -i tcp@ops:ssh</li>
</ul>
</li>
<li>-t：只输出符合要求的进程pid</li>
<li>-X：不关联TCP、UDP的文件<ul>
<li>范例：lsof -p 22929 -X</li>
</ul>
</li>
<li>-s <code>^</code> <code>[p:s]</code>：(不)属于某个tcp、udp协议状态(如established)的<ul>
<li>范例：lsof -a -i tcp -s tcp:established -c nginx【查看nginx并发连接】</li>
</ul>
</li>
<li>–：表示选项的的结束，在文件名中包含“-”时有用</li>
<li>file-names：列出打开文件的进程</li>
</ul>
<h1 id="任务模式"><a href="#任务模式" class="headerlink" title="任务模式"></a>任务模式</h1><ul>
<li>cmd&amp;：将命令以”任务“方式放入后台执行</li>
<li>jobs：查看后台运行的任务</li>
<li>fg number：将后台任务调入前台执行</li>
</ul>
<h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><ul>
<li>由于cmd&amp;方式产生的进程父id为tty或pts终端shell，当用户注销或网络断开时，终端会收到HUP（hangup）信号从而关闭其所有子进程</li>
<li>nohup不接收HUP信号，同时输出内容到非tty终端，因此可以使用【nohup cmd &amp;】方式将命令放入后台长期运行</li>
</ul>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><ul>
<li>功能：显示当前的进程状态【whatis ps】</li>
<li>用法：【man ps】、【ps –help all】</li>
<li>常用组合<ul>
<li><a href="#ef格式详解">ps -ef</a></li>
<li><a href="#aux格式详解">ps -aux</a></li>
</ul>
</li>
</ul>
<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ul>
<li>-A：显示所有进程</li>
<li>-a：显示所有终端下的进程</li>
<li>-r：显示正在运行的进程</li>
<li>-x：与a搭配使用，显示较完整的进程信息</li>
<li>-h：不显示header信息</li>
<li>-e：命令后显示环境变量</li>
<li>-f：全格式</li>
<li>-l：长格式</li>
</ul>
<h2 id="ef格式详解"><a href="#ef格式详解" class="headerlink" title="ef格式详解"></a>ef格式详解</h2><ul>
<li>UID：用户ID       </li>
<li>PID：进程ID</li>
<li>PPID：父进程ID</li>
<li>C：进程占用CPU的百分比</li>
<li>STIME：进程启动的时间</li>
<li>TTY：该进程在哪个终端上运行，若与终端无关，则显示？若为pts/0等，则表示由网络连接主机进程         </li>
<li>TIME：该进程实际使用CPU运行的时间</li>
<li>CMD：命令的名称和参数</li>
</ul>
<h2 id="aux格式详解"><a href="#aux格式详解" class="headerlink" title="aux格式详解"></a>aux格式详解</h2><ul>
<li>USER：用户名</li>
<li>PID：进程ID</li>
<li>%CPU：cpu使用率</li>
<li>%MEM：内存使用率</li>
<li>VSZ：该进程使用的虚拟内存量（KB）</li>
<li>RSS：该进程占用的固定内存量（KB）</li>
<li>TTY：该进程在哪个终端上运行，若与终端无关，则显示？若为pts/0等，则表示由网络连接主机进程</li>
<li>STAT：进程状态</li>
<li>START：进程开始的时间</li>
<li>TIME：进程实际占用cpu的时间</li>
<li>COMMAND：进程使用的命令</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>runnable（on run queue）运行</td>
<td>正在运行或在运行队列中等待</td>
</tr>
<tr>
<td>S</td>
<td>sleeping休眠中</td>
<td>休眠中，受阻，在等待某个条件的形成或接受到信号</td>
</tr>
<tr>
<td>D</td>
<td>uninterruptible sleep (usually IO)不可中断</td>
<td>收到信号不唤醒和不可运行，进程必须等待直到有中断发生</td>
</tr>
<tr>
<td>T</td>
<td>stopped停止</td>
<td>进程收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU信号后停止运行</td>
</tr>
<tr>
<td>Z</td>
<td>zombie僵死</td>
<td>进程已终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放</td>
</tr>
<tr>
<td>s</td>
<td>进程下有子进程</td>
<td>-</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
<td>-</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>位于后台的进程</td>
<td>-</td>
</tr>
<tr>
<td>l</td>
<td>多线程</td>
<td>-</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kill</tag>
        <tag>ps</tag>
        <tag>nohup</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统-网络管理</title>
    <url>/blog/2019/07/17/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h1><ul>
<li>tcpdump<ul>
<li>-i eth0：指定监听的网络接口</li>
<li>tcp port 3306：监听本机tcp协议3306端口</li>
<li>icmp：监听icmp协议</li>
<li>ip host 192.168.100.2：监听指定来源的主机</li>
<li>-t：不显示时间戳</li>
<li>-n：补办ip解析成域名</li>
<li>-nn：不把端口转换成对应的协议</li>
<li>-c：只抓取多少行数据</li>
<li>dst：指定数据流向【到本机还是离开本机】<ul>
<li>范例：tcpdump -i eth1 -tnn dst port 80 -c 100</li>
</ul>
</li>
</ul>
</li>
<li>ping：测试网络连通性</li>
<li>traceroute：路由追踪</li>
<li>nslookup：域名解析【ip与mac对应关系】<ul>
<li>dns设置：/etc/resolv.conf </li>
</ul>
</li>
<li>arp：地址解析协议</li>
<li><a href="#curl">curl</a></li>
<li><a href="#iptables">iptables</a></li>
<li><a href="#firewalld">firewalld</a></li>
<li><a href="#tcp-wrapper">tcp_wrapper</a></li>
<li>netstat：显示网络链接<ul>
<li>-a：显示所有链接状态</li>
<li>-n：以数字形式显示ip和端口</li>
<li>-u：显示udp链接</li>
<li>-t：显示tcp链接</li>
<li>-p：显示建立链接的进程信息【PID】</li>
</ul>
</li>
<li><a href="#ifconfig">ifconfig</a>：查看或临时设置网卡信息</li>
<li>ethtool：查看网口信息</li>
<li><a href="#route">route</a>：查看或临时设置路由信息</li>
<li>iftop</li>
<li><a href="#wget">wget</a></li>
<li><a href="#nc">nc</a></li>
<li>nmap</li>
</ul>
<h1 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h1><blockquote>
<p>永久修改网卡信息：/etc/sysconfig/network-scripts/ifcfg-eth0</p>
</blockquote>
<ul>
<li>ifconfig：查看处于开启状态的网卡信息</li>
<li>ifconfig -a：查看所有状态的网卡信息【包含down状态】</li>
<li>设置网卡：<ul>
<li>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</li>
<li>ifconfig eth0 192.168.1.1/24</li>
</ul>
</li>
<li>添加虚拟网卡：Ifconfig eth0:0 192.168.20.1/24</li>
<li>打开或关闭网卡：ifconfig eth0 up/down<ul>
<li>启用/禁用网络接口：ifup/ifdown eth0</li>
</ul>
</li>
</ul>
<h1 id="route"><a href="#route" class="headerlink" title="route"></a>route</h1><ul>
<li>查看路由表：route –n </li>
<li>添加默认网关：route add default gw 192.168.1.1 </li>
<li>删除默认网关：route del default gw 192.168.1.1 </li>
<li>添加默认路由(下一跳)：route add –net 10.0.0.0 netmask 255.0.0.0 gw 192.168.30.254 </li>
<li>添加默认路由(本地出口)：route add –net 10.0.0.0 netmask 255.0.0.0   dev eth0</li>
<li>添加主机路由(本地出口)：route add –host 11.22.22.3 dev eth0 </li>
<li>添加主机路由(下一跳)：route add –host 1.2.3.4 gw 192.168.30.254 </li>
<li>删除默认路由：route del –net 10.0.0.0 netmask 255.0.0.0 gw 192.168.30.254 </li>
<li>删除默认路由：route del –net 10.0.0.0 netmask 255.0.0.0 dev eth0</li>
</ul>
<h1 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h1><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><ul>
<li>-o filename：下载文件并另存为</li>
<li>-O 下载文件并保持文件名</li>
<li>-L, –location 跟踪重定向</li>
<li>-c –cookie-jar FILE将服务器发送的cookie保存到文件中：<code>curl -c cookie.txt -s https://www.linuxidc.com</code></li>
<li>-I 只显示header信息：<code>curl -s -I http://www.baidu.com</code></li>
<li>-s –silent静默输出</li>
<li>-w 显示特定变量的信息【变量参考<code>man curl</code>】：<code>curl -o /dev/null -s -w &quot;%{http_code}&quot; www.baidu.com</code></li>
</ul>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><ul>
<li><p>-X, –request 指定请求方法【默认get】</p>
</li>
<li><p>-d/–data 指定post请求数据：<code>curl -X POST --data &#39;{&quot;message&quot;: &quot;01&quot;, &quot;pageIndex&quot;: &quot;1&quot;}&#39; http://127.0.0.1:5000/python</code></p>
</li>
<li><p>-H/–header 指定要发送的header信息：<code>curl -H &quot;Content-Type: application/json&quot; -X POST  --data &#39;{&quot;userID&quot;:10001}&#39; http://localhost:8085/GetUserInfo</code></p>
</li>
<li><p>-A 指定user-agent信息：<code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; -o page.html  https://www.linuxidc.com</code></p>
</li>
<li><p>-b, –cookie STRING/FILE 指定发送请求时要发送的cookie文件或字符串：<code>curl -b &#39;a=1;b=2&#39; https://www.linuxidc.com</code></p>
</li>
<li><p>-e, –referer指定上次访问的页面【可用于盗链】:<code>curl -o test.jpg -e http://oldboy.blog.51cto.com/2561410/1009292 http://img1.51cto.com/attachment/201209/155625967.jpg</code></p>
</li>
<li><p>-x, –proxy [protocol://]host[:port] 使用代理服务器：<code>--proxy http://127.0.0.1:10809</code></p>
</li>
<li><p>-g, –globoff 允许在URL中使用<code>[] {}</code>表示范围：<code>curl -g &quot;localhost:9200/bank/_search?q=age:%20[22%20TO%2025]&amp;pretty&quot;</code></p>
</li>
</ul>
<h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><p>netcat是一个用于TCP/UDP连接和监听的工具,nc是开源版本的netcat工具</p>
<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ul>
<li>-l：开启监听模式</li>
<li>-p：nc使用的源端口</li>
<li>-s：发送数据使用的接口ip</li>
<li>-n：不要使用DNS反向查询IP地址的域名</li>
<li>-u：使用udp协议</li>
<li>-w：设置超时时间</li>
<li>-v：设置详情输出</li>
<li>-z：扫描时不发送任何数据</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="监听和连接"><a href="#监听和连接" class="headerlink" title="监听和连接"></a>监听和连接</h3><ul>
<li>服务端：nc -l 1234</li>
<li>udp服务端：nc -ul 2345</li>
<li>客户端(可用于测试服务端口是否开启)：nc 127.0.0.1 1234</li>
</ul>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><ul>
<li>服务端：nc -l 1234 &gt; filename.out</li>
<li>客户端：nc host.example.com 1234 &lt; filename.in</li>
</ul>
<h4 id="文本传输"><a href="#文本传输" class="headerlink" title="文本传输"></a>文本传输</h4><ul>
<li>与web服务器通信：printf “GET / HTTP/1.0\r\n\r\n” | nc host.example.com 80</li>
<li>与snmp服务器通信：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc [-C] localhost 25 &lt;&lt; EOF</span><br><span class="line">HELO host.example.com</span><br><span class="line">MAIL FROM:&lt;user@host.example.com&gt;</span><br><span class="line">RCPT TO:&lt;user2@host.example.com&gt;</span><br><span class="line">DATA</span><br><span class="line">Body of email.</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ul>
<li>范围扫描：nc -zv host.example.com 20-30</li>
<li>列表扫描：nc -zv host.example.com 80 20 22</li>
</ul>
<h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1><p>非交互式网络下载器，wget支持https、http、ftp下载</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-O：另存为其他文件</li>
<li>-b：后台执行【查看下载进度：tail -f wget-log】</li>
<li>-c：支持断点续传</li>
<li>-i file：从文件中读取下载地址【一行一个】</li>
<li>–limit-rate： 限速【1M=限速1MB/s】</li>
<li>–spider：像spider一样只测试文件是否存在，而不是真正下载</li>
<li>–user-agent=agent-string：设置浏览器代理</li>
<li>–ftp-user/–ftp-password：ftp下载选项</li>
<li>–http-user/–http-password：http下载选项</li>
<li>–proxy-user=user/–proxy-password=password：proxy选项设置</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p><code>wget -b -c --limit-rate=300K https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.10.0/docker-compose-Linux-x86_64 -O docker-compose.box</code></p>
<h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><ul>
<li>iptables是一个用于ipv4/ipv6包过滤和地址转换的管理工具</li>
<li>iptables语法主要由路由表、规则链、匹配规则、执行动作构成</li>
<li>iptables语法：iptables (-t 路由表) (<a href="#规则操作">规则操作</a> 规则链) (<a href="#功能参数">功能参数</a>) (<a href="#匹配规则">匹配规则</a>)  (-j <a href="#执行动作">执行动作</a>) </li>
</ul>
<h2 id="表和链"><a href="#表和链" class="headerlink" title="表和链"></a>表和链</h2><p>iptables包含4个表和5个链，路由表是对数据包的不同类型的操作，规则链是在处理流程中的不同时间点进行的操作<br><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/iptables-tables-chains.gif" alt></p>
<ul>
<li>路由表：优先级：raw &gt; mangle &gt; nat &gt; filter<ul>
<li>filter：一般的主机过滤功能，默认表</li>
<li>nat：一般用于网络地址转换（nat）</li>
<li>mangle：主要负责修改数据包中特殊的路由标记，如TTL、TOS、MARK等</li>
<li>raw，优先级最高，设置raw一般是为了不再让iptables做数据包的链接追踪处理，提高性能</li>
</ul>
</li>
<li>规则链<ul>
<li>PREROUTING：数据包进入路由表之前</li>
<li>INPUT：通过路由表后目的地为本机</li>
<li>FORWARD：通过路由表，目的地不是本机</li>
<li>OUTPUT：本计产生的数据包</li>
<li>POSTROUTING：发送到网卡接口前</li>
</ul>
</li>
</ul>
<h2 id="规则操作"><a href="#规则操作" class="headerlink" title="规则操作"></a>规则操作</h2><ul>
<li>-A，–append chain rule-spec：在链的末尾添加规则</li>
<li>-D，–delete<ul>
<li>-D chain rule-spec：删除特定的规则</li>
<li>-D chain rulenum：删除特定编号的规则</li>
</ul>
</li>
<li>-C，–check chain rule-spec：检查特定规则是否存在（与-D chain rule-spec处理逻辑相同）</li>
<li>-I，–insert chain <code>[rulenum]</code> rule-spec：在链的指定规则编号前插入规则；如果没有指定规则编号，则在链的第一行插入规则</li>
<li>-R，–replace chain rulenum rule-spec：使用规则替换指定编号的规则</li>
<li>-L，–list <code>[chain]</code>：显示表下链的规则（不指定则显示所有链）</li>
<li>-S，–list-rules <code>[chain]</code>：以和iptables-save一样的格式显示规则</li>
<li>-F，–flush <code>[chain]</code>：删除链中的所有规则</li>
<li>-Z，–zero <code>[chain [rulenum]]</code>：清空链中规则的数据包计数器</li>
<li>-P，–policy chain target：更改链的默认处理规则【ACCEPT、DROP等】</li>
<li>-N，–new-chain chain：添加用户自定义链</li>
<li>-X，–delete-chain <code>[chain]</code> ：删除用户自定义链（不能被引用）；如果未定义链名，则删除所有用户自定义链</li>
<li>-E，–rename-chain old-chain new-chain：重命名用户自定义的链</li>
</ul>
<h2 id="功能参数"><a href="#功能参数" class="headerlink" title="功能参数"></a>功能参数</h2><ul>
<li>-v，–verbose：展示详情输出</li>
<li>-n，–numeric：IP地址和端口以数字形式输出</li>
<li>-x，–exact：在使用-L选项时，显示数字计数器的精确值</li>
<li>–line-numbers：显示规则行号</li>
<li>–modprobe=command：当添加或插入规则时，加载必要的模块【targets、match extensions】</li>
</ul>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p><code>[!]</code>是对指定内容取反</p>
<ul>
<li><code>[!]</code> -p，–protocol protocol：只对特定协议(如tcp、udp、icmp)的数据包处理，默认为all</li>
<li><code>[!]</code> -s，–sorce address<code>[/mask][,...]</code>：匹配源地址，可以是网段或主机ip地址，–src标志是这个选项的别名</li>
<li><code>[!]</code> -d, –destination address<code>[/mask][,...]</code>：匹配目标地址。–dst标志是这个选项的别名</li>
<li><code>[!]</code>-i，–in-interface name：接收数据包的网络接口【仅适用于INPUT, FORWARD、PREROUTING链】</li>
<li><code>[!]</code>-o，–out-interface name：将要发送数据包的网络接口【仅适用于FORWARD、OUTPUT、POSTROUTING链】</li>
<li>-j，–jump target：可以跳转到用户自定义的链处理；或直接使用内置处理规则【ACCEPT、DROP】处理数据包</li>
<li>-g，–got chain：转向到用户自定义的链处理</li>
<li>-m, –match match：匹配特定属性的扩展规则模块</li>
</ul>
<h3 id="扩展匹配规则"><a href="#扩展匹配规则" class="headerlink" title="扩展匹配规则"></a>扩展匹配规则</h3><ul>
<li>multiport：多端口匹配【这个模块可以一次性匹配多个源或目的端口，最多可以指定15个端口；地址范围(port:port)被当做是2个端口；只能跟在tcp、udp协议后。】<ul>
<li><code>[!] --source-ports,--sports port[,port|,port:port]</code>：源端口匹配</li>
<li><code>[!] --destination-ports,--dports port[,port|,port:port]</code>：目的端口匹配</li>
<li><code>[!] --ports port[,port|,port:port]</code>：端口匹配</li>
<li>范例：iptables -I INPUT -p udp -m multiport –dports 100,180 -j DROP</li>
</ul>
</li>
<li>state：网络连接状态匹配【如ftp】<ul>
<li>–state 连接状态：NEW(新连接)、ESTABLISHED(已连接)、RELATED(正在连接或已连接)、INVALID(未知连接)</li>
<li>范例：iptables -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT</li>
</ul>
</li>
<li>tcp：tcp协议匹配，在-p tcp指定后即可使用<ul>
<li><code>[!] --source-port,--sport port[:port]</code>：源端口匹配，只接受一个端口或端口范围</li>
<li><code>[!] --destination-port,--dport port[:port]</code>：目的端口匹配</li>
<li><code>[!] --tcp-flags mask</code>：tcp连接状态匹配</li>
<li>范例：iptables -A FORWARD -p tcp –tcp-flags SYN,ACK,FIN,RST SYN</li>
</ul>
</li>
<li>udp：udp协议匹配<ul>
<li><code>[!] --source-port,--sport port[:port]</code>：源端口匹配，只接受一个端口或端口范围</li>
<li><code>[!] --destination-port,--dport port[:port]</code>：目的端口匹配</li>
</ul>
</li>
</ul>
<h2 id="执行动作"><a href="#执行动作" class="headerlink" title="执行动作"></a>执行动作</h2><ul>
<li>ACCEPT：允许数据包通过</li>
<li>DROP：拒绝数据包通过</li>
<li>REJECT：向匹配的数据包发送一个错误响应，仅适用于INPUT, FORWARD、OUTPUT链</li>
<li>MASQUERADE：仅用于nat表的POSTROUTING链，仅用于出口为动态公网ip的nat连接</li>
<li>SNAT：修改数据包的源地址；仅适用于nat表的INPUT、POSTROUTING链；仅适用于tcp、udp协议<ul>
<li><code>--to-source [ipaddr[-ipaddr]][:port[-port]]</code>：转换为特定源地址</li>
</ul>
</li>
<li>DNAT：修改数据包的目的地址；仅适用于nat表的 PREROUTING、OUTPUT链<ul>
<li><code>--to-destination [ipaddr[-ipaddr]][:port[-port]]</code>：转换为特定目的地址</li>
</ul>
</li>
</ul>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><h3 id="filter与nat数据流"><a href="#filter与nat数据流" class="headerlink" title="filter与nat数据流"></a>filter与nat数据流</h3><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/iptables-filter-nat.gif" alt></p>
<h3 id="主机防火墙设置"><a href="#主机防火墙设置" class="headerlink" title="主机防火墙设置"></a>主机防火墙设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line">iptables -A INPUT -s 192.168.100.0/24 -j ACCEPT</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -m multiport --dports 3306,80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>
<h3 id="正向代理设置"><a href="#正向代理设置" class="headerlink" title="正向代理设置"></a>正向代理设置</h3><blockquote>
<p>代理局域网主机访问公网</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">sysctl -p</span><br><span class="line"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -X -t nat </span><br><span class="line">iptables -Z -t nat </span><br><span class="line">modprobe ipt_stat             #开启iptables的状态记录模块</span><br><span class="line">modprobe ip_conntrack_ftp     #开启iptables的ftp连接追踪模块</span><br><span class="line">modprobe ip_nat_ftp       #开启iptables的ftp网络地址转换模块</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o eth1 -j MASQUERADE</span><br><span class="line"># iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o eth1 -j SNAT --to-source 192.168.1.50</span><br></pre></td></tr></table></figure>
<h3 id="反向代理设置"><a href="#反向代理设置" class="headerlink" title="反向代理设置"></a>反向代理设置</h3><blockquote>
<p>代理内网服务，以便公网可以访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 -j DNAT --to-destination 192.168.100.2:80</span><br><span class="line">#iptables -t nat -A PREROUTING -d 192.168.1.50 -p tcp --dport 80 -j DNAT --to-destination 192.168.100.2:80</span><br></pre></td></tr></table></figure>
<h1 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h1><ul>
<li>firewalld为centos7提供的防火墙服务</li>
<li>firewall-cmd命令需要firewalld进程处于运行状态</li>
<li>修改配置后可通过重启服务【 systemctl restart firewalld 】或重载配置【 <code>firewall-cmd --reload</code> 】使配置生效</li>
<li>服务启动后默认开放ssh服务【默认22端口】</li>
<li><code>--permanent</code>（–permanent永久生效，没有此参数重启后失效）</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>systemctl status/start/stop/restart firewalld </p>
<h2 id="端口与服务开放"><a href="#端口与服务开放" class="headerlink" title="端口与服务开放"></a>端口与服务开放</h2><p> 可以通过两种方式控制端口的开放，一种是指定端口号另一种是指定服务名。虽然开放http服务就是开放了80端口，但是还是不能通过端口号来关闭，也就是说通过指定服务名开放的就要通过指定服务名关闭；通过指定端口号开放的就要通过指定端口号关闭。还有一个要注意的就是指定端口的时候一定要指定是什么协议，tcp还是udp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-services  # 查看可以开放的服务</span><br><span class="line">firewall-cmd --add-service=mysql # 开放mysql端口</span><br><span class="line">firewall-cmd --remove-service=http # 阻止http端口</span><br><span class="line">firewall-cmd --list-services # 查看开放的服务</span><br><span class="line">firewall-cmd --add-port=3306/tcp # 开放通过tcp访问3306</span><br><span class="line">firewall-cmd --remove-port=80/tcp # 阻止通过tcp访问80</span><br><span class="line">firewall-cmd --add-port=233/udp # 开放通过udp访问233</span><br><span class="line">firewall-cmd --list-ports # 查看开放的端口</span><br></pre></td></tr></table></figure>
<h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><ul>
<li><p>开启ip与端口伪装【访问信息与目标信息转换】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-masquerade # 检查是否允许伪装IP</span><br><span class="line">firewall-cmd --add-masquerade # 允许防火墙伪装IP</span><br><span class="line">firewall-cmd --remove-masquerade# 禁止防火墙伪装IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口转发设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将80端口的流量转发至8080</span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 </span><br><span class="line"># 将80端口的流量转发至192.168.0.1的8080端口</span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1:toport=8080</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载配置：<code>firewall-cmd --reload</code></p>
</li>
</ul>
<h1 id="tcp-wrapper"><a href="#tcp-wrapper" class="headerlink" title="tcp-wrapper"></a>tcp-wrapper</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><a href="https://www.cnblogs.com/long-cnblogs/p/10716091.html" target="_blank" rel="noopener">tcp_wrapper</a>是一个类似于iptables的实现访问控制工具；但是，iptables是工作在内核中的，所以只要是一个网络服务经由内核中的TCP/IP协议栈就能够受到netfilter的控制</li>
<li>tcp_wrapper是基于库调用来实现其功能的。这就意味着只有那些在开发时调用了tcp_wrapper相关库（这个库叫libwrap）的应用，tcp_wrapper的控制才能生效。</li>
</ul>
<h2 id="应用受控判断"><a href="#应用受控判断" class="headerlink" title="应用受控判断"></a>应用受控判断</h2><ul>
<li>编译方式：一个程序在开发时如果调用了某个接口，它在编译时会有两种编译方式<ul>
<li>动态编译：表示基于动态链接库的方式使用库</li>
<li>静态编译：表示把调用的库文件直接编译进应用程序内部</li>
</ul>
</li>
<li>应用是否支持tcp_wrapper，两种编译方式的判断如下<ul>
<li>动态编译：使用ldd命令，显示出链接至libwrap，即表示支持tcp_wrapper功能；比如ssh服务：【ldd /usr/sbin/sshd】</li>
<li>静态编译：使用strings命令，显示结果中出现两个文件（hosts.allow和hosts.deny）表示支持tcp_wrapper</li>
</ul>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>/etc/hosts.allow：允许访问的设置</li>
<li>/etc/hosts.deny：禁止访问的设置<ul>
<li>范例：【vsftpd:192.168.241.1】vsftpd服务不允许192.168.241.1访问</li>
</ul>
</li>
<li>执行顺序：先检查hosts.allow，后检查hosts.deny【有相同条目时，allow生效】</li>
</ul>
<h2 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h2><p>语法：daemon_list：client_list <code>：[option_list]</code></p>
<ul>
<li>daemon_list：服务列表<ul>
<li>服务的二进制文件名【应用程序是通过二进制文件链接至libwrap库文件来完成访问控制的】</li>
<li>多个服务间逗号分隔</li>
</ul>
</li>
<li>client_list：客户端地址<ul>
<li>ip地址</li>
<li>主机名：<ul>
<li>LOCAL 代表本机</li>
<li>ALL 代表所有程序，所有ip</li>
</ul>
</li>
<li>网络地址<ul>
<li>格式1：172.16.0.0/255.255.0.0</li>
<li>格式2：172.16.【最后那个点不能省略】</li>
<li>不能是： <del>172.16.0.0/16</del></li>
</ul>
</li>
</ul>
</li>
<li>option_list：可选参数列表<ul>
<li>except：排除选项<ul>
<li>范例要求：这个网络开放给172.16访问但是这个172.16.100.1不能访问</li>
<li>设置：【vsftpd:172.16. EXCEPT 172.16.100.1】</li>
</ul>
</li>
<li>deny：表示拒绝，用于host.allow文件中，在允许的文件中实现拒绝的功能【vsftpd:192.168.241. :deny】</li>
<li>allow：表示允许，用于hosts.deny文件，实现allow的功能</li>
<li>spawn：额外启动其它应用程序，完成一部分的管理或其它功能<ul>
<li>范例要求：本地开放了ftp服务，一旦有人访问了，默认策略【allow或deny】执行后，将其记录到日志中</li>
<li>设置：【vsftpd:ALL :spawn /bin/echo <code>date</code> login attemp from %c to %s,%d &gt;&gt; /var/log/vsftpd.deny.log】</li>
<li>参数注解：%c表示client ip,客户端地址，%s表示server ip，服务器端地址，%d为daomon name即访问的是服务器上的哪个守护进程；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统-权限管理</title>
    <url>/blog/2019/08/26/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li><a href="#useradd">useradd</a>：添加用户</li>
<li><a href="#usermod">usermod</a>：更改用户信息</li>
<li>userdel：删除用户【-r删除主目录】</li>
<li>id：查看用户id信息</li>
<li><a href="#密码过期范例">passwd</a>：设置或更改密码<ul>
<li>-l：锁定用户</li>
<li>-u：解锁用户</li>
</ul>
</li>
<li><a href="#密码过期范例">chage</a>：设置密码过期信息<ul>
<li>范例要求：要求oldboy用户7天内不能更改密码，60天以后必须修改密码，过期前10天通知oldboy用户，过期后30天后禁止用户登陆</li>
<li>passwd实现：passwd -n 7 -x 60 -w 10 -i 30 oldboy</li>
<li>chage实现：chage -m 7 -M 60 -W 10 -I 30 oldboy</li>
</ul>
</li>
<li>groupadd、groupdel、groupmod：添加、删除、变更组</li>
<li>groups：查看用户组信息</li>
<li>gpasswd：向组添加用户<ul>
<li>-a：单用户添加</li>
<li>-M：多用户添加【逗号分隔】</li>
<li>-d：删除组用户</li>
<li>范例：gpasswd -a user group</li>
</ul>
</li>
</ul>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ul>
<li><a href="#文件权限示例">文件权限示例</a></li>
<li><a href="#权限表示">权限表示</a></li>
<li><a href="#粘滞类权限">粘滞类权限</a></li>
<li><a href="#chmod">chmod</a>：设置文件的基本权限</li>
<li><a href="#chown">chown</a>：设置文件属主属组</li>
<li><a href="#getfacl">getfacl</a>：查看文件访问控制列表</li>
<li><a href="#setfacl">setfacl</a>：设置文件访问控制列表</li>
<li><a href="#chattr">chattr</a>：设置文件隐藏属性</li>
<li><a href="#lsattr">lsattr</a>：查看文件隐藏属性</li>
<li><a href="#sudo">sudo</a>：权限提升</li>
<li><a href="#su">su</a>：切换用户</li>
</ul>
<h2 id="登录查询"><a href="#登录查询" class="headerlink" title="登录查询"></a>登录查询</h2><ul>
<li>users：所有登录用户</li>
<li>w、who：查看所有用户登录详情</li>
<li>last：查看系统最近登录情况</li>
<li>lastlog：显示最近登录的用户名，登录端口及时间</li>
<li>lastb：登录失败信息</li>
</ul>
<h1 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h1><blockquote>
<p>默认使用/etc/default/useradd配置</p>
</blockquote>
<ul>
<li>-d：指定用户用户主目录</li>
<li>-g：指定用户基本组</li>
<li>-G：指定用户附加组</li>
<li>-m：创建用户主目录</li>
<li>-M：不创建用户主目录</li>
<li>-r：创建一个系统账号【默认不会创建家目录，需-m创建】</li>
<li>-s：设置登录shell</li>
<li>-u：设置用户uid</li>
</ul>
<h1 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h1><blockquote>
<p>注意：不能更改在线使用者的信息</p>
</blockquote>
<ul>
<li>-d：指定用户新的家目录，有-m参数时则将原有家目录内容移动至新家目录</li>
<li>-g/-G：指定基本组、附加组</li>
<li>-s：更改shell</li>
<li>-l：更改用户名</li>
<li>-e mm/dd/yy：指定账号过期时间</li>
</ul>
<h1 id="文件权限示例"><a href="#文件权限示例" class="headerlink" title="文件权限示例"></a>文件权限示例</h1><p>ll命令结果【-rw-r–r– 2 root root 5 8月  14 19:55 1.txt】解读：</p>
<ul>
<li>-：说明此为普通文件</li>
<li>rw-：属主权限</li>
<li>r–：属组权限</li>
<li>r–：其他人权限</li>
<li>2：硬链接数</li>
<li>root：属主</li>
<li>root：属组</li>
<li>5：最后修改时间【日】</li>
<li>8月：最后修改时间【月】</li>
<li>14：文件大小</li>
<li>19:55：最后修改时间</li>
<li>1.txt：文件名</li>
</ul>
<h1 id="权限表示"><a href="#权限表示" class="headerlink" title="权限表示"></a>权限表示</h1><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><ul>
<li>写权限：对文件内容修改(但不包含删除文件本身)</li>
<li>执行权限：普通用户需要同时有读权限才能执行</li>
<li>删除文件：文件名放在上级目录的block中，删除文件是对上级目录的操作，需要有对上级目录的写权限</li>
<li>默认权限：权限掩码umask设置【默认0002】<ul>
<li>root用户：目录755 文件644</li>
<li>普通用户：目录775 文件664</li>
</ul>
</li>
</ul>
<h2 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h2><ul>
<li>读权限：具有查看目录内文件名（仅指文件名）列表的权限</li>
<li>写权限：具有增删移动目录内文件的权限【需配合x权限】</li>
<li>执行权限：具有进入目录，查看文件名称和属性的权限</li>
</ul>
<h2 id="权限表示法"><a href="#权限表示法" class="headerlink" title="权限表示法"></a>权限表示法</h2><ul>
<li>数字表示法<ul>
<li>数字表示法：4-读 2-写 1-执行 0-无权限(数字可叠加)</li>
<li>范例：644【3位数字式】<ul>
<li>属主权限：6=4+2+0</li>
<li>属组权限：4=4+0+0</li>
<li>其他人权限：4=4+0+0</li>
</ul>
</li>
</ul>
</li>
<li>字母表示法<ul>
<li>字母表示法：r-读 w-写 x-执行 -无权限</li>
<li>范例：rw-r–r–<ul>
<li>属主权限：rw-</li>
<li>属组权限：r–</li>
<li>其他人权限：r–</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户组表示"><a href="#用户组表示" class="headerlink" title="用户组表示"></a>用户组表示</h2><ul>
<li>a：所有用户</li>
<li>u：属主</li>
<li>g：属组</li>
<li>o：其他人</li>
</ul>
<h1 id="粘滞类权限"><a href="#粘滞类权限" class="headerlink" title="粘滞类权限"></a>粘滞类权限</h1><h2 id="suid设置"><a href="#suid设置" class="headerlink" title="suid设置"></a>suid设置</h2><ul>
<li>含义：作用于二进制文件，使文件在执行阶段具有文件所有者的权限</li>
<li>表示法：<ul>
<li>数字表示法：4【4位数字式的首位】</li>
<li>字母表示法：(u+)s</li>
</ul>
</li>
<li>范例：普通用户对/etc/shadow 无任何权限，但普通用户却可以修改自己的密码，结果是修改到其中的内容；这是由于/usr/bin/passwd具有suid权限，普通用户执行passwd命令过程中短暂获得root用户权限，从而可以修改/etc/shadow内容。</li>
</ul>
<h2 id="sgid设置"><a href="#sgid设置" class="headerlink" title="sgid设置"></a>sgid设置</h2><ul>
<li>含义<ul>
<li>文件：作用于二进制文件，使文件在执行阶段具有文件属组的权限</li>
<li>目录：用户有进入目录的权限，用户在此目录下的有效属组将变成该目录的属组</li>
</ul>
</li>
<li>表示法：<ul>
<li>数字表示法：2【4位数字式的首位】</li>
<li>字母表示法：(g+)s</li>
</ul>
</li>
<li>范例：用于目录时，若用户对此目录有写权限，则在此目录下建立的目录或文件的属组为此目录的属组</li>
</ul>
<h2 id="sticky设置"><a href="#sticky设置" class="headerlink" title="sticky设置"></a>sticky设置</h2><ul>
<li>含义：常用于目录，表示该目录下用户建立的文件只能自己删除</li>
<li>表示法：<ul>
<li>数字表示法：1【4位数字式的首位】</li>
<li>字母表示法：(o+)t</li>
</ul>
</li>
</ul>
<h2 id="大写S与大写T"><a href="#大写S与大写T" class="headerlink" title="大写S与大写T"></a>大写S与大写T</h2><p>由于所设置的文件ugo位都没有x权限，所以当赋予suit，sgit，sbit权限时，对应为空权限，即字符s，t由小写变为大写S，T。</p>
<h1 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h1><blockquote>
<p>更改文件权限</p>
</blockquote>
<ul>
<li>语法：chmod 权限设置 文件</li>
<li>范例：<ul>
<li>数字式设置权限：chmod nnnn file</li>
<li>字母式增加/减少/精确设置权限：chmod u+r,g-w,o=rwx file</li>
<li>所有用户权限设置：chmod a+/-/=rwx file</li>
<li>特殊权限设置：chmod u+s,g+s,o+t file</li>
</ul>
</li>
</ul>
<h1 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h1><blockquote>
<p>更改文件属主属组</p>
</blockquote>
<ul>
<li>语法：chown 参数 用户组 文件</li>
<li>参数<ul>
<li>-R 递归更改属性</li>
</ul>
</li>
<li>范例<ul>
<li>chown user:group file</li>
<li>chown user.group file</li>
<li>chown user file</li>
<li>chown .group file</li>
<li>chown :group file</li>
</ul>
</li>
</ul>
<h1 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h1><blockquote>
<p>获取文件或目录的访问控制列表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:  # file: somedir/</span><br><span class="line">2:  # owner: lisa</span><br><span class="line">3:  # group: staff</span><br><span class="line">4:  # flags: -s-</span><br><span class="line">5:  user::rwx</span><br><span class="line">6:  user:joe:rwx               #effective:r-x</span><br><span class="line">7:  group::rwx                 #effective:r-x</span><br><span class="line">8:  group:cool:r-x</span><br><span class="line">9:  mask::r-x</span><br><span class="line">10:  other::r-x</span><br><span class="line">11:  default:user::rwx</span><br><span class="line">12:  default:user:joe:rwx       #effective:r-x</span><br><span class="line">13:  default:group::r-x</span><br><span class="line">14:  default:mask::r-x</span><br><span class="line">15:  default:other::---</span><br></pre></td></tr></table></figure>
<ul>
<li>1-3表示文件名、属主、属组</li>
<li>4显示特殊权限setuid (s), setgid (s), sticky (t)【3个权限都无时，不显示此行内容】</li>
<li>5、7、10对应属主、属组、其他人的权限，表示基本的acl条目</li>
<li>6、8是命名的用户和组的权限条目</li>
<li>9是有效的权限掩码，针对所有的组和命名的用户【但不包含属主、其他人】</li>
<li>11-15显示目录的默认权限【普通文件则没有】</li>
</ul>
<h1 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h1><blockquote>
<p>设置文件或目录的访问控制列表</p>
</blockquote>
<ul>
<li>语法：<code>setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file ...</code></li>
<li>使用注意<ul>
<li>命令行下操作权限时，多个ACL条目以逗号分隔</li>
<li>从文件中读取ACL时，最终会有getfacl式的结果输出</li>
<li>属主、属组、其他人这3个基本的权限条目不可移除，且只能有一个</li>
<li>当ACL包含命名的用户和组的条目时，必须包含有效的权限掩码</li>
</ul>
</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-m(–modify)、-M (–modify-file)：定义ACL权限，-m在命令行定义，-M从文件中或标准输入读取要定义的ACl</li>
<li>-x(–remove)、-X (–remove-file)：移除ACl权限，-x在命令行移除，-X从文件中或标准输入读取要移除的ACL</li>
<li>-b、–remove-all：移除所有扩展的ACL【不包含对3个基本条目修改的恢复】</li>
<li>-k、–remove-default：移除默认的ACL</li>
<li>-n, –no-mask：不计算掩码条目</li>
<li>–mask：计算掩码条目</li>
<li>-d、–default：使用默认ACL</li>
<li>–restore=file：从文件中恢复ACL【使用getfacl -R备份的文件】</li>
<li>–test：测试模式</li>
<li>-R, –recursive：递归应用权限</li>
<li>-L, –logical：操作适用于符号链接关联的目录</li>
<li>-P, –physical：操作不适用于符号链接关联的目录</li>
</ul>
<h2 id="权限条目"><a href="#权限条目" class="headerlink" title="权限条目"></a>权限条目</h2><ul>
<li>用户权限：<code>[d[efault]:] [u[ser]:]uid [:perms]</code>：设置命名用户的权限，uid为空则表示属主的权限</li>
<li>组权限：<code>[d[efault]:] g[roup]:gid [:perms]</code>：设置命名组的权限，gid为空则表示属组的权限</li>
<li>权限掩码：<code>[d[efault]:] m[ask][:] [:perms]</code></li>
<li>其他人权限：<code>[d[efault]:] o[ther][:] [:perms]</code></li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>默认权限：setfacl -m d:u:hjq:rwx test</li>
<li>设置属主权限：setfacl -m u::r test/</li>
<li>设置属组权限：setfacl -m g::rw test/</li>
<li>设置权限掩码：setfacl -m d:m:rx test/</li>
<li>移除所有扩展权限：setfacl -b test/</li>
</ul>
<h1 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h1><blockquote>
<p>改变文件的隐藏属性</p>
</blockquote>
<ul>
<li>用法：<code>chattr [ -RVf -v version ] [ mode ] files...</code></li>
<li>一般参数：<ul>
<li>-R：递归设置文件和目录</li>
<li>-V：显示设置过程</li>
<li>-f：屏蔽错误输出</li>
<li>-v version：设置文件版本</li>
</ul>
</li>
<li>模式参数：<code>+-=[acdeijstuADST]</code><ul>
<li>+表示增加模式</li>
<li>-表示较少模式</li>
<li>=表示只设置此种模式</li>
</ul>
</li>
</ul>
<h2 id="模式参数"><a href="#模式参数" class="headerlink" title="模式参数"></a>模式参数</h2><ul>
<li>a：只允许增加内容，不允许修改和删除</li>
<li>A：不修改atime时间戳</li>
<li>c：文件存储时压缩，读取时自动解压</li>
<li>d：dump程序启动备份时，不对此文件备份</li>
<li>i：不能被修改和删除</li>
<li>s：删除数据的同时将数据从磁盘删除</li>
<li>S：将数据同步写入磁盘【一般为异步】</li>
<li>u：与s相反，删除文件但不从磁盘上删除【可以用于恢复】</li>
</ul>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><ul>
<li>只许向文件追加内容：chattr +a 12</li>
<li>撤销追加属性：chattr -a 12</li>
</ul>
<h2 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h2><ul>
<li>-d：显示目录本身隐藏属性</li>
<li>-R：递归显示目录及目录下的隐藏属性</li>
</ul>
<p>查看文件的隐藏属性：lsattr 12</p>
<h1 id="su"><a href="#su" class="headerlink" title="su"></a>su</h1><ul>
<li>su：切换用户【默认切换到root】</li>
<li>su -：切换用户的同时切换环境变量</li>
<li>sudo：权限提升，一般为切换为root</li>
</ul>
<h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>时间：5分钟内无需再次输入密码</li>
<li>命令<ul>
<li>visudo -c：语法检查</li>
<li>visudo -f：加载指定配置文件</li>
<li>sudo -l【查看用户sudo权限】</li>
</ul>
</li>
<li>文件：/etc/sudoers</li>
<li>环境设置：<ul>
<li><code>Defaults    env_reset</code>【执行命令时环境变量被重置】</li>
<li><code>Defaults:muker !requiretty</code>【允许用户远程执行sudo命令】</li>
</ul>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>范例：<ul>
<li>单用户设置：<code>admin   ALL=(ALL)       /usr/sbin/useradd</code></li>
<li>用户组设置：<code>%admin          ALL=(ALL)       NOPASSWD: ALL</code></li>
</ul>
</li>
<li>语法：用户或组+来源主机+可以切换到的用户+可以执行的命令<ul>
<li>用户或组：admin</li>
<li>来源主机：ALL</li>
<li>可以切换的用户：ALL</li>
<li>可以执行的命令：/usr/sbin/useradd<ul>
<li>命令需要使用全路径</li>
<li>命令前使用<code>！</code>表示取反【<code>admin   ALL=NOPASSWD:/sbin/*, !/sbin/fdisk</code>】，禁止命令需要放在允许命令之后</li>
<li>命令前<code>NOPASSWD</code>表示执行sudo时无需输入密码</li>
<li>多个命令之间逗号分隔，且逗号与下个命令之间要有空格</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><blockquote>
<p>可以对sudo语法中的4个主要条目设置别名<br>别名必须使用大写字母，%表示引用组名</p>
</blockquote>
<ul>
<li>用户：<code>User_Alias ADMINS = admin, baby, %admin</code></li>
<li>来源主机：<code>Host_Alias     MAILSERVERS = smtp, smtp2</code></li>
<li>可切换用户：<code>Runas_Alias  OP = root, admin</code></li>
<li>可执行命令：<code>Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum</code></li>
</ul>
<h2 id="远程sudo"><a href="#远程sudo" class="headerlink" title="远程sudo"></a>远程sudo</h2><p>配置文件requiretty参数和命令行ssh -t参数的差异</p>
<ul>
<li>以客户端角度看：ssh以-t参数远程运行命令(ssh -t host sudo comand)，无论requiretty如何配置都可以远程sudo执行</li>
<li>以服务端角度看<ul>
<li>【!requiretty】不要求有tty终端，【ssh host sudo comand】命令可以执行（ansible的sudo方式也可以执行）</li>
<li>【requiretty】要求有tty终端，【ssh host sudo comand】无法执行执行</li>
</ul>
</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h2><ul>
<li>修改密码时报错 passwd: Authentication token manipulation error</li>
<li>添加用户报错：unable to lock password file</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>检查相关配置文件权限正常：/etc/passwd 和/etc/shadow</li>
<li>df查看硬盘空间正常</li>
<li>使用命令strace -f passwd 追踪分析原因，看到关键报错信息：“No space left on device”，可是df查看硬盘空间没问题，有可能是inode满了，使用df –i查看inode使用情况，确实/var/spool/clientmqueue占用大量的inode</li>
<li>/var/spool/clientmqueue 生成的文件占用完inode，此目录下文件的产生原因主要是crontab里面的命令没有添加“&gt;/dev/null 2&gt;&amp;1”标准输出、错误输出信息都输出到标准输出，以文件形似存储在clientmqueue</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>删除文件后正常，将crontab命令后面添加“&gt;/dev/null 2&gt;&amp;1”</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/blog/2019/07/30/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><ul>
<li>当变量值为字符串时，尽量使用单或双引号，避免字符串中有空格或特殊字符；如果变量值时数字或操作系统路径时，可以不使用引号</li>
<li>等号两边不能有空格</li>
<li>变量名的开头必须是字母</li>
</ul>
<h2 id="引用机制"><a href="#引用机制" class="headerlink" title="引用机制"></a>引用机制</h2><ul>
<li>反斜杠：转义符，保留字面含义【当行尾有反斜杠时表示续行】<ul>
<li>特殊转义序列：<code>\t \n</code></li>
</ul>
</li>
<li>单引号：保留字符字面含义</li>
<li>双引号：可以解析变量及使用转义符</li>
</ul>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><ul>
<li>$n表示shell脚本或shell函数的位置参数【n&gt;=1】</li>
<li>当数字n大于9时应该这样表示：${12}</li>
</ul>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul>
<li><code>$* $@</code>：所有的位置参数<ul>
<li><code>$*</code>：相当于“$1空格$2空格$3…”，即【空格分隔多个位置参数，同时整体作为一个字符串】</li>
<li><code>$@</code>：相当于”$1” “$2”…，即【空格分隔多个位置参数，并作为多个独立的字符串】</li>
</ul>
</li>
<li><code>$#</code>：位置参数个数</li>
<li><code>$?</code>：上一个shell命令执行状态【返回码，0表示执行成功，非0表示执行失败】</li>
<li><code>$$</code>：当前shell的pid【进程id】</li>
<li><code>$!</code>：上一个放入后台执行的命令的pid</li>
<li>$0：shell脚本的名字</li>
<li>波浪线(~)：表示当前用户家目录</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h3><ul>
<li>定义整个数组：name=(value1 … valueN)<ul>
<li>arry=(128 string http html)</li>
</ul>
</li>
<li>定义数组的某个值：<code>name[subscript]=value</code><ul>
<li><code>arry[4]=&quot;ceshi&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><ul>
<li>查看数组某个元素(下标从0开始)：<code>${arry[0]}</code></li>
<li>查看全体元素：<code>${arry[*]}</code></li>
<li>查看数组某个元素长度：${#arry[0]}</li>
<li>查看数组元素个数：${#arry[*]}</li>
<li>数组元素替换：<code>${arry[*]/string/jing}</code></li>
<li>删除数组某个元素：<code>unset arry[0]</code></li>
<li>删除整个数组：<code>unset arry</code></li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul>
<li>统计并发连接：<code>netstat -ant|awk -F &#39;[ :]+&#39; &#39;$1 !~ /^Active|^Proto/ &amp;&amp; $6 !~ /0.0.0.0|^172.16/{if($5==443)++ip[$6]}END{for(i in ip)print i,ip[i]}&#39;|sort -rn -k2</code></li>
</ul>
<h2 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h2><ul>
<li>赋值：将一个变量的值(值可能为空或不存在)赋值给另一个变量时的操作</li>
<li>截取：<ul>
<li><code>${变量名:起始索引}</code>            显示起始索引开始的字符串</li>
<li><code>${变量名:起始索引:长度}</code>   显示起始索引开始的指定长度字符串</li>
<li>${#变量名}                       显示变量长度</li>
<li><code>${变量名#样式}</code>                从行首开始截取符合样式的最短字符串：<code>${PATH#/*:}</code></li>
<li><code>${变量名##样式}</code>               从行首开始截取符合样式的最长字符串：<code>${PATH##/*:}</code></li>
<li><code>${变量名%样式}</code>                从行尾开始截取符合样式的最短字符串：<code>${PATH%:/*}</code></li>
<li><code>${变量名%%样式}</code>             从行尾开始截取符合样式的最长字符串：<code>${PATH%%:/*}</code></li>
</ul>
</li>
<li>替换和删除<ul>
<li><code>${变量名/样式/替换}</code>          替换第一个样式字符串：<code>${PATH/sbin/Sbin}</code></li>
<li><code>${变量名//样式/替换}</code>         替换所有的样式字符串：<code>${PATH//sbin/Sbin}</code></li>
<li><code>${变量名/样式/ }</code>               删除第一个样式字符串：<code>${PATH/sbin/}</code></li>
<li><code>${变量名//样式/ }</code>              删除所有的样式字符串：<code>${PATH//sbin/}</code></li>
</ul>
</li>
</ul>
<h2 id="路径名匹配"><a href="#路径名匹配" class="headerlink" title="路径名匹配"></a>路径名匹配</h2><blockquote>
<p>即bash下的通配符</p>
</blockquote>
<ul>
<li><code>*</code>：匹配任意字符串</li>
<li><code>?</code>：匹配任意单个字符</li>
<li><code>[...]</code>：<ul>
<li>匹配括号内任意字符</li>
<li>包含横杆【-】时表示匹配字符范围内的字符</li>
<li>首字符是<code>!</code>或<code>^</code>表示不匹配括号内字符</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[python@simple test]$ touch abc.txt  ab.txt  ac.txt  ad.txt  bc.txt</span><br><span class="line">[python@simple test]$ ls</span><br><span class="line">abc.txt  ab.txt  ac.txt  ad.txt  bc.txt</span><br><span class="line">[python@simple test]$ ls a*.txt</span><br><span class="line">abc.txt  ab.txt  ac.txt  ad.txt</span><br><span class="line">[python@simple test]$ ls a?.txt</span><br><span class="line">ab.txt  ac.txt  ad.txt</span><br><span class="line">[python@simple test]$ ls a[b-d].txt</span><br><span class="line">ab.txt  ac.txt  ad.txt</span><br><span class="line">[python@simple test]$ ls a[bd].txt </span><br><span class="line">ab.txt  ad.txt</span><br><span class="line">[python@simple test]$ ls a[^bd].txt</span><br><span class="line">ac.txt</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>name () { cmd-list }</li>
<li>function name <code>[()]</code> { cmd-list }</li>
<li>定义局部变量：local</li>
</ul>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>func_name</p>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义：</span><br><span class="line">usage ()&#123;</span><br><span class="line">    echo &quot;usage: $0 &lt;git branch name&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 调用：</span><br><span class="line">usage</span><br></pre></td></tr></table></figure>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><ul>
<li>使用方式1：cmd1|cmd2：将cmd1命令的标准输出传递给cmd2的标准输入</li>
<li>使用方式2：cmd1|&amp;cmd2：【|&amp;等同于2&gt;&amp;1 |】将cmd1的标准输出和错误输出都传递给cmd2</li>
<li>管道与进程：管道中的每个命令都在单独的进程中执行【subshell】</li>
</ul>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><ul>
<li><p>重定向标准输入：<code>&lt;word</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.txt</span><br><span class="line">echo tianyu &gt; 1.txt</span><br><span class="line"># 2.sh</span><br><span class="line">read -p &apos;input your name:&apos; name</span><br><span class="line">echo Hello $name</span><br><span class="line"># shell</span><br><span class="line">sh 2.sh &lt; 1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向输出：</p>
<ul>
<li>标准输出：&gt;word</li>
<li>错误输出：2&gt;word</li>
</ul>
</li>
<li><p>追加重定向输出：<code>[n]</code>&gt;&gt;word</p>
</li>
<li><p>同时重定向标准输出和错误输出：<code>&amp;&gt;word</code>或<code>&gt;word 2&gt;&amp;1</code> </p>
</li>
<li><p>追加重定向标准输出和错误输出：<code>&amp;&gt;&gt;word</code>或<code>&gt;&gt;word 2&gt;&amp;1</code></p>
</li>
</ul>
<h2 id="重定向多行输入"><a href="#重定向多行输入" class="headerlink" title="重定向多行输入"></a>重定向多行输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &lt;&lt; 分隔符</span><br><span class="line">文本</span><br><span class="line">分隔符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; ceshi.txt</span><br><span class="line">he</span><br><span class="line">jing</span><br><span class="line">qi</span><br><span class="line">EOF</span><br><span class="line"># cat为接收文本的命令</span><br><span class="line"># EOF为分隔符【可以是任意的】</span><br><span class="line"># &gt;ceshi.txt为cat命令的重定向输出</span><br><span class="line"># he jing qi 为输入文本</span><br></pre></td></tr></table></figure>
<h1 id="括号使用"><a href="#括号使用" class="headerlink" title="括号使用"></a>括号使用</h1><ul>
<li>(list)：开启一个子shell执行命令列表，$(list)表示list命令的输出结果（也可以使用反撇号执行命令），常用于a=$(list)这样的赋值语句</li>
<li>((expression))：括号里的进行的是数字运算(因此可以用+、-、*、/、&gt;、&lt;等算术运算符)，同样的，$((expression))表示计算的结果</li>
<li><code>[]</code>：条件表达式，其实是一个程序<code>/usr/bin/[</code>，相当于/usr/bin/test，后面多的那个<code>]</code>只是对称好看，所以<code>[</code>后要有空格</li>
<li><code>[[ expression ]]</code>：表示里面进行的是逻辑运算，可以使用<code>!、&amp;&amp;、||</code>逻辑运算符</li>
<li>{ list; }：内部分组，这个结构事实上创建了一个匿名函数。大括号内的命令不会开启一个子shell运行。括号内的命令用分号分隔，最后一个也要用分号，第一个命令和左括号之间必须要有一个空格。它也支持如下扩展：<ul>
<li>扩展字母和数字：{1..n} {a..z}</li>
<li>逗号分隔的扩展：{1,5,a}</li>
</ul>
</li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul>
<li><p>for列表循环：<code>for name [ [ in [ word ... ] ] ; ] do list ; done</code>：</p>
<ul>
<li><p>用法1：循环列表中的内容</p>
<p>  <code>for name in a b c;do echo $name;sleep 0.5;done</code></p>
</li>
<li><p>用法2：如果in word省略相当于循环位置参数(见范例)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># for_1与for_2函数等价</span><br><span class="line">for_1()&#123;</span><br><span class="line">  for var</span><br><span class="line">  do</span><br><span class="line">    echo $var</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_2()&#123;</span><br><span class="line">  for var in &quot;$@&quot;</span><br><span class="line">  do</span><br><span class="line">    echo $var</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line">for_1 1 2 3</span><br><span class="line">for_2 a b c</span><br></pre></td></tr></table></figure>
<ul>
<li>for自增循环：<code>for((expr1;expr2;expr3))</code>：条件循环；expr1为初始条件，expr2为终止条件，expr为循环条件<ul>
<li>范例：for((a=50;a&gt;=0;a–));do echo $a;done</li>
</ul>
</li>
<li>select循环：<code>select name [in word];do list;done</code>：交互式选择列表中的项目<ul>
<li>范例：<code>select name in a b c;do echo $name;done</code></li>
</ul>
</li>
<li>case循环：<code>case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac</code>：多条件选择</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case variable in</span><br><span class="line">value1 | value2)        // value1支持通配符和|作为or的关系</span><br><span class="line">   command1</span><br><span class="line">   ;;</span><br><span class="line">value3)</span><br><span class="line">   command2</span><br><span class="line">   ;;</span><br><span class="line">[vV]alue4)</span><br><span class="line">   command3</span><br><span class="line">   ;;</span><br><span class="line">*)</span><br><span class="line">   command4</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句：<code>if list; then list; [ elif list; then list; ] ... [ else list; ] fi</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $1 -gt 5 ];then</span><br><span class="line">    echo $1</span><br><span class="line">elif [ $1 -eq 5 ];then</span><br><span class="line">    echo 5</span><br><span class="line">else</span><br><span class="line">    echo &quot;$1 is less than 5&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<ul>
<li>while循环：<code>while list-1; do list-2; done</code>：list-1满足条件则执行list-2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare -i i=0</span><br><span class="line">while ((i&lt;=10));</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">    i=i+1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 读取文件方式1</span><br><span class="line">exec &lt; FILE</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    CMD</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">2. 读取文件方式2</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    CMD</span><br><span class="line">done&lt;FILE</span><br><span class="line"></span><br><span class="line"># 范例</span><br><span class="line">while read line</span><br><span class="line">do </span><br><span class="line">    echo $line</span><br><span class="line">    sleep 1</span><br><span class="line">done &lt; $1 #$1是命令行的的第一个参数（文件名）</span><br></pre></td></tr></table></figure>
<ul>
<li>break和continue<ul>
<li>只能用于for、while、until、select循环</li>
<li>单循环中：break终止循环；continue终止本次循环(不执行循环后语句)，继续下次循环</li>
<li>双循环中：break跳出内循环，执行外循环语句；break 2直接跳出外循环。continue跳出内循环中的本次循环，继续下次内循环；continue 2跳出内循环，继续下次外循环。</li>
</ul>
</li>
<li>exit <code>[n]</code>：以n作为返回值退出脚本</li>
<li>return <code>[n]</code>：以n作为返回值退出函数</li>
</ul>
<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>id++，id–：变量后加减</li>
<li>++id，–id：变量先加减</li>
<li>+-：加减</li>
<li>&amp; ^ | ~：位与、异或、同或、非</li>
<li><code>**</code>：幂函数</li>
<li>*/%：乘除取余</li>
<li><code>&lt;&lt; &gt;&gt;</code>：向左位移、向右位移</li>
<li><code>&gt; &gt;= &lt;= &lt;</code>：比较</li>
<li>== !=：等于、不等于</li>
<li>&amp;&amp; ||  !：逻辑与、或、非</li>
<li>expr?expr:expr：三元表达式</li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>(())：echo $((5+4))</li>
<li><code>expr 1 + 4</code>：空格分隔</li>
<li>declare：<code>declare -i i=2;i=i+3;echo $i</code></li>
<li>let：<code>let a=3+2;echo $a</code></li>
</ul>
<h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><blockquote>
<p>test或[命令使用</p>
</blockquote>
<ul>
<li>-a、-o：逻辑与、或</li>
<li>-n、-z：字符串长度不为0、为0</li>
<li>=、!=：字符串相等、不等</li>
<li>-ne、-eq、-lt、-le、-gt、-ge：数字上的大【等】于、小【等】于、【不】等于</li>
<li>-e：文件存在</li>
</ul>
<h1 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h1><ul>
<li><code>:</code>：冒号表示空语句，什么也不做</li>
<li>./script.sh：在当前shell环境执行脚本，变量值可以回传给shell</li>
<li>sh/bash：开启子shell执行脚本，变量值不能回传给父shell</li>
<li>declare：声明变量<ul>
<li>declare -r variable=value     声明只读变量.</li>
<li>declare -a variable=(1 2 3 4)     声明数组</li>
<li>declare -i aa                    声明整数型变量</li>
</ul>
</li>
<li>eval text：将text文本转换为shell命令执行，如【eval “echo text”】即为执行echo text命令</li>
<li>export：设置全局变量，如export PATH=/data/tomcat:$PATH</li>
<li>getopts：解析shell脚本位置参数</li>
<li>shift：解析shell脚本位置参数时用于移动参数位置</li>
<li>printf：格式化输出</li>
<li>set：显示所有shell变量<ul>
<li>-n：读取命令但不执行，此用于检测脚本语法【bash/sh -n file】</li>
<li>-x：展开所有简单的命令，同时显示for、case、select的每一个循环，主要用于脚本调试<ul>
<li>脚本内使用：set -x</li>
<li>命令行使用：sh -x file</li>
</ul>
</li>
<li>+x：关闭命令的展开显示：set +x</li>
</ul>
</li>
<li>unset：删除变量或函数</li>
<li>env：显示环境变量</li>
</ul>
<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><ul>
<li>&amp;会将命令放入后台执行</li>
<li>以“;”分隔的命令会顺序执行，shell等待每个命令执行完成</li>
<li>cmd1&amp;&amp;cmd2 逻辑“与”连接两个命令，cmd1执行成功后才执行cmd2</li>
<li>cmd1||cmd2 逻辑“或”连接两个命令，cmd1执行不成功才执行cmd2</li>
</ul>
<h1 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h1><p>其他范例参考：<a href="https://gitee.com/simple0426/sysadm/tree/master/shell" target="_blank" rel="noopener">https://gitee.com/simple0426/sysadm/tree/master/shell</a></p>
<h2 id="菜单制作"><a href="#菜单制作" class="headerlink" title="菜单制作"></a>菜单制作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">menu_1 () &#123;</span><br><span class="line">    echo -e &quot;</span><br><span class="line">    ====================</span><br><span class="line">    1.\033[32minstall lamp\033[0m</span><br><span class="line">    2.\033[32minstall lnmp\033[0m</span><br><span class="line">    3.\033[31mexit\033[0m</span><br><span class="line">    please install your choice:</span><br><span class="line">    &quot;</span><br><span class="line">&#125;</span><br><span class="line">menu_1</span><br><span class="line">read num1</span><br><span class="line">echo $num1</span><br></pre></td></tr></table></figure>
<h2 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h2><blockquote>
<p>输入英文单词，产生1-100之间的随机数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while true # 输入循环</span><br><span class="line">do</span><br><span class="line">    read -p &quot;Please input your name:&quot; name    # 交互式输入</span><br><span class="line">    echo &quot;$name&quot;|grep -E -q -w &quot;^exit|^quit&quot; &amp;&amp; exit # 定义退出码</span><br><span class="line">    echo &quot;$name&quot;|grep -E -q -w &quot;[a-zA-Z]+&quot; || continue # 非字母则继续输入循环</span><br><span class="line">    [ $&#123;#name&#125; -eq 0 ] &amp;&amp; continue # 为空继续输入循环</span><br><span class="line">    grep -E -w &quot;$name&quot; random.list 2&gt;/dev/null &amp;&amp; continue # 内容已存在则继续输入循环</span><br><span class="line">    while true # 随机数循环</span><br><span class="line">    do</span><br><span class="line">        random=$(awk &apos;BEGIN&#123;srand();val=int(rand()*100);print val&#125;&apos;) # 产生随机数</span><br><span class="line">        grep -E -w -q &quot;$random&quot; random.list 2&gt;/dev/null &amp;&amp; continue # 随机数存在则继续随机数循环产生新随机数</span><br><span class="line">        printf &quot;$name\t$random\n&quot;</span><br><span class="line">        printf &quot;$name\t$random\n&quot; &gt;&gt; random.list &amp;&amp; break # 保存输入和随机数</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="99乘法表"><a href="#99乘法表" class="headerlink" title="99乘法表"></a>99乘法表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 一、处理顺序：第1行1-9列 第2行1-9列 。。。</span><br><span class="line"># 二、1-外层循环:行  2-内层循环:列</span><br><span class="line"># 三、显示：列位置*行位置=乘积结果</span><br><span class="line">for ((i=1;i&lt;=9;i++)) # 行</span><br><span class="line">do</span><br><span class="line">    for ((j=1;j&lt;=9;j++)) # 列</span><br><span class="line">    do</span><br><span class="line">        if [ $j -lt $i ];then # 列小于行则输出</span><br><span class="line">            printf &quot;$j*$i=$((j*i))\t&quot;</span><br><span class="line">        elif [ $j -eq $i ];then  # 列等于行则换行</span><br><span class="line">            printf &quot;$j*$i=$((j*i))\n&quot;</span><br><span class="line">        else # 列大于行退出循环</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux远程连接工具-ssh</title>
    <url>/blog/2019/08/07/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7-ssh/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Secure shell protocol：安全的shell协议</p>
</blockquote>
<ul>
<li>服务端软件：openssh</li>
<li>客户端软件：securecrt、putty、openssh-client</li>
<li>登录方式：<ul>
<li>口令：交互式输入用户名和密码</li>
<li>秘钥：使用秘钥文件<ul>
<li>产生秘钥对：ssh-keygen -t rsa -P “” -f ./bastion</li>
<li>传送公钥到远端：ssh-copy-id -i ~/.ssh/bastion.pub</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><blockquote>
<p>/etc/ssh/sshd_config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin no # 是否允许root登录</span><br><span class="line">PermitEmptyPasswords no # 是否允许无密码登录</span><br><span class="line">Port 22 # 端口设置</span><br><span class="line">ClientAliveInterval 60 #server每隔60秒发送一次请求给client，然后client响应，从而保持连接</span><br><span class="line">ClientAliveCountMax 3 #server发出请求后，client没有响应次数达到3，就自动断开连接，一般client会响应。</span><br></pre></td></tr></table></figure>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><ul>
<li>配置文件：/etc/ssh/ssh_config（全局）、~/.ssh/config（用户级）</li>
<li>用途1：通过ssh代理转发实现跳板机功能（主机A通过B登录C）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host ops</span><br><span class="line">  User muker #连接跳板机使用的用户名</span><br><span class="line">  HostName 47.99.78.151 #跳板机ip</span><br><span class="line">  ProxyCommand none</span><br><span class="line">  BatchMode yes #跳板机模式</span><br><span class="line">  IdentityFile ~/keyfiles/bastion #本地连跳板机时使用的私钥</span><br><span class="line">  StrictHostKeyChecking no #首次登录时禁止秘钥检查</span><br><span class="line">Host 172.16.0.*  # 目标主机网络</span><br><span class="line">  ServerAliveInterval 60 </span><br><span class="line">  TCPKeepAlive        yes</span><br><span class="line">  ProxyCommand ssh -qaY -i ~/keyfiles/bastion muker@ops &apos;nc -w 14400 %h %p&apos; # ssh代理转发</span><br><span class="line">  IdentityFile    ~/keyfiles/internal #跳板机使用私钥internal连接目标主机</span><br><span class="line">  StrictHostKeyChecking no</span><br></pre></td></tr></table></figure>
<ul>
<li>用途2：实现快速登录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">     IdentityFile ~/.ssh/feidao</span><br><span class="line">     PreferredAuthentications publickey,keyboard-interactive,password</span><br><span class="line">     ForwardAgent yes</span><br><span class="line">     StrictHostKeyChecking no</span><br><span class="line">     ServerAliveInterval 300</span><br><span class="line">     ServerAliveCountMax 24</span><br><span class="line">Host gitlab</span><br><span class="line">     User root</span><br><span class="line">     Hostname 10.0.124.6</span><br><span class="line">     Port 22</span><br></pre></td></tr></table></figure>
<h1 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h1><p>ssh 选项 user@host <code>command</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-a：禁用转发身份验证代理连接</li>
<li>-Y：启用可信的X11转发</li>
<li>-q：抑制警告和诊断信息输出</li>
<li>-F configfile：客户端配置文件</li>
<li>-i identity_file：私钥文件</li>
<li>-p port：远程ssh服务端口</li>
<li>-v：开启连接详细输出<ul>
<li>主要用于故障调试</li>
<li>最多使用3个v</li>
</ul>
</li>
</ul>
<h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><ul>
<li>-P：设置连接端口</li>
<li>-p：保留文件时间戳</li>
<li>-r：递归复制目录下内容</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul>
<li>只允许秘钥登录<ul>
<li>现象：Permission denied (publickey)</li>
<li>解决：变更配置sshd_config 【PasswordAuthentication yes】</li>
</ul>
</li>
<li>不允许root登录<ul>
<li>现象：ssh使用root登录时，密码正确但是拒绝登陆</li>
<li>解决：变更配置sshd_config【PermitRootLogin yes】</li>
</ul>
</li>
</ul>
<h1 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h1><ul>
<li><a href="https://blog.csdn.net/qq_25934401/article/details/83419849" target="_blank" rel="noopener">Centos 6.5升级openssh到7.9p1</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>守护进程工具supervisor</title>
    <url>/blog/2018/05/30/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7supervisor/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>supervisor用于管理非daemon进程</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>可使用系统安装apt-get install supervisor</li>
<li>可使用python安装：pip install supervisor</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><blockquote>
<p>更多配置说明请<a href="http://supervisord.org/configuration.html" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[inet_http_server]</span>  <span class="comment">;web管理界面设置</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9001</span>  </span><br><span class="line"><span class="attr">username</span>=user      </span><br><span class="line"><span class="attr">password</span>=<span class="number">123456</span>    </span><br><span class="line"><span class="section">[program:logstash]</span> <span class="comment">;管理单个进程的配置</span></span><br><span class="line"><span class="comment">;设置需要守护的进程，此进程必须是前台执行</span></span><br><span class="line"><span class="attr">command</span>=/home/zj-ops/logstash-<span class="number">5.1</span>.<span class="number">1</span>/bin/logstash -f /home/zj-ops/logstash-<span class="number">5.1</span>.<span class="number">1</span>/config/logstash-test.conf</span><br><span class="line"><span class="comment">;主要用于启动时间过长的进程</span></span><br><span class="line"><span class="attr">startsec</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">;是否随supervisor一起启动</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">;不同服务的启动优先级，默认999</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment">;异常退出后是否自动重启</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment">;运行进程的用户</span></span><br><span class="line"><span class="attr">user</span>=zj-ops</span><br><span class="line"><span class="comment">;设置环境变量</span></span><br><span class="line"><span class="attr">environment</span>=JAVA_HOME=/usr/local/jdk1.<span class="number">8.0</span>_121</span><br><span class="line"><span class="comment">;日志配置，配合supervisor日志用于调试进程是否运行</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/tmp/mgt_operation.log</span><br><span class="line"><span class="attr">stderr_logfile</span>=/tmp/mgt_operation.log</span><br></pre></td></tr></table></figure>
<h1 id="配置范例"><a href="#配置范例" class="headerlink" title="配置范例"></a>配置范例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:mgt_user]</span><br><span class="line">command=/home/&#123;&#123; ansible_ssh_user &#125;&#125;/tomcat8/bin/catalina.sh run</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/jdk1.8.0_121&quot;</span><br><span class="line">startsec=100</span><br><span class="line">directory=/home/&#123;&#123; ansible_ssh_user &#125;&#125;</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=&#123;&#123; ansible_ssh_user &#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="命令行管理"><a href="#命令行管理" class="headerlink" title="命令行管理"></a>命令行管理</h1><blockquote>
<p>start、restart、stop都不会载入最新的配置文件。</p>
</blockquote>
<ul>
<li>start xxx 启动某个进程  </li>
<li>stop xxx 停止某个进程  </li>
<li>status xxx 查看进程状态  </li>
<li>restart xxx 重启某个进程  </li>
<li>tail xxx 查看进程的日志  </li>
<li>reload 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程  </li>
<li>update 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。  </li>
</ul>
<h1 id="web管理"><a href="#web管理" class="headerlink" title="web管理"></a>web管理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port=0.0.0.0:9001  </span><br><span class="line">username=user      </span><br><span class="line">password=123456</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统原理-文件系统</title>
    <url>/blog/2019/09/03/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/linux%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>实质：组织和存储数据的一种机制</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><blockquote>
<p>以ls -l命令的输出的第一个符号为区别标志，其中字符设备、块设备、FIFO文件可使用mknod命令创建</p>
</blockquote>
<ul>
<li>普通文件：文本文件、二进制文件、数据文件<ul>
<li>ll表示：首字符显示为”-“</li>
<li>范例：lsof.txt文件：<code>-rw-rw-r-- 1 muker muker 135522 Jul 18 13:17 lsof.txt</code></li>
</ul>
</li>
<li>目录<ul>
<li>ll表示：首字符显示为“d”</li>
<li>范例：roles目录：<code>drwxrwxr-x  7 muker muker  4096 Jun 21 17:31 roles/</code></li>
</ul>
</li>
<li>符号链接：表示软连接<ul>
<li>ll表示：首字符显示为”l”</li>
<li>范例：<code>lrwxrwxrwx. 1 root root 7 Oct 15  2017 /bin/python -&gt; python2</code></li>
</ul>
</li>
<li>套接字文件：用于网络通信<ul>
<li>ll表示：首字符显示为“s”</li>
<li>范例：supervisor程序的socket文件：<code>srwx------ 1 root root 0 May 22 14:33 /var/run/supervisor/supervisor.sock</code></li>
</ul>
</li>
<li>字符设备文件：表示串行端口设备、管道类型设备，提供输入输出功能<ul>
<li>ll表示：首字符显示为”c“</li>
<li>范例：pts虚拟终端：<code>crw--w---- 1 muker tty 136, 0 Jul 19 09:16 /dev/pts/0</code></li>
</ul>
</li>
<li>块设备文件：表示提供存储功能的设备<ul>
<li>ll表示：首字符显示为”b“</li>
<li>范例：vda磁盘：<code>brw-rw---- 1 root disk 253, 0 May 22 17:12 /dev/vda</code></li>
</ul>
</li>
<li>FIFO文件：命名管道文件，提供双向通信<ul>
<li>ll表示：首字符显示为“p”</li>
<li>管道的不同区别：FIFO是命名的双向通道，任何程序任何时间都可以通过此管道进行双向通信；而“|”是无名的单向通道，管道运行完即销毁</li>
</ul>
</li>
</ul>
<h2 id="软链接与硬链接"><a href="#软链接与硬链接" class="headerlink" title="软链接与硬链接"></a>软链接与硬链接</h2><ul>
<li>实质：<ul>
<li>软链接是新建一个文件（软链接使用不同于源文件的新inode号），文件内容记录源文件或目录的路径信息，相当于windows的快捷方式</li>
<li>硬链接相当于为文件建立一个新的索引别名（硬链接和源文件使用相同的inode号），源文件和硬链接除了名称不一样外，其他属性信息完全相同</li>
</ul>
</li>
<li>不能对目录建立硬链接，也不能跨文件系统对文件建立硬链接</li>
<li>可以在同一文件系统或跨文件系统，对目录或文件建立软链接</li>
<li>删除源文件，软链接失效，硬链接依然可以显示文件内容</li>
<li>生产现场经常使用软链接【相对硬链接限制更少】；而许多硬件设备的快照功能则类似硬链接</li>
</ul>
<h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><ul>
<li>原理：linux系统对文件的删除是通过控制文件的link数达到的，而link数主要由i_nlink（硬链接数，磁盘引用次数）和i_count（文件被进程调用的次数，内存引用次数），只有当这两个数值同时为0时，文件（确切的说是文件名及相应的inode）才从文件系统中消失。但此时若无新数据写入或系统未执行磁盘检查收回空间，数据还是可以找回的</li>
<li>删除条件：<ul>
<li>硬链接都被删除（i_nlink为0）</li>
<li>没有被进程调用（i_count）</li>
<li>实际存储空间没有被覆盖或回收</li>
</ul>
</li>
<li>范例：磁盘幽灵空间<ul>
<li>现象：df与du统计相差巨大</li>
<li>原因：文件被删除，但是使用这些文件的进程还在，造成空间不能释放</li>
<li>解决：使用 lsof|grep deleted 查看占用删除文件的进程，重启或删除相关进程</li>
</ul>
</li>
<li>范例：web服务日志写满磁盘，删除日志后，磁盘空间依然充满未被释放；此时重启apache服务，磁盘空间释放，日志可重新写入。</li>
</ul>
<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>默认系统就会启用tmpfs，以实现特殊功能，如保存系统运行状态；tmpfs是临时文件系统，是一种基于内存的文件系统，<br>它和虚拟磁盘ramdis比较类似，但不完全相同。和ramdisk一样，tmpfs可以使用RAM，但它也可以使用swap分区来存储；<br>ramdisk是个传统的块设备，需要使用mkfs格式化后才能使用；tmpfs是一个文件系统，直接挂载就可以使用。  </p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>查看使用情况：df -h</li>
<li>fstab设置：<code>tmpfs                   /dev/shm                tmpfs   defaults,size=64g        0 0</code><ul>
<li>卸载：umount /dev/shm</li>
<li>加载：mount /dev/shm</li>
</ul>
</li>
<li>实时修改tmpfs大小：mount -o remount,size=64G /dev/shm</li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul>
<li>oracle启动错误：<code>ORA-00845: MEMORY_TARGET not supported on this system</code></li>
<li>原因与解决：tmpfs管理下的物理内存或swap不足，此时可通过增加tmpfs大小解决问题（首先增加swap大小）</li>
</ul>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><blockquote>
<p>fdisk -l命令结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disk /dev/sda: 120.0 GB, 120034123776 bytes</span><br><span class="line">255 heads, 63 sectors/track, 14593 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>
<ul>
<li>磁盘容量大小</li>
<li>255个磁头(heads)，63个扇区(sectors)/磁道(track)，14593个柱面(cylinders)</li>
<li>每个柱面大小(units)=扇区数(255<em>63)</em>扇区大小(512)</li>
<li>扇区大小512</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>纵切图看，一个磁盘有多个盘片，每个盘片对于2个盘面，一个盘面对应一个磁头(heads)</li>
<li>横切图看，一个盘面有多个磁道(track)，一个磁道有多个扇区(sector)【磁盘存储的最小单位】</li>
<li>俯视图看，多个盘面相同半径的磁道共同构成一个柱面(cylinders)【磁盘分区的最小单位】</li>
</ul>
<h2 id="容量计算"><a href="#容量计算" class="headerlink" title="容量计算"></a>容量计算</h2><ul>
<li>磁盘容量：磁头数*磁道/柱面数*每道扇区数*扇区大小，即：<code>255*14593*63*512=120031511040</code><ul>
<li>缩写式：柱面大小(units)*柱面数(cylinders)</li>
</ul>
</li>
<li>数据三维地址：磁头、柱面/磁道、扇区</li>
</ul>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><ul>
<li>读写原理：将磁粒子的极性转换为电脉冲信号</li>
<li>读写流程：从盘片的边缘向里依次从0磁道开始读写</li>
</ul>
<h1 id="raid"><a href="#raid" class="headerlink" title="raid"></a>raid</h1><ul>
<li>简介：RAID(redundant arrays of independed disk)：廉价且具有冗余功能的磁盘阵列</li>
<li>功能：提供比单个物理磁盘更大的存储容量及不同级别的数据冗余备份</li>
</ul>
<h2 id="raid0"><a href="#raid0" class="headerlink" title="raid0"></a>raid0</h2><blockquote>
<p>生产中使用单盘也要做成raid0，否则无法使用</p>
</blockquote>
<ul>
<li>原理：将连续的数据交叉存储在多个磁盘上（stripe-条带存储），</li>
<li>容量计算：最少需要1个磁盘，总容量=各盘容量之和</li>
<li>优点：磁盘利用率高【100%】</li>
<li>缺点：无冗余备份，1块磁盘损坏raid就不能使用</li>
</ul>
<h2 id="raid1"><a href="#raid1" class="headerlink" title="raid1"></a>raid1</h2><ul>
<li>原理：将数据分成完全一样的两份写入两块磁盘【mirror-镜像存储】</li>
<li>容量计算：2个磁盘，总容量=最小的那块磁盘</li>
<li>优点：有冗余备份，安全性好</li>
<li>缺点：磁盘利用率低【50%】，成本高</li>
</ul>
<h2 id="raid5"><a href="#raid5" class="headerlink" title="raid5"></a>raid5</h2><ul>
<li>原理：将数据和数据的奇偶校验码交叉存储在不同的磁盘</li>
<li>容量计算：最少需要3个磁盘，总容量=最小磁盘容量*（磁盘数-1）</li>
<li>优点：兼顾安全性和成本【可以损坏1块磁盘，当损坏磁盘大于等于2块时，数据彻底损坏】</li>
<li>热备盘【hot spare】：当阵列中的某颗磁盘损毁时，spare disk被主动拉进阵列，坏磁盘被移除阵列，实时进行数据重建</li>
</ul>
<h2 id="raid10"><a href="#raid10" class="headerlink" title="raid10"></a>raid10</h2><blockquote>
<p>也有raid01，但是服务器常用只有raid10</p>
</blockquote>
<ul>
<li>原理：先组成raid1，再组成raid0</li>
<li>容量计算：最少需要4个磁盘，且为偶数个磁盘，总容量=所有盘容量之和的一般</li>
<li>优点：安全性好</li>
<li>缺点：磁盘利用率低【50%】，成本高</li>
</ul>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul>
<li>分区实质：划分起止柱面号</li>
<li>格式化实质：创建文件系统</li>
<li>分区工具：fdisk【小于2T】和pated【大于2T】</li>
</ul>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/MBR.png" alt></p>
<ul>
<li>MBR(广义)：每个磁盘只有一个主引导扇区，它不属于任何分区【所以格式化不能清除mbr】</li>
<li>物理位置：位于0柱面，0磁道，1扇区</li>
<li>组成：主引导程序、硬盘分区表、硬盘有效标志<ul>
<li>主引导程序（boot-loader）占用446个字节<ul>
<li>包含开机管理程序，直接指向可开机的程序区段，引导操作系统启动</li>
<li>提供多重引导选项，将控制权移交到其他boot-loader</li>
</ul>
</li>
<li>分区表（DPT）占用64字节，每个分区表项长16个字节，一共4个，所以最多4个主分区(磁盘限制)或扩展分区（操作系统显示只能有一个扩展分区）</li>
<li>硬盘有效标志（MN）占2字节，内容：55AA</li>
</ul>
</li>
</ul>
<h2 id="分区构成"><a href="#分区构成" class="headerlink" title="分区构成"></a>分区构成</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/linux%E5%88%86%E5%8C%BA%E6%9E%84%E6%88%90.png" alt></p>
<ul>
<li>组成(格式化后分区构成)：启动扇区、数个块组<ul>
<li>启动扇区(boot sector)<ul>
<li>每个分区都有一个启动扇区</li>
<li>可以装载开机管理程序【boot-loader】，以用于多重引导<ul>
<li>对linux来说，安装时默认在分区boot-sector保存一份boot-loader，可选择是否在MBR保存另一份【只安装linux系统时，则必须在mbr也安装一份】</li>
<li>对windows来说，强制在MBR和分区boot-sector各保存一份boot-loader【所以双os需先安装windows后linux】</li>
</ul>
</li>
</ul>
</li>
<li>块组（block group）</li>
</ul>
</li>
<li>块组（block group）：可通过dumpe2fs查看分区superblock和block group信息<ul>
<li>super block：存储block和inode的大小、已用、未用数量，分区的挂载与否，挂载时间等【每个分区只有一个super block，块组中第一个块组包含超级块，其他块组可能包含super block，但只是作为第一个超级块的备份】</li>
<li>文件系统描述：说明block group、block bitmap、inode bitmap、inode table等的起止block号</li>
<li>block映射表：显示区块号是否被使用</li>
<li>inode映射表：显示inode号是否被使用</li>
<li>inode table：显示文件属性（不包含文件名），显示文件实际存储的block号，常用大小256字节；每个文件一个inode号(指向数据实际存储区域)</li>
<li>data block：用于实际存储数据，块由扇区组成，常用块大小4K；文件根据大小占用数量不等的block<ul>
<li>区块(block)是文件系统读写的最小单位（windows下为簇）</li>
<li>block大小应当适量：block过大浪费磁盘空间；block过小则影响读写速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>安装linux时强制将/boot设为主分区，以使/boot分区位于磁盘的最前面</li>
<li>swap分区非必需的，内存较大负载不高时可以不分。</li>
</ul>
<h1 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h1><ul>
<li>LVM(logical volume manage)逻辑卷管理，一个灵活的扩展分区管理工具</li>
</ul>
<h2 id="新建LVM"><a href="#新建LVM" class="headerlink" title="新建LVM"></a>新建LVM</h2><h3 id="新建LVM分区"><a href="#新建LVM分区" class="headerlink" title="新建LVM分区"></a>新建LVM分区</h3><ul>
<li>新建分区：fdisk /dev/sdb   n,p,w</li>
<li>更改分区类型为lvm：t   8e</li>
</ul>
<h3 id="新建物理卷"><a href="#新建物理卷" class="headerlink" title="新建物理卷"></a>新建物理卷</h3><ul>
<li>新建：pvcreate /dev/sdb1、pvcreate /dev/sdc1</li>
<li>物理卷命令：<ul>
<li>pvcreate  ：将实体 partition 建立成为 PV；</li>
<li>pvscan  ：搜寻目前系统里面任何具有 PV 的磁盘</li>
<li>pvdisplay  ：显示出目前系统上面的 PV 状态；</li>
<li>pvremove  ：将 PV 属性移除，让该 partition不具有PV属性。</li>
</ul>
</li>
</ul>
<h3 id="新建卷组"><a href="#新建卷组" class="headerlink" title="新建卷组"></a>新建卷组</h3><ul>
<li>新建：vgcreate -s 8M cipan /dev/sdb1 /dev/sdc1【在磁盘分区sdb1，sdc1上创建pe大小为8M，名称为cipan的卷组】</li>
<li>卷组命令：<ul>
<li>vgcreate  ：就是主要建立 VG 的指令</li>
<li>vgscan  ：搜寻系统上面是否有 VG 存在</li>
<li>vgdisplay  ：显示目前系统上面的 VG 状态</li>
<li>vgextend  ：在 VG 内增加额外的 PV  </li>
<li>vgreduce  ：在 VG 内移除 PV </li>
<li>vgchange  ：设定 VG 是否启动 (active) </li>
<li>vgremove  ：移除一个 VG </li>
</ul>
</li>
</ul>
<h3 id="新建逻辑卷"><a href="#新建逻辑卷" class="headerlink" title="新建逻辑卷"></a>新建逻辑卷</h3><ul>
<li>新建：lvcreate -L 5G -n juan1 cipan【在卷组cipan中添加大小为5G名称为juan1的逻辑卷】</li>
<li>逻辑卷命令：<ul>
<li>lvcreate  ：建立 LV 啦</li>
<li>lvscan  ：查询系统上面的 LV </li>
<li>lvdisplay  ：显示系统上面的 LV 状态啊</li>
<li>lvextend  ：在 LV 里面增加容量</li>
<li>lvreduce  ：在 LV 里面减少容量</li>
<li>lvremove  ：移除一个 LV  </li>
<li>lvresize  ：对 LV 迚行容量大小的调整</li>
</ul>
</li>
</ul>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/cipan/juan1 </span><br><span class="line">mkdir /juan</span><br><span class="line">mount /dev/cipan/juan1 /juan/</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h2 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h2><ul>
<li>新建分区：fdisk /dev/sdd</li>
<li>新建物理卷：pvcreate /dev/sdd1</li>
<li>扩容卷组：vgextend  /dev/cipan  /dev/sdd1</li>
<li>扩容逻辑卷：lvextend -L 8G /dev/cipan/juan1</li>
<li>文件系统扩容：resize2fs -p /dev/cipan/juan1</li>
<li>逻辑卷重新挂载：mount -o remount,rw /juan/</li>
</ul>
<h2 id="LVM减容"><a href="#LVM减容" class="headerlink" title="LVM减容"></a>LVM减容</h2><ul>
<li>卸载逻辑卷：umount /dev/cipan/juan1</li>
<li>文件系统减容：resize2fs /dev/cipan/juan1 4G <ul>
<li>减容前 强制逻辑卷检查：fsck -f /dev/cipan/juan1</li>
</ul>
</li>
<li>逻辑卷减容：lvreduce -L 4G /dev/cipan/juan1</li>
<li>挂载逻辑卷：mount /dev/cipan/juan1 /juan</li>
<li>卷组减容【后续】：vgreduce /dev/cipan /dev/sdc1</li>
</ul>
<h2 id="删除LVM"><a href="#删除LVM" class="headerlink" title="删除LVM"></a>删除LVM</h2><ul>
<li>卸载逻辑卷：umount /dev/cipan/juan1</li>
<li>删除逻辑卷：lvremove juan1</li>
<li>删除卷组：vgremove cipan</li>
<li>删除物理卷：pvremove /dev/sdb1</li>
</ul>
<h1 id="开机过程"><a href="#开机过程" class="headerlink" title="开机过程"></a>开机过程</h1><blockquote>
<p>centos6系统启动过程</p>
</blockquote>
<p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.bmp" alt></p>
<ul>
<li>BIOS开机自检：检测硬件是否存在故障；根据bios设置确定引导次序</li>
<li>MBR引导：bios读取MBR中的boot-loader（grub程序）</li>
<li>grub引导【可选】：grub程序读取grub配置(grub.conf)，显示grub菜单选项（将开机管理功能转交给其他loader（boot sector）负责）</li>
<li>加载kernel(此时kernel从bios取得系统控制权,并再次扫描硬件情况)和initrd，挂载根文件系统rootfs，并切换到根目录<ul>
<li>initrd：虚拟文件系统，在内存中仿真成根目录；它包含一个可执行程序，能够帮助kenel加载真实根文件系统rootfs所需驱动程序</li>
</ul>
</li>
<li>启动init进程，读取配置文件【/etc/inittab或/etc/init目录下所有文件】，确定启动级别</li>
<li>读取/etc/rc.sysinit文件，完成系统初始化设定<ul>
<li>激活udev和selinux</li>
<li>设置内核参数/etc/sysctl.conf</li>
<li>设置系统时钟</li>
<li>设置网卡</li>
<li>启用交换分区</li>
<li>加载键盘映射</li>
<li>激活RAID和lvm逻辑卷</li>
<li>挂载额外的文件系统/etc/fstab</li>
<li>设置环境变量</li>
</ul>
</li>
<li>根据启动级别加载相应级别/etc/rc*.d下的服务脚本</li>
<li>执行/etc/rc.local中用户自定义脚本</li>
<li>使用Mingetty命令调出tty终端或使用prefdm调出x-windows供终端用户登录</li>
</ul>
<h2 id="启动级别"><a href="#启动级别" class="headerlink" title="启动级别"></a>启动级别</h2><ul>
<li>0   关机</li>
<li>1   单用户模式</li>
<li>2   无网络多用户命令行模式</li>
<li>3   有网络多用户命令行模式</li>
<li>4   不可用</li>
<li>5   带图形界面的多用户模式</li>
<li>6   重启</li>
</ul>
<h2 id="grub-conf配置"><a href="#grub-conf配置" class="headerlink" title="grub.conf配置"></a>grub.conf配置</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/linux-grub_conf.png" alt></p>
<h2 id="inittab详解"><a href="#inittab详解" class="headerlink" title="inittab详解"></a>inittab详解</h2><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/linux-inittab.png" alt></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/Apollon_krj/article/details/77869770" target="_blank" rel="noopener">MBR和启动扇区</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title>shell命令行</title>
    <url>/blog/2019/08/27/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/shell%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><ul>
<li><a href="#crontab">crontab</a>：设置周期性任务</li>
<li>at：一次性任务（使用较少）</li>
<li>head -n：显示前n行内容【默认10】</li>
<li>tail：末尾显示<ul>
<li>-n：显示末尾n行内容【默认10】</li>
<li>-f：持续追踪末尾输出</li>
</ul>
</li>
<li>echo：回显文本<ul>
<li>-e：支持特殊转义符：【\n \t等】</li>
<li>-n：移除末尾换行</li>
</ul>
</li>
<li><a href="#read">read</a>：从标准输入读取一行内容</li>
<li>seq <code>[start [step]]</code> end：打印数字序列<ul>
<li>-f printf格式</li>
<li>-s 分隔符【默认\n】</li>
<li>-w 列表前加0使宽度相等</li>
</ul>
</li>
<li>man：查看命令man文档</li>
<li>xargs：从标准输入读取内容，构建并执行命令【一般用于不支持管道的命令，如ls；或一次无法处理过多参数的命令，如rm】<ul>
<li>-I <code>{}</code>：指定替换字符串（一般使用<code>{}</code>）：find . -type f|xargs -I {} mv {} ..</li>
<li>-a file：从文件中读取内容：xargs -a /etc/hosts -I {} echo {}</li>
<li>-d delimiter：定义输入分隔符【单字符，默认为换行符】</li>
</ul>
</li>
<li>reboot、init、shutdown、poweroff、halt：服务器启停控制</li>
<li>history：查看命令历史【-c 清除命令历史】</li>
<li>which：查看命令全路径</li>
<li>time：执行时间统计</li>
<li>watch：周期性的执行程序，同时全屏显示输出</li>
<li>alias、unalias：命令别名</li>
<li>ulimit：控制shell终端可使用的资源</li>
<li>whatis：显示命令含义</li>
<li>logger：向syslog写入特定信息<ul>
<li>-i 在每行都记录进程ID</li>
<li>-t logger_test 每行记录都加上“logger_test”这个标签</li>
<li>-p local3.notice 设置记录的设备和级别</li>
<li>范例：echo “this is message”|logger -it logger_test -p local3.notice</li>
</ul>
</li>
<li>dmesg：系统启动过程</li>
<li>uname：显示系统信息</li>
<li>dmidecode：查询bios信息</li>
<li><a href="#时间">date</a>：时间</li>
</ul>
<h1 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h1><ul>
<li><a href="#chkconfig">chkconfig</a>：自启动管理【centos6】</li>
<li><a href="#systemctl">systemctl</a>：服务控制【centos7】</li>
<li><a href="#rpm">rpm</a>：rpm包安装、卸载、查询</li>
<li><a href="#yum">yum</a></li>
<li><a href="#dpkg">dpkg</a></li>
<li><a href="#apt">apt</a></li>
<li><a href="#程序源码安装">源码安装</a></li>
</ul>
<h2 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h2><ul>
<li>sysV是centos6之前控制系统服务的工具<ul>
<li>chkconfig是管理系统各个运行级别下服务的启停</li>
<li>service则控制系统服务的启停</li>
</ul>
</li>
<li>system是centos7控制系统服务的工具<ul>
<li>systemctl</li>
</ul>
</li>
<li>系统运行级别：<ul>
<li>0：关机</li>
<li>1：单用户模式</li>
<li>2：无网络多用户命令行模式</li>
<li>3：有网络多用户命令行模式</li>
<li>4：不可用</li>
<li>5：带图形界面的多用户模式</li>
<li>6：重启</li>
</ul>
</li>
</ul>
<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>/etc/cron.deny：不允许使用cron的用户</li>
<li>/var/spool/cron：所有用户cron文件存放的目录</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-u：指定要操作cron的用户【默认操作自己的cron】</li>
<li>-l：查看crontab配置内容</li>
<li>-r：删除crontab</li>
<li>-e：编辑crontab</li>
</ul>
<h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><table>
<thead>
<tr>
<th>*</th>
<th>8-18</th>
<th>*</th>
<th>5</th>
<th>0,1,4</th>
</tr>
</thead>
<tbody>
<tr>
<td>每分钟执行一次</td>
<td>8点到18点</td>
<td>忽略此项</td>
<td>5月份</td>
<td>周日，周一，周四</td>
</tr>
</tbody>
</table>
<ul>
<li>字段1：一个小时的第几分（0-59）</li>
<li>字段2：一天的第几小时（0-23）</li>
<li>字段3：一个月中的第几天（1-31）</li>
<li>字段4：一年中的第几月（1-12）</li>
<li><p>字段5：一周中的第几天（0-7）【0,7都是周日】</p>
</li>
<li><p>其他选项</p>
<ul>
<li>*：所有时间点</li>
<li>-：连续的时间段</li>
<li>,：间隔的时间点</li>
<li>/：时间频率</li>
</ul>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>命令行或脚本试验后【如变量、特殊字符处理】，crontab里书写</li>
<li>使用&amp;&amp;连接先后顺序的命令</li>
<li>定时任务结尾加&gt;/dev/null 2&gt;&amp;1 【重定向所有输出到空设备】</li>
<li>添加注释</li>
</ul>
<h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><p>从标准输入读取一行内容，语法：read <code>[选项]</code> name-1 <code>[... name-n]</code></p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-a：将空格分隔的多个字符串组成一个数组赋值给变量name</li>
<li>-d：定义行终止符【默认换行符\n】</li>
<li>-p：设置提示语</li>
<li>-s：隐藏输入内容【可用于密码输入】</li>
<li>-t：设置交互式超时时间</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>readline：<code>while read line;do echo $line;sleep 2;done &lt; /etc/hosts</code></li>
<li>read：<code>read -p &#39;pls input you name:&#39; -t 30 -d \# -s name</code></li>
</ul>
<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="BIOS与系统时间"><a href="#BIOS与系统时间" class="headerlink" title="BIOS与系统时间"></a>BIOS与系统时间</h2><p>系统每次启动时会读取BIOS时间，将之赋给系统时间；之后系统时间将独立运行。</p>
<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><blockquote>
<p>显示或设置系统时间</p>
</blockquote>
<ul>
<li>-d, –date=STRING：显示指定描述的时间</li>
<li>-f, –file=DATEFILE：从文件中读取并显示指定描述的时间【一行一个】</li>
<li>-s, –set=STRING：根据字符串的描述设置时间</li>
</ul>
<h3 id="时间字符串"><a href="#时间字符串" class="headerlink" title="时间字符串"></a>时间字符串</h3><p>时间字符串可以是任何人类可读的用于标识时间的字符串，比如：</p>
<ul>
<li>Sun, 29 Feb 2004 16:21:42 -0800</li>
<li>2004-02-29 16:21:42</li>
<li>next Thursday</li>
<li>3 hours</li>
<li>-3 years</li>
</ul>
<h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><ul>
<li>简单表示法：“date +%D\ %T”</li>
<li>全量表示法：“date +%Y-%m-%d\ %H:%M:%S”</li>
<li>3天前表示：“date -d “-3 days””</li>
</ul>
<h2 id="时间设置"><a href="#时间设置" class="headerlink" title="时间设置"></a>时间设置</h2><ul>
<li>手动设置系统时间：date -s “01/01/2014 13:16:13”</li>
<li>使用ntp同步时间服务器：ntpdate -u time.windows.com</li>
<li>将系统时间写入bios：clock -w</li>
</ul>
<h2 id="ntpdate与ntpd的区别"><a href="#ntpdate与ntpd的区别" class="headerlink" title="ntpdate与ntpd的区别"></a>ntpdate与ntpd的区别</h2><ul>
<li>ntpd在实际同步时间时是一点点的校准过来时间的，最终把时间慢慢的校正对。</li>
<li>ntpdate不会考虑其他程序是否会阵痛，直接调整时间。</li>
</ul>
<h1 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h1><ul>
<li>-qa：查询软件是否安装【grep】</li>
<li>-qf：查询文件属于哪个软件包</li>
<li>-ql：查询软件包的展开文件列表</li>
<li>-ivh：安装软件</li>
<li>-e：卸载软件</li>
</ul>
<h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><p>是一个在rhel、Centos、SUSE中的shell前端软件包管理器，能从指定的服务器自动下载和安装软件包，并解决软件之间的依赖性。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>yum list|grouplist：查看yum源上可用安装包、包组</li>
<li>yum info：查看软件信息</li>
<li>yum search：yum源搜索软件</li>
<li>yum install|groupinstall：安装单个软件、包组</li>
<li>yum reinstall： 重装软件</li>
<li>yum update|groupupdate： 软件更新【有参时更新个别，无参全部更新】</li>
<li>yum remove|groupremove：移除单个软件、包组</li>
<li>yum clean all：清除yum缓存</li>
<li>yum makecache：生成yum缓存</li>
<li>yum provides */command：查询包含命令command的软件包</li>
</ul>
<h2 id="软件源设置"><a href="#软件源设置" class="headerlink" title="软件源设置"></a>软件源设置</h2><blockquote>
<p>文件必须位于/etc/yum.repos.d下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[local]                --yum源标题</span><br><span class="line">name=local          ---》yum源名称</span><br><span class="line">baseurl=file:///media  ---》yum源路径</span><br><span class="line">enable=1             引导文件起作用</span><br><span class="line">gpgcheck=0          ---》不进行md5校验</span><br></pre></td></tr></table></figure>
<h1 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h1><ul>
<li>-i：安装deb软件</li>
<li>-r：删除软件</li>
<li>-P：删除软件和配置</li>
<li>-l：显示软件列表</li>
</ul>
<h1 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h1><ul>
<li>update：更新软件</li>
<li>upgrade：升级软件</li>
<li>install：安装软件</li>
<li>remove：删除已安装软件</li>
<li>purge：删除软件和配置文件</li>
<li>apt-cache search：在本地搜索软件【apt update更新后本地形成缓存】</li>
</ul>
<h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>设置/etc/apt/sources.list</p>
<h1 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h1><ul>
<li>–add：添加服务，Chkconfig确保每个运行级别都有一项启动（S）或者停止（K）入口。若有缺少，则会从缺省的init脚本中自动创建。<ul>
<li>范例：chkconfig –add httpd</li>
</ul>
</li>
<li>–del：删除服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件中（<code>/etc/rc[0-6].d</code>）删除相关数据<ul>
<li>范例：chkconfig –del httpd</li>
</ul>
</li>
<li>–list：默认显示所有运行级别下所有服务的运行状态（on或off）；若指定了服务，则显示指定服务所有运行级别的运行状态<ul>
<li>范例：chkconfig –list mysqld</li>
</ul>
</li>
<li>–level：对指定运行级别下的指定服务进行操作（开启、关闭或初始化）；不加参数时，对于【on】或【off】命令，系统默认只对级别2,3,4,5进行操作；<ul>
<li>范例：chkconfig –level httpd 2345 on</li>
</ul>
</li>
</ul>
<h1 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h1><h2 id="systemd添加服务"><a href="#systemd添加服务" class="headerlink" title="systemd添加服务"></a>systemd添加服务</h2><ul>
<li>将服务控制文件放入/usr/lib/systemd/system/</li>
<li>systemd服务重载配置：systemctl daemon-reload</li>
</ul>
<h2 id="systemd管理"><a href="#systemd管理" class="headerlink" title="systemd管理"></a>systemd管理</h2><ul>
<li>查看已经启动的服务：systemctl list-units –type=service</li>
<li>查看所有服务：systemctl list-units –type=service –all</li>
<li>开机启动：systemctl enable crond</li>
<li>关闭开启启动：systemctl disable crond</li>
<li>是否开机启动：systemctl is-enabled crond</li>
<li>服务状态：systemctl status crond</li>
<li>开启服务：systemctl start crond</li>
<li>关闭服务：systemctl stop crond</li>
<li>重启服务：systemctl restart crond</li>
</ul>
<h1 id="非编译二进制程序安装"><a href="#非编译二进制程序安装" class="headerlink" title="非编译二进制程序安装"></a>非编译二进制程序安装</h1><ul>
<li><p>下载可执行程序到工作目录</p>
</li>
<li><p>准备二进制程序启动所需配置文件</p>
</li>
<li><p>准备服务可systemd管理的文件/usr/lib/systemd/system/XXXXXX.service</p>
<ul>
<li>指定二进制文件路径</li>
<li>指定程序主配置文件</li>
<li>指定程序其他启动参数</li>
</ul>
</li>
<li><p>启动服务并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start XXXXXX</span><br><span class="line">systemctl enable XXXXXX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="程序源码安装"><a href="#程序源码安装" class="headerlink" title="程序源码安装"></a>程序源码安装</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>开放源码：人可以看懂的文本类型的程序源码</li>
<li>编译程序：将程序源码编译成机器可以看懂的语言，类似翻译者的角色</li>
<li>可执行程序：开放源码经过编译生成的二进制文件，机器可以看懂并执行</li>
</ul>
<h2 id="安装前置条件"><a href="#安装前置条件" class="headerlink" title="安装前置条件"></a>安装前置条件</h2><ul>
<li>系统核心是否适合本软件</li>
<li>是否有编译程序【gcc、make、autoconfig等】</li>
<li>是否存在本软件所需要的函数库或其他依赖软件</li>
<li>是否存在核心的头文件（header include）</li>
</ul>
<h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ul>
<li>解压：将压缩类型文件【如tar.gz等格式】展开成文本类型普通文件</li>
<li>configure（配置编译参数）：测试系统环境是否满足软件安装的需求，满足后，根据某些用户的自定义项生成源码如何编译的规则文件makefile</li>
<li>make：根据makefile的编译规则，使用源码、编译程序、依赖的库函数编译程序，生成二进制文件</li>
<li>make install：将make产生的二进制文件和配置文件安装在自己的主机上</li>
</ul>
<h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><p>函数库依照是否被编译到程序内部分为动态库和静态库【查看可执行程序的动态库：ldd binary-file】</p>
<table>
<thead>
<tr>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩展名通常为libxxx.a</td>
<td>扩展名通常为libxxx.a</td>
</tr>
<tr>
<td>此类函数库在编译时直接整合到可执行程序中【生成的可执行程序较大】</td>
<td>编译时仅将函数库的位置点编入程序，因此生成的可执行程序较小</td>
</tr>
<tr>
<td>可执行程序可独立执行</td>
<td>程序不能被独立执行，要确保函数库位置不变且必须存在</td>
</tr>
<tr>
<td>函数库升级后，所有包含次函数的可执行程序必须重新编译</td>
<td>函数库升级后，程序无需变更【函数名不变】</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统监控inotify</title>
    <url>/blog/2019/05/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7inotify/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>inotify是一个细粒度的异步文件监控系统，可以监控文件发生的一切变化，如：</p>
<ul>
<li>访问属性</li>
<li>读写属性</li>
<li>权限属性</li>
<li>删除</li>
<li>移动</li>
</ul>
<p>inotify-tools是linux下使用inotify接口的简单实现</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="内核检查"><a href="#内核检查" class="headerlink" title="内核检查"></a>内核检查</h2><p><code>ls -l /proc/sys/fs/inotify/</code></p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul>
<li>【centos】：yum install inotify-tools -y</li>
<li>【ubuntu】：apt install inotify-tools -y</li>
</ul>
<h2 id="安装检查"><a href="#安装检查" class="headerlink" title="安装检查"></a>安装检查</h2><p>安装完成后会得到两个命令:inotifywait和inotifywatch</p>
<h1 id="inotify事件"><a href="#inotify事件" class="headerlink" title="inotify事件"></a>inotify事件</h1><table>
<thead>
<tr>
<th>事件</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>access</td>
<td>访问或读取</td>
</tr>
<tr>
<td>modify</td>
<td>内容变更</td>
</tr>
<tr>
<td>attrib</td>
<td>属性变更</td>
</tr>
<tr>
<td>close</td>
<td>文件或目录关闭</td>
</tr>
<tr>
<td>open</td>
<td>文件或目录打开</td>
</tr>
<tr>
<td>move</td>
<td>文件或目录移动</td>
</tr>
<tr>
<td>create</td>
<td>新建文件或目录</td>
</tr>
<tr>
<td>delete</td>
<td>文件或目录删除</td>
</tr>
</tbody>
</table>
<h1 id="inotifywatch"><a href="#inotifywatch" class="headerlink" title="inotifywatch"></a>inotifywatch</h1><p>统计文件和目录发生的变化</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-z –zero 输出表格的行和列，即使元素为空</li>
<li>–exclude 正则匹配需要排除的文件，大小写敏感</li>
<li>–excludei 正则匹配需要排除的文件，大小写忽略</li>
<li>-r –recursie 监控一个目录下的所有子目录</li>
<li>-t –timeout 设置超时时间</li>
<li>-e –event <code>&lt;event1&gt;</code>监控指定的事件，多个事件之间逗号分隔</li>
<li>-a|–ascending <code>&lt;event&gt;</code> 升序统计指定事件</li>
<li>-d|–descending <code>&lt;event&gt;</code> 降序统计指定事件</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>inotifywatch -v -e access -e modify -t 60 -r /home</p>
<h1 id="inotifywait"><a href="#inotifywait" class="headerlink" title="inotifywait"></a>inotifywait</h1><p>等待文件或目录发生的变化</p>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-m|–monitor 接收一个事件而不退出，无限执行下去。默认接受一个事件后退出</li>
<li>-d|–daemon 和-m一样，但是在后台执行，同时必须指定–outfile选项，包含–syslog</li>
<li>-o|–outfile <code>&lt;file&gt;</code> 输出事件到文件</li>
<li>-s|–syslog 输出错误到系统日志</li>
<li>-r –recursie 监控一个目录下的所有子目录</li>
<li>-q|–quiet 不输出详细信息（指定2次时，除了致命错误，不会输出任何信息)</li>
<li>–exclude 正则匹配需要排除的文件，大小写敏感</li>
<li>–excludei 正则匹配需要排除的文件，大小写忽略</li>
<li>-t –timeout 接收一个事件前的超时退出时间，0为永不超时；但是接收一个事件后会退出</li>
<li>-e –event <code>&lt;event1&gt;</code>监控指定的事件，多个事件之间逗号分隔</li>
<li>-c|–csv 输出csv格式</li>
<li>–timefmt <code>&lt;fmt&gt;</code> 指定时间格式<ul>
<li>–timefmt ‘%y-%m-%d %H:%M’</li>
</ul>
</li>
<li>–format <code>&lt;fmt&gt;</code> 指定输出信息格式<ul>
<li>–format ‘%T %f %e’</li>
<li>%w 发生事件的目录</li>
<li>%f 发生事件的文件</li>
<li>%e 发生的事件</li>
<li>%T timefmt定义的时间格式</li>
</ul>
</li>
</ul>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><ul>
<li>监控事件：inotifywait -mrq -e ‘create,delete,close_write,attrib,moved_to’ –timefmt ‘%Y-%m-%d %H:%M’ –format ‘%T %f %e’ /tmp/</li>
<li>排除特定的目录和文件不予监控：<code>inotifywait -mrq --exclude &quot;.*\.py|test.*/\..*&quot; -e &quot;open,access,modify&quot; python_scripts/</code>【此例为排除python_scripts下的py文件和test**目录下的隐藏文件】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-05-21 19:53 xiaoke.txt CREATE  </span><br><span class="line">2018-05-21 19:53 xiaoke.txt ATTRIB  </span><br><span class="line">2018-05-21 19:53 xiaoke.txt CLOSE_WRITE,CLOSE  </span><br><span class="line">2018-05-21 19:54 xiaoke.txt DELETE</span><br></pre></td></tr></table></figure>
<h1 id="rsync-inotify"><a href="#rsync-inotify" class="headerlink" title="rsync+inotify"></a>rsync+inotify</h1><p>可实现单向的目录或文件的实时同步</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li>安装并配置rsync【daemon模式服务端与客户端设置】</li>
<li>安装inotify</li>
<li>编写实时同步脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">src=/oldboy</span><br><span class="line">dst=oldboy</span><br><span class="line">user=backup_user</span><br><span class="line">host=192.168.1.1</span><br><span class="line">inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format &apos;%T %w%f%e&apos; -e modify,delete,create,attrib $src \</span><br><span class="line">| while read files</span><br><span class="line">        do</span><br><span class="line">        cd $src &amp;&amp; rsync -arzu -R --delete --timeout=100 --password-file=/etc/rsyncd.pass ./ $user@$host::$dst  </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ul>
<li>将同步脚本放入后台执行【nohup cmd &amp;或supervisor方式】</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>rsync的客户端和服务端的密码文件内容不同<ul>
<li>服务端含用户名和密码</li>
<li>客户端只有密码</li>
</ul>
</li>
<li>服务端和客户端的密码文件权限相似<ul>
<li>属主只能是运行用户</li>
<li>权限只能是0600</li>
</ul>
</li>
<li>rsync-daemon端要关闭防火墙和selinux</li>
<li>若要同步目录的内容一定要进入目录后再进行同步，否则会将客户端的目录作为服务端模块下的子目录进行同步</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>inotify</tag>
      </tags>
  </entry>
  <entry>
    <title>文件同步rsync</title>
    <url>/blog/2018/02/26/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5rsync/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>远程同步：remote synchronization</li>
<li>是一个快速的、全能的远程或本地的文件复制工具</li>
<li>只支持本地、本地与远程之间的文件拷贝，不支持俩个远程主机之间的文件拷贝</li>
<li>当只有源没有目标指定时，命令类似于【ls -l】</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h2><p>rsync [OPTION…] SRC… [DEST]</p>
<h2 id="远程shell模式"><a href="#远程shell模式" class="headerlink" title="远程shell模式"></a>远程shell模式</h2><ul>
<li>Pull: rsync [OPTION…] [USER@]HOST:SRC… [DEST]</li>
<li>Push: rsync [OPTION…] SRC… [USER@]HOST:DEST</li>
</ul>
<h2 id="远程daemon模式"><a href="#远程daemon模式" class="headerlink" title="远程daemon模式"></a>远程daemon模式</h2><ul>
<li>Pull<ul>
<li>rsync [OPTION…] [USER@]HOST::SRC… [DEST]</li>
<li>rsync [OPTION…] rsync://[USER@]HOST[:PORT]/SRC… [DEST]</li>
</ul>
</li>
<li>Push<ul>
<li>rsync [OPTION…] SRC… [USER@]HOST::DEST</li>
<li>rsync [OPTION…] SRC… rsync://[USER@]HOST[:PORT]/DEST</li>
</ul>
</li>
</ul>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul>
<li>支持拷贝链接、设备、属主、属组、权限</li>
<li>类似于tar命令一样的排除选项</li>
<li>类似于版本控制系统一样的排除模式</li>
<li>可以使用任何的远程管道方式传输，包括ssh、rsh等</li>
<li>不需要超级用户权限</li>
<li>最小花费的管道传输</li>
<li>支持匿名和认证的rsync进程模式</li>
</ul>
<h1 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h1><blockquote>
<p>目录末尾加斜线，则只拷贝目录内的内容；与此相反，没有斜线时，会拷贝目录本身以及目录下的内容。</p>
</blockquote>
<ul>
<li>-e 指定远程shell选项，如：-e ‘ssh -p 50121’</li>
<li>–password-file 指定连接rsync daemon的密码文件</li>
<li>-C –cvs-exclude 和版本控制系统一样忽略文件</li>
<li>-v ,–verbose  显示传输详情</li>
<li>-z , - -compress 压缩传输</li>
<li>-a ,- -archive 归档模式，表示以递归方式传输文件，并保持文件属性不变</li>
<li>-P ,- -progress 显示传输进度</li>
<li>–delete 保持源和目标文件的一致性，如果目标的文件在源没有则删除</li>
<li>–delete-before 在传输前删除相关文件</li>
</ul>
<h1 id="include与exclude"><a href="#include与exclude" class="headerlink" title="include与exclude"></a>include与exclude</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>–exclude=PATTERN       exclude files matching PATTERN</li>
<li>–exclude-from=FILE     read exclude patterns from FILE</li>
<li>–include=PATTERN       don’t exclude files matching PATTERN</li>
<li>–include-from=FILE     read include patterns from FILE</li>
</ul>
<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><ul>
<li>当要排除特定内容时，可以只使用exclude选项以排除指定的文件或目录</li>
<li>但要只包含特定内容时，必须先使用include包含特定内容，再使用exclude排除其余部分</li>
<li>.当使用include-from或exclude-from包含文件时，一行一个匹配规则， <ul>
<li>include选项引用时，规则行首使用“+”</li>
<li>exclude选项引用时，规则行首使用“-”</li>
</ul>
</li>
<li>匹配规则以“/”开始时，则传输根路径上的文件和目录都匹配</li>
<li>匹配规则以“/”结束，则只匹配目录</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><blockquote>
<p>只同步部分目录及其下的目录和文件</p>
</blockquote>
<ul>
<li>include：rsync -azvP –include “pre/“ –include “keyfile/“ –exclude “/*” files/ test </li>
<li>include-from：rsync -azvP –include-from include_file.list –exclude “/*” python_scripts/ test11/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include_file.list文件</span><br><span class="line">+ test1  </span><br><span class="line">+ test2</span><br></pre></td></tr></table></figure>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><blockquote>
<p>排除部分不需要同步的目录</p>
</blockquote>
<ul>
<li>exclude：rsync -azvP –exclude “prod/“ files/ test </li>
<li>exclude-from：rsync -azvP –exclude-from exclude_file.list python_scripts/ test11/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exclude_file.list文件</span><br><span class="line">- aa</span><br><span class="line">- socket_tcp.py</span><br><span class="line">- test1/test234</span><br></pre></td></tr></table></figure>
<h1 id="daemon模式"><a href="#daemon模式" class="headerlink" title="daemon模式"></a>daemon模式</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>rsyncd.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rsyncd.conf</span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = 2000</span><br><span class="line">timeout = 600</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">ignore errors</span><br><span class="line">read only = false</span><br><span class="line">list = false</span><br><span class="line">hosts allow = 172.16.1.0/24</span><br><span class="line">hosts deny = 0.0.0.0/32</span><br><span class="line">auth users = tridge, susan</span><br><span class="line">secrets file = /etc/rsync.password</span><br><span class="line">[backup]</span><br><span class="line">comment = backup</span><br><span class="line">path = /backup</span><br><span class="line">[share]</span><br><span class="line">comment = share</span><br><span class="line">path = /share</span><br></pre></td></tr></table></figure>
<ul>
<li>rsync.password<ul>
<li>文件属主：chown rsync.rsync rsync.password</li>
<li>文件权限：chmod 0600 rsync.password</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tridge:mypass</span><br><span class="line">susan:herpass</span><br></pre></td></tr></table></figure>
<h2 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h2><ul>
<li>默认配置 <ul>
<li>默认使用873端口</li>
<li>默认配置文件/etc/rsyncd.conf</li>
</ul>
</li>
<li>启动<ul>
<li>rsync –daemon –config=config_file</li>
</ul>
</li>
</ul>
<h2 id="daemon错误集锦"><a href="#daemon错误集锦" class="headerlink" title="daemon错误集锦"></a>daemon错误集锦</h2><ul>
<li>服务端有防火墙阻挡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@client-2 log]# rsync -avzP messages_2014-03-30.tar.gz susan@192.168.100.1::oldboy --password-file=/etc/rsyncd.secrets</span><br><span class="line">rsync: failed to connect to 192.168.100.1: No route to host (113)</span><br><span class="line">rsync error: error in socket IO (code 10) at clientserver.c(124) [sender=3.0.6]</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端log显示secrets file权限有问题，此文件不能被其他人读取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># client</span><br><span class="line">[root@client-3 mnt]# rsync -avzP /mnt rsync1@192.168.100.2::oldboy</span><br><span class="line">Password: </span><br><span class="line">@ERROR: auth failed on module oldboy</span><br><span class="line">rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]</span><br><span class="line"></span><br><span class="line"># server</span><br><span class="line">2014/04/11 16:22:26 [1768] secrets file must not be other-accessible (see strict modes option)</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端提示secrets file权限有问题，此文件不能被其他人读取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@client-3 mnt]# rsync -avzP /mnt rsync1@192.168.100.2::oldboy --password-file=/etc/rsyncd.secrets </span><br><span class="line">password file must not be other-accessible</span><br><span class="line">continuing without password file</span><br></pre></td></tr></table></figure>
<ul>
<li>ssh使用系统账号登陆</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@client-2 oldboy]# rsync -avzP -e &quot;ssh -p 22&quot; /etc/hosts susan@192.168.100.1::oldboy --password-file=/etc/rsyncd.secrets</span><br><span class="line">susan@192.168.100.1&apos;s password: </span><br><span class="line">rsync error: received SIGINT, SIGTERM, or SIGHUP (code 20) at rsync.c(544) [sender=3.0.6]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>文本处理语言-awk</title>
    <url>/blog/2019/07/06/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80-awk/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>awk是用于文本检索和处理的语言</li>
<li>awk程序是由一系列的pattern-action以及可选的函数定义组成</li>
<li>可以在命令行中输入短程序文本(通常使用单引号括起来以避免被shell解释)，也可以使用-f选项从文件中读取长的awk程序</li>
<li>读取的数据源可以是命令行的文件列表或标准输入</li>
<li>输入的数据被记录分隔符RS(RS默认为”\n“)切分为多条记录，每个记录都会与每个模式进行比较，如果匹配则执行{action}的程序文本</li>
</ul>
<h1 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h1><h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><ul>
<li>awk <a href="#选项">选项</a> -f <a href="#awk程序">awk程序文件</a> 待处理的文本文件</li>
<li>awk 选项 awk程序文本 待处理的文本文件</li>
</ul>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-f awk程序文件</li>
<li>-F 定义分隔符【也可使用变量FS】，可以同时定义多个分隔符<ul>
<li>范例：<code>ifconfig eth0|awk -F&#39;[ :]*&#39; &#39;NR==2{print $3}&#39;</code>【同时使用任意多个空格和任意多个冒号作为分隔符】</li>
</ul>
</li>
<li>-v var=val 定义变量【定义程序执行前的变量】</li>
<li>-e awk程序文本【可省略】</li>
</ul>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul>
<li>命令行-v指定的变量</li>
<li>BEGIN指定的规则</li>
<li>处理命令行下引用的每一个源文件【ARGV方式调用】</li>
<li>使用pattern匹配每一个record，匹配成功则执行actions</li>
<li>所有record处理完成后，执行END规则</li>
</ul>
<h1 id="awk程序"><a href="#awk程序" class="headerlink" title="awk程序"></a>awk程序</h1><ul>
<li>awk程序是由一系列的<a href="#awk模式">pattern</a> { <a href="#awk执行">action</a> }以及可选的函数定义组成</li>
<li>awk是面向行的语言，先是模式(pattern)，后是行为(action)，并且pattern和action是捆绑在一起的【模式控制的动作从紧挨的第一个花括号开始到第一个花括号结束】</li>
<li>pattern或action其中之一可能不存在，但不可能出现二者都缺失的情况；假如pattern缺失，则action应用于每一行记录；如果action缺失，则相当于action是{print}【即打印整行记录】</li>
</ul>
<h2 id="awk模式"><a href="#awk模式" class="headerlink" title="awk模式"></a>awk模式</h2><ul>
<li>BEGIN/END：<ul>
<li>BEGIN和END模式不对输入进行测试【也即不需要源文件也能使用BEGIN】，BEGIN在读取输入之前执行，END在所有输入都被处理完毕后执行</li>
<li>BEGIN模式通常被用来改变内建变量，如OFS，RS，FS等，也可以用于初始化自定义变量值，或打印输出标题</li>
<li>BEGIN和END模式必须有action部分</li>
<li>所有BEGIN模式的action部分会合并执行，END模式也是如此；但是BEGIN和END模式不与模式匹配中的表达式合并。</li>
</ul>
</li>
<li>BEGINFILE/ENDFILE：BEGINFILE是在读取命令行的每个文件中的第一行记录之前执行的模式；相应的，ENDFILE是读取命令行的每个文件中最后一行记录之后执行的模式</li>
<li>模式匹配部分：由表达式(可以是记录、字段、内置变量、字符串、数字、正则表达式)和<a href="#操作符">操作符</a>构成<ul>
<li>正则表达式<ul>
<li>语法：expr ~ /r/</li>
<li>含义：expr用来和正则表达式【和egrep一样的正则】进行匹配测试</li>
<li>说明：【/r/ { action }】和【$0 ~ /r/ { action }】都是相同的意思，都是用一行记录和正则进行匹配测试</li>
</ul>
</li>
<li>条件表达式<ul>
<li>范例：’NR&gt;=2&amp;&amp;NR&lt;=10{print $3}’【取2到10行中第3个字段中的内容】</li>
</ul>
</li>
<li>关系表达式：使用<a href="#操作符">操作符</a>【&amp;&amp;、||、!、三元操作符、括号(改变连接顺序)，逗号(先后进行匹配测试)】连接多个表达式</li>
</ul>
</li>
</ul>
<h2 id="awk执行"><a href="#awk执行" class="headerlink" title="awk执行"></a>awk执行</h2><ul>
<li>action语句和大多数程序语言一样，由控制语句、输入输入语句、赋值、操作符构成</li>
<li>循环体或action部分被大括号<code>{...}</code>分块，块内语句由分号或换行符分隔，块内最后一条语句不需要终止符</li>
<li>可以使用<code>\</code>来继续长语句；相反的，在逗号、左大括号、&amp;&amp;、do、else、if/while/for语句的右括号、自定义函数的右括号之后，可以在没有反斜杠的情况下断开语句</li>
</ul>
<h1 id="awk语法"><a href="#awk语法" class="headerlink" title="awk语法"></a>awk语法</h1><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul>
<li>记录通常由换行符分隔【也即一行内容为一个记录】，也可以由内置变量RS定义分隔符</li>
<li>只有单字符或正则表达式可以作为分隔符</li>
<li>如果RS设置空，则由空行(\n\n)作为记录分隔符；此时，换行符(\n)作为字段分隔符【FS】</li>
</ul>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><ul>
<li>默认使用空格分隔记录为多个字段</li>
<li>使用FS定义字段分隔符，FS可以是单字符或正则表达式</li>
<li>如果设定FIELDWIDTHS，即每个字段相同宽度，则会覆盖FS设置</li>
<li>记录中的每个字段都可以使用$1,$2…$N进行引用，$0表示整个记录，不能使用负数进行字段引用</li>
<li>变量NF表示记录中的总字段数</li>
<li>引用不存在的字段将会产生空字符串</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul>
<li>ARGC：【count of arg】命令行参数数量【不包括选项和awk程序】</li>
<li>ARGIND：【index in ARGV of file being processed 】当前处理的文件在ARGV中的索引</li>
<li>ARGV：【arry of cmd arg】命令行参数数组<ul>
<li>ARGV[0]为awk解释器</li>
<li>ARGV[1]…ARGV[ARGC-1]为待处理的文件</li>
</ul>
</li>
<li>ENVIRON：环境变量数组【环境变量是由a父进程shell传递给awk程序的】<ul>
<li>范例：<code>awk &#39;BEGIN{print ENVIRON[&quot;HOME&quot;]}&#39;</code></li>
</ul>
</li>
<li>FIELDWIDTHS：固定宽度分隔字段</li>
<li>FILENAME：当前输入的文件名，在BEGIN阶段则是未定义</li>
<li>NR【number of record】：到目前为止的输入记录总数</li>
<li>FNR：【number record of current file】正在处理的记录在当前文件的行号<ul>
<li>NR与FNR：由于awk可以一次处理多个文件，而FNR每打开一个文件都会重置为0，所以总是存在NR&gt;=FNR【在一个文件中NR和FNR相等】</li>
<li>范例(打印5到10行之间的内容)：awk ‘NR&gt;=5&amp;&amp;NR&lt;=10{print $0}’ access.log</li>
</ul>
</li>
<li>FS【field separator】：输入字段分隔符【默认空格】</li>
<li>OFS【output field separator】：输出字段分隔符【默认空格】</li>
<li>RS【record separator】：输入记录分隔符【默认换行符】</li>
<li>ORS【output record separator】：输出记录分隔符【默认换行符】</li>
<li>NF【number of field】：输入记录的字段总数</li>
<li>OFMT【output format】：数字输出格式，默认”%.6g”</li>
<li>RT【record terminator】：记录终止符，awk将RT设置为与RS相匹配的字符或正则表达式匹配的文本</li>
<li>IGNORECASE：在正则表达式和字符串操作中关闭大小写敏感【当IGNORECASE内置变量的值为非0时，表示在进行字符串操作和处理正则表达式时关闭大小写敏感。】</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>字符串常量<ul>
<li><code>\n</code>：换行符</li>
<li><code>\t</code>：制表符</li>
<li><code>\\</code>：反斜杠</li>
</ul>
</li>
<li>字符串：由双引号包围</li>
<li>数字：在awk中变量无须定义即可使用，变量在赋值时即已经完成了定义。变量的类型可以是数字、字符串。根据使用的不同，未初始化变量的值为0或空白字符串” “，这主要取决于变量应用的上下文。</li>
<li>数组<ul>
<li>删除数组成员：delete array[index]</li>
<li>删除数组：delete array</li>
</ul>
</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>(…)：分组(但是awk分组功能不支持后向引用)</li>
<li>$：字段或变量引用</li>
<li>^：指数【也可以使用<code>**</code>，例如<code>**</code>=可以在赋值语句中使用】</li>
<li><code>+ - * / % ++ --</code>：算数运算符：加、减、乘、除、取余、递增、递减</li>
<li>|和|&amp;：用于getline、print、printf的的管道符</li>
<li><code>&lt; &gt; &lt;= &gt;= != ==</code>：比较运算符</li>
<li>~ !~：正则匹配，正则否定；只在符号的右侧使用常量，比如【$1 ~ ‘ceshi’】</li>
<li>in：在数组之中</li>
<li>&amp;&amp; || !：逻辑运算符：“与”、“或”、“非”</li>
<li>?:：三元运算符【第一个为真则执行第二个，否则执行第三个】</li>
<li>= += -= *= /= %= ^=：赋值语句（包含绝对赋值和带有其他操作符的赋值）</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>if语句：if (condition) statement [ else statement ]<ul>
<li>多个条件语句使用圆括号分组后使用逻辑操作符连接</li>
<li>多个执行语句使用分号分隔，整体使用花括号包围</li>
</ul>
</li>
<li>循环语句while：while (condition) statement</li>
<li>循环语句do-while：do statement while (condition)</li>
<li>循环语句for：for (expr_st; expr_end; expr_incre) statement</li>
<li>数组循环for：for (var in array) statement</li>
<li>跳出循环体：break</li>
<li>跳出本次循环：continue</li>
<li>退出awk程序【但是不会跳过END模块】：exit [ expression ]{ statements }</li>
<li><p>多种选择switch：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line">case value|regex : statement</span><br><span class="line">...</span><br><span class="line">[ default: statement ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><ul>
<li>使用shell的通用重定向符号“&gt;”完成awk的输出重定向</li>
<li>使用”&gt;”时，被打开的文件先被清空；文件会持续打开，直到文件被明确关闭(close)或awk程序结束</li>
<li>使用”&gt;&gt;”时，重定向的输出只是添加到文件末尾</li>
</ul>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><ul>
<li>awk对于输入重定向是通过getline函数完成的，</li>
<li>getline可以从标准输入、管道、当前正在处理的文件之外的其他文件获取</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><a href="#getline与next">getline</a>：从下一个输入记录中设置$0，同时设置NF, NR, FNR, RT.<ul>
<li>对于模式匹配的记录直接跳过，直接处理相邻的下一个记录</li>
</ul>
</li>
<li>getline &lt; file：从下一个文件记录中设置$0，设置NF，RT</li>
<li>getline var：从下一个输入记录中设置变量，设置NR，FNR，RT</li>
<li>getline var &lt; file：从下一个文件记录中设置变量，设置RT</li>
<li>command| getline <code>[var]</code>：执行命令，将结果保存在$0或变量var中以及RT中<ul>
<li>范例【命令输出保存为变量并打印】：<code>awk &#39;BEGIN{&quot;date&quot;|getline d;print d}&#39;</code></li>
</ul>
</li>
<li>command|&amp; getline <code>[var]</code>：执行命令，同时将结果保存在$0或变量var中以及RT中</li>
<li>print：打印当前记录【即$0】到标准输出</li>
<li>print expr-list：打印表达式到标准输出<ul>
<li>表达式之间以OFS分隔，输出记录以ORS定义的值结束</li>
<li>表达式可以时变量、数值、字符串【字符串使用双引号引用】、字符串常量【如<code>\t</code>：制表符 <code>\n</code>：换行符】</li>
<li>参数之间使用逗号分隔；没有分隔符时，参数就“黏”在一起</li>
<li>范例：<ul>
<li>默认格式(%.6g)：<code>awk &#39;BEGIN{a=1.23456789,print a}&#39;</code></li>
<li>自定义格式：<code>awk &#39;BEGIN{OFMT=&quot;%.2f&quot;;a=1.23456789;print a}&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li>print expr-list &gt;file：打印表达式到文件【文件名使用双引号】</li>
<li>print … &gt;&gt; file：打印表达式到文件末尾</li>
<li>printf fmt, expr-list：格式化输出<ul>
<li>范例：<ul>
<li>显示日期的每一个字段：<code>date|awk &#39;{for(i=1;i&lt;=NF;i++)printf(&quot;%s\n&quot;,$i)}&#39;</code></li>
<li>格式化数字：<code>awk &#39;BEGIN{a=123.456;printf(&quot;a is %.2f\n&quot;, a)}&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li>printf fmt, expr-list &gt;file：格式化输出到文件</li>
<li>print … | command：输出写入管道</li>
<li>print … |&amp; command：打印输出并写入管道</li>
<li><a href="#getline与next">next</a>：停止处理当前的输入记录，读取下一个输入记录并使用awk程序的第一个模式处理；在到达输入数据的末尾时，awk执行END规则<ul>
<li>对于第一个模式匹配的记录直接跳过，直接处理余下的全部记录</li>
<li>因此需要至少一个匹配模式，next位于第一个匹配模式之后，且由花括号包围</li>
</ul>
</li>
<li>nextfile：停止处理当前的输入文件，读取的下一个记录来自下一个文件。FILENAME和ARGIND被更新，FNR设置为1，并使用awk程序的第一个模式处理；在到达输入数据的末尾时，awk执行END规则</li>
<li>close：关闭文件或管道</li>
<li>system(cmd-line)：执行命令并返回退出状态【不适用于非unix系统】<ul>
<li><code>awk &#39;BEGIN{system(&quot;date&quot;)}&#39;</code></li>
</ul>
</li>
<li><code>fflush([file])</code>：刷新所有输出文件或管道的buffer，如果文件丢失或为空则刷新所有输出文件或管道</li>
</ul>
<h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>当从print或printf进行i/o重定向到文件，或使用getline从文件中进行i/o重定向时，awk程序可以从内部识别某些特殊的文件名。<br>这些文件名允许通过继承自awk的父进程【一般为shell】来进行访问<br>这些文件名也可以直接在命令行【即在shell】进行访问  </p>
<ul>
<li>-：标准输入</li>
<li>/dev/stdin：标准输入</li>
<li>/dev/stdout：标准输出</li>
<li>/dev/stderr：标准错误输出</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>gsub(regx, substr [, target_str])</code> ：在目标字符串中，每个与正则表达式匹配的子串都被替换，并返回替换的次数；如果目标字符串未提供则使用$0<ul>
<li>范例：<code>awk &#39;{gsub(&quot;:1&quot;,&quot;--&quot;);print}&#39; test.txt</code>【将记录中的”:1”替换为”–”】</li>
</ul>
</li>
<li><code>sub(regx, substr [, target_str])</code>：只替换第一个匹配的字符串</li>
<li><code>index(str, substr)</code>：返回子字符串在字符串中的索引位置，从1开始<ul>
<li>范例：<code>awk &#39;BEGIN{print index(&quot;1a2b3&quot;,&quot;2b&quot;)}&#39; test.txt</code>【返回”2b”第一个字符在”1a2b3”中的索引位置】</li>
</ul>
</li>
<li><code>length([str])</code>：返回字符串的长度或数组个数</li>
<li><code>match(str, regx [, arry])</code>：返回正则表达式在字符串中出现的位置，找不到则返回0</li>
<li><code>substr(str, index [, n])</code>：字符串截取，从字符串中的第index个索引位置截取n个字符</li>
<li><code>tolower(str)</code>：返回字符串的字母的小写形式</li>
<li><code>toupper(str)</code>：返回字符串中字母的大写形式</li>
<li><code>split(str, arry [, regx [, seps] ])</code>：使用正则表达式regx定义的分隔符将字符串str拆分成数组arry，如果regx未定义则使用FS<ul>
<li>范例：<code>awk &#39;BEGIN{split(&quot;1a 2b 3c&quot;,a)}END{for(i=0;i&lt;length(a);i++)print a[i]}&#39; test.txt</code></li>
<li>awk的切分算法：用split函数将字符串切分为数组，用RS分隔符将文件切分为记录，用FS分隔符将记录切分为字段</li>
</ul>
</li>
<li><code>strtonum(str)</code>：字符串转化我数字</li>
<li><code>sprintf(fmt, expr-list)</code>：使用指定格式输出表达式</li>
</ul>
<h3 id="格式化输出printf"><a href="#格式化输出printf" class="headerlink" title="格式化输出printf"></a>格式化输出printf</h3><ul>
<li>%c：单字符</li>
<li>%d, %i：十进制数（整数部分）</li>
<li>%e, %E：<code>[-]d.dddddde[+-]dd</code>格式的浮点数【科学表示法】</li>
<li>%f, %F：<code>[-]ddd.dddddd</code>格式浮点数</li>
<li>%g, %G：取%e或%f中较短的内容，并抑制无意义0的输出</li>
<li>%o：无符号八进制数【整数】</li>
<li>%u：无符号十进制数【整数】</li>
<li>%s：字符串</li>
<li>%x, %X：无符号十六进制数【整数】，使用ABCDEF代替abcdef</li>
<li>%%：单字符%</li>
<li>count$：格式化字符串时指定位置参数</li>
<li>-：表达式应该在字段内左对齐</li>
<li>空格：对于数字转化，应该使用空格为正值添加前缀，使用减号为负值添加前缀</li>
<li>+：数字转化时，为宽度修饰符提供前缀符号</li>
<li>#：对数字系列的控制字符提供转化形式</li>
<li>0：前导0用于数字格式化的填充</li>
<li>width：定义输出宽度</li>
<li>.prec：定义输出精度控制</li>
</ul>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li>int(expr)：截断为整数</li>
<li>rand()：返回0和1之间的随机数N【0 ≤ N &lt; 1】</li>
<li><code>srand([expr])</code>：使用expr作为随机数生成器的新种子，如果未提供expr则使用时间作为种子<ul>
<li>范例：<code>awk &#39;BEGIN{srand();printf(&quot;%d\n&quot;, rand()*10)}&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><ul>
<li>systime()：返回当前时间到epoch(1970-01-01 00:00:00 UTC)之间的秒数【即timestamp】</li>
<li>mktime(datespec)：将datespec转换成和systime一样的时间戳（timestamp），datespec形式为<code>YYYY MM DD HH MM SS[ DST]</code></li>
<li>strftime([format [, timestamp[, utc-flag]]])：将timestamp格式化为指定格式的字符串输出<ul>
<li>范例：<code>awk &#39;BEGIN{print strftime(&quot;%Y%m%d&quot;, systime())}&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h3><p>isarray(x)：如果x是数组则返回为真</p>
<h2 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h2><ul>
<li>语法:function name(parameter list) { statements }</li>
<li>使用：<ul>
<li>可以在pattern或action中调用函数</li>
<li>函数调用时，左括号需要紧跟函数名【但这不适用于内置函数】</li>
<li>可以在函数中使用return表达式来返回值，假如没有提供值则返回值显示为未定义</li>
</ul>
</li>
</ul>
<h1 id="awk范例"><a href="#awk范例" class="headerlink" title="awk范例"></a>awk范例</h1><h2 id="getline与next"><a href="#getline与next" class="headerlink" title="getline与next"></a>getline与next</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 源文本</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">00</span><br><span class="line">23</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line"># next用法示例</span><br><span class="line">awk &apos;/3/&#123;next&#125;&#123;print $0&#125;&apos; 1.txt：直接过滤掉包含3的记录</span><br><span class="line"># getline用法示例</span><br><span class="line">awk &apos;/3/&#123;getline;print $0&#125;&apos; 1.txt：对包含3的记录进行处理：读取下一行内容后直接打印</span><br><span class="line">awk &apos;/3/&#123;getline&#125;&#123;print $0&#125;&apos; 1.txt：此时和next用法一直：直接过滤掉包含3的记录</span><br></pre></td></tr></table></figure>
<h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><ul>
<li>循环获取命令输出并打印：<code>awk &#39;BEGIN{while(&quot;ls&quot;|getline)print}&#39;</code></li>
<li>getline交互式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;print &quot;what is your name?&quot;;getline name &lt; &quot;/dev/pts/0&quot;&#125;\</span><br><span class="line">$1 ~ name&#123;print &quot;Found &quot; name &quot;on line&quot;, NR&#125;\</span><br><span class="line">END&#123;print&quot;See ya,&quot; name&#125;&apos; test.txt</span><br><span class="line"></span><br><span class="line"># BEGIN部分：打印标题【what is your name?】，从pts终端获取输入并赋值给name</span><br><span class="line"># pattern-action部分：如果文件中的某一行记录的第一个字段是name变量的值，则打印内容</span><br><span class="line"># END部分：打印name变量相关内容</span><br></pre></td></tr></table></figure>
<h2 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h2><ul>
<li>SQL执行统计【将java项目运行过程中的sql导出】：<code>awk -F&#39;Preparing: &#39; &#39;/Preparing/{var=$2;sub(&quot;  .*$&quot;,&quot;&quot;,var);print var}&#39; catalina.out-20190622</code><ul>
<li>过滤包含“Preparing”的行【这样的行包含sql语句】</li>
<li>将第一步过滤的记录以“Preparing: ”分隔取第二个字段</li>
<li>删除【双空格及以后的内容】</li>
</ul>
</li>
<li>TCP状态统计：【统计服务器443端口外网tcp各种连接状态及数量】<ul>
<li>连接状态统计并排序：<code>netstat -ant|awk -F &#39;[ :]+&#39; &#39;$1 !~ /^Act|^Pro/{if(($5==443)&amp;&amp;($6!=&quot;0.0.0.0&quot;))++count[$8]}END{for(i in count)print i,count[i]}&#39;|sort -nr -k2</code><ul>
<li>排除Act和Pro开头的字头行</li>
<li>包含连接443端口的连接</li>
<li>排除来自0.0.0.0的连接</li>
<li>以tcp状态为作为自加数组变量，不同tcp状态共同构成数组</li>
<li>打印tcp状态及数量</li>
<li>以tcp状态的个数作为排序依据</li>
</ul>
</li>
<li>连接总数【并发】：<code>netstat -ant|awk -F &#39;[ :]+&#39; &#39;$1 !~ /^Act|^Pro/{if(($5==443)&amp;&amp;($6!=&quot;0.0.0.0&quot;))++count[$1]}END{print count[$1]}&#39;</code><ul>
<li>选取每行都不变的信息作为自加变量，最终统计并发连接</li>
</ul>
</li>
</ul>
</li>
<li>WEB访问统计：【nginx日志中：第1个字段为访问者ip，第7个字段为访问的url【含get参数】，第10个字段为访问url响应体大小】<ul>
<li>统计每天访问量最大的资源【get去除参数】TOP10:<code>awk -F&#39;[ ?]&#39; &#39;{++url[$7]}END{for(i in url)print i,url[i]}&#39; access.log|sort -rn -k2|head -10</code></li>
<li>统计每天占用带宽最大的资源TOP10：<code>awk &#39;{sub(&quot;?.*$&quot;,&quot;&quot;,$7);url[$7]+=$10}END{for(i in url)print i,url[i]}&#39; access.log|sort -rn -k2</code><ul>
<li>sub(“?.*$”,””,$7)：get去除参数，获取真正的资源</li>
<li><code>url[$7]+=$10</code>：对同一个资源，参数不同，获取的响应体大小也不一样；因此需要将相同资源每次返回的响应体大小累加</li>
</ul>
</li>
<li>统计每天访问量最大的ip TOP10：<code>awk &#39;{++ip[$1]}END{for(i in ip)print i,ip[i]}&#39; access.log|sort -rn -k2|head -10</code></li>
</ul>
</li>
</ul>
<h2 id="shell脚本中的awk"><a href="#shell脚本中的awk" class="headerlink" title="shell脚本中的awk"></a>shell脚本中的awk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read -p &quot;pls input a ip:&quot; ip</span><br><span class="line">egrep -v &quot;localhost|^$&quot; /etc/hosts|awk &apos;&#123;if($1==&quot;&apos;$ip&apos;&quot;)print $2&#125;&apos;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>centos下的gawk man文档</li>
<li>ubuntu下的mawk man文档</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>文本编辑器-vim</title>
    <url>/blog/2019/07/15/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-vim/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h2><p>vimtutor命令</p>
<h2 id="主要文件"><a href="#主要文件" class="headerlink" title="主要文件"></a>主要文件</h2><ul>
<li>历史记录文件：~/.viminfo</li>
<li><p>配置文件：~/.vimrc</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;显示行号</span><br><span class="line">set nu</span><br><span class="line">&quot;tab长度为4个空格</span><br><span class="line">set ts=4</span><br><span class="line">&quot;把tab显示成空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot;自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">&quot;搜索高亮</span><br><span class="line">set hlsearch</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><ul>
<li>-o 同时编辑多个文件【ctrl+w+↑↓切换文件】</li>
<li>+n 直接打开文件并定位光标到第n行</li>
</ul>
<h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><ul>
<li><a href="#光标定位">普通模式</a>：主要进行光标移动，或进行删除、复制、粘贴操作</li>
<li><a href="#文本编辑">编辑模式</a>：对文本进行编辑</li>
<li><a href="#命令行模式">命令行模式</a>：主要对普通模式进行输入输出操作</li>
</ul>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="多行注释与删除"><a href="#多行注释与删除" class="headerlink" title="多行注释与删除"></a>多行注释与删除</h3><ol>
<li>ctrl+v进入块编辑模式  </li>
<li>使用上下键选中行首  </li>
<li>【大写i】插入#等字符进行注释或d键删除  </li>
<li>Esc退出，wq保存</li>
</ol>
<h1 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h1><blockquote>
<p>普通模式下操作</p>
</blockquote>
<ul>
<li>光标任意移动：n(↑↓←→) 移动n个位置</li>
<li>向右移动n个字符位置：n space：</li>
<li>移动光标到行首：^、0、home</li>
<li>移动光标到行尾：$、end</li>
<li>移动光标到单词结束：e</li>
<li>移动光标到下个单词开始：w</li>
<li>移动光标到文件首行：gg（ngg/nG移动到第n行）</li>
<li>移动光标到文件尾行：G</li>
<li>多行选择：先按<strong>Shift + v</strong>后,使用上下键选中多行操作</li>
<li>区块选择<ul>
<li>v：对光标以前的所有行的区块进行选择<ul>
<li>【v :w filename】将区块选择内容保存到filename中</li>
</ul>
</li>
<li>ctrl+v：对光标左上的区块进行选择</li>
</ul>
</li>
</ul>
<h1 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h1><blockquote>
<p>普通模式下操作；或普通模式使用i、o、a等进入编辑模式下操作(编辑模式使用Esc退回到普通模式)</p>
</blockquote>
<ul>
<li>单字符操作<ul>
<li>x、delete：删除光标下字符</li>
<li>rx：替换当前光标字符为字符x</li>
</ul>
</li>
<li>增加<ul>
<li>i：光标前添加内容</li>
<li>I：当前行首添加内容</li>
<li>a：光标后添加内容</li>
<li>A：当前行尾添加内容</li>
<li>o：光标的下一行添加内容</li>
<li>O：光标的上一行添加内容</li>
</ul>
</li>
<li>删除：d(delete)<ul>
<li>dw：删除内容到下一个单词开始<ul>
<li>d2w：删除两个单词</li>
</ul>
</li>
<li>de：删除内容到单词末尾</li>
<li>d$/d^：删除内容到行尾、行首</li>
<li>dd：删除当前行<ul>
<li>2dd：删除2行</li>
</ul>
</li>
</ul>
</li>
<li>替换：c(change)<ul>
<li>ce：替换单词【删除原单词，并进入编辑模式】</li>
<li>c0、c$：替换光标至行首或行尾内容【删除原内容，并进入编辑模式】</li>
</ul>
</li>
<li>复制：y(yank)<ul>
<li>yy：复制一行</li>
<li>5yy：复制5行</li>
<li>y$：复制到行尾内容</li>
</ul>
</li>
<li>粘贴：p(paster)【将最近删除或复制的内容放入当前光标所在的下一行】</li>
<li>撤销操作：u(undo) 撤销最后一个命令的操作<ul>
<li>多个u撤销最近n个操作</li>
<li>ctrl+r：撤销最近一次撤销的动作</li>
<li>U：恢复一行到修改前状态</li>
</ul>
</li>
</ul>
<h1 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h1><blockquote>
<p>普通模式使用【:、/、?】符号进入命令行模式(命令行模式下使用Esc退回到普通模式)</p>
</blockquote>
<ul>
<li>搜索<ul>
<li>/word：普通模式下默认向后搜索文本</li>
<li>n、N：显示文本下一次【上一次】出现的位置</li>
<li>?word：普通模式下默认向前搜索文本</li>
</ul>
</li>
<li>替换<ul>
<li>:s/old/new 将当前行第一次出现的old替换为new</li>
<li>:s/old/new/g 将当前行出现的old都替换为new</li>
<li>:n,ms/old/new/g 将n到m行出现的old都替换为new</li>
<li>:%s/old/new/g 将当前文件出现的old都替换为new</li>
<li>%s/old/new/gc 将当前文件出现的old都替换为new，每个替换都进行交互提示</li>
</ul>
</li>
<li>输入输出<ul>
<li><code>:w</code>：保存(:w! 强制保存)</li>
<li><code>:q</code>：退出(:q! 强制退出)</li>
<li><code>:wq</code>：保存修改并退出(:wq! 强制保存退出)</li>
<li><code>:w filename</code>：保存当前文件到filename</li>
<li><code>n,m w file2</code>：将当前文件的n到m行保存为file2</li>
<li><code>:r filename</code>：读入filename文件内容到光标的下一行</li>
<li><code>:r !command</code>：读取命令行输出到光标的下一行</li>
<li><code>:e file2</code>：跳出当前文件，另行编辑file2文件</li>
<li><code>:! command</code>：执行shell或cmd命令</li>
</ul>
</li>
<li>帮助与设置<ul>
<li><code>:help</code>：帮助信息</li>
<li><code>set nu/set nonu</code>：设置行号</li>
</ul>
</li>
</ul>
<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>查看文件内容，类似命令有more，但是less比more强大</p>
<ul>
<li>space：换屏输出</li>
<li>↑↓：换行输出</li>
<li>/string：向下搜索</li>
<li>?string：向上搜索</li>
<li>n：下一个匹配字符串</li>
<li>N：上一个匹配字符串</li>
<li>q：退出查看模式</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>less</tag>
        <tag>more</tag>
      </tags>
  </entry>
  <entry>
    <title>类unix终端显示控制</title>
    <url>/blog/2018/05/28/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%B1%BBunix%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="ANSI转义序列"><a href="#ANSI转义序列" class="headerlink" title="ANSI转义序列"></a>ANSI转义序列</h1><blockquote>
<p><a href="https://www.cnblogs.com/crabxx/p/4046498.html" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<p>通常我们可以使用echo命令加-e选项输出各种颜色的文本，例如：echo -e “\033[31mRed Text\033[0m”，可以输出红色的字体“Red Text”。其中：”\033[31m”和”\033[0m”是ANSI转义序列（ANSI escape code/sequence），它控制文本输出的格式、颜色等，大多数的类unix终端仿真器都能够解释ANSI转义序列。  </p>
<h2 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>CSI n1 [;n2 [;…]] m</li>
<li>其中CSI全称为“控制序列引导器”（Control Sequence Introducer/Initiator），也就是上述示例中的”\033[“（其中\033是你键盘左上角Esc键对应的ascii码（八进制））；n1、n2等表示SGR参数（下面会列出一些常用的SGR参数），用于控制颜色、粗体、斜体、闪烁等文本输出格式；m表示转义序列结束。</li>
</ul>
<h3 id="常用SRG参数"><a href="#常用SRG参数" class="headerlink" title="常用SRG参数"></a>常用SRG参数</h3><table>
<thead>
<tr>
<th>编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>关闭所有格式</td>
</tr>
<tr>
<td>1</td>
<td>粗体或高亮</td>
</tr>
<tr>
<td>2</td>
<td>模糊</td>
</tr>
<tr>
<td>3</td>
<td>斜体</td>
</tr>
<tr>
<td>4</td>
<td>下划线</td>
</tr>
<tr>
<td>5</td>
<td>闪烁（慢）</td>
</tr>
<tr>
<td>6</td>
<td>闪烁（快）</td>
</tr>
<tr>
<td>7</td>
<td>交换前景背景色</td>
</tr>
<tr>
<td>8</td>
<td>隐藏</td>
</tr>
<tr>
<td>30-37</td>
<td>前景色（30+x）</td>
</tr>
<tr>
<td>40-47</td>
<td>背景色（40+x）</td>
</tr>
</tbody>
</table>
<h3 id="颜色表"><a href="#颜色表" class="headerlink" title="颜色表"></a>颜色表</h3><table>
<thead>
<tr>
<th>颜色值</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>黑</td>
</tr>
<tr>
<td>1</td>
<td>红</td>
</tr>
<tr>
<td>2</td>
<td>绿</td>
</tr>
<tr>
<td>3</td>
<td>黄</td>
</tr>
<tr>
<td>4</td>
<td>蓝</td>
</tr>
<tr>
<td>5</td>
<td>紫</td>
</tr>
<tr>
<td>6</td>
<td>青</td>
</tr>
<tr>
<td>7</td>
<td>白</td>
</tr>
</tbody>
</table>
<h2 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h2><h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\33[K</td>
<td>清除从光标到行尾的内容</td>
</tr>
<tr>
<td>\33[?25l</td>
<td>隐藏光标</td>
</tr>
<tr>
<td>\33[?25h</td>
<td>显示光标</td>
</tr>
</tbody>
</table>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 隐藏光标</span></span><br><span class="line">    print(<span class="string">'\x1b[?25l'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 将光标移到行首位置，并清除光标到行尾的内容</span></span><br><span class="line">    <span class="comment">#print('\r\x1b[K', end='')</span></span><br><span class="line">    print(<span class="string">'\x1b[K'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 打印内容后换行</span></span><br><span class="line">    <span class="comment">#print('*'*i, end='\n', flush=True)</span></span><br><span class="line">    print(<span class="string">'*'</span>*i, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 显示光标</span></span><br><span class="line">print(<span class="string">'\x1b[?25h'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>颜色</tag>
        <tag>光标</tag>
      </tags>
  </entry>
  <entry>
    <title>版本库命令-git</title>
    <url>/blog/2018/02/26/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91/%E7%89%88%E6%9C%AC%E5%BA%93%E5%91%BD%E4%BB%A4-git/</url>
    <content><![CDATA[<h1 id="状态迁移"><a href="#状态迁移" class="headerlink" title="状态迁移"></a>状态迁移</h1><p>版本库=》工作区=》暂存区=》版本库</p>
<h1 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h1><blockquote>
<p>从工作区中清理未追踪的文件或目录</p>
</blockquote>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-d 清除未追踪的目录</li>
<li>-f 强制删除未追踪的文件或目录</li>
<li>-x 删除为追踪的文件，使目录保持干净的原始状态<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>清除未追踪的文件或目录：git clean -xdf </li>
</ul>
<h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><h2 id="指定路径或文件的回退"><a href="#指定路径或文件的回退" class="headerlink" title="指定路径或文件的回退"></a>指定路径或文件的回退</h2><ul>
<li>还原暂存区内容，即撤销 git add操作</li>
<li>git reset HEAD 【file】</li>
</ul>
<h2 id="版本库整体回退"><a href="#版本库整体回退" class="headerlink" title="版本库整体回退"></a>版本库整体回退</h2><ul>
<li>在git中用HEAD表示当前版本,上个版本HEAD^,往上100个版本HEAD~100</li>
<li>回退到上个版本：git reset –hard HEAD^</li>
<li>回退到特定版本：git reset –hard 2ff6b08 </li>
</ul>
<h1 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h1><blockquote>
<p>切换分支或恢复工作区为版本库文件【撤销工作区变更】</p>
</blockquote>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><ul>
<li>切换：git checkout 【branch_name】</li>
<li>创建+切换：git checkout -b 【branch_name】 【start_point】<ul>
<li>从某一分支创建新分支，不写默认为当前分支</li>
</ul>
</li>
</ul>
<h1 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h1><ul>
<li>git tag：查看标签列表<ul>
<li>git show tag_name：查看标签变更 </li>
</ul>
</li>
<li>git tag tag_name：使用当前commit打标签</li>
<li>git tag -d tag_name：删除本地标签</li>
<li>-m：tag注释</li>
<li>git tag tag_name commit_id：针对某个commit打标签</li>
</ul>
<h1 id="add-rm"><a href="#add-rm" class="headerlink" title="add/rm"></a>add/rm</h1><ul>
<li>add：提交工作区变更到暂存区</li>
<li>rm：删除版本库文件</li>
</ul>
<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><blockquote>
<p>设置或获取版本库或全局配置</p>
</blockquote>
<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><ul>
<li>–global </li>
<li>有此参数对此电脑下的所有仓库有效，形成的参数文件在用户主目录的.gitconfig文件中</li>
<li>无此参数，只对某个仓库有效，形成的参数文件在仓库.git/config文件中<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2></li>
<li>git config –global alias.st status</li>
<li>git config –global alias.last ‘log -1’<h2 id="设置用户及邮件"><a href="#设置用户及邮件" class="headerlink" title="设置用户及邮件"></a>设置用户及邮件</h2></li>
<li>git config –global user.name “何静奇” </li>
<li>git config –global user.email “<a href="mailto:hejingqi@quxiu8.com" target="_blank" rel="noopener">hejingqi@quxiu8.com</a>“</li>
</ul>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 查看当前代理设置</span><br><span class="line">git config --global http.proxy</span><br><span class="line"></span><br><span class="line">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy &apos;http://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;http://127.0.0.1:1080&apos;</span><br><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line"></span><br><span class="line">// 删除代理</span><br><span class="line">删除 proxy git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<h1 id="push-pull"><a href="#push-pull" class="headerlink" title="push/pull"></a>push/pull</h1><ul>
<li>push：推送本地版本库对象到远程<ul>
<li>tag：<ul>
<li>推送指定标签：git push origin 1.4</li>
<li>推送所有标签：git push origin –tags</li>
<li>删除远程标签：git push origin –delete tag <tagname></tagname></li>
</ul>
</li>
<li>branch：<ul>
<li>推送分支：git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;<ul>
<li>如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支</li>
</ul>
</li>
<li>删除远程分支：git push origin –delete 【branchName】</li>
<li>范例：<ul>
<li>git push origin master：origin为主机名，在配置文件中设置</li>
<li>git push -u origin master：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>pull：拉取远程版本库对象到本地</li>
</ul>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><ul>
<li>diff：对比工作区和版本库中某个文件的差异</li>
<li>commit：提交暂存区至版本库</li>
<li>status：版本库状态查看</li>
<li>reflog：查看命令操作历史</li>
<li>clone：克隆分支<ul>
<li>将远程库克隆至本地【默认克隆master分支】：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:simple0426/Spoon-Knife.git</li>
<li>-b dev 克隆dev分支</li>
</ul>
</li>
<li>log：历史变更查看<ul>
<li>–pretty=oneline</li>
</ul>
</li>
<li>branch：分支管理<ul>
<li>git branch 查看分支<ul>
<li>git branch -r 查看远程分支</li>
</ul>
</li>
<li>git branch 【name】 创建分支</li>
<li>git branch -d 【name】 删除分支</li>
<li>git branch –set-upstream dev origin/dev  关联本地分支和远程分支</li>
</ul>
</li>
<li>merge：分支合并<ul>
<li>合并某分支到当前分支</li>
<li>git merge dev</li>
</ul>
</li>
<li>init：将普通目录初始化为版本库</li>
<li>.gitignore 配置.gitignore文件忽略部分文件或目录的变更</li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="git中文数字类型乱码"><a href="#git中文数字类型乱码" class="headerlink" title="git中文数字类型乱码"></a>git中文数字类型乱码</h2><p>git config –global core.quotepath false</p>
<h2 id="强制放弃本地修改和增加的文件"><a href="#强制放弃本地修改和增加的文件" class="headerlink" title="强制放弃本地修改和增加的文件"></a>强制放弃本地修改和增加的文件</h2><blockquote>
<p>此时，本地修改“多于”远程库</p>
</blockquote>
<ul>
<li>git checkout . 放弃修改</li>
<li>git clean -xdf 删除未追踪文件</li>
</ul>
<h2 id="强制本地与远程版本库保持一致"><a href="#强制本地与远程版本库保持一致" class="headerlink" title="强制本地与远程版本库保持一致"></a>强制本地与远程版本库保持一致</h2><blockquote>
<p>此时本地与远程库的均有修改</p>
</blockquote>
<ul>
<li>git fetch –all  取回远程端所有【分支】修改，但不和本地合并</li>
<li>git reset –hard origin/master <ul>
<li>将版本强制设置到origin/master【远程master】这个分支的最新代码</li>
<li>放弃本地所有修改等操作，保持与远程代码库的一致</li>
</ul>
</li>
<li>git pull 与远程分支保持同步</li>
</ul>
<h1 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h1><ul>
<li>变更本地关联的远程库：git remote set-url origin URL</li>
</ul>
<h1 id="故障收集"><a href="#故障收集" class="headerlink" title="故障收集"></a>故障收集</h1><ul>
<li>git bash乱码：git config –global core.quotepath false</li>
</ul>
<h1 id="清除污点提交或大文件"><a href="#清除污点提交或大文件" class="headerlink" title="清除污点提交或大文件"></a>清除污点提交或大文件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>git库提交内容有时候会包含大文件或密码这样的隐私信息，当使用正常的git提交等措施删除文件或密码信息后，仍然可以从历史提交记录中找到这些内容。对于删除的大文件而言，它会占用仓库存储空间；对于密码等隐私内容来说，隐私内容依然存在。</li>
<li>git自带的工具git-filter-branch可以清除历史提交信息，但是操作比较复杂</li>
<li>可以使用第三方工具<a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">BFG Repo-Cleaner</a>方便的处理文件和密码的历史提交信息</li>
</ul>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><ul>
<li>bfg是一个jar文件，<a href="https://search.maven.org/classic/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST" target="_blank" rel="noopener">下载地址</a></li>
<li>以下命令bfg就是【java -jar bfg.jar】的别名</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul>
<li><p>克隆仓库元数据：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --mirror git@github.com:my-account/my-repo.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除文件【可以是下列任意一个操作】：</p>
<ul>
<li>删除所有文件id_rsa或id_dsa：<code>bfg --delete-files id_{dsa,rsa}  my-repo.git</code></li>
<li>删除目录.git：<code>bfg --delete-folders .git --delete-files .git  --no-blob-protection  my-repo.git</code></li>
<li>删除大于1M的文件：<code>bfg --strip-blobs-bigger-than 1M  my-repo.git</code></li>
<li>删除密码等文本：<code>bfg --replace-text banned.txt  my-repo.git</code><ul>
<li>在指定的文件【比如：banned.txt】中一行定义一个要删除的密码等隐私信息，执行删除后，密码信息会被【REMOVED】关键词替换</li>
<li>比如在banned.txt中包含原来密码信息【426hx118】，则在执行操作时会将历史记录中=的【426hx118】替换为REMOVED</li>
</ul>
</li>
</ul>
</li>
<li><p>将本地修改推送到远程</p>
<ol>
<li><code>cd my-repo.git</code></li>
<li><code>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code></li>
<li>git push</li>
</ol>
</li>
<li><p>将远程元数据信息同步到本地</p>
<ol>
<li><code>cd my-repo</code></li>
<li><code>git pull</code></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>日志切割工具logrotate</title>
    <url>/blog/2019/06/13/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%B7%A5%E5%85%B7logrotate/</url>
    <content><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/haproxy/log/*.log &#123;</span><br><span class="line">rotate 15</span><br><span class="line">daily</span><br><span class="line">dateext</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">compress</span><br><span class="line">delaycompress</span><br><span class="line">copytruncate</span><br><span class="line">size 50M</span><br><span class="line"># create 0640 user group</span><br><span class="line"># olddir oldlog</span><br><span class="line"># sharedscripts</span><br><span class="line"># postrotate</span><br><span class="line">#  reload rsyslog &gt;/dev/null 2&gt;&amp;1 || true</span><br><span class="line"># endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">介绍</a></h1><ul>
<li>功能<ul>
<li>日志轮转</li>
<li>压缩</li>
<li>删除</li>
</ul>
</li>
<li>默认在每天的定时任务【cron.daily】下执行，因此每天只会执行一次</li>
<li>只有当日志轮转参数基于日志大小并且多次运行logrotate，或者使用-f参数【logrotate -f】才会形成对日志的修改</li>
<li>可以在命令行使用任意多的配置文件或定义配置文件目录；具有相同功能的配置选项，后面的配置会覆盖前面的配置</li>
<li>命令参数<ul>
<li>-f 强制日志轮转</li>
<li>-s 使用轮转状态文件，默认使用/var/lib/logrotate.status</li>
</ul>
</li>
</ul>
<h1 id="默认轮转命令"><a href="#默认轮转命令" class="headerlink" title="默认轮转命令"></a>默认轮转命令</h1><p>/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</p>
<h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h1><ul>
<li>rotate count：日志轮转数量【保留的旧日志数量】</li>
<li>include：包含其他配置选项<ul>
<li>包含在全局配置中，但不能包含在log配置中</li>
</ul>
</li>
<li>compress：旧日志压缩，默认使用gzip</li>
<li>delaycompress：延迟压缩功能</li>
<li>nocompress：不对旧日志进行压缩</li>
<li>copy：对当前日志文件创建一个副本，但不改变原来的日志文件【create选项会覆盖此功能】</li>
<li>nocopy：不复制日志</li>
<li>copytruncate：对当前日志建立一个副本后，清空原有日志文件【create选项会覆盖此功能】<ul>
<li>在实时日志较大时会出现小部分丢失清空</li>
<li>适用于程序不能产生新日志文件的情况</li>
</ul>
</li>
<li>nocopytruncate：在建立新副本后不清空原有日志</li>
<li>create mode owner group：设置新日志的属性<ul>
<li>需要搭配postrotate脚本来通知程序产生新的日志文件</li>
<li>当任何的属性不设置时，都采用和原文件相同的属性</li>
</ul>
</li>
<li>nodelaycompress：不延迟压缩日志</li>
<li>ifempty：日志为空也轮转</li>
<li>notifempty：日志为空不轮转</li>
<li>size：日志轮转大小，以字节为单位，可选单位【k、M、G】</li>
<li>missingok：日志不存在不报错</li>
<li>nomissingok：需要轮转的日志不存在时，报错</li>
<li>daily：按天轮转日志</li>
<li>weekly：按周轮转日志</li>
<li>monthly：按月轮转日志</li>
<li>yearly：按年轮转日志</li>
<li>dateext：以日期设置旧日志文件后缀【布尔类型】</li>
<li>nodateext：不用日期设置旧日志文件后缀</li>
<li>dateformat：设置旧日志文件后缀格式【默认-%Y%m%d】</li>
<li>olddir directory：旧日志被移动到一个单独的目录，可以是相对路径，也可以是绝对路径【但必须在同一个物理磁盘上】</li>
<li>noolddir：轮转日志在同级目录</li>
<li>postrotate/endscript：日志轮转之后执行的命令或脚本【/bin/sh】，这些指令只可能出现在日志文件定义中<ul>
<li>可以向进程发送特殊信号【signal】触发程序产生新的日志文件【相当于使用了create选项】</li>
</ul>
</li>
<li>prerotate/endscript：日志轮转之前执行的命令或脚本【/bin/sh】，这些指令只可能出现在日志文件定义中</li>
<li>sharedscripts：对于同一个log定义下的所有待轮转的日志文件，他们所需执行的pre或post脚本仅被执行一次；</li>
<li>nosharedscripts：默认情况下，同一个log定义下每个待轮转的文件都会触发pre或post脚本的执行</li>
</ul>
<h1 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局设置</span><br><span class="line">compress  </span><br><span class="line"></span><br><span class="line"># 使用双引号以处理特殊情况，比如文件名中的空格等</span><br><span class="line"></span><br><span class="line"># 对于使用同一轮转配置的多个文件</span><br><span class="line"># 可以在一行书写多个待轮转文件，空格分隔</span><br><span class="line">&quot;/var/log/httpd/access.log&quot; /var/log/httpd/error.log &#123; </span><br><span class="line">    xxxxxx</span><br><span class="line">&#125;</span><br><span class="line"># 也可以一行写一个待轮转文件，书写多行</span><br><span class="line">/home/web/webhive/log/uwsgi/imgstore.log</span><br><span class="line">/home/web/webhive/log/uwsgi/shownail.log</span><br><span class="line">&#123;</span><br><span class="line">  copytruncate</span><br><span class="line">  daily</span><br><span class="line">  dateext</span><br><span class="line">  rotate 60</span><br><span class="line">  compress</span><br><span class="line">  delaycompress</span><br><span class="line">  missingok</span><br><span class="line">  notifempty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用掩码进行文件名匹配</span><br><span class="line">/var/log/news/* &#123; </span><br><span class="line">    xxxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>部署工具fabric</title>
    <url>/blog/2018/04/20/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7fabric/</url>
    <content><![CDATA[<h1 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h1><ul>
<li>-l 显示任务名称</li>
<li>-f 指定fab入口文件，默认为fabfile.py</li>
<li>-H 指定目标主机，多台主机以逗号分隔【当fab文件中只定义排除的主机列表时有效】</li>
<li>-x 排除指定主机【当fab文件中定义主机列表时有效，且列表形式必须一致，比如主机名，ip或同时包含用户名】</li>
<li>-u 目标主机用户名</li>
<li>-p 目标主机密码</li>
<li>-I 打开连接目标主机时的交互式提示</li>
<li>-P 以异步并行方式运行多主机任务，默认为串行运行</li>
<li>-R 指定role（角色），以角色名区分不同业务组设备</li>
<li>–skip-bad-hosts 跳过不可达主机</li>
<li>-t 设置目标主机连接超时时间（秒）</li>
<li>-T 设置远程主机命令执行超时时间（秒）</li>
<li>-w 当命令执行失败，发出警告，而非默认中止任务。</li>
<li>–set=KEY=VALUE,…   以逗号分隔设置环境变量</li>
<li>-z 设置并行执行时的进程数量</li>
</ul>
<h1 id="env设置"><a href="#env设置" class="headerlink" title="env设置"></a>env设置</h1><ul>
<li>env.hosts 定义目标主机列表，可以是ip或主机名<ul>
<li>此时可以只定义主机列表，形如：[‘172.17.20.12’, ‘172.17.20.13’]，此时所有主机将使用已定义好的用户名和密码连接目标主机</li>
<li>当各主机的用户名不同时，在hosts里定义用户名，形如：[<a href="mailto:&#39;zj-ops@172.17.20.12" target="_blank" rel="noopener">&#39;zj-ops@172.17.20.12</a>‘, <a href="mailto:&#39;zj-ops@172.17.20.13" target="_blank" rel="noopener">&#39;zj-ops@172.17.20.13</a>‘]</li>
</ul>
</li>
<li>env.exclude_hosts 排除指定主机</li>
<li>env.user 定义目标主机用户名<ul>
<li>仅限于所有主机使用相同用户名</li>
<li>当没有定义user变量，同时hosts里也没有user选项时，将设置user为本地用户</li>
</ul>
</li>
<li>env.password 定义目标主机密码<ul>
<li>仅限于所有主机使用相同密码</li>
<li>当没有定义password变量，同时passwords里没有定义密码时，将出现交互式的密码输入提示</li>
</ul>
</li>
<li>env.passwords 定义目标主机密码组<ul>
<li>passwords变量中的key中user、host、port必须同时设置，否则将依然提示输入密码</li>
<li>范例：env.passwords = <a href="mailto:{&#39;user1@172.17.20.12" target="_blank" rel="noopener">{&#39;user1@172.17.20.12</a>:22’: ‘123’, <a href="mailto:&#39;user2@172.17.20.13" target="_blank" rel="noopener">&#39;user2@172.17.20.13</a>:22’: ‘456’, <a href="mailto:&#39;zj-ops@2.2.2.2" target="_blank" rel="noopener">&#39;zj-ops@2.2.2.2</a>:22’: ‘abc’}</li>
</ul>
</li>
<li>env.gateway 定义网关设备【堡垒机、跳板机】，<ul>
<li>网关设备的认证信息在passwords变量中定义</li>
<li>当堡垒机的用户名与应用主机不同时，应当在此添加，如：env.gateway = <a href="mailto:&#39;zj-ops@2.2.2.2" target="_blank" rel="noopener">&#39;zj-ops@2.2.2.2</a>‘</li>
</ul>
</li>
<li>env.roledefs 将主机分组<ul>
<li>定义：env.roledefs = {‘test1’: [<a href="mailto:&#39;zj-ops@1.1.1.1" target="_blank" rel="noopener">&#39;zj-ops@1.1.1.1</a>‘], ‘test2’: [<a href="mailto:&#39;zj-web@1.1.1.2" target="_blank" rel="noopener">&#39;zj-web@1.1.1.2</a>‘], ‘test3’: [<a href="mailto:&#39;zj-ops@1.1.1.1" target="_blank" rel="noopener">&#39;zj-ops@1.1.1.1</a>‘, <a href="mailto:&#39;zj-web@1.1.1.2" target="_blank" rel="noopener">&#39;zj-web@1.1.1.2</a>‘]}</li>
<li>使用：使用roles装饰器，表明仅某个主机组执行此任务，例如：@roles(‘test1’)</li>
</ul>
</li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>with 上下文管理，与python的with类似<ul>
<li>导入：from fabric.context_managers import *</li>
</ul>
</li>
<li>run 运行远程命令</li>
<li>cd 远程切换目录</li>
<li>local 运行本地命令</li>
<li>lcd 本地切换目录</li>
<li>sudo 使用sudo执行远程命令</li>
<li>put 上传本地文件至远程主机</li>
<li>get 下载远程文件到本地主机</li>
<li>prompt  获得用户输入信息，如：prompt(‘please input user password:’)<ul>
<li>导入：from fabric.contrib.console import confirm, prompt</li>
</ul>
</li>
<li>confirm  获得提示信息确认，如：confirm(‘Test failed,Continue[Y/N]?’)<ul>
<li>导入：from fabric.contrib.console import confirm, prompt</li>
</ul>
</li>
<li>yellow|green|red 输出带颜色字体<ul>
<li>导入：from fabric.colors import *</li>
</ul>
</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul>
<li>@task 定义任务可以通过命令行【fab -l】看到</li>
<li>@runs_once 定义任务仅运行一次</li>
<li>@roles(‘test1’, ‘test2’) 定义任务仅被主机组执行</li>
<li>@hosts(<a href="mailto:&#39;zj-ops@172.17.20.12" target="_blank" rel="noopener">&#39;zj-ops@172.17.20.12</a>‘) 定义任务仅被此主机执行</li>
<li>@parallel 在多个主机并行执行任务【默认串行】</li>
</ul>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/4/16 17:08</span></span><br><span class="line"><span class="comment"># @Author  : simple0426</span></span><br><span class="line"><span class="comment"># @Email   : istyle.simple@gmail.com</span></span><br><span class="line"><span class="comment"># @File    : fabfile.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @desc    : 功能如下</span></span><br><span class="line"><span class="comment"># 1.查看系统信息</span></span><br><span class="line"><span class="comment"># 2.部署nginx代码</span></span><br><span class="line"><span class="comment"># 3.回滚nginx代码</span></span><br><span class="line"><span class="comment"># 4.更新nginx配置【更新成功后自动重启，更新失败自动回滚配置】</span></span><br><span class="line"><span class="comment"># 5.查看nginx日志【分主机分项目】</span></span><br><span class="line"><span class="comment"># 6.登陆nginx主机【分主机】</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> fabric.context_managers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> fabric.contrib.console <span class="keyword">import</span> prompt</span><br><span class="line"><span class="keyword">from</span> fabric.colors <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">'zj-ops@1.1.1.1'</span>, <span class="string">'zj-web@1.1.1.2'</span>]</span><br><span class="line">env.gateway = <span class="string">'zj-ops@2.2.2.2'</span></span><br><span class="line">env.passwords = &#123;</span><br><span class="line">    <span class="string">'zj-ops@1.1.1.1:22'</span>: <span class="string">'1213456'</span>,</span><br><span class="line">    <span class="string">'zj-web@1.1.1.2:22'</span>: <span class="string">'1213456'</span>,</span><br><span class="line">    <span class="string">'zj-ops@2.2.2.2:22'</span>: <span class="string">'1213456'</span>,</span><br><span class="line">&#125;</span><br><span class="line">env.roledefs = &#123;</span><br><span class="line">    <span class="string">'web1'</span>: [<span class="string">'zj-ops@1.1.1.1'</span>],</span><br><span class="line">    <span class="string">'web2'</span>: [<span class="string">'zj-web@1.1.1.2'</span>],</span><br><span class="line">    <span class="string">'webserver'</span>: [<span class="string">'zj-ops@1.1.1.1'</span>, <span class="string">'zj-web@1.1.1.2'</span>]</span><br><span class="line">&#125;</span><br><span class="line">project_dict = &#123;</span><br><span class="line">    <span class="string">'fop'</span>: &#123;<span class="string">'name'</span>: <span class="string">'fop'</span>, <span class="string">'log'</span>: <span class="string">'fop.abc.cn.log'</span>&#125;,</span><br><span class="line">    <span class="string">'kop'</span>: &#123;<span class="string">'name'</span>: <span class="string">'kop'</span>, <span class="string">'log'</span>: <span class="string">'kop.abc.cn.log'</span>&#125;,</span><br><span class="line">    <span class="string">'check'</span>: &#123;<span class="string">'name'</span>: <span class="string">'cloud-h5'</span>, <span class="string">'log'</span>: <span class="string">'check.fff.cn.log'</span>&#125;,</span><br><span class="line">    <span class="string">'open'</span>: &#123;<span class="string">'name'</span>: <span class="string">'cloud'</span>, <span class="string">'log'</span>: <span class="string">'open.fff.cn.log'</span>&#125;,</span><br><span class="line">    <span class="string">'www'</span>: &#123;<span class="string">'name'</span>: <span class="string">'kingold-web'</span>, <span class="string">'log'</span>: <span class="string">'www.fff.cn.log'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="meta">@parallel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">df</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''查看所有主机的磁盘信息'''</span></span><br><span class="line">    <span class="keyword">print</span> yellow(run(<span class="string">'df -h'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="meta">@roles('web1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''只用于查看web1的内存'''</span></span><br><span class="line">    run(<span class="string">'free -m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="meta">@hosts('zj-web@1.1.1.2')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uptime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''只用于查看1.1.1.2的负载信息'''</span></span><br><span class="line">    <span class="keyword">print</span> green(run(<span class="string">'uptime'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''如果文件或目录存在则删除'''</span></span><br><span class="line">    dest_file = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'deploy'</span>, filename)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(dest_file) <span class="keyword">and</span> os.path.isdir(dest_file):</span><br><span class="line">        shutil.rmtree(dest_file)</span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(dest_file) <span class="keyword">and</span> os.path.isfile(dest_file):</span><br><span class="line">        os.remove(dest_file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@runs_once</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tar_code</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''本地代码打包'''</span></span><br><span class="line">    project = prompt(<span class="string">'请输入要部署的项目:'</span>).strip()</span><br><span class="line">    <span class="keyword">print</span> yellow(<span class="string">'本地代码打包'</span>)</span><br><span class="line">    <span class="keyword">if</span> project <span class="keyword">not</span> <span class="keyword">in</span> project_dict.keys():</span><br><span class="line">        abort(<span class="string">'请输入正确的项目名称'</span>)</span><br><span class="line">    project_name = project_dict[project][<span class="string">'name'</span>]</span><br><span class="line">    delete_files(project_name)</span><br><span class="line">    delete_files(<span class="string">'%s.tar.gz'</span> % project_name)</span><br><span class="line">    <span class="keyword">with</span> lcd(<span class="string">'~/deploy'</span>):</span><br><span class="line">        local(<span class="string">'git clone git@10.10.10.164:kingold_app/%s.git'</span> %  project_name, capture=<span class="literal">True</span>)</span><br><span class="line">        local(<span class="string">'tar czf %s.tar.gz %s'</span> % (project_name, project_name), capture=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> project</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backup_code</span><span class="params">(project)</span>:</span></span><br><span class="line">    <span class="string">'''远程备份代码'''</span></span><br><span class="line">    <span class="keyword">print</span> yellow(<span class="string">'远程备份代码'</span>)</span><br><span class="line">    <span class="keyword">if</span> project <span class="keyword">not</span> <span class="keyword">in</span> project_dict.keys():</span><br><span class="line">        abort(<span class="string">'请输入正确的项目名称'</span>)</span><br><span class="line">    project_name = project_dict[project][<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">with</span> cd(<span class="string">'~/nginx'</span>):</span><br><span class="line">        <span class="keyword">with</span> settings(warn_only=<span class="literal">True</span>):</span><br><span class="line">            result = run(<span class="string">'rsync -az --delete %s/ %s.bak/'</span> % (project_name, project_name), quiet=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> result.succeeded:</span><br><span class="line">            <span class="keyword">print</span> green(<span class="string">'代码备份成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_code</span><span class="params">(project)</span>:</span></span><br><span class="line">    <span class="string">"""上传代码【传输压缩包】"""</span></span><br><span class="line">    <span class="keyword">print</span> yellow(<span class="string">'本地上传代码'</span>)</span><br><span class="line">    <span class="keyword">if</span> project <span class="keyword">not</span> <span class="keyword">in</span> project_dict.keys():</span><br><span class="line">        abort(<span class="string">'请输入正确的项目名称'</span>)</span><br><span class="line">    project_name = project_dict[project][<span class="string">'name'</span>]</span><br><span class="line">    result = put(<span class="string">'~/deploy/%s.tar.gz'</span> % project_name, <span class="string">'~/nginx/%s.tar.gz'</span> % project_name)</span><br><span class="line">    <span class="keyword">if</span> result.failed:</span><br><span class="line">        abort(<span class="string">"上传代码失败！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> cd(<span class="string">'~/nginx'</span>):</span><br><span class="line">            run(<span class="string">'tar xzf %s.tar.gz'</span> % project_name, quiet=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">print</span> green(<span class="string">'代码部署成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateconf</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''更新配置文件目录'''</span></span><br><span class="line">    <span class="comment"># 备份</span></span><br><span class="line">    <span class="keyword">with</span> cd(<span class="string">'nginx'</span>):</span><br><span class="line">        run(<span class="string">'rsync -az --delete conf/ conf.bak/'</span>)</span><br><span class="line">    <span class="comment"># 上传</span></span><br><span class="line">    result = put(<span class="string">'~/deploy/conf'</span>, <span class="string">'~/nginx'</span>)</span><br><span class="line">    <span class="keyword">with</span> settings(warn_only=<span class="literal">True</span>) <span class="keyword">and</span> cd(<span class="string">'nginx'</span>):</span><br><span class="line">        <span class="keyword">if</span> result.failed:</span><br><span class="line">            <span class="comment"># 回滚</span></span><br><span class="line">            run(<span class="string">'rsync -az --delete conf.bak/ conf/'</span>)</span><br><span class="line">            abort(<span class="string">'上传失败'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res_conf = sudo(<span class="string">'~/nginx/sbin/nginx -t'</span>, quiet=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 配置文件有效，重启nginx</span></span><br><span class="line">            <span class="keyword">if</span> res_conf.succeeded:</span><br><span class="line">                nginx_count = run(<span class="string">'ps aux|grep nginx|grep -v grep|wc -l'</span>)</span><br><span class="line">                <span class="keyword">if</span> nginx_count.stdout == <span class="string">'0'</span>:</span><br><span class="line">                    sudo(<span class="string">'~/nginx/sbin/nginx'</span>)</span><br><span class="line">                    <span class="keyword">print</span> green(<span class="string">'nginx启动成功'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sudo(<span class="string">'~/nginx/sbin/nginx -s reload'</span>)</span><br><span class="line">                    <span class="keyword">print</span> green(<span class="string">'nginx重启成功'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 配置文件无效，回滚配置</span></span><br><span class="line">                run(<span class="string">'rsync -az --delete conf.bak/ conf/'</span>)</span><br><span class="line">                <span class="keyword">print</span> red(res_conf.stdout)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rollback</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''服务回滚'''</span></span><br><span class="line">    project = prompt(<span class="string">'请输入要回滚的项目:'</span>).strip()</span><br><span class="line">    <span class="keyword">print</span> yellow(<span class="string">'代码回滚'</span>)</span><br><span class="line">    <span class="keyword">if</span> project <span class="keyword">not</span> <span class="keyword">in</span> project_dict.keys():</span><br><span class="line">        abort(<span class="string">'请输入正确的项目名称'</span>)</span><br><span class="line">    project_name = project_dict[project][<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">with</span> settings(warn_only=<span class="literal">True</span>):</span><br><span class="line">        result = run(<span class="string">'rsync -az --delete %s.bak/ %s/'</span> % (project_name, project_name), quiet=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> result.succeeded:</span><br><span class="line">            <span class="keyword">print</span> green(<span class="string">'代码回滚成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deploy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''服务部署'''</span></span><br><span class="line">    project = tar_code()</span><br><span class="line">    backup_code(project)</span><br><span class="line">    push_code(project)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="meta">@runs_once</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">host</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''设置登陆主机'''</span></span><br><span class="line">    <span class="keyword">print</span> green(json.dumps(env.hosts, indent=<span class="number">4</span>))</span><br><span class="line">    host = prompt(<span class="string">'请输入要登陆的主机'</span>)</span><br><span class="line">    env.exclude_hosts.extend(env.hosts)</span><br><span class="line">    <span class="keyword">for</span> hostname <span class="keyword">in</span> env.hosts:</span><br><span class="line">        <span class="keyword">if</span> host <span class="keyword">in</span> hostname:</span><br><span class="line">            env.exclude_hosts.remove(hostname)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''远程登陆[需设置登陆主机]'''</span></span><br><span class="line">    open_shell()</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''查看日志[需设置登陆主机]'''</span></span><br><span class="line">    <span class="keyword">print</span> green(json.dumps(project_dict.keys()))</span><br><span class="line">    project = prompt(<span class="string">'请输入要部署的项目:'</span>).strip()</span><br><span class="line">    project_log = project_dict[project][<span class="string">'log'</span>]</span><br><span class="line">    <span class="keyword">with</span> cd(<span class="string">'~/nginx/logs'</span>):</span><br><span class="line">        run(<span class="string">'tail -10f %s'</span> % project_log)</span><br></pre></td></tr></table></figure>
<h1 id="QAQ"><a href="#QAQ" class="headerlink" title="QAQ"></a>QAQ</h1><ul>
<li>安装：pip install fabric</li>
<li><a href="http://www.cnblogs.com/aslongas/p/5961144.html" target="_blank" rel="noopener">参考</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>文件共享samba</title>
    <url>/blog/2018/02/26/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%ABsamba/</url>
    <content><![CDATA[<h1 id="安装samba软件"><a href="#安装samba软件" class="headerlink" title="安装samba软件"></a>安装samba软件</h1><h1 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h1><h2 id="创建系统用户组"><a href="#创建系统用户组" class="headerlink" title="创建系统用户组"></a>创建系统用户组</h2><p>groupadd marketop</p>
<h2 id="创建系统用户"><a href="#创建系统用户" class="headerlink" title="创建系统用户"></a>创建系统用户</h2><ul>
<li>useradd -g marketop -s /usr/sbin/nologin -M ceshi1</li>
<li>useradd -g marketop -s /usr/sbin/nologin -M marketop</li>
</ul>
<h2 id="将系统用户转为samba用户"><a href="#将系统用户转为samba用户" class="headerlink" title="将系统用户转为samba用户"></a>将系统用户转为samba用户</h2><blockquote>
<p>同时设置密码</p>
</blockquote>
<ul>
<li>smbpasswd -a marketop</li>
<li>smbpasswd -a ceshi1</li>
</ul>
<h1 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h1><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>mkdir market_operation</p>
<h2 id="变更目录所有者"><a href="#变更目录所有者" class="headerlink" title="变更目录所有者"></a>变更目录所有者</h2><p>chown ceshi1.marketop market_operation/</p>
<h2 id="目录设置粘滞位"><a href="#目录设置粘滞位" class="headerlink" title="目录设置粘滞位"></a>目录设置粘滞位</h2><blockquote>
<p>当一个目录被设置为”粘着位”(用chmod a+t),则该目录下的文件只能由<br>一、超级管理员删除<br>二、该目录的所有者删除<br>三、该文件的所有者删除<br>也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。</p>
</blockquote>
<p>chmod a+t market_operation/</p>
<h1 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h1><h2 id="可用参数"><a href="#可用参数" class="headerlink" title="可用参数"></a>可用参数</h2><ul>
<li>[public] 共享文件夹名称</li>
<li>path 共享路径</li>
<li>public 公共文件夹，不许凭证可访问（访问权限在本地设置）</li>
<li>writable 可对文件夹写操作</li>
<li>Valid users 有访问文件夹权限的用户【@为组 】</li>
<li>browseable 该文件夹是否可见</li>
<li>read only =yes （默认）</li>
<li>write list= @shichang，cw1  可写权限列表（当前面为readonly=yes 时可写用户列表）</li>
<li>directory mask= 0744 （文件夹建立后的默认权限）</li>
<li>create  mask = 0600（文件建立后的默认权限）</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">   workgroup = WORKGROUP</span><br><span class="line">        server string = %h server (Samba, Ubuntu)</span><br><span class="line">   dns proxy = no</span><br><span class="line">   security = user</span><br><span class="line">   log file = /var/log/samba/log.%m</span><br><span class="line">   max log size = 1000</span><br><span class="line">   syslog = 0</span><br><span class="line">   panic action = /usr/share/samba/panic-action %d</span><br><span class="line">   server role = standalone server</span><br><span class="line">   passdb backend = tdbsam</span><br><span class="line">   obey pam restrictions = yes</span><br><span class="line">   unix password sync = yes</span><br><span class="line">   passwd program = /usr/bin/passwd %u</span><br><span class="line">   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .</span><br><span class="line">   pam password change = yes</span><br><span class="line">   map to guest = bad user</span><br><span class="line">   usershare allow guests = yes</span><br><span class="line"># 自定义选项</span><br><span class="line">[市场部]</span><br><span class="line">        path = /home/dell/market_operation</span><br><span class="line">        readonly = yes</span><br><span class="line">        write list = zhangwanting</span><br><span class="line">        valid users = @marketop</span><br><span class="line">        directory mask = 0755</span><br><span class="line">        create mask = 0640</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>连接：<code>win + R</code>  =》 <code>\\10.10.10.244</code></li>
<li>切换用户测试：<ul>
<li>删除网络连接：net use <code>****</code> /d</li>
</ul>
</li>
</ul>
<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><p>finder =》 连接服务器 =》 <code>smb://10.10.10.244</code></p>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><code>mount -t cifs –o username=sc1,passwordd=sc1 //10.10.10.1/Market   /mnt</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>域名解析服务-bind9</title>
    <url>/blog/2019/09/09/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1-bind9/</url>
    <content><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><code>sudo apt-get install bind9 -y</code></p>
<h1 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h1><ul>
<li>named.conf.options</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forwarders &#123;</span><br><span class="line">          202.106.196.115; //配置将不能解析的请求转发到哪[配置转发时，可不需配置根区域文件]</span><br><span class="line">   &#125;;</span><br><span class="line">   allow-query &#123;0.0.0.0/0;&#125;; //接收哪个网段下的解析请求</span><br></pre></td></tr></table></figure>
<ul>
<li>named.conf.local</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zone &quot;example.com&quot; &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;/etc/bind/db.example.com&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>db.example.com</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;此域的权威授权服务器为本机</span><br><span class="line">@       IN      NS      localhost.</span><br><span class="line">;解析example.com</span><br><span class="line">          IN      A      1.1.1.1</span><br><span class="line">;www.example.com解析设置</span><br><span class="line">www   IN      A       1.1.1.1</span><br><span class="line">test1   IN      A       10.10.10.244</span><br><span class="line">;test2.example.com 与test1.example.com互为别名</span><br><span class="line">test2   IN      CNAME   test1</span><br><span class="line">;test3.example.com 与 www.abc.com互为别名</span><br><span class="line">test3   IN      CNAME   www.abc.com.</span><br><span class="line">;邮件服务器解析</span><br><span class="line">@   IN  MX  10  mail.example.com.</span><br><span class="line">mail IN  A  192.168.1.2</span><br><span class="line">;基于域名解析的负载均衡</span><br><span class="line">www2 IN A 1.1.1.2</span><br><span class="line">www2 IN A 1.1.1.3</span><br><span class="line">www2 IN A 1.1.1.4</span><br><span class="line">;泛域名解析</span><br><span class="line">* IN A 1.1.1.5</span><br></pre></td></tr></table></figure>
<h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><ul>
<li>nslookup</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;www.example.com</span><br><span class="line">&gt;set type=mx #测试此域名下的邮件服务</span><br><span class="line">&gt;example.com</span><br></pre></td></tr></table></figure>
<ul>
<li>dig</li>
</ul>
<p><code>dig www.example.com</code></p>
<h1 id="非常用功能"><a href="#非常用功能" class="headerlink" title="非常用功能"></a>非常用功能</h1><ul>
<li>反向解析</li>
<li><p>主从复制</p>
<ul>
<li><p>主配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> zone &quot;abc.com&quot; IN &#123;</span><br><span class="line">    type master;</span><br><span class="line">    file &quot;abc.com.zone&quot;;</span><br><span class="line">    allow-transfer &#123; 192.168.0.98; &#125;; //允许从机复制</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zone &quot;abc.com&quot; IN &#123;</span><br><span class="line">    type slave;</span><br><span class="line">    file &quot;abc.com.zone&quot;;</span><br><span class="line">    masters &#123; 192.168.0.99; &#125;;  //从哪个主机复制内容</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分离解析[内外网解析不同的结果]</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view &quot;lan&quot; &#123;</span><br><span class="line">    match-clients &#123; 192.168.0.0/24; &#125;;</span><br><span class="line">    zone &quot;abc.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;abc.com.lan&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    zone &quot;.&quot; IN &#123;</span><br><span class="line">        type hint;</span><br><span class="line">        file &quot;named.ca&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">view &quot;wan&quot; &#123;</span><br><span class="line">    match-clients &#123; any; &#125;;</span><br><span class="line">    zone &quot;abc.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;abc.com.wan&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>子域委派【父域abc.com 不解析对子域da.abc.com的dns请求，将对子域的解析请求传给子域】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># zone区域配置</span><br><span class="line">da  IN  NS  ds-dns.abc.com.</span><br><span class="line">ds-dns IN  A  192.168.0.98</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bind9</tag>
      </tags>
  </entry>
  <entry>
    <title>版本库管理-svn</title>
    <url>/blog/2019/06/24/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91/%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86-svn/</url>
    <content><![CDATA[<h1 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a><a href="https://yq.aliyun.com/articles/38802" target="_blank" rel="noopener">安装与部署</a></h1><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><ul>
<li>authz</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[groups]</span><br><span class="line">member = xianing,chengle,liuzuowei</span><br><span class="line">[repos:/]</span><br><span class="line">@member = rw</span><br></pre></td></tr></table></figure>
<ul>
<li>passwd</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">xianing = svn1234</span><br><span class="line">chengle = svn1234</span><br><span class="line">liuzuowei = svn1234</span><br></pre></td></tr></table></figure>
<ul>
<li>svnserve.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[general]</span><br><span class="line">anon-access = none</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure>
<h1 id="hooks设置"><a href="#hooks设置" class="headerlink" title="hooks设置"></a>hooks设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">export LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">export LANGUAGE=&quot;en_US:en&quot;</span><br><span class="line">REPOS=&quot;$1&quot;</span><br><span class="line">REV=&quot;$2&quot;</span><br><span class="line">SVN_PATH=/usr/bin/svn</span><br><span class="line">WEB_PATH=/usr/share/nginx/html</span><br><span class="line">LOG_PATH=/tmp/svn_update.log</span><br><span class="line">#此行已注释</span><br><span class="line">#/usr/bin/svn update --username user --password password $WEB_PATH --no-auth-cache</span><br><span class="line">echo &quot;\n\n\n##########开始提交 &quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &apos;##################&apos; &gt;&gt;$LOG_PATH</span><br><span class="line">echo `whoami`,$REPOS,$REV &gt;&gt; $LOG_PATH</span><br><span class="line">#注意将此行user和password改为你具体的user和password</span><br><span class="line">sudo $SVN_PATH update --username like --password svn1234 $WEB_PATH --no-auth-cache &gt;&gt; $LOG_PATH</span><br><span class="line">sudo chown -R www-data:www-data $WEB_PATH</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之templates学习</title>
    <url>/blog/2018/06/13/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91%E4%B9%8Btemplates%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>约定</strong><br>为避免模板二次渲染，特在变量{{ }}和流程控制{% %}中添加短横线屏蔽，替换结果如下：</p>
<ul>
<li>{{ }} 替换为<code>{-{ }-}</code></li>
<li>{% %}替换为<code>{-% %-}</code></li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>含有模板【例如jinja2模板】语法的html文件即是模板文件</p>
<h2 id="主要语法"><a href="#主要语法" class="headerlink" title="主要语法"></a>主要语法</h2><ul>
<li><a href="#变量">变量</a>：<code>{-{ }-}</code></li>
<li><a href="#流程控制">流程控制(标签)</a>：<code>{-% %-}</code></li>
<li>注释：{# #}</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>== 等于</li>
<li>!= 不等于</li>
<li><code>&gt; &gt;=</code> 大于等于</li>
<li><code>&lt; &lt;=</code> 小于等于</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.template import Template, Context</span><br><span class="line">#建立模板对象</span><br><span class="line">t = Template(&quot;my name is &#123;-&#123; name &#125;-&#125;&quot;) </span><br><span class="line">#建立参数对象</span><br><span class="line">c = Context(&#123;&quot;name&quot;: &quot;jingqi&quot;&#125;) </span><br><span class="line">#使用Template的render方法将Context对象传入</span><br><span class="line">t.render(c)</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><blockquote>
<p>在django模板系统中处理复杂数据结构使用（.）字符</p>
</blockquote>
<ul>
<li>根据对象的key或索引获取对象的value</li>
<li>调用对象的方法【方法不能加括号，不能加参数】</li>
<li>获取对象的属性</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>变量可以通过过滤器进行结果显示变更的操作，<br>例如设置变量的默认值：<code>{-{ test|default:&#39;空值&#39; }-}</code></p>
<h2 id="特殊变量forloop"><a href="#特殊变量forloop" class="headerlink" title="特殊变量forloop"></a>特殊变量forloop</h2><blockquote>
<p>forloop变量只能在循环中得到，当模板解析器到达endfor时forloop就消失了</p>
</blockquote>
<ul>
<li>forloop.counter：表示循环的次数，从1开始计数</li>
<li>forloop.counter0：表示循环的次数，从0开始计数</li>
<li>forloop.revcounter：反向循环计数，末尾是1</li>
<li>forloop.revcounter0：反向循环计数，末尾是0</li>
<li>forloop.first：如果是循环的第一个元素</li>
<li>forloop.last：如果是循环的最后一个元素</li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h2><blockquote>
<p>if可以接受and、or、not测试同一变量，但不允许同一个标签内同时出现and和or，<br>但可以多次出现and或or等同一逻辑</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;-% if test &gt; 2 %-&#125;</span><br><span class="line">    &lt;p&gt;大于2&lt;/p&gt;</span><br><span class="line">&#123;-% elif test == 2 %-&#125;</span><br><span class="line">    &lt;p&gt;等于2&lt;/p&gt;</span><br><span class="line">&#123;-% else %-&#125;</span><br><span class="line">    &lt;p&gt;小于2&lt;/p&gt;</span><br><span class="line">&#123;-% endif %-&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul>
<li>列表迭代</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;-% for item in test %-&#125;</span><br><span class="line">    &lt;p&gt;&#123;-&#123; item &#125;-&#125;&lt;/p&gt;</span><br><span class="line">&#123;-% empty %-&#125;</span><br><span class="line">    &lt;p&gt;列表为空&lt;/p&gt;</span><br><span class="line">&#123;-% endfor %-&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字典迭代</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;-% for key,value in test.items %-&#125;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;-&#123; key &#125;-&#125;:&#123;-&#123; value &#125;-&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&#123;-% endfor %-&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><ul>
<li>csrf_token：<code>{-% csrf_token %-}</code> 用于防治csrf跨站攻击验证；其实这里会生成一个input标签，和其他表单标签一起提交给后台</li>
<li>url引用：<code>&lt;form action=&quot;{-% url &quot;bieming&quot;%-}&quot; &gt;</code> 在html中引用urls.py中配置的url路径</li>
<li>with别名设置：<code>{-% with total=fhjsaldfhjsdfhlasdfhljsdal %-} {-{ total }-} {-% endwith %-}</code></li>
<li>verbatim禁止渲染：<code>{-%  verbatim %-}{-{ ceshi }-}{-% endverbatim %-}</code></li>
</ul>
<h2 id="安全转义"><a href="#安全转义" class="headerlink" title="安全转义"></a>安全转义</h2><blockquote>
<p>为了避免非法输入造成安全威胁，django模板系统对html开启自动转义</p>
</blockquote>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><code>&lt;自动转义为&amp;lt</code></li>
<li><code>&gt;自动转义为&amp;gt</code></li>
<li><code>&#39;自动转义为&amp;#39</code></li>
<li><code>&quot;自动转义为&amp;quot</code></li>
<li><code>&amp;自动转义为&amp;amp</code></li>
</ul>
<h3 id="转义范例"><a href="#转义范例" class="headerlink" title="转义范例"></a>转义范例</h3><ul>
<li><p>单变量关闭自动转义</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tm = Template(&apos;my name is &#123;&#123; name|safe &#125;&#125;&apos;)</span><br><span class="line">con = Context(&#123;&apos;name&apos;: &apos;&lt;b&gt;&apos;&#125;)</span><br><span class="line">tm.render(con)</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块级别关闭自动转义</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">Hello &#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="自定义标签和过滤器"><a href="#自定义标签和过滤器" class="headerlink" title="自定义标签和过滤器"></a>自定义标签和过滤器</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li>在已经注册过的app下新建templatetags包</li>
<li>在templatetags包下编写python文件</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>filter对变量进行处理，可以在if和for中使用</li>
<li>simple_tag为自定义流程标签，不能在if和for中使用</li>
</ul>
<h2 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h2><h3 id="python文件"><a href="#python文件" class="headerlink" title="python文件"></a>python文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import template</span><br><span class="line">register = template.Library()</span><br><span class="line"># name为给过滤器添加别名</span><br><span class="line">@register.filter(name=&apos;percent&apos;)</span><br><span class="line">def percent_decimal(value):</span><br><span class="line">    value = float(str(value))</span><br><span class="line">    value = round(value, 3)</span><br><span class="line">    value = value * 100</span><br><span class="line">    return str(value) + &apos;%&apos;</span><br><span class="line"># 自定义标签</span><br><span class="line">@register.simple_tag</span><br><span class="line">def add_sum(v1, v2):</span><br><span class="line">    return v1 + v2</span><br></pre></td></tr></table></figure>
<h3 id="html文件"><a href="#html文件" class="headerlink" title="html文件"></a>html文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--在html文件顶部使用load加载标签文件名--&gt;</span><br><span class="line">&#123;-% load MyTag %-&#125;</span><br><span class="line">Your input is &#123;-&#123; value|percent &#125;-&#125;.</span><br><span class="line">&lt;p&gt;output is &#123;-% add_sum v1 v2 %-&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h1 id="静态文件设置"><a href="#静态文件设置" class="headerlink" title="静态文件设置"></a>静态文件设置</h1><p>在编写模板时，引入一些现成的库文件【如bootstrap，jquery】，此时需要做一些额外的配置，相关设置如下：</p>
<ol>
<li>在settings中设置公有静态目录</li>
<li>将库文件放入设置的静态目录中</li>
<li>使用【load staticfiles】标签导入相关语法</li>
<li>使用标签语法【static “url”】导入相关库文件</li>
</ol>
<h1 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h1><h2 id="基础模板设置"><a href="#基础模板设置" class="headerlink" title="基础模板设置"></a>基础模板设置</h2><blockquote>
<p>每个block必须是唯一的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&#123;-% load staticfiles %-&#125;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&#123;-% block title %-&#125;title&#123;-% endblock %-&#125;&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;-% static &quot;bootstrap-3.3.7-dist/css/bootstrap.css&quot; %-&#125;&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;-% static &quot;jquery-3.1.1.js&quot; %-&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;-% static &quot;bootstrap-3.3.7-dist/js/bootstrap.js&quot; %-&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;-% block content %-&#125;你好&#123;-% endblock %-&#125;</span><br><span class="line">&#123;-% block footer %-&#125;测试&#123;-% endblock %-&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="子模板设置"><a href="#子模板设置" class="headerlink" title="子模板设置"></a>子模板设置</h2><p>当需要继承基础模板时，使用extends关键词导入基础模板，且extends必须位于文件首行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;-% extends &quot;base.html&quot; %-&#125;</span><br><span class="line">&#123;-% load Mytag %-&#125;</span><br><span class="line">&#123;-% block content %-&#125;</span><br><span class="line">&lt;p&gt;output is&#123;-% add_sum v1 v2 %-&#125;&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;table class=&quot;table table-bordered&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;1&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;2&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;3&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;4&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;a&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;b&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;c&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;d&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;-% endblock %-&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>templates</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之中间件学习</title>
    <url>/blog/2018/06/30/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul>
<li>保存在浏览器端的键值对</li>
<li>cookie依附在请求头或响应头中出现</li>
<li>向网站发送请求时，会自动携带网站的cookie信息</li>
<li>缺点<ul>
<li>明文传输，容易被劫持和篡改</li>
<li>不能用于存储敏感信息</li>
<li>客户端存储，因此cookie可能被拒绝</li>
</ul>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>查看cookie：request.COOKIES、request.COOKIES[‘id’]</li>
<li>设置cookie：request.set_cookie</li>
<li>测试客户端是否可以存储cookie：request.test_cookie_worked</li>
<li>cookie参数：<br><code>set_cookie(self, key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False)</code></li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_age</td>
<td>None</td>
<td>cookie有效期，单位s</td>
</tr>
<tr>
<td>expires</td>
<td>None</td>
<td>指定时间点cookie过期</td>
</tr>
<tr>
<td>path</td>
<td>/</td>
<td>只在某个url下cookie有效</td>
</tr>
<tr>
<td>domain</td>
<td>None</td>
<td>只在某个域有效</td>
</tr>
<tr>
<td>secure</td>
<td>False</td>
<td>为True时只在https下有效</td>
</tr>
<tr>
<td>httponly</td>
<td>False</td>
<td>只在http下有效</td>
</tr>
</tbody>
</table>
<h2 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test_cookie(request):</span><br><span class="line">    if request.COOKIES and &apos;id&apos; in request.COOKIES:</span><br><span class="line">        return HttpResponse(&apos;hello %s&apos; % request.COOKIES[&apos;id&apos;])</span><br><span class="line">    else:</span><br><span class="line">        ip = request.META[&apos;REMOTE_ADDR&apos;]</span><br><span class="line">        response = HttpResponse(&apos;hello world&apos;)</span><br><span class="line">        response.set_cookie(&apos;id&apos;, ip, max_age=10)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><h2 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul>
<li>视图的第一个参数request包含session属性，它是一个字典对象</li>
<li>它是基于cookie实现<ul>
<li>检测客户端cookie是否可用：request.session.test_cookie_worked()</li>
<li>设置测试cookie：request.session.set_test_cookie()</li>
<li>删除测试的cookie：request.session.delete_test_cookie()      </li>
</ul>
</li>
<li>用户登录时，django产生随机字符串作为session的key，将用户设置的session的key/value对进过“加工”后作为session的value在数据库中存储；同时设置一个cookie键值对，key为“sessionid”，value为session的key返回给客户端存储</li>
<li>当用户再次登陆时，服务端从cookie中取出sessionid的值作为session的key，根据key在数据库中取出session的value，从而可以验证用户是否已登录</li>
</ul>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="开启session"><a href="#开启session" class="headerlink" title="开启session"></a>开启session</h3><blockquote>
<p>项目settings.py</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.sessions&apos;,</span><br><span class="line">]</span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="session配置"><a href="#session配置" class="headerlink" title="session配置"></a>session配置</h3><ul>
<li><p>默认配置</p>
<ul>
<li>django.conf.global_settings中有默认设置，可在settings中覆盖</li>
<li>默认使用数据库存储<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SESSION_ENGINE = &apos;django.contrib.sessions.backends.db&apos;   # 引擎（默认）</span><br><span class="line">SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）</span><br><span class="line">SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）</span><br><span class="line">SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）</span><br><span class="line">SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）</span><br><span class="line">SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）</span><br><span class="line">SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）</span><br><span class="line">SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）</span><br><span class="line">SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其他存储方式</p>
<ul>
<li><p>使用redis存储[django-redis-sessions]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SESSION_REDIS_DB = 5</span><br><span class="line">SESSION_REDIS_HOST = 127.0.0.1</span><br><span class="line">SESSION_REDIS_PORT = 6379</span><br><span class="line">SESSION_ENGINE = &apos;redis_sessions.session&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用cache系统存储</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SESSION_ENGINES= &quot;django.contrib.sessions.backends.cache&quot;</span><br><span class="line">SESSION_CACHE_ALIAS = &quot;default&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="#http://www.cnblogs.com/wupeiqi/articles/5246483.html">其他存储方式</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="应用范例-1"><a href="#应用范例-1" class="headerlink" title="应用范例"></a>应用范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def auth(func):</span><br><span class="line">    def wrapper(request, *args, **kwargs):</span><br><span class="line">        if request.session.get(&apos;username&apos;):</span><br><span class="line">            obj = func(request, *args, **kwargs)</span><br><span class="line">            return obj</span><br><span class="line">        else:</span><br><span class="line">            return redirect(&apos;login.html&apos;)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@auth</span><br><span class="line">def ok(request):</span><br><span class="line">    user = request.session.get(&apos;username&apos;)</span><br><span class="line">    return render(request, &apos;ok.html&apos;, context=&#123;&apos;user&apos;:user&#125;)</span><br><span class="line"></span><br><span class="line">@csrf_exempt</span><br><span class="line">def login(request):</span><br><span class="line">    if request.session.get(&apos;username&apos;):</span><br><span class="line">        return redirect(&apos;ok.html&apos;)</span><br><span class="line">    if request.method == &apos;POST&apos;:</span><br><span class="line">        if request.session.test_cookie_worked():</span><br><span class="line">            request.session.delete_test_cookie()</span><br><span class="line">            user = request.POST.get(&apos;user&apos;)</span><br><span class="line">            pwd = md5.encrypt(request.POST.get(&apos;passwd&apos;))</span><br><span class="line">            obj = UserInfo.objects.filter(username=user, password=pwd).first()</span><br><span class="line">            if obj:</span><br><span class="line">                request.session[&apos;username&apos;] = user</span><br><span class="line">                return redirect(&apos;ok.html&apos;)</span><br><span class="line">            else:</span><br><span class="line">                return render(request, &apos;login.html&apos;, &#123;&apos;msg&apos;: &apos;用户名或密码错误&apos;&#125;)</span><br><span class="line">        else:</span><br><span class="line">            return HttpResponse(&apos;请开启cookie&apos;)</span><br><span class="line">    request.session.set_test_cookie()</span><br><span class="line">    return render(request, &apos;login.html&apos;)</span><br><span class="line"></span><br><span class="line">@auth</span><br><span class="line">def logout(request):</span><br><span class="line">    del request.session[&apos;username&apos;]</span><br><span class="line">    return redirect(&apos;login.html&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="csrf装饰器"><a href="#csrf装饰器" class="headerlink" title="csrf装饰器"></a>csrf装饰器</h3><ul>
<li>导入：from django.views.decorators.csrf import csrf_exempt, csrf_protect</li>
<li>csrf_exempt：被装饰的函数不使用csrf【csrf中间件开启时，全站使用csrf验证】</li>
<li>csrf_protect：被装饰的函数使用csrf【csrf中间件屏蔽时，全站禁用csrf验证】</li>
</ul>
<h3 id="查看session存储内容"><a href="#查看session存储内容" class="headerlink" title="查看session存储内容"></a>查看session存储内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.sessions.models import Session</span><br><span class="line">session = Session.objects.get(session_key=&apos;90nv2o99bykw3qtqotrlt947c2pnx75f&apos;)</span><br><span class="line"># 解码session内容</span><br><span class="line">session.get_decoded()</span><br><span class="line"># 查看session过期时间</span><br><span class="line">session.expire_date</span><br><span class="line"># 查看session内容</span><br><span class="line">session.session_data</span><br></pre></td></tr></table></figure>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><ol>
<li>中间件1</li>
<li>中间件2</li>
</ol>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><ul>
<li>socket</li>
<li>中间件1的request</li>
<li>中间件2的request</li>
<li>url路由</li>
<li>中间件1的view</li>
<li>中间件2的view</li>
<li>视图函数</li>
<li>中间件2的response</li>
<li>中间件1的response</li>
<li>socket</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li>process_request<ul>
<li>process_request默认返回None，此时其他流程可以继续执行</li>
<li>如果返回非None，则请求只到此中间件即停止并返回请求</li>
</ul>
</li>
<li>process_response</li>
<li>process_view：和process_request一样从前往后执行，默认返回None</li>
<li>process_exception</li>
<li>process_template_response</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line">class M1(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&apos;M1.process_request&apos;)</span><br><span class="line">        # return HttpResponse(&apos;gun&apos;)</span><br><span class="line">    def process_view(self, request, callback, callback_args, call_kwargs):</span><br><span class="line">        print(&apos;M1.process_view&apos;, callback)</span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&apos;M1.process_response&apos;)</span><br><span class="line">        return response</span><br><span class="line">    def process_exception(self, request, exception):</span><br><span class="line">        print(&apos;M2.process_exception&apos;)</span><br><span class="line">        return HttpResponse(&apos;内部错误&apos;)</span><br><span class="line">class M2(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&apos;M2.process_request&apos;)</span><br><span class="line">    def process_view(self, request, callback, callback_args, call_kwargs):</span><br><span class="line">        print(&apos;M2.process_view&apos;, callback)</span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&apos;M2.process_response&apos;)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><ul>
<li>开发调试：dummy</li>
<li>内存：locmem<ul>
<li>默认选项：django.core.cache.backends.locmem.LocMemCache</li>
</ul>
</li>
<li>文件：filebased</li>
<li>数据库：db<ul>
<li>创建缓存表：python manage.py createcachetable</li>
</ul>
</li>
<li>memcached：memcached</li>
<li>redis【pip install django-redis】  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># settings设置</span><br><span class="line">CACHES = &#123;</span><br><span class="line">&quot;default&quot;: &#123;</span><br><span class="line">    &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, # 引擎</span><br><span class="line">    &quot;LOCATION&quot;: &quot;redis://192.168.10.10:6379/0&quot;, # 缓存位置</span><br><span class="line">    &apos;TIMEOUT&apos;: 300,  # 缓存超时，None永不过期，0立即过期</span><br><span class="line">    &quot;OPTIONS&quot;: &#123;</span><br><span class="line">        &apos;MAX_ENTRIES&apos;: 1000, # 最大缓存个数</span><br><span class="line">        &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,</span><br><span class="line">        # 默认使用纯python编写的解析器，HiredisParser为c语言编写的解析器可提高性能10倍</span><br><span class="line">        # 安装hiredis：pip install hiredis</span><br><span class="line">        #  &quot;PARSER_CLASS&quot;: &quot;redis.connection.HiredisParser&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="缓存级别"><a href="#缓存级别" class="headerlink" title="缓存级别"></a>缓存级别</h2><ul>
<li>全局模式【中间件】<ul>
<li>‘django.middleware.cache.UpdateCacheMiddleware’【位于所有中间件之前】</li>
<li>‘django.middleware.cache.FetchFromCacheMiddleware’【位于所有中间件之后】</li>
</ul>
</li>
<li><p>视图函数【cache_page装饰器】</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.views.decorators.cache import cache_page </span><br><span class="line">@cache_page(60 * 5) #括号内为时间以秒计算</span><br><span class="line">def test(request):</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    return HttpResponse(now)</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板变量【cache标签】</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 5是缓存时间，&apos;ceshi&apos;是缓存key</span><br><span class="line">&#123;% cache 5 &apos;ceshi&apos; %&#125;</span><br><span class="line">    &#123;&#123; now1 &#125;&#125;</span><br><span class="line">&#123;% endcache %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><ul>
<li>主要功能为：当识别到请求处理流程中的某一行为时，触发自定义动作</li>
<li>可以保存在项目同名app下<code>__init__.py</code>文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请求到来前，请求结束后触发</span><br><span class="line">from django.core.signals import request_finished, request_started, got_request_exception</span><br><span class="line"># 对象保存前后触发</span><br><span class="line">from django.db.models.signals import pre_delete, pre_init, pre_save, pre_migrate</span><br><span class="line">from django.db.models.signals import post_delete, post_init, post_migrate, post_save</span><br><span class="line"># 多对多关系表变更触发</span><br><span class="line">from django.db.models.signals import m2m_changed, class_prepared</span><br><span class="line"># 创建数据库连接时触发</span><br><span class="line">from django.db.backends.signals import connection_created</span><br><span class="line"></span><br><span class="line">def callback(sender, **kwargs):</span><br><span class="line">    print(&apos;request is comming!&apos;)</span><br><span class="line">    print(sender, kwargs)</span><br><span class="line">request_started.connect(callback)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>缓存</tag>
        <tag>中间件</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之models学习</title>
    <url>/blog/2018/06/14/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91%E4%B9%8Bmodels%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ORM介绍"><a href="#ORM介绍" class="headerlink" title="ORM介绍"></a>ORM介绍</h1><h2 id="ORM介绍-1"><a href="#ORM介绍-1" class="headerlink" title="ORM介绍"></a>ORM介绍</h2><ul>
<li>Object Relational Mapping(对象关系映射)：是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间进行转换。</li>
<li>在django中主要实现方式为：在modles文件中定义类，通过映射关系和相关命令转换为对数据库中对应的对象进行操作。</li>
</ul>
<h2 id="django中的映射关系"><a href="#django中的映射关系" class="headerlink" title="django中的映射关系"></a>django中的映射关系</h2><table>
<thead>
<tr>
<th>程序</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>类名</td>
<td>表名</td>
</tr>
<tr>
<td>属性</td>
<td>字段名</td>
</tr>
<tr>
<td>类实例化对象</td>
<td>数据记录</td>
</tr>
</tbody>
</table>
<h2 id="ORM功能"><a href="#ORM功能" class="headerlink" title="ORM功能"></a>ORM功能</h2><ul>
<li><a href="#创建数据表">创建数据表</a></li>
<li><a href="#数据操作">操作数据</a></li>
</ul>
<h1 id="前置配置"><a href="#前置配置" class="headerlink" title="前置配置"></a>前置配置</h1><ul>
<li>创建数据库，设置相应的用户和权限</li>
<li>安装python连接数据库的引擎【如连接mysql的pymysql】</li>
<li>在settings文件中配置<a href="/2018/06/12/django开发之基本设置/#数据库设置">数据库相关选项</a></li>
</ul>
<h1 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h1><h2 id="数据库建模"><a href="#数据库建模" class="headerlink" title="数据库建模"></a>数据库建模</h2><ul>
<li>作者（Author）和作者详情（AuthorDetail）为一对一关系（OneToOneField）</li>
<li>出版社（Publisher）和书籍（Book）为一对多关系（ForeignKey）</li>
<li>书籍（Book）和作者（Author）为多对多关系（ManyToManyField）</li>
</ul>
<h2 id="表结构范例"><a href="#表结构范例" class="headerlink" title="表结构范例"></a>表结构范例</h2><blockquote>
<p>modles.py文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Publisher(models.Model):</span><br><span class="line">    name = models.CharField(max_length=30, verbose_name=&apos;名称&apos;)</span><br><span class="line">    address = models.CharField(&quot;地址&quot;, max_length=50)</span><br><span class="line">    city = models.CharField(&quot;城市&quot;, max_length=60)</span><br><span class="line">    state_province = models.CharField(max_length=30)</span><br><span class="line">    country = models.CharField(max_length=50)</span><br><span class="line">    website = models.URLField()</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &apos;出版商&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">class Author(models.Model):</span><br><span class="line">    name = models.CharField(max_length=30)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">class AuthorDetail(models.Model):</span><br><span class="line">    sex = models.BooleanField(max_length=1, choices=((0, &apos;男&apos;), (1, &apos;女&apos;)))</span><br><span class="line">    email = models.EmailField()</span><br><span class="line">    address = models.CharField(max_length=50)</span><br><span class="line">    birthday = models.DateField()</span><br><span class="line">    author = models.OneToOneField(Author)</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    publisher = models.ForeignKey(Publisher)</span><br><span class="line">    publication_date = models.DateField()</span><br><span class="line">    price = models.DecimalField(max_digits=5, decimal_places=2, default=10)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure>
<h2 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h2><ul>
<li>创建执行SQL的脚本：python manage.py makemigrations</li>
<li>查看建表SQL语句：python manage.py sqlmigrate app01 0001</li>
<li>执行建表SQL脚本：python manage.py migrate</li>
</ul>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><h3 id="基础操作方式"><a href="#基础操作方式" class="headerlink" title="基础操作方式"></a>基础操作方式</h3><ul>
<li>create方法：<br>  <code>Author.objects.create(name=&#39;he&#39;)</code></li>
<li>save方法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author = Author(name=&apos;jing&apos;)</span><br><span class="line">author.save()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一对多关系操作方式"><a href="#一对多关系操作方式" class="headerlink" title="一对多关系操作方式"></a>一对多关系操作方式</h3><blockquote>
<p>含有外键的表</p>
</blockquote>
<ul>
<li>获取外键字段对象【出版社】<br>  <code>pub_obj=Publisher(name=&#39;河大出版社&#39;,address=&#39;保定&#39;,city=&#39;保定&#39;,state_province=&#39;河北&#39;,country=&#39;China&#39;,website=&#39;http://www.hbu.com&#39;)</code></li>
<li>在添加数据时绑定外键字段<br>  <code>Book.objects.create(title=&#39;php&#39;, publication_date=&#39;2017-7-7&#39;, price=99, publisher=pub_obj)</code></li>
</ul>
<h3 id="多对多关系操作方式"><a href="#多对多关系操作方式" class="headerlink" title="多对多关系操作方式"></a>多对多关系操作方式</h3><blockquote>
<p>实质为关系表数据增加</p>
</blockquote>
<h4 id="正向操作"><a href="#正向操作" class="headerlink" title="正向操作"></a>正向操作</h4><blockquote>
<p>以外键所在表为操作对象，例如book</p>
</blockquote>
<ul>
<li>获取作者对象：<code>author = Author.objects.filter(id__gt=1)</code></li>
<li>获取书籍对象：<code>book = Book.objects.get(id=1)</code></li>
<li>在书籍处添加作者【一本书多个作者】：<code>book.authors.add(*author)</code><ul>
<li>删除作者：<code>book.authors.remove(*author)</code></li>
</ul>
</li>
</ul>
<h4 id="反向操作"><a href="#反向操作" class="headerlink" title="反向操作"></a>反向操作</h4><blockquote>
<p>从外键所映射的主键所在的表为操作对象，例如author</p>
</blockquote>
<ul>
<li>获取书籍对象：<code>book1 = Book.objects.filter(id__gt=1)</code></li>
<li>获取作者对象：<code>author1 = Author.objects.get(id=2)</code></li>
<li>作者处添加书籍【一个作者有多本书】：<code>author1.book_set.add(*book1)</code><ul>
<li>删除书籍：<code>author1.book_set.remove(*book1)</code></li>
</ul>
</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>Modle对象删除：Author.objects.get(id=1).delete()</li>
<li>Queryset对象删除：Author.objects.filter(id=1).delete()</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>update方法<ul>
<li>只能用于queryset对象【比如filter、all的结果】</li>
<li>update方法只对变更的属性赋值，效率较高<br><code>Author.objects.filter(id=1).update(name=&#39;yang&#39;)</code></li>
</ul>
</li>
<li>save方法<ul>
<li>对modle对象进行操作【比如get的结果】</li>
<li>save方法会对所有属性重新赋值，效率较低<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author = Author.objects.get(id=2)</span><br><span class="line">author.name = &apos;meng&apos;</span><br><span class="line">author.save()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询类API"><a href="#查询类API" class="headerlink" title="查询类API"></a>查询类API</h3><ul>
<li>filter：获取所有匹配的queryset对象</li>
<li>all：获取所有的queryset对象</li>
<li>get：获取指定条件的modle对象【没有或多于1个时则报错】</li>
</ul>
<h3 id="过滤型API"><a href="#过滤型API" class="headerlink" title="过滤型API"></a>过滤型API</h3><ul>
<li>value：获取由指定字段组成的queryset对象<br>  <code>Book.objects.filter(price__gt=12).values(&#39;price&#39;)</code></li>
<li>exclude：排除指定条件的数据<br>  <code>Book.objects.all().exclude(title=&#39;java&#39;)</code></li>
<li>count：返回指定条件的结果数量</li>
<li><code>[]</code>(切片)：返回指定数量的结果<br>  <code>Book.objects.all().order_by(&#39;title&#39;)[:2]</code></li>
<li>first/last：返回结果集中的第一条或最后一条数据</li>
<li>exists：判断返回的结果中是否有数据【True或False】</li>
<li>order_by：根据指定字段对结果排序<ul>
<li>字段名前加减号【-】为反向排序，字段可以有多个</li>
</ul>
</li>
<li>reverse：反向排序</li>
<li>distinct：结果去重</li>
</ul>
<h3 id="下划线语法"><a href="#下划线语法" class="headerlink" title="下划线语法"></a>下划线语法</h3><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul>
<li>contains：包含指定字符串的数据【icontains不区分大小写】<br>  <code>Book.objects.filter(title__contains=&#39;php&#39;)</code></li>
<li>regex：正则查询【iregex不区分大小写】<br>  <code>Book.objects.filter(title__regex=&#39;^p&#39;)</code></li>
<li>lt/gt：数值比较<br>  <code>Author.objects.filter(id__gt=1)</code></li>
<li>range/in：范围与区间查询<br>  <code>Author.objects.filter(id__in=[1, 3])</code><br>  <code>Author.objects.filter(id__range=[1, 3])</code></li>
</ul>
<h4 id="跨表使用"><a href="#跨表使用" class="headerlink" title="跨表使用"></a>跨表使用</h4><ul>
<li>正向查询【从外键所在的表查询主键所在表中的数据，跨表时使用表内的外键字段名】<br>  <code>Book.objects.filter(title__icontains=&#39;php&#39;).values(&#39;publisher__name&#39;)</code></li>
<li>反向查询【从主键所在的表查询外键所在表中的数据，跨表时使用另一个表的表名】<br>  <code>Publisher.objects.filter(id=1).values(&#39;book__title&#39;)</code></li>
</ul>
<h3 id="聚合和分组"><a href="#聚合和分组" class="headerlink" title="聚合和分组"></a>聚合和分组</h3><blockquote>
<p>from django.db.models import Avg, Sum</p>
</blockquote>
<ul>
<li>aggregate：对返回的结果进行聚合运算【平均值，最大值，最小值】<br>  <code>Book.objects.all().aggregate(avg=Avg(&#39;price&#39;))</code></li>
<li>annotate：对返回的结果的每一个分组分别进行聚合运算<br>  <code>Book.objects.values(&#39;authors__name&#39;).annotate(Sum(&#39;price&#39;))</code></li>
</ul>
<h3 id="F和Q查询"><a href="#F和Q查询" class="headerlink" title="F和Q查询"></a>F和Q查询</h3><blockquote>
<p>from django.db.models import F, Q</p>
</blockquote>
<ul>
<li>F查询：保存中间状态值<br>  <code>Book.objects.all().update(price=F(&#39;price&#39;) + 10)</code></li>
<li>Q查询：根据<code>&amp;|~</code>【与或非】逻辑组合查询条件<br>  <code>Book.objects.filter(Q(id__gt=1)&amp;Q(title=&#39;python&#39;))</code></li>
</ul>
<h1 id="admin-site"><a href="#admin-site" class="headerlink" title="admin site"></a>admin site</h1><p>主要功能是：在web页面操作Django ORM</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul>
<li>settings中默认配置【INSTALLED_APPS和MIDDLEWARE_CLASSES】</li>
<li>urls中保持默认配置【存在admin路由】</li>
<li>数据库中存在django相关表</li>
<li>后台汉化<ul>
<li>‘django.middleware.locale.LocaleMiddleware’【SessionMiddleware之后添加】</li>
</ul>
</li>
</ul>
<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>python manage.py createsuperuser</p>
<h2 id="注册模块"><a href="#注册模块" class="headerlink" title="注册模块"></a>注册模块</h2><h3 id="显示逻辑"><a href="#显示逻辑" class="headerlink" title="显示逻辑"></a>显示逻辑</h3><ul>
<li>list_display：可显示的字段</li>
<li>list_display_links：可点击编辑的字段</li>
<li>search_fields：可搜索字段</li>
<li>list_filter：在字段列表右侧显示可用于过滤的字段</li>
<li>date_hierarchy：在字段列表上方显示日期过滤参数</li>
<li>ordering：默认排序方式【优先级左右依次降低】</li>
<li>filter_horizontal：设置多对多字段使用水平的可选控件</li>
<li>raw_id_fields：设置外键使用可搜索的文本框形式而非列表【降低列表加载带来的系统开销】</li>
<li>actions：执行函数功能</li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from app01.models import *</span><br><span class="line">class BookAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&apos;title&apos;, &apos;price&apos;, &apos;publisher&apos;, &apos;publication_date&apos;]</span><br><span class="line">    list_display_links = [&apos;title&apos;]</span><br><span class="line">    search_fields = [&apos;title&apos;, &apos;publisher&apos;]</span><br><span class="line">    list_filter = [&apos;publication_date&apos;]</span><br><span class="line">    date_hierarchy = &apos;publication_date&apos;</span><br><span class="line">    ordering = [&apos;-publication_date&apos;]</span><br><span class="line">    filter_horizontal = [&apos;authors&apos;]</span><br><span class="line">    raw_id_fields = [&apos;publisher&apos;]</span><br><span class="line">    def func(self, request, queryset):</span><br><span class="line">        print(self, request, queryset)</span><br><span class="line">        print(request.POST.getlist(&apos;_selected_action&apos;))</span><br><span class="line">    func.short_description = &apos;显示结果&apos;</span><br><span class="line">    actions = [func,]</span><br><span class="line"></span><br><span class="line">admin.site.register(Book, BookAdmin)</span><br><span class="line">admin.site.register(Author)</span><br></pre></td></tr></table></figure>
<h2 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h2><p><a href="http://localhost/admin" target="_blank" rel="noopener">http://localhost/admin</a></p>
<h1 id="多数据库联用"><a href="#多数据库联用" class="headerlink" title="多数据库联用"></a>多数据库联用</h1><h2 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据库设置</span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    # default为默认数据库，具有特殊含义</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;NAME&apos;: &apos;app_data&apos;,</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.postgresql_psycopg2&apos;,</span><br><span class="line">        &apos;USER&apos;: &apos;postgres_user&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;s3krit&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;users&apos;: &#123;</span><br><span class="line">        &apos;NAME&apos;: &apos;user_data&apos;,</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;USER&apos;: &apos;mysql_user&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;priv4te&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 数据库路由设置[类名]</span><br><span class="line">DATABASE_ROUTERS = [&apos;utils.dbroute.DBRouter&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DBRouter:</span><br><span class="line">    # 指定读数据库路由</span><br><span class="line">    def db_for_read(self, model, **hints):</span><br><span class="line">        app_label = model._meta.app_label</span><br><span class="line">        if app_label in (&apos;order&apos;, &apos;payment&apos;):</span><br><span class="line">            return &apos;order&apos;</span><br><span class="line">        if app_label in (&apos;xcass_passport&apos;, &apos;store_manage&apos;):</span><br><span class="line">            return &apos;xcass&apos;</span><br><span class="line">        return &apos;default&apos;</span><br><span class="line">    # 指定写数据库路由</span><br><span class="line">    def db_for_write(self, model, **hints):</span><br><span class="line">        app_label = model._meta.app_label</span><br><span class="line">        if app_label in (&apos;order&apos;, &apos;payment&apos;):</span><br><span class="line">            return &apos;order&apos;</span><br><span class="line">        if app_label in (&apos;xcass_passport&apos;, &apos;store_manage&apos;):</span><br><span class="line">            return &apos;xcass&apos;</span><br><span class="line">        return &apos;default&apos;</span><br><span class="line">    # 如果obj1 和obj2 之间应该允许关联则返回True，如果应该防止关联则返回False，</span><br><span class="line">    # 如果路由无法判断则返回None</span><br><span class="line">    def allow_relation(self, obj1, obj2, **hints):</span><br><span class="line">        if obj1._meta.app_label == obj2._meta.app_label:</span><br><span class="line">            return True</span><br><span class="line">    # 定义迁移操作是否允许在别名为db的数据库上运行。如果操作应该运行则返回True，</span><br><span class="line">    # 如果不应该运行则返回False，如果路由无法判断则返回None</span><br><span class="line">    def allow_migrate(self, db, app_label, model_name=None, **hints):</span><br><span class="line">        if app_label in (&apos;order&apos;, &apos;payment&apos;):</span><br><span class="line">            return db ==  &apos;order&apos; </span><br><span class="line">        if app_label in (&apos;xcass_passport&apos;, &apos;store_manage&apos;):</span><br><span class="line">            return db == &apos;xcass&apos;</span><br><span class="line">        return db  ==  &apos;default&apos;</span><br></pre></td></tr></table></figure>
<h2 id="数据对象操作"><a href="#数据对象操作" class="headerlink" title="数据对象操作"></a>数据对象操作</h2><ul>
<li>queryset对象：Book.objects.using(‘default’).all()</li>
<li>Models对象  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author = Author(first_name=&apos;yashuai&apos;, last_name=&apos;gao&apos;)</span><br><span class="line">author.save(using=&apos;default&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据导入导出"><a href="#数据导入导出" class="headerlink" title="数据导入导出"></a>数据导入导出</h2><ul>
<li>数据同步【建表】：python manage.py migrate –database=test</li>
<li>数据导出：python manage.py dumpdata app1 –database=db1 &gt; app1_fixture.json</li>
<li>数据导入：python manage.py loaddata app1_fixture.json –database=db1</li>
</ul>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>models</tag>
        <tag>ORM</tag>
        <tag>admin</tag>
      </tags>
  </entry>
  <entry>
    <title>python-编码</title>
    <url>/blog/2020/07/10/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="通用编码"><a href="#通用编码" class="headerlink" title="通用编码"></a>通用编码</h1><ul>
<li>ASCII[1个字节] 只支持英文字母和一些常用的符号</li>
<li>Unicode[2个字节]</li>
<li>UTF-8 把一个Unicode字符根据不同的数字大小编码成1-6个字节<ul>
<li>常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</li>
<li>ASCII编码实际上可以被看成是UTF-8编码的一部分</li>
</ul>
</li>
</ul>
<h1 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h1><ul>
<li>gb2312<ul>
<li>GB2312(1980年)一共收录了7445个字符，在windows中的代码页是CP936</li>
<li>原来的CP936和GB 2312-80一模一样</li>
</ul>
</li>
<li>gbk<ul>
<li>GBK最初是由微软对GB2312的扩展，也就是CP936字码表 (Code Page 936)的扩展</li>
<li>gbk并非国家正式标准</li>
</ul>
</li>
<li>GB18030<ul>
<li>GB18030取代了GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。</li>
<li>现在的PC平台必须支持GB18030，GB18030在windows中的代码页是CP54936。</li>
</ul>
</li>
</ul>
<h1 id="python文件设置"><a href="#python文件设置" class="headerlink" title="python文件设置"></a>python文件设置</h1><p>python3默认使用utf-8编码读取文件，支持读取中文<br>python2默认使用ASCII编码读取文件，不支持读取中文；在文件中设置<code>#-*- coding:utf8 -*-</code>可以使python2使用UTF-8编码方式读取文件，从而支持读取中文  </p>
<h1 id="python2与python3"><a href="#python2与python3" class="headerlink" title="python2与python3"></a>python2与python3</h1><ul>
<li>python3<ul>
<li>str即为unicode</li>
<li>bytes即为str.encode()的结果</li>
</ul>
</li>
<li>python2<ul>
<li>str是bytes</li>
<li>u’str’为unicode</li>
</ul>
</li>
</ul>
<h1 id="python3下encode与decode"><a href="#python3下encode与decode" class="headerlink" title="python3下encode与decode"></a>python3下encode与decode</h1><p><img src="https://simple0426-blog.oss-cn-beijing.aliyuncs.com/python_encode_decode.jpg" alt></p>
<ul>
<li>数据在内存中，数据类型为str，统一使用unicode编码</li>
<li>数据在网络传输或磁盘存储，数据类型为bytes，使用UTF-8编码</li>
<li>内存中的数据转换为网络或磁盘上的数据时(str==&gt;bytes)，使用encode方法</li>
<li>从网络或磁盘读取数据到内存(bytes==&gt;str)，需要使用decode方法</li>
</ul>
<h1 id="单字符的编码"><a href="#单字符的编码" class="headerlink" title="单字符的编码"></a>单字符的编码</h1><ul>
<li>ord(ordinals)：获取单字符的unicode编码(整数)<ul>
<li>print(ord(‘中’))</li>
</ul>
</li>
<li>chr(character)：把Unicode编码(整数)转换为对应的字符<ul>
<li>print(chr(20013))</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之views学习</title>
    <url>/blog/2018/06/29/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91%E4%B9%8Bviews%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="request内容"><a href="#request内容" class="headerlink" title="request内容"></a>request内容</h1><h2 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h2><ul>
<li>request.path：除域名以外的请求路径，以斜杠开头</li>
<li>request.get_host()：主机名（比如通常所说的域名）</li>
<li>request.get_full_path()：请求路径，可能包含查询字符串</li>
<li>request.is_secure()：请求方法是否是https，是则返回True</li>
</ul>
<h2 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h2><ul>
<li>request.method：请求方法</li>
<li>request.GET：对收到的get请求进行数据【来自form或url中的查询串】解析，它是一个类字典对象</li>
<li>request.POST：对收到的post请求进行数据【来自html中的form】解析，他是一个类字典对象<ul>
<li>仅当Content-Type：application/x-www-form-urlencoded</li>
</ul>
</li>
<li>request.body：请求体内容<ul>
<li>get请求体为空</li>
<li>post请求体范例：<br><code>b&#39;csrfmiddlewaretoken=SP3GO7LEfUb0QqWwE4Rq0r0W&amp;user=he&amp;passwd=12&#39;</code></li>
</ul>
</li>
<li>request.Meta：它是一个python字典，包含了本次请求的所有header信息，可以通过get请求获得【防止异常退出】<ul>
<li>HTTP_REFERER，进站前链接网页，如果有的话。</li>
<li>HTTP_USER_AGENT，用户浏览器的user-agent字符串，如果有的话。</li>
<li>REMOTE_ADDR 客户端IP</li>
</ul>
</li>
</ul>
<h1 id="类视图"><a href="#类视图" class="headerlink" title="类视图"></a>类视图</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul>
<li>使用类方式实现通用视图，和使用函数方式相比，类能更方便的实现继承和mixins</li>
<li>类视图在URLconf中的实现：<ul>
<li>调用类的as_view方法，比如<code>url(r&#39;^login&#39;, views.LoginView.as_view())</code></li>
<li>接受request并实例化，返回实例的dispatch方法</li>
<li>实例的dispatch方法根据请求的类型返回同名的处理函数</li>
</ul>
</li>
<li>类视图在增加功能时【比如授权登录】，可以采取两种方式：<ul>
<li><a href="#基础功能类">类的多重继承方式</a></li>
<li><a href="#基础功能装饰器">装饰器方式</a><ul>
<li>当类视图使用装饰器时，必须使用django内置的装饰器方法【比如method_decorator】</li>
<li>在类视图使用csrf装饰器时，必须在dispatch方法前使用</li>
<li>类视图装饰器可以放在类前【必须指明要装饰的具体函数名称】，也可以放在类下的方法前</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h2><h3 id="基础功能类"><a href="#基础功能类" class="headerlink" title="基础功能类"></a>基础功能类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BaseView(View):</span><br><span class="line">    def dispatch(self, request, *args, **kwargs):</span><br><span class="line">        if request.session.get(&apos;username&apos;):</span><br><span class="line">            response = super(BaseView, self).dispatch(request, *args, **kwargs)</span><br><span class="line">            return response</span><br><span class="line">        else:</span><br><span class="line">            return redirect(&apos;login.html&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="基础功能装饰器"><a href="#基础功能装饰器" class="headerlink" title="基础功能装饰器"></a>基础功能装饰器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def auth(func):</span><br><span class="line">    def wrapper(request, *args, **kwargs):</span><br><span class="line">        if request.session.get(&apos;username&apos;):</span><br><span class="line">            obj = func(request, *args, **kwargs)</span><br><span class="line">            return obj</span><br><span class="line">        else:</span><br><span class="line">            return redirect(&apos;login.html&apos;)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<h3 id="主功能组件"><a href="#主功能组件" class="headerlink" title="主功能组件"></a>主功能组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.utils.decorators import method_decorator</span><br><span class="line">class LoginView(View):</span><br><span class="line">    @method_decorator(csrf_exempt)</span><br><span class="line">    def dispatch(self, request, *args, **kwargs):</span><br><span class="line">        response = super(LoginView, self).dispatch(request, *args, **kwargs)</span><br><span class="line">        return response</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return render(request, &apos;login.html&apos;)</span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        user = request.POST.get(&apos;user&apos;)</span><br><span class="line">        pwd= md5.encrypt(request.POST.get(&apos;passwd&apos;))</span><br><span class="line">        obj = UserInfo.objects.filter(username=user, password=pwd).first()</span><br><span class="line">        if obj:</span><br><span class="line">            request.session[&apos;username&apos;] = user</span><br><span class="line">            return redirect(&apos;ok.html&apos;)</span><br><span class="line">        return render(request, &apos;login.html&apos;, &#123;&apos;msg&apos;: &apos;用户或密码错误&apos;&#125;)</span><br><span class="line"></span><br><span class="line"># class OkView(BaseView, View): # 可以使用类的多重继承凡是增加功能【比如登录授权】</span><br><span class="line">@method_decorator(auth, name=&apos;get&apos;)</span><br><span class="line"># 在类前使用装饰器必须指明要装饰的具体函数名称，比如get、post等</span><br><span class="line">class OkView(View):</span><br><span class="line">    def get(self,request,*args, **kwargs):</span><br><span class="line">        return render(request, &apos;ok.html&apos;, &#123;&apos;user&apos;: request.session[&apos;username&apos;]&#125;)</span><br><span class="line"></span><br><span class="line"># class LogoutView(BaseView, View):</span><br><span class="line">class LogoutView(View):</span><br><span class="line">    # 装饰器也可放在类下的方法前</span><br><span class="line">    @method_decorator(auth)</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        del request.session[&apos;username&apos;]</span><br><span class="line">        return redirect(&apos;login.html&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h1><ul>
<li>自动生成html标签，并对字段进行校验</li>
<li>表单框架最主要的用法是：为HTML下每一个将要处理的表单定义一个Form类</li>
</ul>
<h2 id="Form对象"><a href="#Form对象" class="headerlink" title="Form对象"></a>Form对象</h2><h3 id="表单要素"><a href="#表单要素" class="headerlink" title="表单要素"></a>表单要素</h3><ul>
<li>字段类型<ul>
<li>CharField：文本框</li>
<li>DateField：日期选择</li>
<li>DecimalField：数字</li>
<li>MultipleChoiceField：多选框</li>
<li>ChoiceField：单选框</li>
<li>FileField：文件选择框</li>
</ul>
</li>
<li>字段参数<ul>
<li>label：标签显示内容</li>
<li>required：是否必选</li>
<li>initial：初始值</li>
<li>min_length/max_length：最大最小长度</li>
<li>error_messages：错误提示</li>
<li>widget：插件</li>
<li>choices：可选项【choice相关字段类型】</li>
<li>validators：简单的验证规则</li>
</ul>
</li>
<li>常用插件<ul>
<li>TextInput：默认插件</li>
<li>RadioSelect：单选插件</li>
<li>CheckboxSelectMultiple：多选插件</li>
<li>Textarea：多行文本框</li>
<li>PasswordInput：密码类型输入框</li>
</ul>
</li>
</ul>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookForm(Form):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super(BookForm, self).__init__(*args, **kwargs)</span><br><span class="line">        # 初始化时从数据库获取信息</span><br><span class="line">        self.fields[&apos;authors&apos;].choices = Author.objects.values_list(&apos;id&apos;, &apos;name&apos;)</span><br><span class="line">        self.fields[&apos;publisher&apos;].choices = Publisher.objects.values_list(&apos;id&apos;, &apos;name&apos;)</span><br><span class="line"></span><br><span class="line">    title = fields.CharField(</span><br><span class="line">        required=True,</span><br><span class="line">        label=&apos;书名&apos;,</span><br><span class="line">        widget=widgets.Input(</span><br><span class="line">            attrs= &#123;&apos;class&apos;: &apos;c1&apos;, &apos;style&apos;: &apos;color: red&apos;&#125;,</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    publication_date = fields.DateField(</span><br><span class="line">        required=True,</span><br><span class="line">        label=&apos;出版日期&apos;,</span><br><span class="line">        widget=widgets.SelectDateWidget(</span><br><span class="line">            years=range(2018, 1970, -1),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    price = fields.DecimalField(</span><br><span class="line">        required=True,</span><br><span class="line">        label=&apos;价格&apos;</span><br><span class="line">    )</span><br><span class="line">    authors = fields.MultipleChoiceField(</span><br><span class="line">        label=&apos;作者&apos;,</span><br><span class="line">        choices=[],</span><br><span class="line">    )</span><br><span class="line">    publisher = fields.ChoiceField(</span><br><span class="line">        label=&apos;出版社&apos;,</span><br><span class="line">        choices=[],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h2 id="Form规则验证"><a href="#Form规则验证" class="headerlink" title="Form规则验证"></a>Form规则验证</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><table>
<thead>
<tr>
<th>位置</th>
<th>使用方法</th>
<th>验证级别</th>
<th>是否有返回值</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>类字段下的validators参数</td>
<td>1. RegexValidator对象【只支持正则判断】<br> 2.  自定义函数 【支持逻辑判断，错误时抛出异常】</td>
<td>字段级别</td>
<td>有错误时抛出异常</td>
<td>在默认规则前生效</td>
</tr>
<tr>
<td>类下的clean_字段</td>
<td>类下的clean_字段【支持逻辑判断和与数据库联动】</td>
<td>字段级别</td>
<td>返回字段信息，同时有错误抛出异常</td>
<td>在默认规则后生效</td>
</tr>
<tr>
<td>类下的clean方法</td>
<td>类下的clean方法</td>
<td>表单级别多字段</td>
<td>返回表单数据，同时有错误抛出异常</td>
<td>在默认规则后生效</td>
</tr>
</tbody>
</table>
<h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.core.exceptions import ValidationError</span><br><span class="line">from django.core.validators import RegexValidator</span><br><span class="line"></span><br><span class="line">def validate_username(msg):</span><br><span class="line">    if &apos;test&apos; in msg:</span><br><span class="line">        raise ValidationError(&apos;关键词不能包含test&apos;)</span><br><span class="line"></span><br><span class="line">class UserForm(Form):</span><br><span class="line">    username = fields.CharField(</span><br><span class="line">        min_length=6,</span><br><span class="line">        max_length=20,</span><br><span class="line">        required=True,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">        &quot;required&quot;: &apos;用户名不能为空&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        validators=[RegexValidator(r&apos;^(\D)&apos;, &apos;不能数字开头&apos;),</span><br><span class="line">                    validate_username]</span><br><span class="line">    )</span><br><span class="line">    password = fields.CharField(</span><br><span class="line">        required=True,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            &quot;required&quot;: &apos;密码不能为空&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        widget=widgets.PasswordInput(render_value=True),</span><br><span class="line">    )</span><br><span class="line">    password_confirm = fields.CharField(</span><br><span class="line">        required=True,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            &quot;required&quot;: &apos;密码不能为空&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        widget=widgets.PasswordInput(render_value=True),</span><br><span class="line">    )</span><br><span class="line">    email = fields.EmailField(</span><br><span class="line">        required=True,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            &quot;required&quot;: &apos;邮箱不能为空&apos;,</span><br><span class="line">            &quot;invalid&quot;: &apos;邮箱格式错误&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    user_type = fields.ChoiceField(</span><br><span class="line">        required=True,</span><br><span class="line">        choices=((&apos;1&apos;, u&apos;普通用户&apos;), (&apos;2&apos;, u&apos;超级用户&apos;)),</span><br><span class="line">    )</span><br><span class="line">    # 字段级别验证</span><br><span class="line">    def clean_username(self):</span><br><span class="line">        username = self.cleaned_data[&apos;username&apos;]</span><br><span class="line">        if not re.match(r&apos;^(\D)&apos;, username):</span><br><span class="line">            raise ValidationError(&apos;不能数字开头&apos;)</span><br><span class="line">        if &apos;test&apos; in username:</span><br><span class="line">            raise ValidationError(&apos;关键词不能包含test&apos;)</span><br><span class="line">        return username</span><br><span class="line">    # 表单级别多字段验证</span><br><span class="line">    def clean(self):</span><br><span class="line">        # 调用父类初始化</span><br><span class="line">        cleaned_data = super().clean()</span><br><span class="line">        # get方法避免取空值</span><br><span class="line">        password = cleaned_data.get(&apos;password&apos;)</span><br><span class="line">        password_confirm = cleaned_data.get(&apos;password_confirm&apos;)</span><br><span class="line">        if password == password_confirm:</span><br><span class="line">            return self.cleaned_data</span><br><span class="line">        else:</span><br><span class="line">            # 可以将表单验证结果绑定在特定字段</span><br><span class="line">            self.add_error(&apos;password_confirm&apos;, ValidationError(&apos;密码输入不一致&apos;))</span><br><span class="line">            return self.cleaned_data</span><br></pre></td></tr></table></figure>
<h2 id="Form对象实例化"><a href="#Form对象实例化" class="headerlink" title="Form对象实例化"></a>Form对象实例化</h2><h3 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h3><ul>
<li>初始化：data = UserForm(initial=xxx)</li>
<li>实例化：data = UserForm(data=request.POST)</li>
<li>调用验证规则：data.is_valid()</li>
<li>获取校验后的数据：data.cleaned_data</li>
<li>返回的错误信息：data.errors/data.errors.字段.字段错误索引</li>
</ul>
<h3 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def book_admin(request, book_id=None):</span><br><span class="line">    # 图书信息变更</span><br><span class="line">    if request.method == &apos;POST&apos;:</span><br><span class="line">        data = BookForm(data=request.POST)</span><br><span class="line">        if data.is_valid():</span><br><span class="line">            data = data.cleaned_data</span><br><span class="line">            # 设置书籍出版社【一对多关系】</span><br><span class="line">            data[&apos;publisher&apos;] = Publisher.objects.get(id=data[&apos;publisher&apos;])</span><br><span class="line">            # 获取作者id列表</span><br><span class="line">            authors_id_list = data.pop(&apos;authors&apos;)</span><br><span class="line">            # 获取作者对象列表</span><br><span class="line">            authors_list = Author.objects.filter(id__in=authors_id_list)</span><br><span class="line">            # 编辑图书</span><br><span class="line">            if book_id is not None and Book.objects.filter(id=int(book_id)).exists():</span><br><span class="line">                query = Book.objects.filter(id=int(book_id))</span><br><span class="line">                # 更新其他信息</span><br><span class="line">                query.update(**data)</span><br><span class="line">                # 更新作者信息</span><br><span class="line">                book_obj = query.first()</span><br><span class="line">                book_obj.authors.clear()</span><br><span class="line">                book_obj.authors.add(*authors_list)</span><br><span class="line">                return HttpResponseRedirect(&apos;book_admin_%s&apos; % book_id)</span><br><span class="line">            # 添加书籍</span><br><span class="line">            else:</span><br><span class="line">                # 添加书籍</span><br><span class="line">                new_book = Book.objects.create(**data)</span><br><span class="line">                # 书籍对象处添加作者【多对多关系】</span><br><span class="line">                new_book.authors.add(*authors_list)</span><br><span class="line">                book_id = str(new_book.id)</span><br><span class="line">                return HttpResponseRedirect(&apos;book_admin_%s&apos; % book_id)</span><br><span class="line">    # 显示书籍</span><br><span class="line">    elif book_id is not None:</span><br><span class="line">        book_obj = Book.objects.filter(id=int(book_id)).first()</span><br><span class="line">        if book_obj:</span><br><span class="line">            authors_list = book_obj.authors.values_list(&apos;id&apos;)</span><br><span class="line">            authors_id_list = list(zip(*authors_list))[0]</span><br><span class="line">            book_info = &#123;</span><br><span class="line">                &apos;title&apos;: book_obj.title,</span><br><span class="line">                &apos;publication_date&apos;: book_obj.publication_date,</span><br><span class="line">                &apos;price&apos;: book_obj.price,</span><br><span class="line">                &apos;authors&apos;: authors_id_list,</span><br><span class="line">                &apos;publisher&apos;: book_obj.publisher.id</span><br><span class="line">            &#125;</span><br><span class="line">            data = BookForm(initial=book_info)</span><br><span class="line">        else:</span><br><span class="line">            return HttpResponseRedirect(&apos;book_admin&apos;)</span><br><span class="line">    # 默认显示空表格</span><br><span class="line">    else:</span><br><span class="line">        data = BookForm()</span><br><span class="line">    return render(request, &apos;book_admin.html&apos;, &#123;&apos;form&apos;: data&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="HTML渲染"><a href="#HTML渲染" class="headerlink" title="HTML渲染"></a>HTML渲染</h2><h3 id="使用要点-1"><a href="#使用要点-1" class="headerlink" title="使用要点"></a>使用要点</h3><ul>
<li><code>&lt;form method=&quot;post&quot; novalidate&gt;</code>：novalidate关闭浏览器验证</li>
<li>form.as_p：循环模式下生产p标签，由于标签格式固定不利于css渲染</li>
<li>form.username：获取表单字段</li>
<li>form.errors.username.0：获取表单字段的错误信息</li>
</ul>
<h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><ul>
<li>表单内容较多时<ul>
<li>此时表单验证使用前台提交(url跳转)方式【验证时页面刷新】</li>
<li>由于页面刷新，所以可以在页面中内置错误变量，刷新后显示错误</li>
</ul>
</li>
<li>表单内容较少时<ul>
<li>如场景：模态对话框，此时表单验证使用ajax方式【验证时页面无刷新】<ul>
<li>验证成功时，前台处理url跳转</li>
</ul>
</li>
<li>由于页面无刷新，页面内的错误变量无法被渲染，所以此时需要使用DOM新建错误标签后显示</li>
</ul>
</li>
</ul>
<h3 id="ajax范例"><a href="#ajax范例" class="headerlink" title="ajax范例"></a>ajax范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &lt;p&gt;书名：&#123;&#123; form.title &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;出版日期：&#123;&#123; form.publication_date &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;价格：&#123;&#123; form.price &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;作者: &#123;&#123; form.authors &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;出版社：&#123;&#123; form.publisher &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;提交&quot; class=&quot;submit&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(&apos;.submit&apos;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &apos;book_ajax&apos;,</span><br><span class="line">            type: &apos;POST&apos;,</span><br><span class="line">            data: $(&quot;form&quot;).serialize(),</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            success:function (data) &#123;</span><br><span class="line">                if(data.status)&#123;</span><br><span class="line">                    // ajax处理页面跳转</span><br><span class="line">                    location.href = &apos;book_admin_3&apos;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    $.each(data.Error, function (k, v) &#123;</span><br><span class="line">                        var tag = document.createElement(&apos;span&apos;);</span><br><span class="line">                        tag.innerHTML = v[0];</span><br><span class="line">                        tag.className = &apos;error&apos;;</span><br><span class="line">                        $(&apos;input[name=&quot;&apos;+k+&apos;&quot;]&apos;).after(tag);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def book_ajax(request):</span><br><span class="line">    if request.method == &apos;POST&apos;:</span><br><span class="line">        response = &#123;&apos;status&apos;: True, &apos;Error&apos;: None&#125;</span><br><span class="line">        data = BookForm(request.POST)</span><br><span class="line">        if data.is_valid():</span><br><span class="line">            data = data.cleaned_data</span><br><span class="line">            # ajax跳转在前台处理，此处redirect无用</span><br><span class="line">        else:</span><br><span class="line">            response[&apos;status&apos;] = False</span><br><span class="line">            response[&apos;Error&apos;] = data.errors</span><br><span class="line">        return HttpResponse(json.dumps(response))</span><br><span class="line">    else:</span><br><span class="line">        data = BookForm()</span><br><span class="line">        return render(request, &apos;book_ajax.html&apos;, &#123;&apos;form&apos;: data&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>CBV</tag>
        <tag>Form</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之基本设置</title>
    <url>/blog/2018/06/12/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MTV模型"><a href="#MTV模型" class="headerlink" title="MTV模型"></a>MTV模型</h1><p>MTV即是通用的web开发模型MVC在django中的实现，  此外django中还有一个URLconf。</p>
<ul>
<li>M【models】：建立和操作数据库</li>
<li>T【templates】：建立和渲染html</li>
<li>V【views】：连接models和templates，进行逻辑操作</li>
<li><a href="#URLconf">URLconf</a>：匹配相关的url请求，交于后端的views处理</li>
</ul>
<h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><ul>
<li>创建project：django-admin startproject webapp</li>
<li>创建app：python manage.py startapp books</li>
<li>项目目录简介：<ul>
<li>webapp：项目的根目录<ul>
<li>webapp：项目的默认app【主要用于项目各种配置】<ul>
<li>settings.py：项目的主配置文件</li>
<li>urls.py：项目的主url配置入口</li>
</ul>
</li>
<li>manage.py：项目的命令行工具入口</li>
<li>books：项目下books app目录<ul>
<li>models.py：books app的模型文件</li>
<li>views.py：books app的视图文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><ul>
<li>语法：python manage.py [CMD]</li>
<li>可选子命令</li>
</ul>
<table>
<thead>
<tr>
<th>命令[CMD]</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>runserver 0.0.0.0:80</td>
<td>运行django内建的web服务器[默认8000端口]</td>
</tr>
<tr>
<td>makemigrations</td>
<td>根据models生成表结构</td>
</tr>
<tr>
<td>sqlmigrate</td>
<td>查看用于建表的语句</td>
</tr>
<tr>
<td>migrate</td>
<td>将表结构写入数据库</td>
</tr>
<tr>
<td>dumpdata books &gt; books.json</td>
<td>导出books的数据【不加app默认导出所有app数据】</td>
</tr>
<tr>
<td>flush</td>
<td>清空数据库</td>
</tr>
<tr>
<td>loaddata books.json</td>
<td>导入books数据【不需要设置app】</td>
</tr>
<tr>
<td>shell</td>
<td>进入django项目终端环境</td>
</tr>
<tr>
<td>dbshell</td>
<td>根据settings设置进入相应数据库</td>
</tr>
<tr>
<td>collectstatic</td>
<td>把静态文件收集到 STATIC_ROOT 目录</td>
</tr>
<tr>
<td>check</td>
<td>检验数据模型（models）有效性</td>
</tr>
</tbody>
</table>
<h1 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h1><ul>
<li>DEBUG = True：开启调试模式</li>
<li>ALLOWED_HOSTS = [‘*’]：当DEBUG=False时，此值必须设置</li>
<li>INSTALLED_APPS：此处可以让django自动在app下的templates子目录中查找模板文件，在static子目录中查找静态文件</li>
<li>BASE_DIR：项目根目录</li>
</ul>
<h2 id="模板目录设置"><a href="#模板目录设置" class="headerlink" title="模板目录设置"></a>模板目录设置</h2><ul>
<li>TEMPLATES：设置模板目录<ul>
<li><code>&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;).replace(&#39;\\&#39;, &#39;/&#39;),],</code>：设置公有模板目录</li>
<li><code>&#39;APP_DIRS&#39;: True,</code>：开启app私有的模板目录</li>
</ul>
</li>
</ul>
<h2 id="静态目录设置"><a href="#静态目录设置" class="headerlink" title="静态目录设置"></a>静态目录设置</h2><ul>
<li>STATIC_URL = ‘/static/‘：使用STATIC_ROOT中的静态文件时使用的url前缀</li>
<li>STATICFILES_DIRS = (os.path.join(BASE_DIR, “statics”),)：设置app公有的静态目录</li>
<li>STATIC_ROOT = os.path.join(BASE_DIR,’static_root’) ：这个目录配置只在运行collectstaitc时才会用到</li>
</ul>
<h2 id="数据库设置"><a href="#数据库设置" class="headerlink" title="数据库设置"></a>数据库设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装数据库引擎</span><br><span class="line">pip install pymysql</span><br><span class="line"># pip install psycopg2</span><br><span class="line"># 使用pymysql作为mysql数据库引擎</span><br><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        # &apos;ENGINE&apos;: &apos;django.db.backends.postgresql_psycopg2&apos;,</span><br><span class="line">        &apos;NAME&apos;: &apos;mysite&apos;,</span><br><span class="line">        &apos;HOST&apos;: &apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;PORT&apos;: &apos;3306&apos;,</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;123456&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="邮件设置"><a href="#邮件设置" class="headerlink" title="邮件设置"></a>邮件设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEFAULT_FROM_EMAIL = &apos;zabbix@abc.com&apos;</span><br><span class="line">EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;</span><br><span class="line">EMAIL_HOST = &apos;smtp.exmail.qq.com&apos;</span><br><span class="line">EMAIL_HOST_USER = &apos;zabbix@abc.com&apos;</span><br><span class="line">EMAIL_HOST_PASSWORD = &apos;******&apos;</span><br><span class="line">EMAIL_PORT = 587</span><br><span class="line">EMAIL_USE_TLS = True</span><br><span class="line">#django邮件发送</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">send_mail(subject, body, from_address, list_to_address)</span><br></pre></td></tr></table></figure>
<h2 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h2><blockquote>
<p>在进行ORM操作时，在日志中还原为原始SQL</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    &apos;version&apos;: 1,</span><br><span class="line">    &apos;disable_existing_loggers&apos;: False,</span><br><span class="line">    &apos;handlers&apos;: &#123;</span><br><span class="line">        &apos;console&apos;:&#123;</span><br><span class="line">            &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">            &apos;class&apos;:&apos;logging.StreamHandler&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        &apos;django.db.backends&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;console&apos;],</span><br><span class="line">            &apos;propagate&apos;: True,</span><br><span class="line">            &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="URLconf"><a href="#URLconf" class="headerlink" title="URLconf"></a>URLconf</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>url(url正则匹配，views视图函数，参数，别名)</p>
<h2 id="url正则匹配"><a href="#url正则匹配" class="headerlink" title="url正则匹配"></a>url正则匹配</h2><h3 id="不分组url"><a href="#不分组url" class="headerlink" title="不分组url"></a>不分组url</h3><blockquote>
<p>此时按位置将参数传递给视图函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># urls.py</span><br><span class="line">urls.py：</span><br><span class="line">    url(r&apos;^time/plus/(\d)/$&apos;, hours_ahead),</span><br><span class="line">views.py</span><br><span class="line">    def hours_ahead(request, offset):</span><br><span class="line">        now = datetime.now()</span><br><span class="line">        new_date = now + timedelta(hours=int(offset))</span><br><span class="line">        return HttpResponse(str(new_date))</span><br></pre></td></tr></table></figure>
<h3 id="分组url"><a href="#分组url" class="headerlink" title="分组url"></a>分组url</h3><blockquote>
<p>此时按关键词方式将参数传递给视图函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py：</span><br><span class="line">    url(r&apos;^image/getimage/(?P&lt;file_id&gt;\w+)_(?P&lt;image_width&gt;\d+)_(?P&lt;image_height&gt;\d+)&apos;, imgview.get_image, name=&apos;get_image&apos;)</span><br><span class="line">views.py：</span><br><span class="line">    def get_image(request, file_id, image_width, image_height):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py：</span><br><span class="line">    url(r&apos;^foo/$&apos;, views.foobar_view, &#123;&apos;template_name&apos;: &apos;template1.html&apos;&#125;),</span><br><span class="line">views.py：</span><br><span class="line">    def foobar_view(request, template_name):</span><br><span class="line">        m_list = MyModel.objects.filter(is_new=True)</span><br><span class="line">        return render_to_response(template_name, &#123;&apos;m_list&apos;: m_list&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="views参数优先级"><a href="#views参数优先级" class="headerlink" title="views参数优先级"></a>views参数优先级</h3><ul>
<li>URLconf设置的参数</li>
<li>正则匹配捕获的参数【命名分组》无名分组】</li>
<li>参数默认值</li>
</ul>
<h2 id="别名设置"><a href="#别名设置" class="headerlink" title="别名设置"></a>别名设置</h2><h3 id="views中使用"><a href="#views中使用" class="headerlink" title="views中使用"></a>views中使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py</span><br><span class="line">        url(r&apos;^calc/(\d+)/(\d+)/$&apos;, calc, name=&apos;calc&apos;),</span><br><span class="line">        url(r&apos;^add/(?P&lt;v1&gt;\d+)/(?P&lt;v2&gt;\d+)/$&apos;, calc2, name=&apos;add&apos;),</span><br><span class="line">views.py</span><br><span class="line">        def calc(request, v1, v2):</span><br><span class="line">            return HttpResponseRedirect(reverse(&apos;add&apos;, args=(v1, v2)))</span><br><span class="line">        def calc2(request, v1, v2):</span><br><span class="line">            result = int(v1) + int(v2)</span><br><span class="line">            return HttpResponse(str(result))</span><br><span class="line">解释：</span><br><span class="line">1）访问calc时重定向url</span><br><span class="line">2）reverse组合要跳转的url，第一个参数为视图名称【非视图函数名称】，args、kwargs为捕获或设置的参数</span><br></pre></td></tr></table></figure>
<h3 id="template中使用"><a href="#template中使用" class="headerlink" title="template中使用"></a>template中使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py：</span><br><span class="line">    url(r&apos;^register&apos;, views.index, name=&apos;reg&apos;)</span><br><span class="line">html：</span><br><span class="line">    &lt;form action=&quot;&#123;% url &quot;reg&quot; %&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py：</span><br><span class="line">    url(r&apos;^time/&apos;, include(&apos;contact.urls&apos;)),</span><br><span class="line">contact.urls.py：</span><br><span class="line">    url(r&apos;^(?P&lt;year&gt;\d&#123;4&#125;)/(?P&lt;month&gt;\d&#123;1,2&#125;)/(?P&lt;day&gt;\d&#123;1,2&#125;)/&apos;, views.current_datetime),</span><br><span class="line">eg：</span><br><span class="line">    http://127.0.0.1:8000/time/2014/12/1/</span><br></pre></td></tr></table></figure>
<ul>
<li>主URLconf使用include关键词包含子URLconf</li>
<li>主URLconf捕获url的第一部分time，子URLconf对time之后的部分进行匹配</li>
<li>当使用include时，主URLconf捕获的命名参数和手动设置的参数将传递给子URLconf的每一行</li>
</ul>
<h1 id="Pycharm中运行django"><a href="#Pycharm中运行django" class="headerlink" title="Pycharm中运行django"></a>Pycharm中运行django</h1><ul>
<li>创建django项目</li>
<li>设置django项目使用的语言解释器【使用virtualenv】<ul>
<li>设置位置：file -》settings -》project simplesite-》project Interpreter</li>
</ul>
</li>
<li>设置django项目的框架配置<ul>
<li>设置位置：file -》settings -》languages &amp; frameworks -》django</li>
<li>开启django支持：enable django support<ul>
<li>设置django项目根目录：django project root</li>
<li>设置django项目配置：settings</li>
</ul>
</li>
</ul>
</li>
<li>设置server运行配置<ul>
<li>设置位置：run -》Edit Configuration<ul>
<li>添加一个django server<ul>
<li>设置django server名称</li>
<li>设置django server使用的端口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>URLconf</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/blog/2018/05/09/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><ul>
<li>内置名称空间：python解释器自带的名字所在的空间</li>
<li>全局名称空间：文件级别定义的名字所在的空间</li>
<li>局部名称空间：函数级别定义的名字所在的空间</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>全局作用域：内置名称空间、全局名称空间<ul>
<li>查看全局作用域的名字：globals</li>
</ul>
</li>
<li>局部作用域：局部名称空间<ul>
<li>查看局部作用域的名字：locals</li>
</ul>
</li>
<li>名字查找顺序：局部名称空间》全局名称空间》内置名称空间</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>空函数pass：空函数可以作为占位符，在某部分代码没想好之前，可以先让函数运行起来</p>
</li>
<li><p>函数定义阶段只检查语法定义错误</p>
</li>
<li><p>定义函数时，需要确定函数名和参数个数；如有必要，可以先对参数的数据类型做检查。</p>
</li>
<li><p>函数定义和文档注释</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_name</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>,...)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文档注释：</span></span><br><span class="line"><span class="string">    1. 功能：</span></span><br><span class="line"><span class="string">    2. 参数1:传入的参数含义、传入的参数类型</span></span><br><span class="line"><span class="string">       参数2:</span></span><br><span class="line"><span class="string">    3. 返回值: 返回值的含义，返回值的数据类型</span></span><br><span class="line"><span class="string">    4. 使用范例</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>函数可使用return随时返回值</li>
<li>没有return语句时，默认返回None</li>
<li>当返回多个值时，以元组形式组成<ul>
<li>多个值的解包：a, b, c, d, e = t</li>
<li>只取某些值【下划线占位】：  <code>a, _, b, _, c = t</code></li>
<li>只取首尾的值：<code>x, *_, y = t</code></li>
</ul>
</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><ul>
<li>是必选参数</li>
<li>按位置赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x / y</span><br><span class="line">print(foo(<span class="number">4</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><ul>
<li><p>关键字参数必须在位置参数之后</p>
</li>
<li><p>以key-value形式赋值</p>
</li>
<li>范例：<code>print(foo(y=4, x=2))</code></li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>默认参数在非默认参数之后</li>
<li>默认参数只在定义时赋值一次</li>
<li>默认参数需要定义为不可变类型</li>
<li><p>范例：</p>
<ul>
<li><p>错误使用范例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># print(add_end([1,2,3]))</span></span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正确使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># print(add_end([1,2,3]))</span></span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比解释：</p>
<ul>
<li>python函数在定义的时候，默认参数L的值就被计算出来，即[],因为默认参数L也是一个变量，它指向对象[]</li>
<li>每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是定义时的[]的了。</li>
<li>所以定义默认参数要牢记一点：默认参数必须指向不变对象！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可变长参数-args"><a href="#可变长参数-args" class="headerlink" title="可变长参数*args"></a>可变长参数*args</h3><ul>
<li>*会把溢出的按位置定义的实参都接收，并以元组的形式赋值给args</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        total+=i</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">print(foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>在list或tuple前面加一个*号，可以把list或tuple解包为多个位置参数传递给函数使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">foo(*li)</span><br></pre></td></tr></table></figure>
<h3 id="可变长参数-kwargs"><a href="#可变长参数-kwargs" class="headerlink" title="可变长参数**kwargs"></a>可变长参数**kwargs</h3><ul>
<li>**会把溢出的按关键字定义的实参都接收，并以字典的形式赋值给kwargs</li>
<li>在字典前使用**可以把字典解包为多个关键字参数传递给函数使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_kw</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">dic = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">test_kw(**dic)</span><br></pre></td></tr></table></figure>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><ul>
<li>*后为命名关键字参数，必须传值，且以关键字形式赋值</li>
<li>参数搭配使用及顺序：位置参数、默认参数、*、命名关键字参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x, y=<span class="number">1</span>, *, z)</span>:</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line">foo(<span class="number">2</span>, z=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h3><ul>
<li>严格的顺序：位置参数、默认参数、可变长参数*args，[*，命名关键字参数]，可变长参数**kwargs</li>
<li>一般使用：位置参数、默认参数、可变长参数*args、可变长参数**kwargs</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b=<span class="string">'x'</span>, *args, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, args, kwargs)</span><br><span class="line">bar(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, x=<span class="string">'a'</span>, y=<span class="string">'g'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><ul>
<li>递归函数的优点是定义简单，逻辑清晰。理论上所有递归函数都可以写成循环的方式。但循环的逻辑不如递归清晰</li>
<li>使用递归函数需要防止栈溢出。在计算机中，函数调用是通过栈【stack】这种数据结构实现的，每当进入一个函数调用，栈就会增加一层栈帧。每当函数返回，栈就会减少一层栈帧。由于栈的大小不是无限的，所以递归调用的次数过多就会导致栈溢出。</li>
<li>尾递归可以解决递归栈溢出，但由于python解释器没有对尾递归做优化，依然会存在栈溢出，只要保证函数嵌套不超过100一般就没问题。</li>
</ul>
<h3 id="范例（汉诺塔）"><a href="#范例（汉诺塔）" class="headerlink" title="范例（汉诺塔）"></a>范例（汉诺塔）</h3><p>把圆盘从下面开始按大小顺序重新摆放到另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(n,x,y,z)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        print(x,<span class="string">'--&gt;'</span>,z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanoi(n<span class="number">-1</span>,x,z,y) <span class="comment">#将前n-1个盘子从x移动到y上</span></span><br><span class="line">        hanoi(<span class="number">1</span>,x,y,z) <span class="comment">#将最底下的最后一个盘子从x移动到z上</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>,y,x,z) <span class="comment">#将y上的n-1个盘子移动到z上</span></span><br><span class="line">hanoi(<span class="number">5</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>语法：lambda 参数：表达式</li>
<li>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果</li>
</ul>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> y &gt; x <span class="keyword">else</span> y</span><br><span class="line">print(f(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ul>
<li>map函数接收两个参数，一个是函数，一个是迭代器</li>
<li>map将传入的函数依次作用到序列的每个元素，并把结果作为新的迭代器返回</li>
</ul>
<h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = map(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">print(list(result))</span><br></pre></td></tr></table></figure>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ul>
<li>在python3中，reduce函数已经被从全局名字空间中移除了，它被放置在functools模块里，用的话需要先引入</li>
<li>reduce函数接收两个参数，一个是函数且必需有两个参数，一个是迭代器</li>
<li>reduce会把相邻的两个元素使用函数处理后，再把处理的结果和相邻的元素进行处理，以此类推。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x,y: x + y, range(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">print(result):</span><br></pre></td></tr></table></figure>
<h3 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h3><p>将数字字符串转换为数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dict(zip(<span class="string">'0123456789'</span>, range(<span class="number">0</span>,<span class="number">10</span>)))[s]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x + y</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</span><br><span class="line">print(str2int(<span class="string">'123'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><ul>
<li>filter也接收一个函数和一个迭代器。</li>
<li>和map不同的是，filter把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">result = list(filter(is_odd, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h3><ul>
<li>质数：在大于1的自然数中，除了1和它本身之外不再有其他因数</li>
<li>删除1-100内的质数<ul>
<li>利用filter函数，只显示有返回值的函数结果【是质数，不返回；不是质数则返回】</li>
<li>单个数除以比它小但大于2的数，如果余数为0说明不是质数，直接返回。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">print(list(filter(not_prime, range(<span class="number">1</span>, <span class="number">101</span>))))</span><br></pre></td></tr></table></figure>
<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><ul>
<li>第一个参数接收可迭代的序列<ul>
<li>list的sort属性只可用于list类型</li>
</ul>
</li>
<li>key为只接收一个参数的函数，以此定义排序依据</li>
<li>reverse为是否逆序排列</li>
<li>结果：生成新序列的副本<ul>
<li>list的sort属性变更list生成新列表</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student_tuple = ((<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>))</span><br><span class="line">print(sorted(student_tuple, key=<span class="keyword">lambda</span> student:student[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul>
<li>定义在函数内部的函数，它包含对外部作用域而非全局作用域的引用，该内部函数就是闭包函数</li>
<li>一个闭包就是你调用了函数A，这个函数A返回了一个函数B给你，这个返回的函数B就是闭包；调用函数A传递的参数就是自由变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">()</span>:</span></span><br><span class="line">        print(x) <span class="comment">#可以引用外部作用域的变量x</span></span><br><span class="line">    <span class="keyword">return</span> funcB</span><br><span class="line">f = funcA()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> urlopen(url).read()</span><br><span class="line">    <span class="keyword">return</span> get</span><br><span class="line">res = index(<span class="string">'https://blog.unforget.cn'</span>)</span><br><span class="line">print(res().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>符合开闭原则：对源代码修改封闭，对功能扩展开放</p>
<h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p>多个装饰器，从上往下依次执行，从下往上依次装饰</p>
</blockquote>
<table>
<thead>
<tr>
<th>写法</th>
<th>使用decorator</th>
<th>不使用decorator</th>
</tr>
</thead>
<tbody>
<tr>
<td>单个Decorator，不带参数</td>
<td>@dec<br>def method(args):<br>&emsp;pass</td>
<td>def method(args):<br>&emsp;pass<br>method = dec(method)</td>
</tr>
<tr>
<td>多个Decorator，不带参数</td>
<td>@dec_a<br>@dec_b<br>@dec_c<br>def method(args):<br>&emsp;pass</td>
<td>def method(args):<br>&emsp;pass<br>method = dec_a(dec_b(dec_c(method)))</td>
</tr>
<tr>
<td>单个Decorator，带参数</td>
<td>@dec(params)<br>def method(args):<br>&emsp;pass</td>
<td>def method(args):<br>&emsp;pass<br>method = dec(params)(method)</td>
</tr>
<tr>
<td>多个Decorator，带参数</td>
<td>@dec_a(params1)<br>@dec_b(params2)<br>@dec_c(params3)<br>def method(args):<br>&emsp;pass</td>
<td>def method(args):<br>&emsp;pass<br>method = dec_a(params1)(dec_b(params2)(dec_c(params3)(method)))</td>
</tr>
</tbody>
</table>
<h2 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h2><h3 id="无参装饰器"><a href="#无参装饰器" class="headerlink" title="无参装饰器"></a>无参装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 添加此装饰器后可保持原函数属性不变</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args, **kwargs)  <span class="comment">#index()</span></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'run time is %s'</span> % (end_time - start_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer  #timmer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'welcome!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index1</span><span class="params">(args)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'%s'</span> % args)</span><br><span class="line">index()</span><br><span class="line">index1(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a>有参装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(time.time())</span><br><span class="line">now()</span><br><span class="line">print(now.__name__)</span><br></pre></td></tr></table></figure>
<h3 id="装饰器的叠加"><a href="#装饰器的叠加" class="headerlink" title="装饰器的叠加"></a>装饰器的叠加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_a'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_a</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_a'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_b'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_b</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_b'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_b</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in f'</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"><span class="comment"># 函数定义阶段，decorator_b将f作为参数，取得“Get in decorator_b”</span></span><br><span class="line"><span class="comment"># decorator_a把decorator_b作为参数，取得"Get in decorator_a"</span></span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 函数调用阶段，执行等同于decorator_a(decorator_b(f(1))),</span></span><br><span class="line"><span class="comment"># 依次执行decorator_a，decorator_b，f,取得“Get in inner_a”、“ Get in inner_b”“Get in f”</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数之迭代器</title>
    <url>/blog/2018/03/02/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E5%87%BD%E6%95%B0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>迭代：重复的过程称为迭代，每次重复即是一次迭代，但是每次重复的结果都是下一次重复的初始值</li>
<li>可迭代：每个含有<strong>iter</strong>()方法的数据类型都是可迭代的，都可以使用for循环获取对象中的每一个元素</li>
<li>for循环：先执行对象的iter方法得到一个迭代器对象，再执行迭代器对象的next方法从而得到对象的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment"># i = a.__iter__()</span></span><br><span class="line">i = iter(a) <span class="comment">#iter方法获取列表的迭代器对象</span></span><br><span class="line">print(i)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(i)) <span class="comment">#next方法获取迭代器的下一个值</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">print(isinstance([], Iterable))</span><br><span class="line">print(isinstance((), Iterable))</span><br><span class="line">print(isinstance(&#123;&#125;, Iterable))</span><br><span class="line">print(isinstance(<span class="string">''</span>, Iterable))</span><br></pre></td></tr></table></figure>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul>
<li>zip:[拉链函数]</li>
</ul>
<blockquote>
<p>接受一系列的可迭代对象作为参数【至少2个】，返回由可迭代对象元素组成的元组；可用于双循环或多循环的取值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'hejingqi'</span>, <span class="string">'hanjianfang'</span>, <span class="string">'xiaofangfang'</span>]</span><br><span class="line">ages = [<span class="number">27</span>, <span class="number">26</span>, <span class="number">27</span>]</span><br><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> zip(names, ages):</span><br><span class="line">        print(name, age)</span><br></pre></td></tr></table></figure>
<ul>
<li>enumerate</li>
</ul>
<blockquote>
<p>接收一个可迭代对象和索引初始值，返回由索引和元素组成的元组；可用于序列的取值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">l = list(range(<span class="number">5</span>))</span><br><span class="line">i = enumerate(l)</span><br><span class="line">print(isinstance(i, Iterator))</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(l, <span class="number">10</span>):</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li>既含有<code>__iter__()</code>方法，又含有<code>__next__()</code>方法的对象</li>
<li>执行对象的<code>__iter__()</code>方法得到的结果仍然是他本身</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>惰性计算：它仅在迭代至当前元素时才计算该元素的值，在此之前和之后都可以不存在，也就是不需要在遍历之前准备好迭代过程的所有元素，所以适合遍历那些有无穷个元素的集合【比如自然数】</li>
<li>优点<ul>
<li>提供了一种不依赖下标的迭代方式</li>
<li>就迭代器本身来说，更节省内存</li>
</ul>
</li>
<li>缺点<ul>
<li>无法获取迭代器对象的长度</li>
<li>不如序列类型取值灵活，是一次性的，只能往后取值，不能往前退</li>
</ul>
</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul>
<li>调用生成器函数返回一个生成器（和迭代器类似，返回自身）</li>
<li>自动实现了迭代器的功能（相当于为函数封装好iter和next方法）</li>
<li>语法上与函数相似，只是将return替换成了yield；但是return只能返回一次值，函数就终止了；而yield能返回多次值，每次返回都会将函数暂停，下次调用会从上一次暂停的位置继续执行</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>生成器表达式</li>
</ul>
<blockquote>
<p>类似列表推导式(简单理解为元组推导式)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">print(g)</span><br></pre></td></tr></table></figure>
<ul>
<li>生成器函数（使用yield返回的函数）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'first'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">'second'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">'third'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">g = foo() <span class="comment">#函数的执行，得到一个生成器【同时也是一个迭代器】</span></span><br><span class="line">print(g)</span><br><span class="line">next(g) <span class="comment">#使用迭代器的next方法获取对象的元素（此处为执行函数，遇yield第一次返回）</span></span><br><span class="line">print(next(g)) <span class="comment">#执行函数，并打印返回值</span></span><br></pre></td></tr></table></figure>
<h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><h3 id="send定义"><a href="#send定义" class="headerlink" title="send定义"></a>send定义</h3><ul>
<li>生成器必须在执行一次next【也即yield一次，产生一个断点】才能接受send发送的值</li>
<li>send是调用生成器的方法，在断点恢复同时向yield传递值，在下次yield处暂停</li>
<li>next也是调用生成器的方法，但是不向yield传值，此时yield值为空</li>
</ul>
<h3 id="send范例"><a href="#send范例" class="headerlink" title="send范例"></a>send范例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(value=None)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        value = (<span class="keyword">yield</span> value)</span><br><span class="line">        print(<span class="string">"The value is"</span>, value)</span><br><span class="line">        <span class="keyword">if</span> value:</span><br><span class="line">            value = value + <span class="number">1</span></span><br><span class="line">g = echo(<span class="number">1</span>)</span><br><span class="line">print(next(g))</span><br><span class="line">print(g.send(<span class="number">2</span>))</span><br><span class="line">print(g.send(<span class="number">5</span>))</span><br><span class="line">print(next(g))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">The value <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">The value <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">The value <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤详解</span></span><br><span class="line">定义生成器时value为<span class="number">1</span>，返回value【<span class="number">1</span>】</span><br><span class="line">value重新赋值等于<span class="number">2</span>【The value <span class="keyword">is</span> <span class="number">2</span>】，value重新计算等于<span class="number">3</span>，返回value【<span class="number">3</span>】</span><br><span class="line">value重新赋值等于<span class="number">5</span>【The value <span class="keyword">is</span> <span class="number">5</span>】，value重新计算等于<span class="number">6</span>，返回value【<span class="number">6</span>】</span><br><span class="line">next调用，向<span class="keyword">yield</span>中传递空值，value为空【The value <span class="keyword">is</span> <span class="literal">None</span>】，value重新计算为空，返回空值【<span class="literal">None</span>】</span><br></pre></td></tr></table></figure>
<h3 id="send范例详解"><a href="#send范例详解" class="headerlink" title="send范例详解"></a>send范例详解</h3><ul>
<li>参考：<a href="http://codingpy.com/article/python-generator-notes-by-kissg/" target="_blank" rel="noopener">http://codingpy.com/article/python-generator-notes-by-kissg/</a></li>
<li>上述代码既有yield value的形式，又有value = yield形式，看起来有点复杂。但以yield分离代码进行解读，就不太难了。第一次调用next()方法，执行到yield value表达式，保存上下文环境暂停返回1。第二次调用send(value)方法，从value = yield开始，打印，再次遇到yield value暂停返回。后续的调用send(value)或next()都不外如是。</li>
<li>在一次next()(非首次)或send(value)调用过程中，实际上存在2个yield，一个作为恢复点的yield与一个作为暂停点的yield。因此，也就有2个yield表达式。send(value)方法是将值传给恢复点yield;调用next()表达式的值时，其恢复点yield的值总是为None，而将暂停点的yield表达式的值返回。</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>范例1：模拟tail -f a.txt|grep ‘python’</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            line = f.readline().strip()</span><br><span class="line">            <span class="keyword">if</span> line:</span><br><span class="line">                <span class="keyword">yield</span> line</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern, lines)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            print(line)</span><br><span class="line">grep(<span class="string">'python'</span>, tail(<span class="string">'a.txt'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>范例2：获取斐波那契数前n个值</li>
</ul>
<blockquote>
<p>斐波那契数:除第一第二个数之外，其他每个数都由前俩个数相加得到结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">g = fib(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用模块</title>
    <url>/blog/2018/02/28/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="包和模块"><a href="#包和模块" class="headerlink" title="包和模块"></a>包和模块</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>在python中，一个py文件就是一个模块</li>
<li>使用模块还可以避免函数名和变量名冲突，相同的函数和变量完全可以分别存在不同的模块中；我们自己在编写模块时，不必考虑名字与其他模块冲突，但是尽量不要和内置函数名冲突。</li>
<li>为了避免模块名冲突，python又引入了按目录来组织模块的方法，称之为包。</li>
<li>每一个包目录下都会有<code>__init__.py</code>文件，在python2下这个文件是必须存在的【python3中可以不存在】，否则python就会把这个目录当成普通目录,而不是一个包；<code>__init__.py</code>可以是空文件，也可以有python代码；因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是目录名。</li>
</ul>
<h2 id="模块与脚本"><a href="#模块与脚本" class="headerlink" title="模块与脚本"></a>模块与脚本</h2><ul>
<li>当python文件当做脚本直接运行时，<code>__name__ = &#39;__main__&#39;</code>;</li>
<li>当python文件作为模块导入时，<code>__name__=&#39;文件名&#39;</code>;</li>
<li>因此可以在<code>if __name__ == &#39;__main__&#39;:</code>下定义一些只作为脚本使用时的操作，而作为模块不执行。</li>
</ul>
<h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><ul>
<li>import a as b：导入模块a并设置为别名b，实际为导入该包下的init.py文件</li>
<li>from A.C import B：B为具体的模块名或函数名</li>
<li>包内导入：<ul>
<li>绝对导入【最上层使用 包名】：from A.C import B</li>
<li>相对导入【使用逗号表示目录层级】：from ..C import B</li>
</ul>
</li>
</ul>
<h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><blockquote>
<p>sys.path显示模块搜索路径（使用列表的append方法可以修改）</p>
</blockquote>
<ul>
<li>当前目录</li>
<li>PYTHONPATH定义路径</li>
<li>python默认安装路径</li>
</ul>
<h1 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>开启一个子进程，在其中执行系统命令</li>
<li>直接和进程通信获取执行结果，或者获取他们的返回码【成功或失败】</li>
<li>替代一些旧的模块，比如os.system、os.spawn*</li>
</ul>
<h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><ul>
<li>执行命令，并返回执行状态</li>
<li>其中shell参数为False时，命令需要通过列表的方式传入，当shell为True时，可直接传入命令</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">print(<span class="string">'$ nslookup'</span>)</span><br><span class="line">r = subprocess.call([<span class="string">'nslookup'</span>, <span class="string">'www.python.org'</span>])  <span class="comment">#开启子进程，传入命令行参数，捕获返回码</span></span><br><span class="line">print(<span class="string">'Exite code:'</span>, r)</span><br></pre></td></tr></table></figure>
<h2 id="Popen方法"><a href="#Popen方法" class="headerlink" title="Popen方法"></a>Popen方法</h2><p>执行命令，获取命令的执行结果</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>args：shell命令，可以是字符串，或者序列类型，如list,tuple。</li>
<li>stdin,stdout,stderr：分别表示程序的标准输入，标准输出及标准错误</li>
<li>shell：与上面方法中用法相同</li>
<li>cwd：用于设置子进程的当前目录</li>
<li>env：用于指定子进程的环境变量。如果env=None，则默认从父进程继承环境变量</li>
<li>universal_newlines：不同系统的的换行符不同，当该参数设定为true时，则表示使用\n作为换行符</li>
</ul>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read/write"></a>read/write</h3><p>直接和管道通信，进行读写操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(<span class="string">b"print('test')"</span>)</span><br><span class="line">obj.stdin.close()</span><br><span class="line">cmd_out = obj.stdout.read()</span><br><span class="line">obj.stdout.close()</span><br><span class="line">cmd_error = obj.stderr.read()</span><br><span class="line">obj.stderr.close()</span><br><span class="line">print(cmd_out.decode())</span><br></pre></td></tr></table></figure>
<h3 id="communicate"><a href="#communicate" class="headerlink" title="communicate"></a>communicate</h3><p>和管道通信，获取结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="comment">#打开一个管道对象，并把命令行执行结果保存到管道中</span></span><br><span class="line">df = subprocess.Popen([<span class="string">"df"</span>, <span class="string">"-P"</span>, <span class="string">"-k"</span>], stdout=subprocess.PIPE) </span><br><span class="line"><span class="comment">#和管道通信，获取数据</span></span><br><span class="line">output = df.communicate()[<span class="number">0</span>]           </span><br><span class="line"><span class="comment">#将获取的管道数据读到内存中【解码过程】</span></span><br><span class="line">print(output.decode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>将一个子进程的输出，作为另一个子进程的输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">child1 = subprocess.Popen(<span class="string">'cat /etc/passwd'</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">child2 = subprocess.Popen(<span class="string">'grep "0:0"'</span>, shell=<span class="literal">True</span>, stdin=child1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">out = child2.communicate()</span><br><span class="line">print(out[<span class="number">0</span>].decode())</span><br></pre></td></tr></table></figure>
<h3 id="其他进程方法"><a href="#其他进程方法" class="headerlink" title="其他进程方法"></a>其他进程方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">child = subprocess.Popen(<span class="string">'sleep 60'</span>,shell=<span class="literal">True</span>,stdout=subprocess.PIPE)</span><br><span class="line">child.poll()    <span class="comment">#检查子进程状态</span></span><br><span class="line">child.kill()     <span class="comment">#终止子进程</span></span><br><span class="line">child.send_signal()    <span class="comment">#向子进程发送信号</span></span><br><span class="line">child.terminate()   <span class="comment">#终止子进程</span></span><br></pre></td></tr></table></figure>
<h1 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h1><blockquote>
<p>记录日志的模块</p>
</blockquote>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>日志级别：critical&gt;error&gt;warning&gt;info&gt;debug&gt;noset</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>level</td>
<td>大于某等级的日志</td>
</tr>
<tr>
<td>%(asctime)s</td>
<td>创建时间</td>
</tr>
<tr>
<td>%(filename)s</td>
<td>当前执行的文件</td>
</tr>
<tr>
<td>%(lineno)d</td>
<td>当前行号</td>
</tr>
<tr>
<td>%(levelname)s</td>
<td>当前日志级别名称</td>
</tr>
<tr>
<td>%(message)s</td>
<td>当前日志信息</td>
</tr>
<tr>
<td>datefmt</td>
<td>时间格式</td>
</tr>
<tr>
<td>filename</td>
<td>记录的文件名</td>
</tr>
<tr>
<td>filemode</td>
<td>文件打开模式（’w’：写 ‘a’：追加）</td>
</tr>
</tbody>
</table>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">            format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">            datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">            filename=<span class="string">'/tmp/apiserver.log'</span>,</span><br><span class="line">            filemode=<span class="string">'w'</span>)</span><br><span class="line">logging.debug(<span class="string">'this is debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'this is info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'this is warn message'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><ul>
<li><code>os.path.isfile(__file__)</code>：判断文件是否存在</li>
<li>os.environ：获取系统环境变量</li>
<li><code>os.path.abspath(__file__)</code>:当前文件的绝对路径</li>
<li>os.mkdir(‘ceshi’):创建目录</li>
<li>os.rmdir(‘ceshi’)：删除空目录</li>
<li>os.remove(‘./ceshi/1.py’)：删除文件</li>
</ul>
<h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><ul>
<li>shutil.rmtree(‘ceshi’)：删除目录</li>
<li>shutil.copy(‘module.py’, ‘ceshi.txt’)：复制文件</li>
<li>shutil.copytree(‘11’, ‘ww’)：复制目录<ul>
<li>shutil.copytree(‘11’, ‘ww’, ignore=shutil.ignore_patterns(‘12’))：排除指定的文件</li>
</ul>
</li>
<li>shutil.make_archive(‘22’, ‘gztar’, root_dir=’11’)：打包文件或目录</li>
</ul>
<h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><ul>
<li>sys.argv：命令行参数【列表形式】</li>
<li>sys.stdout：进度条实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    <span class="comment"># 向终端输出字符</span></span><br><span class="line">    sys.stdout.write(<span class="string">'%s'</span> % <span class="string">'#'</span>*i)</span><br><span class="line">    <span class="comment"># 刷新缓存立即显示</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># \r光标回到行首</span></span><br><span class="line">    sys.stdout.write(<span class="string">'\r'</span>)</span><br><span class="line">sys.stdout.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h2><p>命令行选项与参数解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nslookup</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(os.system(<span class="string">'nslookup %s'</span> % url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    <span class="comment"># 设置需要解析的选项参数</span></span><br><span class="line">    parser.add_argument(<span class="string">'--hostname'</span>, <span class="string">'-n'</span>, help=<span class="string">"url info"</span>)</span><br><span class="line">    <span class="comment"># 从命令行获取选项参数，并将其转换为字典</span></span><br><span class="line">    args = vars(parser.parse_args())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'hostname'</span>]:</span><br><span class="line">        nslookup(args[<span class="string">'hostname'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 打印帮助信息</span></span><br><span class="line">        print(parser.print_help())</span><br></pre></td></tr></table></figure>
<h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 获取当前系统时间</span></span><br><span class="line">time1 = time.localtime()</span><br><span class="line"><span class="comment"># 获取当前系统时间的子项</span></span><br><span class="line">print(time1.tm_year)</span><br><span class="line"><span class="comment"># 获取格式化时间</span></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">print(time.strftime(<span class="string">'%X'</span>))</span><br><span class="line"><span class="comment"># 格式化时间</span></span><br><span class="line">time2 = time.strptime(<span class="string">'2018-05-12 10:04:55'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">print(time2)</span><br><span class="line"><span class="comment"># 暂停3s</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="comment"># 获取当前系统时间</span></span><br><span class="line">now = datetime.now()</span><br></pre></td></tr></table></figure>
<h2 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h2><p>我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0；<br>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了；<br>转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，<br>因为全球各地的计算机在任意时刻的timestamp都是完全相同的 datetime.timestamp(now)</p>
<h2 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h2><table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>timestamp()</td>
<td>datetime转换为timestamp</td>
<td></td>
</tr>
<tr>
<td>fromtimestamp()</td>
<td>timestamp转换为本地datetime</td>
<td></td>
</tr>
<tr>
<td>strptime()</td>
<td>str转换为datetime</td>
<td>datetime.strptime(‘2015-12-20 11:11:11’, ‘%Y-%m-%d %H:%M:%S’)</td>
</tr>
<tr>
<td>strftime()</td>
<td>datetime转换为str</td>
<td>datetime.now().strftime(‘%y-%d-%m’)</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># timestamp</span></span><br><span class="line">tm = datetime.timestamp(now)</span><br><span class="line">print(datetime.fromtimestamp(tm))</span><br><span class="line"><span class="comment"># strf</span></span><br><span class="line">print(now.strftime(<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line"><span class="comment"># strp</span></span><br><span class="line">time = <span class="string">'1988-04-26 00:00'</span></span><br><span class="line">time1 = datetime.strptime(time, <span class="string">'%Y-%m-%d %H:%S'</span>)</span><br><span class="line">print(type(time1))</span><br></pre></td></tr></table></figure>
<h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># timedelta</span></span><br><span class="line">Tom = now + timedelta(hours=<span class="number">1</span>)</span><br><span class="line">print(Tom)</span><br></pre></td></tr></table></figure>
<h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>返回随机数</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0~1之间的随机小数</span></span><br><span class="line">a = random.random()</span><br><span class="line"><span class="comment"># 1~5之间的随机整数</span></span><br><span class="line">a = random.randint(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 1~5之间的随机整数【不包含结束】</span></span><br><span class="line">a = random.randrange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 从列表中随机选择一个数字</span></span><br><span class="line">a = random.choice(range(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 从列表中国随机选择2个数字组成新的结果</span></span><br><span class="line">a = random.sample(range(<span class="number">1</span>, <span class="number">10</span>), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 1~3之间的随机小数</span></span><br><span class="line">a = random.uniform(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 乱序重排</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">random.shuffle(a)</span><br></pre></td></tr></table></figure>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><blockquote>
<p>生成由数字和大写字母组成的n位字符串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">v_code</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># chr 数字转字母</span></span><br><span class="line">        str1 = chr(random.randint(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line">        int1 = str(random.randint(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">        res1 = random.choice([str1, int1])</span><br><span class="line">        res += res1</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(v_code(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><ul>
<li>摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）</li>
<li>摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改；但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令</li>
<li>通过在原始口令中“加盐”并配合用户名，可以实现不同用户名相同口令但是在数据库中以不同的摘要存储</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">"how to use python"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">print(md5.hexdigest())</span><br><span class="line"></span><br><span class="line">user = <span class="string">'hejingqi'</span></span><br><span class="line">password = <span class="string">'123456'</span></span><br><span class="line">salt = <span class="string">'123eedcdwsx'</span></span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update((user + password + salt).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(sha1.hexdigest())</span><br></pre></td></tr></table></figure>
<h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">'http://www.douban.com/'</span>)</span><br><span class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) \</span></span><br><span class="line"><span class="string">    AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25'</span>)</span><br><span class="line"><span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'status: %s %s'</span> % (f.status, f.reason))</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (k, v))</span><br><span class="line">    print(<span class="string">'Data: %s'</span> % f.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>request.urlretrieve(&#39;http://www.521609.com/uploads/allimg/140717/1-140GF92J7.jpg&#39;, &#39;a.jpg&#39;)</code></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>subprocess</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据类型</title>
    <url>/blog/2018/05/07/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>整数</li>
<li>小数<ul>
<li>小数之所以称为浮点数，是因为按照科学计数法的表示时，小数点的位置是可变的</li>
<li>对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9</li>
</ul>
</li>
<li>字符串<ul>
<li>使用\转义特殊字符如\t</li>
<li>使用r’’表示内部字符串不转义</li>
<li>使用三引号显示多行内容</li>
</ul>
</li>
<li>布尔值<ul>
<li>数字中的0为False，其他均为True</li>
<li>空字符串为False，其他均为True</li>
</ul>
</li>
<li>空值：None</li>
</ul>
<h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><ul>
<li><a href="#列表">列表</a></li>
<li><a href="#字典">字典</a></li>
<li><a href="#元组">元组</a></li>
<li><a href="#集合">集合</a></li>
</ul>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><ul>
<li>常量：通常用全部大写的变量名表示常量</li>
<li>变量名<ul>
<li>包含字母、数字、下划线</li>
<li>不能以数字开头</li>
<li>不能包含内置关键字</li>
<li>命名必须有实际意义</li>
<li>通常将下划线作为变量名字符串的连接符</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>数字运算符</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td>a = 1 + 2</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>c = 2 -1</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>d = 2 * 4</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>e = 6/3</td>
</tr>
<tr>
<td>//</td>
<td>地板除</td>
<td>b = 5//2</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>h = 5%2</td>
</tr>
<tr>
<td>**</td>
<td>平方</td>
<td>g = 3**2</td>
</tr>
</tbody>
</table>
<ul>
<li>比较运算符：==、!=、&gt;=、&lt;=</li>
<li>逻辑运算符：not 、and、or</li>
<li>成员判断：in、not in</li>
</ul>
<h2 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h2><ul>
<li>可变对象，比如字典、列表、集合；对list进行操作，list内部的内容会发生变化</li>
<li>不可变对象，比如str、tuple；调用对象自身的任意方法也不会改变对象自身的内容；相反，这些方法会创建新的对象并返回。</li>
</ul>
<h2 id="list和dict对比"><a href="#list和dict对比" class="headerlink" title="list和dict对比"></a>list和dict对比</h2><table>
<thead>
<tr>
<th>list</th>
<th>dict</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入和查找的时间随着元素的增加而增加</td>
<td>插入和查找速度极快，不会随着key的增加而增加</td>
</tr>
<tr>
<td>占用内存较少</td>
<td>占用大量内存，内存浪费比较严重</td>
</tr>
</tbody>
</table>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>append：追加单个元素</li>
<li>extend：在列表中添加可迭代对象的多个元素（比如：列表中添加列表）<ul>
<li>列表拼接【类同字符串拼接】 c = L + L2</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>]</span><br><span class="line">L2 = (<span class="string">'4'</span>, <span class="string">'a'</span>)</span><br><span class="line">L.append(<span class="string">'a'</span>)</span><br><span class="line">L.extend(L2)</span><br></pre></td></tr></table></figure>
<ul>
<li>clean：清空列表</li>
<li>count：返回元素出现的次数</li>
<li>index：返回元素第一次出现的索引位置</li>
<li>remove：删除第一次出现的元素<ul>
<li><code>del L[1]</code>：删除指定索引位置的值</li>
</ul>
</li>
<li>pop：删除指定位置（索引）元素并返回【默认最后一个】</li>
<li>insert：指定索引位置插入元素</li>
<li>sort：排序</li>
<li>reverse：反向排序</li>
</ul>
<h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><p>切片始终创建新列表，不会改变原有列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = list(range(<span class="number">10</span>))</span><br><span class="line">print(L[:<span class="number">3</span>])</span><br><span class="line">print(L[<span class="number">-2</span>:])</span><br><span class="line">print(L[::<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>使用其他列表创建新的列表的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">'a'</span>, <span class="string">'B'</span>, <span class="number">5</span>, <span class="string">'C'</span>, <span class="string">'d'</span>]</span><br><span class="line">s = [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L <span class="keyword">if</span> isinstance(s, str)]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<h2 id="迭代函数"><a href="#迭代函数" class="headerlink" title="迭代函数"></a>迭代函数</h2><ul>
<li>range：返回一个可迭代的range对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>enumerate：接受一个可迭代对象，返回一个枚举类型对象；当使用for循环时，每次返回一对数，第一个[默认]是从0开始的计数， 第二个为可迭代对象的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(list_1):</span><br><span class="line">        print(k, v)</span><br></pre></td></tr></table></figure>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>列表去重【保持列表元素位置不变】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_1 = [1, 3, 5, 1, 7, 4]</span><br><span class="line">list_2 = []</span><br><span class="line"></span><br><span class="line">for i in list_1:</span><br><span class="line">    if i not in list_2:</span><br><span class="line">        list_2.append(i)</span><br><span class="line">print(list_2)</span><br></pre></td></tr></table></figure>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul>
<li>元组是不可变数据类型[子元素不可变]  </li>
<li>元组的指向固定，但元组的元素内容是可变的[孙元素可变]  </li>
<li>变与不变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple_2 = (1, 3, [&apos;x&apos;, &apos;y&apos;])</span><br><span class="line">tuple_2[2][0] = &apos;A&apos;</span><br><span class="line">print(tuple_2)</span><br></pre></td></tr></table></figure>
<ul>
<li>单元素元组</li>
</ul>
<blockquote>
<p>因为括号()既可以表示tuple，又可以表示数学公式中的小括号，<br>这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup = (1)</span><br><span class="line">type(tup)</span><br><span class="line">tup1 = (1,)</span><br><span class="line">type(tup1)</span><br></pre></td></tr></table></figure>
<ul>
<li>索引和切片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = (1, 3 , 4, 2)</span><br><span class="line">a[1]</span><br><span class="line">a[2:]</span><br></pre></td></tr></table></figure>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>字典的键值对都是无序的，字典的存储顺序和放入顺序无关</li>
<li>字典的key必须是不可变对象【内存中的key以hash值的方式存储，而只有不可变对象才可hash】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="string">'a'</span>, <span class="string">'a'</span>: <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="comment"># True和1等效 False和0等效 会相互覆盖</span></span><br><span class="line">b = &#123;</span><br><span class="line">    <span class="literal">True</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="string">'d'</span></span><br><span class="line">&#125;</span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字典构造</p>
<ul>
<li><p>dict函数（列表或元组中构造）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_1 = [(<span class="string">'hejingqi'</span>, <span class="number">26</span>), (<span class="string">'xiaofang'</span>, <span class="number">27</span>)]</span><br><span class="line">dict_1 = dict(list_1)</span><br><span class="line">dict_2 = dict(hejingqi=<span class="number">25</span>, xiaofang=<span class="number">27</span>, zhaoying=<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_1 = &#123;x: x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)&#125;</span><br><span class="line">print(dict_1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul>
<li>update：更新或插入kv</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line">a.update(&#123;<span class="string">'b'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>clear：字典内容清空<ul>
<li>del a[‘a’]：删除元素</li>
</ul>
</li>
<li>get：取值【不存在不报错】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = dic.get(<span class="string">'c'</span>, <span class="string">'Not'</span>)</span><br><span class="line">v1 = dic[<span class="string">'a'</span>]</span><br><span class="line">print(v, v1)</span><br></pre></td></tr></table></figure>
<ul>
<li>pop：删除并取值</li>
<li>popitem：随机删除kv对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = dic.pop(<span class="string">'b'</span>)</span><br><span class="line">k, v1 = dic.popitem()</span><br><span class="line">print(v)</span><br><span class="line">print(k, v1)</span><br></pre></td></tr></table></figure>
<ul>
<li>setdefault：设置默认值【不存在时使用】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic.setdefault(<span class="string">'c'</span>, <span class="number">111</span>)</span><br><span class="line">dic[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">print(dic[<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>fromkeys：用于创建一个新字典，以序列seq中元素作为字典的键，value为字典所有键对应的初始值【没有则为None】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_dic = dict.fromkeys([<span class="string">'k1'</span>, <span class="string">'k2'</span>, <span class="string">'k3'</span>], [<span class="number">345</span>])</span><br><span class="line"><span class="comment"># new_dic['k1'] = 12</span></span><br><span class="line"><span class="comment"># 因为k1,k2,k3对应同一块内存空间</span></span><br><span class="line"><span class="comment"># 原空间为不可变对象时(如元组、常量、字符串)，只能使用赋值操作变更对应的变量值，而赋值操作新开辟一个内存空间</span></span><br><span class="line"><span class="comment"># 原空间为可变对象时（如列表、字典、集合），可以在原空间进行操作改变对应的变量值，则此时k1,k2,k3值还是会相同</span></span><br><span class="line">new_dic[<span class="string">'k1'</span>].append(<span class="number">12</span>)</span><br><span class="line">print(new_dic)</span><br></pre></td></tr></table></figure>
<ul>
<li>keys：获取key列表【类似选项values、items】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_1 = &#123;</span><br><span class="line">    <span class="string">'hejingqi'</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">'yuanshuo'</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="string">'yangxiaomeng'</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dict_1.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul>
<li>没有重复值的列表，没有value的字典</li>
<li>集合会自动排序和去重</li>
<li>集合的数学运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="comment"># print(a, b)</span></span><br><span class="line">print(a - b)</span><br><span class="line">print(a | b)</span><br><span class="line">print(a &amp; b)</span><br><span class="line">print(a ^ b)</span><br></pre></td></tr></table></figure>
<ul>
<li>集合推导式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'adfaseasdfe'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ul>
<li>add：添加元素</li>
<li>discard：删除集合元素【没有不报错】</li>
<li>remove：删除集合元素【没有则报错】</li>
<li>clear：清空集合内容<ul>
<li>del set_1：删除集合</li>
</ul>
</li>
<li>update：更新集合内容<ul>
<li>使用列表、元组、字典、集合等联合数据类型更新已经存在的集合</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>&#125;</span><br><span class="line">b = [<span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line">a.update(b)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据类型之字符串</title>
    <url>/blog/2018/05/02/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><ul>
<li><p>isdecimal/isdigit/isnumberic：判断是否为数字型字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v1 = a.isdecimal() #2</span><br><span class="line">v2 = a.isdigit() #2 ②</span><br><span class="line">v3 = a.isnumeric() #2 ② 二/贰</span><br><span class="line">print(v1, v2, v3)</span><br></pre></td></tr></table></figure>
</li>
<li><p>istitle：判断首字母是否大写</p>
</li>
<li>isidentifier：变量名有效性判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="string">'temp'</span></span><br><span class="line">v = n.isidentifier()</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>
<ul>
<li>capitalize：使字符串首字母大写</li>
<li>upper/lower：字符串变大小写</li>
<li>startswith/endswith：判断是否以某字符开头或结束</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'abcd'</span></span><br><span class="line">s.startswith(<span class="string">'a'</span>)</span><br><span class="line">s.endswith(<span class="string">'d'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>strip：移除空白或字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="string">' abc '</span></span><br><span class="line">m.lstrip() <span class="comment">#移除左侧空白</span></span><br><span class="line">m.rstrip()</span><br><span class="line">m.strip() <span class="comment">#移除两端空白</span></span><br><span class="line">n = <span class="string">'abc'</span></span><br><span class="line">n.strip(<span class="string">'c'</span>) <span class="comment">#移除字符c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>split：切割</li>
<li>splitlines：按行分割</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">'a|123|3'</span></span><br><span class="line">a.split(<span class="string">'|'</span>) <span class="comment">#默认以空格分割，只能是单字符分隔符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>replace：替换</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="string">'ab12c'</span></span><br><span class="line">n.replace(<span class="string">'a'</span>, <span class="string">'3'</span>) <span class="comment">#替换所有字符</span></span><br><span class="line">n.replace(<span class="string">'a'</span>, <span class="string">'3'</span>, <span class="number">1</span>) <span class="comment">#只替换第一个字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>center：字符串居中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st = <span class="string">'oldboy'</span></span><br><span class="line">v = st.center(<span class="number">10</span>, <span class="string">'#'</span>)</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>
<ul>
<li>encode：编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'测试'</span></span><br><span class="line">print(name.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(name.encode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>format：字符串格式化【关键字(key=value)方式传递值】</li>
<li>format_map：字符串格式化【字典({key: value})方式传递值】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ori = <span class="string">'my name is &#123;name&#125;, my age is &#123;age&#125;'</span></span><br><span class="line"><span class="comment"># new = ori.format(name='he', age=12)</span></span><br><span class="line">new = ori.format_map(&#123;<span class="string">'name'</span>: <span class="string">'he'</span>, <span class="string">'age'</span>: <span class="number">12</span>&#125;)</span><br><span class="line">print(new)</span><br></pre></td></tr></table></figure>
<ul>
<li>join：join可以拼接任意数量的字符串，调用此方法的字符串将被插入多个字符串之间形成一个新的字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">'0'</span></span><br><span class="line">d = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">c = <span class="string">'xyz'</span></span><br><span class="line">e = a.join(d)</span><br><span class="line">h = a.join(c)</span><br><span class="line">print(e, h)</span><br></pre></td></tr></table></figure>
<h1 id="子串判断"><a href="#子串判断" class="headerlink" title="子串判断"></a>子串判断</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a <span class="keyword">in</span> b: <span class="comment">#如果a在b中</span></span><br><span class="line">    print(a)</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b: <span class="comment">#如果a和b相等</span></span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"abcd"</span></span><br><span class="line">print(a[<span class="number">1</span>], a[::<span class="number">2</span>]) <span class="comment"># 取第2个元素；从第一次元素开始，每隔一个取一个元素。</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul>
<li>%d 十进制整数(decimal)</li>
<li>%s 字符串(string)</li>
<li>%f 浮点数(float)</li>
<li>%x 十六进制数(hex)</li>
<li>%o 八进制数(octal)</li>
</ul>
<h2 id="百分号方式"><a href="#百分号方式" class="headerlink" title="百分号方式"></a>百分号方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'my name is %s,my age is %d'</span> % (<span class="string">'he'</span>, <span class="number">29</span>))</span><br></pre></td></tr></table></figure>
<h2 id="format方式"><a href="#format方式" class="headerlink" title="format方式"></a>format方式</h2><ul>
<li>字符串索引方式<ul>
<li><code>&#39;my name is {name}, my age is {age}&#39;.format(name=&#39;he&#39;, age=29)</code></li>
</ul>
</li>
<li>数字索引方式<ul>
<li><code>&#39;my name is {1}, my age is {0}&#39;.format(29, &#39;he&#39;)</code></li>
</ul>
</li>
</ul>
<h1 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h1><h2 id="小数一般处理"><a href="#小数一般处理" class="headerlink" title="小数一般处理"></a>小数一般处理</h2><p>round(3.16, 1) #保留一位小数，按四舍五入处理</p>
<h2 id="数字的格式化处理"><a href="#数字的格式化处理" class="headerlink" title="数字的格式化处理"></a>数字的格式化处理</h2><table>
<thead>
<tr>
<th>填充符号</th>
<th>对其方式</th>
<th>符号</th>
<th>宽度</th>
<th>精度</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意字符</td>
<td>&gt;&lt;=^</td>
<td>+-</td>
<td>任意数字</td>
<td>任意数字</td>
<td>占位符</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;:*&gt;+10.3f&#125;"</span>.format(<span class="number">34</span>)</span><br><span class="line"><span class="string">"&#123;:0=+10.3f&#125;"</span>.format(<span class="number">34</span>)</span><br><span class="line"><span class="string">'&#123;a&#125;\'long format is &#123;a:0=+10.2f&#125;'</span>.format(a=<span class="number">34</span>)</span><br><span class="line"><span class="string">"The number &#123;1&#125; in hex is:&#123;1:#x&#125;, the number &#123;0&#125; in oct is &#123;0:#o&#125;"</span>.format(<span class="number">45</span>, <span class="number">4746</span>)</span><br></pre></td></tr></table></figure>
<h1 id="元组格式化"><a href="#元组格式化" class="headerlink" title="元组格式化"></a>元组格式化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">'xiaomeng'</span>, <span class="string">'jingqi'</span>)</span><br><span class="line">print(<span class="string">'list is %s'</span> % (tup,))</span><br><span class="line"><span class="string">'list is &#123;&#125;'</span>.format(tup)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>格式化</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>python流程控制</title>
    <url>/blog/2018/05/08/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="流程语句"><a href="#流程语句" class="headerlink" title="流程语句"></a>流程语句</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">'input names:'</span>).strip()</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'oldboy'</span>:</span><br><span class="line">    print(<span class="string">'superadmin'</span>)</span><br><span class="line"><span class="keyword">elif</span> name == <span class="string">'alex'</span>:</span><br><span class="line">    print(<span class="string">'admin'</span>)</span><br><span class="line"><span class="keyword">elif</span> name == <span class="string">'jingqi'</span>:</span><br><span class="line">    print(<span class="string">'man'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'other'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><ul>
<li>当条件为真时永远执行</li>
<li>范例：1-2+3-4…+99</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        result = result - i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = result + i</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><ul>
<li>跳出循环体，不再执行循环</li>
<li>break只能跳出单层循环，跳出多层循环需要在内循环设置变量，在外层循环捕捉变量再次跳出</li>
<li>范例：3次登陆失败则退出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    user = input(<span class="string">'input user:'</span>).strip()</span><br><span class="line">    password = input(<span class="string">'input password:'</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">'alex'</span> <span class="keyword">and</span> password == <span class="string">'newb'</span>:</span><br><span class="line">        print(<span class="string">'welcome'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'输入错误'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><ul>
<li>退出本次循环，继续下次循环</li>
<li>continue只能跳出单层循环的本次循环</li>
<li>范例：1到10的循环，遇到5不执行任何操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(i)</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="for-else-while-else"><a href="#for-else-while-else" class="headerlink" title="for-else|while-else"></a>for-else|while-else</h2><ul>
<li>在循环体内没有break语句、没有return语句、或者没有异常都会正常执行else一次</li>
<li><p>范例</p>
<ul>
<li><p>正常执行else</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'everything is ok'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不执行else</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'everything is ok'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="try-except"><a href="#try-except" class="headerlink" title="try-except"></a>try-except</h2><ul>
<li>语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>：</span><br><span class="line">          需要捕获的异常源码部分</span><br><span class="line"><span class="keyword">except</span>    期望捕获的异常类型：</span><br><span class="line">          捕获异常类型后执行的操作</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">          未捕获异常执行的操作</span><br><span class="line"><span class="keyword">finally</span>：</span><br><span class="line">          无论上述代码执行结果都会执行此部分代码</span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意的是，它不但捕获该类型错误，还把其子类也”一网打尽”</li>
<li>如果错误没有被捕获，它就一直往上抛，最后被解释器捕获，打印一个错误信息，然后程序退出</li>
<li><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承关系</a></li>
<li>范例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    <span class="comment"># a = 5 + 'a'</span></span><br><span class="line">    r = <span class="number">10</span> /<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> b:</span><br><span class="line">    print(<span class="string">'except:'</span>, b)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'No error!'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h2><ul>
<li>更改抛出的错误类型【单写raise原样抛出】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># raise ValueError('Error!')</span></span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抛出自定义错误</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">'invalid value:%s'</span> % s)</span><br><span class="line">    print(<span class="number">10</span>/n)</span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>如果第一个条件为假时，抛出第二个语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="comment"># n!=0为假时，抛出后边的断言</span></span><br><span class="line">    <span class="keyword">assert</span> n !=<span class="number">0</span>, <span class="string">'n is zero'</span></span><br><span class="line">    print(<span class="number">10</span>/n)</span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>python文件操作</title>
    <url>/blog/2018/05/11/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h1><h2 id="with使用"><a href="#with使用" class="headerlink" title="with使用"></a>with使用</h2><blockquote>
<p>上下文管理</p>
</blockquote>
<ul>
<li>可以一次打开多个文件进行操作</li>
<li>不用自己处理文件关闭操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f1,open(<span class="string">'b.txt'</span>, mode=<span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    print(f1.read())</span><br><span class="line">    f2.write(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><blockquote>
<p>文本编辑器(vim、记事本等)和python解释器(如open函数)默认使用系统的编码方式(windows的gbk，linux的utf-8)保存和打开文件</p>
<p>当然也可以指定这俩种方式下的编码方式(encoding)</p>
</blockquote>
<ul>
<li>文件的默认操作模式：mode=’r’</li>
<li>文件对象的读方法<ul>
<li>read：一次读取整个文件，或指定字符数</li>
<li>readline：一次读取一行</li>
<li>readlines：将读取的整个文件保存为列表输出</li>
</ul>
</li>
</ul>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><ul>
<li>文件写模式：<ul>
<li>mode=’w’(覆盖写)</li>
<li>mode=’a’(追加写)</li>
</ul>
</li>
<li>文件对象的写方法<ul>
<li>write：一次写入整个内容</li>
<li>writelines：将列表或元组写入文件（列表或元组的元素必须是字符串，此时相当于将多个字符串拼接为单个字符串后写入文件）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shuzi = list(range(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">kexie = [str(n) + <span class="string">'\n'</span> <span class="keyword">for</span> n <span class="keyword">in</span> shuzi]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'shuzi.txt'</span>, mode=<span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(kexie)</span><br></pre></td></tr></table></figure>
<h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><ul>
<li>r+ 读写</li>
<li>w+ 写读</li>
<li>a+ 追加读</li>
<li>b 以bytes形式读取【默认str】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制的实现</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.png'</span>, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> w, open(<span class="string">'test.png'</span>, mode=<span class="string">'rb'</span>) <span class="keyword">as</span> r:</span><br><span class="line">    w.write(r.read())</span><br></pre></td></tr></table></figure>
<h2 id="文件对象操作-seek"><a href="#文件对象操作-seek" class="headerlink" title="文件对象操作-seek"></a>文件对象操作-seek</h2><ul>
<li>seek 移动光标；参数1为偏移量(字节数)，参数2为起始位置<ul>
<li>起始位置0表示数据流的开始(默认)、1表示当前光标位置、2表示数据流的末尾</li>
<li>str模式下<ul>
<li>起始位置为0，偏移量必须大于等于0</li>
<li>起始位置为1、2，偏移量必须等于0</li>
</ul>
</li>
<li>bytes模式下<ul>
<li>起始位置为0，偏移量必须大于等于0</li>
<li>其实位置为1，偏移量可正可负</li>
<li>起始位置为2，偏移量为负数</li>
</ul>
</li>
</ul>
</li>
<li>tell 显示当前光标位置</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>模拟tailf</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'db.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = f.read().strip()</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            print(data)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟文件修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'shuzi.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f1, open(<span class="string">'shuzi.txt.tmp'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    lines = f1.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'ce'</span>):</span><br><span class="line">            line = <span class="string">'aa\n'</span></span><br><span class="line">        f2.write(line)</span><br><span class="line">os.remove(<span class="string">'shuzi.txt'</span>)</span><br><span class="line">os.rename(<span class="string">'shuzi.txt.tmp'</span>, <span class="string">'shuzi.txt'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="json与序列化"><a href="#json与序列化" class="headerlink" title="json与序列化"></a>json与序列化</h1><p>把变量从内存中取出变成可存储或传输的过程</p>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="comment"># 序列化（写）</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./dump.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(d, f)</span><br><span class="line"><span class="comment"># 反序列化（读）</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./dump.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(pickle.load(f))</span><br></pre></td></tr></table></figure>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><ul>
<li>json表示的对象就是标准的javascript语言的对象。  </li>
<li>json不仅是标准格式，并且比XML更快，而且可以直接在web页面中读取，非常方便；  </li>
</ul>
<h3 id="json和python"><a href="#json和python" class="headerlink" title="json和python"></a>json和python</h3><table>
<thead>
<tr>
<th>json类型</th>
<th>python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>‘str’或u’unicode’</td>
</tr>
<tr>
<td>123.45</td>
<td>int或float</td>
</tr>
<tr>
<td>true/flase</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>dump生成一个类文件对象</li>
<li>dumps生成一个字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./1.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># json.dump(d, f, indent=4)</span></span><br><span class="line">    f.write(json.dumps(d, indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li>load 解析类文件对象</li>
<li>loads 解析json格式字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'./1.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># print(json.load(f))</span></span><br><span class="line">    print(json.loads(f.read()))</span><br></pre></td></tr></table></figure>
<h3 id="非标准类型"><a href="#非标准类型" class="headerlink" title="非标准类型"></a>非标准类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> json.encoder <span class="keyword">import</span> JSONEncoder</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># https://docs.python.org/3/library/json.html?highlight=json#module-json</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustJSONEncoder</span><span class="params">(JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, datetime):</span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">'%Y-%m-%d  %H:%M:%S'</span>)</span><br><span class="line">        <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br><span class="line">now = datetime.now()</span><br><span class="line">res = json.dumps(now, cls=CustJSONEncoder)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h1 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="comment"># 创建解析器</span></span><br><span class="line">tree = ET.parse(<span class="string">'repositories.xml'</span>)</span><br><span class="line"><span class="comment"># 获取根节点</span></span><br><span class="line">root = tree.getroot()</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历子元素</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root:</span><br><span class="line">    print(child.tag, child.text, child.attrib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历后代元素</span></span><br><span class="line"><span class="comment"># 查看标签名称、文本、属性内容</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> root.iter():</span><br><span class="line">    print(ele.tag, ele.text, ele.attrib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># findall使用xpath查找子元素下所有特定标签【默认查找当前标签下的子元素】</span></span><br><span class="line">code = root.findall(<span class="string">'connection//code'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find使用xpath查找子元素下第一个特定标签【默认查找当前标签下的子元素】</span></span><br><span class="line">server = root.find(<span class="string">'connection/server'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建节点</span></span><br><span class="line">nei = ET.Element(<span class="string">'nei'</span>)</span><br><span class="line">nei.text = <span class="string">'hi'</span></span><br><span class="line">nei.attrib[<span class="string">'name'</span>] = <span class="string">'ceshi'</span></span><br><span class="line"><span class="comment"># 变更节点</span></span><br><span class="line">par = root.find(<span class="string">'connection/attributes'</span>)</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> par:</span><br><span class="line">    <span class="keyword">if</span> child.find(<span class="string">'code'</span>).text == <span class="string">'IS_CLUSTERED'</span>:</span><br><span class="line">        <span class="comment"># 添加节点【父节点末尾添加】</span></span><br><span class="line">        child.append(nei)</span><br><span class="line">        <span class="comment"># 修改节点相关值</span></span><br><span class="line">        child.find(<span class="string">'attribute'</span>).text = <span class="string">'true'</span></span><br><span class="line">        <span class="comment"># 删除相关节点【父节点删除子节点】</span></span><br><span class="line">        par.remove(child)</span><br><span class="line">tree.write(<span class="string">'res1.xml'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="ini解析"><a href="#ini解析" class="headerlink" title="ini解析"></a>ini解析</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"><span class="comment"># 创建解析器</span></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"><span class="comment"># 读取ini文件</span></span><br><span class="line">config.read(<span class="string">'12.txt'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有块标题</span></span><br><span class="line">print(config.sections())</span><br><span class="line"><span class="comment"># 查看特定标题下的所有key</span></span><br><span class="line">print(config.options(<span class="string">'persistent_connection'</span>))</span><br><span class="line"><span class="comment"># 获取指定标题下key的值</span></span><br><span class="line">print(config.get(<span class="string">'defaults'</span>, <span class="string">'log_path'</span>))</span><br><span class="line">print(config.getint(<span class="string">'persistent_connection'</span>, <span class="string">'connect_timeout'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="变更-1"><a href="#变更-1" class="headerlink" title="变更"></a>变更</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加块</span></span><br><span class="line">config.add_section(<span class="string">'aa'</span>)</span><br><span class="line"><span class="comment"># 添加或修改块的key</span></span><br><span class="line">config.set(<span class="string">'aa'</span>, <span class="string">'name'</span>, <span class="string">'jingqi'</span>)</span><br><span class="line">config.write(open(<span class="string">'12.txt'</span>, <span class="string">'w'</span>))</span><br><span class="line"><span class="comment"># 删除块</span></span><br><span class="line">config.remove_section(<span class="string">'aa'</span>)</span><br><span class="line"><span class="comment"># 删除块的key</span></span><br><span class="line">config.remove_option(<span class="string">'persistent_connection'</span>, <span class="string">'connect_timeout'</span>)</span><br><span class="line">config.write(open(<span class="string">'34.txt'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>open</tag>
        <tag>json</tag>
        <tag>xml</tag>
        <tag>ini</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式</title>
    <url>/blog/2018/05/13/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>python re模块使用的是PCER(Perl Compatible Regular Expression)，即：Perl 兼容的正则表达式【可参考linux系统man pcre文档】。<br>我们平时使用的就是这种正则表达式， 各种编程语言如 Java、Python、C#、JavaScript 实现的就是这种正则表达式。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配除换行符（\n）之外的任意字符</td>
<td>-</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
<td>-</td>
</tr>
<tr>
<td>[…]</td>
<td>一个字符集范围内的任意字符</td>
<td>第一个字符为[^]表示取反</td>
</tr>
</tbody>
</table>
<h2 id="预定义字符"><a href="#预定义字符" class="headerlink" title="预定义字符"></a>预定义字符</h2><blockquote>
<p>可用于字符集[…]</p>
</blockquote>
<table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w</td>
<td>任意字母数字下划线</td>
<td>-</td>
</tr>
<tr>
<td>\W</td>
<td>非字母数字下划线</td>
<td>-</td>
</tr>
<tr>
<td>\d</td>
<td>数字</td>
<td>-</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td>-</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符</td>
<td>-</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h2><blockquote>
<p>可用于字符或分组()之后</p>
</blockquote>
<table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前一个字符0或多次</td>
<td>*?非贪婪模式</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个字符1或多次</td>
<td>+?非贪婪模式</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一个字符0或1次</td>
<td>??非贪婪模式</td>
</tr>
<tr>
<td><code>{m}</code></td>
<td>匹配前一个字符m次</td>
<td>-</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>匹配前一个字符m到n次</td>
<td>1. 省略m则0到n次，省略n则m到多次 <br>2. <code>{m,n}?</code>非贪婪模式</td>
</tr>
</tbody>
</table>
<h2 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h2><table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td>-</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>1【竖线】</td>
<td>匹配左边或右边</td>
<td>没有括号时，范围是整个正则</td>
</tr>
<tr>
<td>（…）</td>
<td>分组</td>
<td>从左到右依次编号</td>
</tr>
<tr>
<td>\n</td>
<td>分组引用</td>
<td>-</td>
</tr>
<tr>
<td><code>(?p&lt;name&gt;...)</code></td>
<td>命名分组</td>
<td>-</td>
</tr>
<tr>
<td><code>(?p=name)</code></td>
<td>引用命名分组</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="不分组构造"><a href="#不分组构造" class="headerlink" title="不分组构造"></a>不分组构造</h2><table>
<thead>
<tr>
<th>表示法</th>
<th>含义</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?:…)</td>
<td>(…)的不分组表示</td>
<td>re.match(‘(?:abc){2}’, ‘abcabc’)</td>
</tr>
<tr>
<td>(?iLmsux)</td>
<td>iLmsux的每个字符代表一个匹配模式<br>只能用在正则表达式的开头，可选多个<br>用来替代整体模式的flag</td>
<td>re.match(‘(?i)abc’, ‘AbC’)</td>
</tr>
<tr>
<td>(?#…)</td>
<td>#后的内容为注释</td>
<td>re.match(‘ab(?#ceshi)cd’, ‘abcd’)</td>
</tr>
<tr>
<td>(?=…)</td>
<td>之后的字符串匹配表达式才能成功匹配</td>
<td>re.match(‘abc(?=ef)’, ‘abcef’) 后面是ef的abc</td>
</tr>
<tr>
<td>(?!…)</td>
<td>之后的字符串不匹配表达式才能成功匹配</td>
<td>re.match(‘abc(?!ef)’, ‘abce’)后面不是ef的abc</td>
</tr>
<tr>
<td>(?&lt;=…)</td>
<td>之前的字符串匹配表达式才能成功匹配【使用search】</td>
<td>re.search(‘(?&lt;=ab)cd’, ‘abcd’)前面是ab的cd</td>
</tr>
<tr>
<td><code>(?&lt;!...)</code></td>
<td>之前的字符串不匹配表达式才能成功匹配【使用search】</td>
<td><code>re.search(&#39;(?&lt;!ab)cd&#39;, &#39;qacd&#39;)前面不是ab的cd</code></td>
</tr>
<tr>
<td>(?(id/name)pattern)</td>
<td>如果编号为id或别名为name的组匹配到字符<br>，则此分组应用同时需要匹配到pattern</td>
<td>re.match(‘(\d)ab(?(1)\d)’, ‘1ab1’)<br>  分组(\d)和表达式之后的分组(?(1)\d)必须同时匹配【1代表第一个分组】</td>
</tr>
</tbody>
</table>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><ul>
<li>search：在字符串中进行匹配测试</li>
<li>findall：在字符串中进行匹配测试，并返回所有匹配的字符串</li>
<li>match：从字符串开始进行匹配测试，<code>re.match(&#39;\s+&#39;, &#39; &#39;)</code></li>
<li>compile：预编译</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_account = re.compile(<span class="string">r'[\w\.\-]+@([\w\.\-]+)\.[a-z]+$|^0(\d)&#123;2,3&#125;(\d)&#123;8&#125;$|^1(\d)&#123;10&#125;$'</span>)</span><br><span class="line">user_account.match(<span class="string">'jingqi.he@zj-inv.cn'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>split：字符串切分，re.split(r’[\s\,]+’, ‘a b, c d’)</li>
<li>sub：替换，re.sub(r’\slove\s’, ‘ hate ‘, ‘i love you’)</li>
</ul>
<h2 id="经典范例"><a href="#经典范例" class="headerlink" title="经典范例"></a>经典范例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.compile(</span><br><span class="line">    <span class="string">r'(^|\s)('</span> + OPTIONS_REGEX +</span><br><span class="line">    <span class="string">r')=(?P&lt;quote&gt;[\'"])?(.*?)(?(quote)(?&lt;!\\)(?P=quote))((?&lt;!\\)(?=\s)|$)'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>(^/\s)</td>
<td>以竖线开头或空格</td>
</tr>
<tr>
<td><code>(?P&lt;quote&gt;[\&#39;&quot;])</code></td>
<td>单或双引号为一个分组</td>
</tr>
<tr>
<td><code>(?(quote)(?&lt;!\\)(?P=quote))</code></td>
<td>如果前面的单或双引号匹配到，则在上述<br>任意字符串之后必须同时匹配一个相同<br>的单或双引号，并且保证此引号之前没有转义符</td>
</tr>
<tr>
<td><code>((?&lt;!\\)(?=\s)/$)</code></td>
<td>直接以上述匹配结束或是上述匹配之后是空格，并且保证空格之前没有转义符</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>PCRE</tag>
      </tags>
  </entry>
  <entry>
    <title>python环境管理</title>
    <url>/blog/2018/05/30/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p>创建一个隔离的python运行环境</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pip3 install virtualenv</p>
<h2 id="创建独立环境"><a href="#创建独立环境" class="headerlink" title="创建独立环境"></a>创建独立环境</h2><ul>
<li>–no-site-packages 不复制系统已存在的软件包</li>
<li>-p指定解释器，否则使用默认解释器</li>
</ul>
<p>virtualenv -p /usr/bin/python3 venv</p>
<h2 id="进入虚拟环境"><a href="#进入虚拟环境" class="headerlink" title="进入虚拟环境"></a>进入虚拟环境</h2><p>source venv/bin/activate</p>
<h2 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h2><p>deactive</p>
<h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p>python包管理工具</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ol>
<li>更新系统软件库：apt-get update</li>
<li>安装python-pip：apt-get install python-pip</li>
<li>升级python-pip：pip install pip –upgrade</li>
<li>使用easy_install替换pip为最新版本：easy_install pip</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>install：安装：pip install xxx [-f requirements.txt]</li>
<li>uninstall：卸载</li>
<li>list：安装包显示</li>
<li>freeze：安装包显示与导出：pip freeze &gt;requirements.txt</li>
<li>search：软件包在线搜索</li>
</ul>
<h2 id="软件源设置"><a href="#软件源设置" class="headerlink" title="软件源设置"></a>软件源设置</h2><blockquote>
<p>文件位置：~/.pip/pip.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python类</title>
    <url>/blog/2018/05/07/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>面向过程：面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行</li>
<li>面向对象：面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收并处理其他对象发送的消息，程序的执行即为一系列消息在各个对象之间的传递<ul>
<li>在python中一切皆为对象，对象包括数据（属性）和操作数据的函数（方法）</li>
<li>object是一个基类或元类，在python2中继承object为新式类，否则为经典类；python3中默认都是新式类（无论是否明写object）</li>
<li>类的三大特性：数据<a href="#封装">封装</a>、<a href="#继承">继承</a>、<a href="#多态">多态</a></li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>类的属性和方法可以共用一套数据【例如下例中echo方法中可以调用age属性的值】</li>
<li>在python中，以双下划线开头同时以双下划线结尾的是特殊变量，可以直接访问</li>
<li>以下划线开头的是私有变量：单下划线开头的变量在导入类时会被忽略，双下划线是类的私有变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def echo(self):</span><br><span class="line">        print(&apos;my age is %s&apos; % self.age)</span><br><span class="line"></span><br><span class="line">person1 = test(&apos;he&apos;, 27)</span><br><span class="line">person1.echo()</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>是指由继承而产生的相关的不同类，这些类的实例对象会对同一消息作出不同的响应</li>
<li>例如：狗和鸡都有“叫”这一方法，但是调用狗的“叫”，狗会吠叫；调用鸡的“叫”，鸡则会啼叫。</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Animal is running&apos;)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Dog is running&quot;)</span><br><span class="line"># 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>在进行主线继承的同时，需要“混入”额外的功能，这可以通过多重继承来实现，这种设计模式即为Mixin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Mammal(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Runnable(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Running&quot;)</span><br><span class="line"></span><br><span class="line">class Dog(Mammal, Runnable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h3 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h3><ul>
<li>MRO即method resolution order，主要用于在多重继承时判断方法的调用路径（来自哪个类）</li>
<li>在新式类中，查找一个要调用的函数或属性时，采用广度优先原则。范例如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class D(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&quot;class D&quot;)</span><br><span class="line">class B(D):</span><br><span class="line">    pass</span><br><span class="line">class C(D):</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&quot;class C&quot;)</span><br><span class="line">class A(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">f = A()</span><br><span class="line">f.foo()</span><br><span class="line">输出：               class C</span><br></pre></td></tr></table></figure>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><p>【只能用于新式类】从运行结果上看，普通继承和super继承是一样的。但是其实他们的内部运行机制不一样，这一点在多重继承时体现得很明显。在super机制里可以保证公共父类仅被执行一次，至于执行顺序，则是按照MRO进行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter C&quot;)</span><br><span class="line">        print(&apos;Leave C&apos;)</span><br><span class="line">class B(C):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter B&quot;)</span><br><span class="line">        super(B, self).__init__()</span><br><span class="line">        print(&quot;leave B&quot;)</span><br><span class="line">b = B()</span><br><span class="line"># 注解：</span><br><span class="line">super(B, self).__init__()【python2中写法】等同于super().__init__()</span><br><span class="line">调用父类进行初始化【__init__为父类方法】</span><br><span class="line">self指代类的实例</span><br></pre></td></tr></table></figure>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ul>
<li>对功能组件扩展开放、对源代码修改封闭</li>
<li>开闭原则是面向对象设计中“可复用设计”的基石</li>
</ul>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><ul>
<li>鸭子类型是动态类型的一种风格。在这种风格中，一个对象的有效语义不是由继承自特定的类或实现特定的接口来决定，而是由当前的方法和属性的集合决定</li>
<li>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来保证正确使用</li>
<li>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class chinese(object):</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s is chinese&apos; % self.name)</span><br></pre></td></tr></table></figure>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><ul>
<li>在类中定义的变量,上例中country即为类属性</li>
<li>既可以在类中，也可以在实例中调用</li>
</ul>
<h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>将类的方法变为属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student():</span><br><span class="line">    # 返回属性值</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line">    # 设置属性值</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score必须是整型&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;socre必须在0和100之间&apos;)</span><br><span class="line">        self._score = value</span><br><span class="line">    # 删除属性值</span><br><span class="line">    @score.deleter</span><br><span class="line">    def score(self):</span><br><span class="line">        del self._score</span><br><span class="line">        # raise PermissionError</span><br><span class="line">s = Student()</span><br><span class="line">s.score = 60</span><br><span class="line">del s.score</span><br><span class="line">print(s.score)</span><br></pre></td></tr></table></figure>
<h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class person():</span><br><span class="line">    # 限制给实例添加的属性</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;, &apos;score&apos;)</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def print_info(self):</span><br><span class="line">        print(&apos;%s:%s&apos; % (self.name, self.age))</span><br><span class="line"></span><br><span class="line">p = person(&apos;he&apos;, 18)</span><br><span class="line"># 1）使用setattr添加属性【getattr获取/hasattr判断/delattr删除】</span><br><span class="line"># setattr(p, &apos;height&apos;, 16)</span><br><span class="line"># 2）直接添加属性</span><br><span class="line">p.score = 32</span><br><span class="line">p.print_info()</span><br></pre></td></tr></table></figure>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul>
<li>在类中定义的函数，默认为实例方法</li>
<li>与实例进行绑定，函数的第一个参数是self，用于指代实例本身<ul>
<li>第一个参数如果不是self，则第一个参数会被当成self，最终解释器会报参数个数错误</li>
</ul>
</li>
<li>类实例化之后才能调用此方法</li>
</ul>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul>
<li>使用classmethod装饰器</li>
<li>与类进行绑定，函数的第一个参数是cls</li>
<li>类和实例均可以直接调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test:</span><br><span class="line">    @classmethod</span><br><span class="line">    def tell(cls):</span><br><span class="line">        print(&apos;ok&apos;)</span><br><span class="line">test.tell()</span><br></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul>
<li>使用staticmethod装饰器</li>
<li>不与实例或类进行绑定（所以不需要第一个参数是self或cls）</li>
<li>类和实例均可以直接调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def tell(x, y):</span><br><span class="line">        print(x, y)</span><br><span class="line">test.tell(3, 5)</span><br></pre></td></tr></table></figure>
<h2 id="方法范例"><a href="#方法范例" class="headerlink" title="方法范例"></a>方法范例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import settings</span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">class Mysql():</span><br><span class="line">    # 类实例化时绑定主机和端口</span><br><span class="line">    def __init__(self, host, port):</span><br><span class="line">        self.__id = self.create_id()</span><br><span class="line">        self.__host = host</span><br><span class="line">        self.__port = port</span><br><span class="line"></span><br><span class="line">    def select(self):</span><br><span class="line">        print(&apos;%s is selecting...&apos; % self.__id)</span><br><span class="line"></span><br><span class="line">    # 当类不实例化时，定义从配置文件中读取参数</span><br><span class="line">    @classmethod</span><br><span class="line">    def from_conf(cls):</span><br><span class="line">        return cls(settings.HOST, settings.PORT)</span><br><span class="line"></span><br><span class="line">    # 定义一个与类或实例无关的工具包</span><br><span class="line">    @staticmethod</span><br><span class="line">    def create_id():</span><br><span class="line">        id = hashlib.md5(str(time.clock()).encode(&apos;utf-8&apos;))</span><br><span class="line">        return id.hexdigest()</span><br><span class="line"></span><br><span class="line">con1 = Mysql(&apos;127.0.0.1&apos;, 3306)</span><br><span class="line">con4 = Mysql.from_conf()</span><br><span class="line">con1.select()</span><br><span class="line">con4.select()</span><br></pre></td></tr></table></figure>
<h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;del---&apos;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;name:%s age:%s&apos; % (self.__name, self.__age)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&apos;setitem&apos;)</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&apos;getitem&apos;)</span><br><span class="line">        return self.__dict__[item]</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&apos;delitem&apos;)</span><br><span class="line">        self.__dict__.pop(key)</span><br><span class="line"></span><br><span class="line">test1 = Foo(&apos;he&apos;, 18)</span><br><span class="line">test1[&apos;score&apos;] = 35</span><br><span class="line">print(test1[&apos;score&apos;])</span><br><span class="line">del test1[&apos;score&apos;]</span><br><span class="line">print(test1)</span><br></pre></td></tr></table></figure>
<h2 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h2><ul>
<li>包含类的名称空间【包含属性和方法的集合】</li>
</ul>
<h2 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h2><ul>
<li>通过<code>__init__</code>方法可以给实例绑定属性，而类的其他函数则给实例绑定方法</li>
<li>它是一个特殊的函数，在类实例化时首先执行，并且此函数不能有返回值</li>
<li>self指代实例本身</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h2><p>待续，参考<a href="https://www.cnblogs.com/34fj/p/6358702.html" target="_blank" rel="noopener">见</a></p>
<h2 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h2><ul>
<li>打印实例对象时触发此方法的执行</li>
<li>此方法只能返回字符串</li>
<li>PS：在命令行直接显示变量，调用的是<code>__repr__</code>方法</li>
</ul>
<h2 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h2><ul>
<li>当实例对象被解释器回收或主动删除实例对象时触发此方法执行</li>
</ul>
<h2 id="setitem"><a href="#setitem" class="headerlink" title="__setitem__"></a><code>__setitem__</code></h2><ul>
<li>以字典形式设置（获取、删除）类的属性时触发方法的执行</li>
<li>这3种方法【setitem、getitem、delitem】和【setattr、getattr、delattr】函数具有相同功能</li>
</ul>
<h2 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h2><p><strong> 以属性形式设置或删除类的属性 </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        print(&apos;setattr&apos;)</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, item):</span><br><span class="line">        print(&apos;delattr&apos;)</span><br><span class="line">        del self.__dict__[item]</span><br><span class="line"></span><br><span class="line">test1 = Foo(&apos;he&apos;, 18)</span><br><span class="line">test1.score = 35</span><br><span class="line">print(test1.score)</span><br><span class="line">del test1.score</span><br><span class="line">print(test1.score)</span><br></pre></td></tr></table></figure>
<h2 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h2><p><strong> 只有在没有找到属性的情况下，才调用<strong>getattr</strong>,已有的属性，比如name，不会在<strong>getattr</strong>中查找 </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">class Open:</span><br><span class="line">    def __init__(self, filepath, mode=&apos;r&apos;, encoding=&apos;utf-8&apos;):</span><br><span class="line">        self.filepath = filepath</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        self.f = open(self.filepath, mode=self.mode, encoding=self.encoding)</span><br><span class="line">    def write(self, msg):</span><br><span class="line">        msg = str(datetime.datetime.now()) + &apos;\t&apos; + msg</span><br><span class="line">        return self.f.write(msg)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return getattr(self.f, item)</span><br><span class="line"></span><br><span class="line">obj = Open(&apos;a.txt&apos;, &apos;w&apos;)</span><br><span class="line">obj.write(&apos;111\n&apos;)</span><br><span class="line">obj.write(&apos;222\n&apos;)</span><br><span class="line">obj.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>以上为重写open的write方法，每次写操作均添加时间</li>
<li>对于其他方法由于没有重写，使用getattr直接获取内置open函数对应文件对象的属性和方法</li>
</ul>
<h2 id="iter-next"><a href="#iter-next" class="headerlink" title="__iter__|__next__"></a><code>__iter__|__next__</code></h2><ul>
<li>如果一个类实现了iter和next方法，那么他就实现了迭代器协议，它就是一个迭代器</li>
<li>如下的类实现了迭代器协议【因此就可以被用于for…in循环】</li>
<li>for循环通过next方法获取循环的下一个值，直到遇到StopIteration错误时退出循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        if self.a &gt; 1000:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a</span><br><span class="line">for n in Foo():</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<h2 id="enter-exit"><a href="#enter-exit" class="headerlink" title="__enter__|__exit__"></a><code>__enter__|__exit__</code></h2><ul>
<li>enter和exit用于上下文管理（with）</li>
<li>enter方法用于入口的处理，直接返回对象本身，当使用as后实现f=self.f效果</li>
<li>exit方法用于出口的处理，exc_type为异常类型，exc_value异常的值，exc_tb为异常的追踪</li>
<li>exit方法必须返回True以保证with代码块的异常不会影响其他代码的执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Open:</span><br><span class="line">    def __init__(self, filepath, mode=&apos;r&apos;, encoding=&apos;utf-8&apos;):</span><br><span class="line">        self.filepath = filepath</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        self.f = open(self.filepath, mode=self.mode, encoding=self.encoding)</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&apos;__enter__&apos;)</span><br><span class="line">        return self</span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        print(&apos;__exit__&apos;)</span><br><span class="line">        print(exc_type)</span><br><span class="line">        print(exc_val)</span><br><span class="line">        print(exc_tb)</span><br><span class="line">        self.f.close()</span><br><span class="line">        return True</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return getattr(self.f, item)</span><br><span class="line"></span><br><span class="line">with Open(&apos;c.txt&apos;, &apos;w&apos;) as f: #f=self.f</span><br><span class="line">    1/0</span><br><span class="line">    f.write(&apos;abc\n&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;ok&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h2><ul>
<li>任何类，只要定义了call方法，就可以直接对类的实例进行调用</li>
<li>对实例进行调用就好比对一个函数进行调用，所以你完全可以把实例对象当成函数</li>
<li>因为任何自定义类都是元类type的实例，而可以直接调用自定义类就是因为元类有call方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&apos;my name is %s.&apos; % self.name)</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Michael&apos;)</span><br><span class="line">s()</span><br></pre></td></tr></table></figure>
<h1 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h1><ul>
<li>元类是类的类，是用来创建类【对象】的</li>
<li>函数type实际上是一个元类。type就是python在背后用来创建所有类【包括自身】的元类。</li>
<li>str是用来创建字符串对象的类，int时用来创建整数对象的类，而type就是用来创建类对象的类</li>
<li>python中所有的东西都是对象，包括整数、字符串、函数、类，他们都是由一个类【元类】创建的</li>
</ul>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><ul>
<li>使用type创建类和直接写class完全一样，因为python解释器遇到class定义时，仅仅是扫描class定义的语法，然后调用type创建class</li>
<li>语法：type(name, bases, dict) -&gt; a new type<ul>
<li>class的名称，字符串形式</li>
<li>继承的父类集合，由于python支持多重继承，所以此处为元组形式</li>
<li>包含的属性或方法的字典</li>
</ul>
</li>
</ul>
<h2 id="修改类"><a href="#修改类" class="headerlink" title="修改类"></a>修改类</h2><p>元类很复杂，对于非常简单的类可以不通过元类对类进行修改，可以通过其他两种两种技术实现</p>
<ul>
<li>Monkey patching</li>
<li>class decorators</li>
</ul>
<h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><blockquote>
<p>读取字符串中的python代码并执行</p>
</blockquote>
<ul>
<li>表达式：exec(object[, globals[, locals]])</li>
<li>参数1：python代码形式字符串对象</li>
<li>参数2：语句执行的全局作用域【下例：复用已存在的globals获取全局变量字典】</li>
<li>参数3：语句执行的本地作用域【下例：将函数的执行结果使用字典接收】</li>
</ul>
<h2 id="type与class对比"><a href="#type与class对比" class="headerlink" title="type与class对比"></a>type与class对比</h2><ul>
<li>使用type</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class_name = &apos;chinese&apos;</span><br><span class="line">class_base = (object,)</span><br><span class="line">class_body = &quot;&quot;&quot;</span><br><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line">def print_info(self):</span><br><span class="line">    print(self.name)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class_dict = &#123;&#125;</span><br><span class="line">exec(class_body, globals(), class_dict)</span><br><span class="line"></span><br><span class="line">chinese = type(class_name, class_base, class_dict)</span><br><span class="line">p = chinese(&apos;he&apos;)</span><br><span class="line">p.print_info()</span><br></pre></td></tr></table></figure>
<ul>
<li>使用class</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class chinese:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def print_info(self):</span><br><span class="line">        print(self.name)</span><br></pre></td></tr></table></figure>
<h2 id="元类扩展阅读"><a href="#元类扩展阅读" class="headerlink" title="元类扩展阅读"></a>元类扩展阅读</h2><ul>
<li><a href="https://www.zhihu.com/question/38791962" target="_blank" rel="noopener">python中type和object关系</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000#0" target="_blank" rel="noopener">使用元类实现自定义ORM框架</a></li>
<li><a href="http://www.cnblogs.com/linhaifeng/articles/6204014.html" target="_blank" rel="noopener">瞎驴讲解元类</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>python网络编程之socket</title>
    <url>/blog/2018/03/12/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/</url>
    <content><![CDATA[<h1 id="数据流处理"><a href="#数据流处理" class="headerlink" title="数据流处理"></a>数据流处理</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol>
<li>绑定端口</li>
<li>监听端口【udp无】</li>
<li>接受tcp连接【udp无】</li>
<li>处理连接<ol>
<li>接收客户端数据</li>
<li>处理数据</li>
<li>向客户端返回数据</li>
</ol>
</li>
<li>关闭连接【udp无】</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>建立连接【udp无】</li>
<li>发送数据</li>
<li>接收数据</li>
<li>关闭连接【udp无】</li>
</ol>
<h1 id="tcp编程"><a href="#tcp编程" class="headerlink" title="tcp编程"></a>tcp编程</h1><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"><span class="comment"># 建立socket</span></span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定端口</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'等待连接。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcplink</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    print(<span class="string">'从%s:%s接受新连接'</span> % addr)</span><br><span class="line">    <span class="comment"># 连接建立时首先向客户端发送信息</span></span><br><span class="line">    sock.send(<span class="string">'Welcome!'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 接受数据</span></span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果数据为空或收到exit关键字子则不再接受数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">'utf-8'</span>) == <span class="string">'exit'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send((<span class="string">'你好,%s'</span> % data.decode(<span class="string">'utf-8'</span>)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    sock.close()</span><br><span class="line">    print(<span class="string">'来自%s:%s的连接已经关闭'</span> % addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line">print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">'Michael'</span>, <span class="string">'Tracy'</span>, <span class="string">'Sarah'</span>]:</span><br><span class="line">    s.send(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'exit'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<h1 id="udp编程"><a href="#udp编程" class="headerlink" title="udp编程"></a>udp编程</h1><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">s = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line">print(<span class="string">'在udp端口9999开启服务'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'从%s:%s接受新连接'</span> % addr)</span><br><span class="line">    s.sendto((<span class="string">'你好,%s'</span> % data.decode(<span class="string">'utf-8'</span>)).encode(<span class="string">'utf-8'</span>), addr)</span><br></pre></td></tr></table></figure>
<h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">s = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">'Michael'</span>, <span class="string">'Tracy'</span>, <span class="string">'Sarah'</span>]:</span><br><span class="line">    s.sendto(data.encode(<span class="string">'utf-8'</span>), (<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<h1 id="socketserver编程"><a href="#socketserver编程" class="headerlink" title="socketserver编程"></a>socketserver编程</h1><ul>
<li>SocketServer模块简化了编写网络服务程序的任务。同时SocketServer模块也 是Python标准库中很多服务器框架的基础。</li>
<li>socketserver中包含了两种类，<ul>
<li>一种为服务类（server class），它提供了许多方法：像绑定，监听，运行…… （也就是建立连接的过程）</li>
<li>一种为请求处理类（request handle class），则专注于如何处理用户所发送的数据（也就是事务逻辑）。</li>
</ul>
</li>
<li>范例【服务端】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myhandler</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 数据处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        res = self.request.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            msg = res.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            print(<span class="string">'client:%s msg:%s'</span> % (self.client_address, res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 连接循环</span></span><br><span class="line">    s = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>), Myhandler)</span><br><span class="line">    s.serve_forever()</span><br></pre></td></tr></table></figure>
<h1 id="粘包与分包"><a href="#粘包与分包" class="headerlink" title="粘包与分包"></a>粘包与分包</h1><blockquote>
<p><a href="https://blog.csdn.net/yannanxiu/article/details/52096465" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><ul>
<li>简单描述：发送方发送两个字符串”hello”+”world”，接收方却一次性接收到了”helloworld”。</li>
<li>产生原因：有时候，TCP为了提高网络的利用率，会使用一个叫做Nagle的算法。该算法是指，发送端即使有要发送的数据，如果很少的话，会延迟发送。如果应用层给TCP传送数据很快的话，就会把两个应用层数据包“粘”在一起，TCP最后只发一个TCP数据包给接收端。</li>
</ul>
<h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><ul>
<li>简单描述：发送方发送字符串”helloworld”，接收方却接收到了两个字符串”hello”和”world”。</li>
<li>产生原因：由于<a href="https://blog.csdn.net/keyouan2008/article/details/5843388" target="_blank" rel="noopener">MTU和MSS</a>的长度限制</li>
</ul>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><h2 id="思路解读【粘包处理】"><a href="#思路解读【粘包处理】" class="headerlink" title="思路解读【粘包处理】"></a>思路解读【粘包处理】</h2><ul>
<li>设置数据的属性信息比如版本、md5、长度为报头信息</li>
<li>【发送】将报头信息的长度发送给接收方【struct】<ul>
<li>struct用于python【str，int】和c【struct】之间的数据类型转换</li>
<li>此处struct将要发送的【数据长度】打包成固定长度的bytes对象发送给接收方</li>
</ul>
</li>
<li>【接收方】接收固定长度的数据【struct】，解析出报头长度</li>
<li>【发送】发送报头信息</li>
<li>【接收方】根据报头长度接收报头信息</li>
<li>【发送】发送数据</li>
<li>【接收方】根据报头信息接收数据信息</li>
</ul>
<h2 id="模拟远程执行命令服务端"><a href="#模拟远程执行命令服务端" class="headerlink" title="模拟远程执行命令服务端"></a>模拟远程执行命令服务端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">'0.0.0.0'</span>, <span class="number">9999</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'端口正在监听。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcplink</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">            res = subprocess.Popen(data.decode(<span class="string">'utf-8'</span>), shell=<span class="literal">True</span>, stdout=subprocess.PIPE,</span><br><span class="line">                                   stderr=subprocess.PIPE)</span><br><span class="line">            res_err = res.stderr.read()</span><br><span class="line">            res_std = res.stdout.read()</span><br><span class="line">            <span class="keyword">if</span> res_err:</span><br><span class="line">                cmd_out = res_err</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> res_std:</span><br><span class="line">                cmd_out = <span class="string">'ok'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cmd_out = res_std</span><br><span class="line">            head = &#123;</span><br><span class="line">                <span class="string">'ver'</span>: <span class="string">'1'</span>,</span><br><span class="line">                <span class="string">'md5'</span>: hashlib.md5(cmd_out).hexdigest(),</span><br><span class="line">                <span class="string">'lenth'</span>: len(cmd_out)</span><br><span class="line">            &#125;</span><br><span class="line">            head_json = json.dumps(head)</span><br><span class="line">            head_bytes = head_json.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            print(head_bytes)</span><br><span class="line">            <span class="comment"># 发送报头长度</span></span><br><span class="line">            sock.send(struct.pack(<span class="string">'i'</span>, len(head_bytes)))</span><br><span class="line">            <span class="comment"># 发送发送报头</span></span><br><span class="line">            sock.send(head_bytes)</span><br><span class="line">            <span class="comment"># 发送数据</span></span><br><span class="line">            sock.send(cmd_out)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    sock.close()</span><br><span class="line">    print(<span class="string">'来自%s:%s的连接已关闭'</span> % addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock, addr = s.accept()</span><br><span class="line">        print(<span class="string">'已接受来自%s:%s的连接'</span> % addr)</span><br><span class="line">        t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h2 id="模拟远程执行命令客户端"><a href="#模拟远程执行命令客户端" class="headerlink" title="模拟远程执行命令客户端"></a>模拟远程执行命令客户端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">t = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">t.connect((<span class="string">'10.10.10.100'</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">'&gt;&gt;&gt;'</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">'exit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t.send(cmd.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="comment"># 接收报头长度</span></span><br><span class="line">        head_info = t.recv(<span class="number">4</span>)</span><br><span class="line">        head_len = struct.unpack(<span class="string">'i'</span>, head_info)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 接收报头</span></span><br><span class="line">        head_bytes = t.recv(head_len)</span><br><span class="line">        head_json = head_bytes.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        head_dict = json.loads(head_json)</span><br><span class="line">        data_len = head_dict[<span class="string">'lenth'</span>]</span><br><span class="line">        print(head_dict)</span><br><span class="line">        <span class="comment"># 接收数据</span></span><br><span class="line">        data_buffers = bytes()</span><br><span class="line">        recv_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">            recv_data = t.recv(<span class="number">1024</span>)</span><br><span class="line">            data_buffers+=recv_data</span><br><span class="line">            recv_size+=len(recv_data)</span><br><span class="line">        print(data_buffers.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">t.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title>python网络编程之进程</title>
    <url>/blog/2018/03/02/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/python%E5%BC%80%E5%8F%91/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>进程是资源集合，至少包含一个线程；线程是程序运行的最小单位</li>
<li>一个进程的多个线程共享内存空间</li>
<li>无论多进程或多线程，数量增加到一定程度，任务开销就会急剧上升，效率就会下降</li>
<li>计算密集型任务，更多使用cpu，注重代码的执行效率，更适合使用C语言开发；而如web应用等io密集型【磁盘和网络】，瓶颈不在cpu和内存，所以适合使用python这样代码少的语言提高开发效率</li>
<li>利用操作系统对异步io的支持，可以用单进程单线程来执行多任务，这种模型即为事件驱动模型，对应到python即为协程</li>
<li>要实现多任务，通常采用master-worker模式，master负责分配任务，worker负责执行任务</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><table>
<thead>
<tr>
<th>-</th>
<th>优点</th>
<th>缺点</th>
<th>应用范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>多进程</td>
<td>稳定性高,一个进程的崩溃不会影响到其他进程</td>
<td>创建进程的开销大,Unix下fork还好,windows下特别明显</td>
<td>Apache默认采用进程模型</td>
</tr>
<tr>
<td>多线程</td>
<td>通常线程模式比进程模式执行快,windows下iis就采用多线程模式</td>
<td>但是由于多线程共享内存,一个线程的崩溃会导致整个进程的崩溃</td>
<td>现在apache和iis都出现了多进程多线程混合模式,在保证稳定性的同时提高效率</td>
</tr>
</tbody>
</table>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="Process方法"><a href="#Process方法" class="headerlink" title="Process方法"></a>Process方法</h2><ul>
<li>Process.name：查看子进程名称</li>
<li>Process.pid：子进程pid</li>
<li>Process.is_alive()：进程是否存活</li>
<li>Process.terminate()：终止进程</li>
<li>Process.daemon：当主进程结束时子进程也跟着结束，子进程的daemon属性必须先于start设置</li>
<li>Process.start：开启子进程</li>
<li>Process.join：父进程等待子进程结束【当不设置join时，父进程不等待子进程结束】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, random, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'子进程 %s(%s)开始'</span> % (name, os.getpid()))</span><br><span class="line">    time.sleep(random.randint(<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">    print(<span class="string">'子进程 %s(%s)结束'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'父进程%s开始'</span> % os.getpid())</span><br><span class="line">    <span class="comment"># Process产生用于执行函数的子进程</span></span><br><span class="line">    p1 = Process(target=run_proc, args=(<span class="string">'test1'</span>,))</span><br><span class="line">    p2 = Process(target=run_proc, args=(<span class="string">'test2'</span>,))</span><br><span class="line">    <span class="comment"># 开启子进程,此时p1与p2并行执行</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="comment"># 等待子进程结束</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(<span class="string">'父进程%s结束'</span> % os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如程序为如下顺序，则p1与p2串行执行</span></span><br><span class="line"><span class="comment"># 子程序1</span></span><br><span class="line">p1.start()</span><br><span class="line">p1.join()  </span><br><span class="line"><span class="comment"># 子程序2</span></span><br><span class="line">p2.start()</span><br><span class="line">p2.join()</span><br></pre></td></tr></table></figure>
<h1 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h1><h2 id="Pool方法"><a href="#Pool方法" class="headerlink" title="Pool方法"></a>Pool方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'运行任务 %s(%s)'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">10</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'任务 %s 运行 %0.2f seconds'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'主进程 %s 开始'</span> % os.getpid())</span><br><span class="line">    <span class="comment"># Pool默认产生和cpu核数相等的子进程</span></span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># apply_async用于产生并行子进程，一个进程结束又会有新的进程进入，维持进程总数不变</span></span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="comment"># 关闭进程池</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'主进程 %s 结束'</span> % os.getpid())</span><br></pre></td></tr></table></figure>
<h2 id="Pool方法回调"><a href="#Pool方法回调" class="headerlink" title="Pool方法回调"></a>Pool方法回调</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程池开启n个进程，每个进程获取一个随机值并取这个随机值的平方</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_int</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = random.randint(<span class="number">1</span>, <span class="number">2</span>*n)</span><br><span class="line">    print(<span class="string">'res is %s'</span> % res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        print(<span class="string">'i is %d'</span> % i)</span><br><span class="line">        p.apply_async(random_int, args=(i,), callback=square)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程 </li>
<li>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改</li>
<li>为了保证一个变量不被多个线程同时修改，可以在一个线程执行前加锁，执行完后释放锁，然后其他线程再执行操作【 由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突】</li>
<li>GIL【global iterpretor lock】 Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</li>
</ul>
<h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>由于CPython的python解释器在单线程模式下执行，所以导致python的多线程在很多的时候并不能很好地发挥多核cpu的资源。<br>大部分情况都推荐使用多进程【多个Python进程有各自独立的GIL锁，互不影响。】。python的多线程的同步与其他语言基本相同，主要包含：</p>
<ul>
<li><a href="#Lock&amp;RLock">Lock&amp;RLock</a> ：用来确保多线程多共享资源的访问。</li>
<li><a href="#Semaphore">Semaphore</a>： 用来确保一定资源多线程访问时的上限，例如资源池</li>
<li><a href="#Event">Event</a>：是最简单的线程间通信的方式，一个线程可以发送信号，其他的线程接收到信号后执行操作。 </li>
</ul>
<h3 id="Lock-amp-RLock"><a href="#Lock-amp-RLock" class="headerlink" title="Lock&amp;RLock"></a>Lock&amp;RLock</h3><ul>
<li>Lock对象的状态可以为locked和unlocked，使用acquire()设置为locked状态；使用release()设置为unlocked状态。<ul>
<li>如果当前的状态为unlocked，则acquire()会将状态改为locked然后立即返回。当状态为locked的时候，acquire()将被阻塞直到另一个线程中调用release()来将状态改为unlocked，然后acquire()才可以再次将状态置为locked。</li>
<li>Lock.acquire(blocking=True, timeout=-1),blocking参数表示是否阻塞当前线程等待，timeout表示阻塞时的等待时间 。如果成功地获得lock，则acquire()函数返回True，否则返回False，timeout超时时如果还没有获得lock仍然返回False。</li>
</ul>
</li>
<li>Rlock在acquire状态时，依然可以再次acquire，只要acquire与release成对出现即可，可以递归使用<ul>
<li>RLock与Lock的区别是：RLock中除了状态locked和unlocked外还记录了当前lock的owner和递归层数</li>
</ul>
</li>
<li>范例Lock【确保只有一个线程可以访问共享资源】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading, random</span><br><span class="line"></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    print(balance)</span><br><span class="line">    balance = balance - n</span><br><span class="line">    print(balance)</span><br><span class="line">    time.sleep(random.random() * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(<span class="string">'final balance is %d'</span> % balance)</span><br></pre></td></tr></table></figure>
<ul>
<li>范例RLock</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">lock1 = threading.RLock()</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase_5</span><span class="params">(lock, loop)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, loop):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        x += <span class="number">5</span></span><br><span class="line">        print(<span class="string">'increase x is %d'</span> % x)</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrease_4</span><span class="params">(lock, loop)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, loop):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        increase_5(lock, loop)</span><br><span class="line">        x -= <span class="number">4</span></span><br><span class="line">        print(<span class="string">'decrease x is %d'</span> % x)</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=decrease_4, args=(lock1, <span class="number">4</span>))</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">print(<span class="string">'x is %d'</span> % x)</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>Semaphore管理一个内置的计数器，每当调用acquire()时内置计数器-1；调用release() 时内置计数器+1。</li>
<li>计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。 </li>
<li>范例【同时只有2个线程可以获得semaphore,即可以限制最大连接数为2】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">semaphore = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> semaphore.acquire():</span><br><span class="line">        print( <span class="string">'%s get semaphore'</span> % name)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        semaphore.release()</span><br><span class="line">        print(<span class="string">'%s release semaphore'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    t1 = threading.Thread(target=func, args=(i,))</span><br><span class="line">    t1.start()</span><br></pre></td></tr></table></figure>
<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><ul>
<li>Event内部包含了一个标志位，初始的时候为false。</li>
<li>可以使用使用set()来将其设置为true，或者使用clear()将其重新设置为false。</li>
<li>可以使用is_set()来检查标志位的状态</li>
<li>wait(timeout=None)，用来阻塞当前线程，直到event的内部标志位被设置为true或者timeout超时。</li>
<li>范例【线程间相互通信】</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_status</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(<span class="string">'mysql is starting'</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    e.set()</span><br><span class="line">    print(<span class="string">'mysql is ready...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_conn</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            print(<span class="string">'%s connected to mysql'</span> % threading.current_thread().getName())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e.wait(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">'%s connecting to mysql'</span> % threading.current_thread().getName())</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=mysql_status, args=(event,))</span><br><span class="line">t2 = threading.Thread(target=mysql_conn, args=(event,))</span><br><span class="line">t3 = threading.Thread(target=mysql_conn, args=(event,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure>
<h2 id="线程隔离Local"><a href="#线程隔离Local" class="headerlink" title="线程隔离Local"></a>线程隔离Local</h2><ul>
<li>全局变量local_school是一个threadlocal对象，每个线程都可以对它的student属性操作，而互不影响</li>
<li>threadlocal常用于为每个线程绑定一个数据库连接、http请求、用户身份信息等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (local_school.student, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</span><br><span class="line">t2 = threading.Thread(target=process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><ul>
<li>对于多线程应用，cpu通过切片的方式来切换线程间的执行，线程切换需要耗时【保存上下文】</li>
<li>协程则只使用一个线程，在一个线程中规定某个代码块的执行顺序</li>
</ul>
<h2 id="生成器实现"><a href="#生成器实现" class="headerlink" title="生成器实现"></a>生成器实现</h2><blockquote>
<p>生产者和消费者在同一进程中的使用范例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[消费者] 正在消费 %s...'</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    next(c)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[生产者] 正在生产 %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[生产者] 消费返回：%s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例详解</span></span><br><span class="line">生产者中：</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">生产<span class="number">1</span></span><br><span class="line">消费者中：</span><br><span class="line">向<span class="keyword">yield</span>传值<span class="number">1</span>后，n为<span class="number">1</span></span><br><span class="line">消费<span class="number">1</span></span><br><span class="line">消费者返回r 为‘<span class="number">200</span> ok’</span><br><span class="line">生产者中：</span><br><span class="line">接受消费者的返回值r为‘<span class="number">200</span> ok’</span><br></pre></td></tr></table></figure>
<h2 id="gevent实现"><a href="#gevent实现" class="headerlink" title="gevent实现"></a>gevent实现</h2><ul>
<li>gevent是第三方库，通过greenlet实现协程</li>
<li>当一个greenlet遇到IO操作时，比如访问网络，就会自动切换到其他的greenlet，等待IO操作完成，再在适当的时候切换回来继续执行</li>
<li>由于IO操作非常耗时，经常处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO</li>
<li>由于gevent是基于IO切换的协程，所以最神奇的是，我们编写的Web App代码，不需要引入gevent的包，也不需要改任何代码，仅仅在部署的时候，用一个支持gevent的WSGI服务器，立刻就获得了数倍的性能提升。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的</span></span><br><span class="line">g1=gevent.spawn(func,<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>)</span><br><span class="line">g2=gevent.spawn(func2)</span><br><span class="line"><span class="comment"># 等待g1结束</span></span><br><span class="line">g1.join() </span><br><span class="line"><span class="comment"># 等待g2结束</span></span><br><span class="line">g2.join() </span><br><span class="line"><span class="comment"># 或者上述两步合作一步：gevent.joinall([g1,g2])</span></span><br><span class="line"><span class="comment"># 拿到func1的返回值</span></span><br><span class="line">g1.value</span><br></pre></td></tr></table></figure>
<h2 id="gevent范例"><a href="#gevent范例" class="headerlink" title="gevent范例"></a>gevent范例</h2><ul>
<li>基本使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s eat 1'</span> % name)</span><br><span class="line">    <span class="comment"># 模拟IO阻塞</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">    在gevent模块里面要用gevent.sleep(2)表示等待的时间</span></span><br><span class="line"><span class="string">    然而我们经常用time.sleep()用习惯了，那么有些人就想着</span></span><br><span class="line"><span class="string">    可以用time.sleep()，那么也不是不可以。要想用，就得在</span></span><br><span class="line"><span class="string">    最上面导入from gevent import monkey;monkey.patch_all()这句话</span></span><br><span class="line"><span class="string">    如果不导入直接用time.sleep()，就实现不了单线程并发的效果了</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s eat 2'</span> % name)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'eat'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s play 1'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'%s play 2'</span> % name)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'play'</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">g1 = gevent.spawn(eat, <span class="string">'egon'</span>)</span><br><span class="line">g2 = gevent.spawn(play, <span class="string">'alex'</span>)</span><br><span class="line">gevent.joinall([g1, g2])</span><br><span class="line">print(<span class="string">'主'</span>, time.time() - start)</span><br><span class="line">print(g1.value)</span><br><span class="line">print(g2.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>爬虫的使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'get :%s'</span> % url)</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        print(<span class="string">'%d bytes received from:%s'</span> % (len(response.text), url))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(get_page, <span class="string">'http://www.baidu.com'</span>),</span><br><span class="line">    gevent.spawn(get_page, <span class="string">'https://www.yahoo.com'</span>),</span><br><span class="line">    gevent.spawn(get_page, <span class="string">'https://github.com'</span>),</span><br><span class="line">])</span><br><span class="line">stop = time.time()</span><br><span class="line">print(<span class="string">'run time is %s'</span> % (stop - start))</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/itech/archive/2012/01/05/2312831.html" target="_blank" rel="noopener">多线程同步</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>协程</tag>
        <tag>gevent</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发之html学习</title>
    <url>/blog/2018/06/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91%E4%B9%8Bhtml%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; html文档的开始和结束标签</span><br><span class="line">&lt;head&gt; 文档头部</span><br><span class="line">&lt;title&gt; 网页标题</span><br><span class="line">&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt; 网页内容</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="标签格式"><a href="#标签格式" class="headerlink" title="标签格式"></a>标签格式</h1><h2 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h2><ul>
<li>语法：&lt;标签名 属性名=”属性值” 属性名=”属性值”&gt;&lt;/标签名&gt;</li>
<li>范例：<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h2 id="标签分类"><a href="#标签分类" class="headerlink" title="标签分类"></a>标签分类</h2><ul>
<li>闭合标签：有开始和结束的标志，如：<code>&lt;title&gt;test&lt;/title&gt;</code></li>
<li>自闭和标签：只有开始的标志，如：<code>&lt;meta charset=&quot;utf-8&quot;&gt;|&lt;img src=&quot;&quot;&gt;</code></li>
<li>块级别标签：显示效果为独占一行，如<code>&lt;h1&gt;&lt;/h1&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</code></li>
<li>内联标签：显示效果取决于内容长度，如<code>&lt;label&gt;&lt;/label&gt;&lt;span&gt;&lt;/span&gt;&lt;img src=&quot;&quot;&gt;</code><ul>
<li>助记：span = 跨度</li>
</ul>
</li>
</ul>
<h2 id="嵌套原则"><a href="#嵌套原则" class="headerlink" title="嵌套原则"></a>嵌套原则</h2><ul>
<li>块级别标签可以嵌套快级别标签和内联标签</li>
<li>内联标签只能嵌套内联标签</li>
</ul>
<h1 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!--搜索引擎搜索网页使用的关键词--&gt;</span><br><span class="line">    &lt;meta name=&quot;keywords&quot; content=&quot;it测试&quot;&gt;</span><br><span class="line">    &lt;!--搜索引擎对网页内容的简单介绍--&gt;</span><br><span class="line">    &lt;meta name=&quot;description&quot; content=&quot;it测试&quot;&gt;</span><br><span class="line">    &lt;!--网页解码方式--&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;!--网页标题前的图标--&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;heart.png&quot;&gt;</span><br><span class="line">    &lt;!--网页使用的css文件--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</span><br><span class="line">    &lt;!--网页使用的js文件--&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--网页标题--&gt;</span><br><span class="line">    &lt;title&gt;我的未来&lt;/title&gt;</span><br><span class="line">    &lt;!--直接在html中定义css样式--&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>
<h1 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h1><h2 id="一般标签"><a href="#一般标签" class="headerlink" title="一般标签"></a>一般标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;一级标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;段落1&lt;/p&gt;</span><br><span class="line"># p = paragraph 段落</span><br><span class="line">&lt;p&gt;段落2&lt;/p&gt;</span><br><span class="line">&lt;br&gt;换行</span><br><span class="line">&lt;hr&gt;分割线</span><br><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br><span class="line">&lt;strong&gt;加粗&lt;/strong&gt;</span><br><span class="line">&lt;i&gt;斜体&lt;/i&gt;</span><br></pre></td></tr></table></figure>
<h2 id="CSS类标签"><a href="#CSS类标签" class="headerlink" title="CSS类标签"></a>CSS类标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;&quot;&gt;自定义块级别标签&lt;/div&gt;</span><br><span class="line">&lt;span&gt;自定义内联标签&lt;/span&gt;</span><br><span class="line">&lt;label&gt;自定义内联标签&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<h2 id="资源标签"><a href="#资源标签" class="headerlink" title="资源标签"></a>资源标签</h2><ul>
<li>图片引用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alt = alternate 备用的</span><br><span class="line">&lt;img src=&quot;http://blog.unforget.cn/2018/04/18/TCP%E8%BF%9E%E6%8E%A5/tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png&quot; </span><br><span class="line">height=&quot;200px&quot; width=&quot;110px&quot; alt=&quot;无资源显示&quot; title=&quot;tcp连接&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>超链接：<code>&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点击地址&lt;/a&gt;</code><ul>
<li>target=”_blank” 跳转时新打开一个窗口</li>
</ul>
</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ul = unordered list</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ol = ordered list</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;ccc&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dl = define list</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;列表名称&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;列表项1&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;列表项2&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;列表项3&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># padding 填充</span><br><span class="line">&lt;!--cellpading内容到内边框的距离--&gt;</span><br><span class="line">&lt;!--cellspacing内边框到外边框的距离--&gt;</span><br><span class="line">&lt;!--border有边框--&gt;</span><br><span class="line">&lt;table border=&quot;1&quot; cellpadding=&quot;5px&quot; cellspacing=&quot;10px&quot;&gt;</span><br><span class="line">&lt;!--tr = table row 表格的行--&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;!--th为头部信息--&gt;</span><br><span class="line">        &lt;th&gt;id&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;name&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;age&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;!--td为数据信息，colspan横跨多少列--&gt;</span><br><span class="line">        &lt;td colspan=&quot;2&quot;&gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;27&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;!--rowspan横跨多少行--&gt;</span><br><span class="line">        &lt;td rowspan=&quot;2&quot;&gt;2&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;jing&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;25&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;qi&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;23&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><ul>
<li>action：处理请求的地址</li>
<li>method：请求使用的方法</li>
<li>范例：<code>&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt;&lt;/form&gt;</code></li>
</ul>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>文本输入框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;!--label的for和input的id使用同一值，则鼠标点击提示信息即可直接输入--&gt;</span><br><span class="line">    &lt;label for=&quot;user&quot;&gt;姓名&lt;/label&gt;</span><br><span class="line">    &lt;!--name为向后端传递的变量名，id则确定标签的唯一性--&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;user&quot;&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><p>密码输入框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;label for=&quot;pass&quot;&gt;密码&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;pass&quot;&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h3><p>复选框【多选】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    爱好：</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;&gt;足球</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;篮球</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h3><p>复选框【单选】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    性别：</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; checked&gt;男</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot;&gt;女</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><p>表单提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; value=&quot;表单提交&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p>触发动作的按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>恢复默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; value=&quot;恢复默认&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul>
<li>上传文件：form表单需要加上属性enctype=”multipart/form-data” method=”post”<ul>
<li>enctype = encode type 编码方式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot;&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>下拉选择</p>
<ul>
<li>size：下拉框一次显示的选项个数</li>
<li>multiple：允许多选</li>
<li>selected：默认选项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;province&quot; size=&quot;2&quot; multiple&gt;</span><br><span class="line">    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;henan&quot; selected&gt;河南&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;hubei&quot;&gt;湖北&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;shanxi&quot;&gt;山西&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>多行文本框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    个人简介</span><br><span class="line">    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://tool.chinaz.com/Tools/htmlchar.aspx" target="_blank" rel="noopener">html特殊标签</a></li>
<li><a href="http://www.cnblogs.com/yuanchenqi/articles/6835654.html" target="_blank" rel="noopener">html学习参考</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发之css学习</title>
    <url>/blog/2018/06/04/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91%E4%B9%8Bcss%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器</span><br><span class="line">selector &#123;</span><br><span class="line">    属性：值；</span><br><span class="line">    property: value;</span><br><span class="line">    property1: value1;</span><br><span class="line">    property2: value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><ul>
<li>定义：在标签的style属性中设置</li>
<li>范例：<code>&lt;p style=&quot;color: chartreuse;font-size: 12px&quot;&gt;hello world&lt;/p&gt;</code></li>
</ul>
<h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><ul>
<li>定义：在head标签下的style标签内引入</li>
<li>范例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    p&#123;</span><br><span class="line">        color: chartreuse;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="链接式"><a href="#链接式" class="headerlink" title="链接式"></a>链接式</h2><ul>
<li>定义：在head标签下使用link引入css文件</li>
<li>范例：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&gt;</code></li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    color: #cf9aff;</span><br><span class="line">    background-color: #8dff84;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><blockquote>
<p>每个标签有唯一的id属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#aa&#123;</span><br><span class="line">    color: aqua;</span><br><span class="line">    font-size: 29px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><blockquote>
<p>多个标签可以有相同的class属性，一个标签也可以有多个class属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ceshi&#123;</span><br><span class="line">    background-color: wheat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义属性选择器"><a href="#自定义属性选择器" class="headerlink" title="自定义属性选择器"></a>自定义属性选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[item]&#123;</span><br><span class="line">    background-color: wheat</span><br><span class="line">&#125;</span><br><span class="line">[item=&quot;2&quot;]&#123;</span><br><span class="line">    background-color: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合选择器"><a href="#混合选择器" class="headerlink" title="混合选择器"></a>混合选择器</h3><h4 id="逻辑“或”"><a href="#逻辑“或”" class="headerlink" title="逻辑“或”"></a>逻辑“或”</h4><blockquote>
<p>逗号分隔</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h4,.xxx,#p2&#123;</span><br><span class="line">    background-color: wheat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逻辑“与”"><a href="#逻辑“与”" class="headerlink" title="逻辑“与”"></a>逻辑“与”</h4><blockquote>
<p>标签名在前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.xxx&#123;</span><br><span class="line">    background-color: green</span><br><span class="line">&#125;</span><br><span class="line">p#p2&#123;</span><br><span class="line">    background-color: green</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后代选择"><a href="#后代选择" class="headerlink" title="后代选择"></a>后代选择</h4><blockquote>
<p>使用空格分隔基础选择器，示例：为.outer的所有后代p选择器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer p&#123;</span><br><span class="line">    background-color: wheat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子选择"><a href="#子选择" class="headerlink" title="子选择"></a>子选择</h4><blockquote>
<p>使用大于号分隔基础选择器，示例：为.outer的所有子p选择器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer &gt;p&#123;</span><br><span class="line">    background-color: wheat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="默认权重"><a href="#默认权重" class="headerlink" title="默认权重"></a>默认权重</h3><ul>
<li>标签选择器：1</li>
<li>class选择器：10</li>
<li>id选择器：100</li>
<li>内嵌在属性中的选择器：1000</li>
<li>特权【!import】:高于一切<ul>
<li>范例：<code>div{background-color: blue!important;}</code></li>
</ul>
</li>
</ul>
<h3 id="同权覆盖"><a href="#同权覆盖" class="headerlink" title="同权覆盖"></a>同权覆盖</h3><p>优先级相同时，排在后边的属性覆盖前面的。</p>
<h1 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h1><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>在未定义时，子类标签的文本类型的属性可以继承父类标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    /*字体大小*/</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    /*字体颜色*/</span><br><span class="line">    color: red;</span><br><span class="line">    /*使标签内的文本或图像左右居中*/</span><br><span class="line">    text-align: center;</span><br><span class="line">    /*设置行高的同时即设置了文本上下居中*/</span><br><span class="line">    line-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背景和边框属性"><a href="#背景和边框属性" class="headerlink" title="背景和边框属性"></a>背景和边框属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ceshi1&#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    /*块标签的宽占浏览器宽度的百分比*/</span><br><span class="line">    width: 100%;</span><br><span class="line">    /*padding 填充</span><br><span class="line">    此区块的内容区块外扩（四周）大小*/</span><br><span class="line">    padding: 50px;</span><br><span class="line">    /*margin 页边距；</span><br><span class="line">    此区块与其他区块的间距，</span><br><span class="line">    第一个为上下间距，第二个为左右间距（auto自动居中【需要搭配width实现居中】）*/</span><br><span class="line">    margin: 20px auto;</span><br><span class="line">    /*边框：厚度 实线 红色*/</span><br><span class="line">    border: 2px solid red;</span><br><span class="line">    /*背景色*/</span><br><span class="line">    background-color: wheat;</span><br><span class="line">    /*背景图片：填充方式 上下左右居中*/</span><br><span class="line">    background: url(&quot;http://724.169pp.net/bizhi/2017/025/1.jpg&quot;) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><ul>
<li>不显示：display：none</li>
<li>块级别标签转内联标签：display：inline</li>
<li>内联标签转块级别标签：display：block</li>
<li>既有内联标签又有块级别标签功能：display：inline-block</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label&#123;</span><br><span class="line">    background-color: wheat;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float和clear"><a href="#float和clear" class="headerlink" title="float和clear"></a>float和clear</h2><ul>
<li>正常文档流的区块占用一行的位置，相互之间上下排版</li>
<li>float文档流的多个float区块在一行排版，但不占用一行位置</li>
<li>当float区块有内容时，它会占用相邻正常文档流的内容空间，从而让正常文档流内容可以“环绕”漂浮文档流内容排版</li>
<li>clear清除浮动，假设上一个或左或右浮动的标签为正常文档流，占用一行位置，从而使自己另起新行排版</li>
<li>float可以对block和line进行操作，对line进行操作类似转为block，可以设置宽和高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    width: 50px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.div2&#123;</span><br><span class="line">    clear: left;</span><br><span class="line">    float: right;</span><br><span class="line">    width: 130px;</span><br><span class="line">    height: 140px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h2><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><blockquote>
<p>绝对定位</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.guding&#123;</span><br><span class="line">    width: 80px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    background-color: gray;</span><br><span class="line">    font-size: 15px;</span><br><span class="line">    color: blue;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 40px;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 20px;</span><br><span class="line">    right: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><blockquote>
<p>相对定位，直接写则为相对自身原位置的定位</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.zhuti&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    line-height: 500px;</span><br><span class="line">    background-color: wheat;</span><br><span class="line">    text-align: center;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: 200px;</span><br><span class="line">    left: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><blockquote>
<p>绝对定位，absolute根据前代的一个准确定位取得当前定位；<br>一般用法：在父代标签中设置相对定位relative，在子代中设置绝对定位absolute，则此时的定位为相对父代的定位</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 80%;</span><br><span class="line">    border: 2px solid red;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.zhuti&#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    width: 50%;</span><br><span class="line">    border: 1px solid gold;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 50px;</span><br><span class="line">    bottom: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><blockquote>
<p>又称anchor伪类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hover 徘徊，萦绕</span><br><span class="line">/*链接默认颜色*/</span><br><span class="line">a:link&#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br><span class="line">/*链接被激活时的颜色*/</span><br><span class="line">a:active&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">/*链接被访问过时的颜色*/</span><br><span class="line">a:visited&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">&#125;</span><br><span class="line">/*链接样式：去除a标签下划线*/</span><br><span class="line">a&#123;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">/*鼠标悬浮在链接上时的颜色*/</span><br><span class="line">/*在 CSS 定义中，:hover 必须位于 :link 和 :visited 之后（如果存在的话），这样样式才能生效。*/</span><br><span class="line">a:hover&#123;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="before与after"><a href="#before与after" class="headerlink" title="before与after"></a>before与after</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*在标签的开始（before）或结束（after）位置添加子标签*/</span><br><span class="line">p:after&#123;</span><br><span class="line">    /*标签内容*/</span><br><span class="line">    content: &quot;aa&quot;;</span><br><span class="line">    color: red;</span><br><span class="line">    /*标签设置为块标签*/</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><ul>
<li>列表属性：<code>ul{list-style: none;}</code></li>
<li>图片属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*对齐的四线：底线、基线、中线、顶线*/</span><br><span class="line">img&#123;</span><br><span class="line">    /*图片与文本的中线对齐*/</span><br><span class="line">    /*vertical-align: middle;*/</span><br><span class="line">    vertical-align: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ul>
<li>正常文档流中，子元素可以填充父元素的宽高</li>
<li>漂浮文档流中，子元素不会填充父元素的宽高</li>
<li>范例：此标签【类clear】添加一个块级子标签，并且块标签前后清除浮动，使此标签变成标准文档流，占用一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box clear&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;test&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.clear:after&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">.div1&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: gold;</span><br><span class="line">&#125;</span><br><span class="line">.div2&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    border: 3px solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发之js学习</title>
    <url>/blog/2018/06/06/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91%E4%B9%8Bjs%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><p>head标签下导入js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h1><ul>
<li><a href="#ECMAScript">ECMAScript</a>：js语法规范<ul>
<li><a href="#变量定义">变量定义</a></li>
<li><a href="#基本数据类型">基本数据类型</a></li>
<li><a href="#数据对象">数据对象</a>（引用数据类型）</li>
<li><a href="#运算符">运算符</a></li>
<li><a href="#流程控制">流程控制</a></li>
</ul>
</li>
<li><a href="#BOM对象">BOM对象</a>（浏览器对象模型）：整合js和浏览器</li>
<li><a href="#DOM对象">DOM对象</a>（文档对象模型）：整合js、css、html</li>
</ul>
<h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><ul>
<li>变量声明使用关键词var，如果不用var，则声明的是全局变量</li>
<li>变量名区分大小写，首字符可以是：美元$、下划线、字符，余下的字符可以是：字符、数字、下划线、美元$</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>字符串</li>
<li>数值</li>
<li>布尔值：true或false</li>
<li>null：空值</li>
<li>undefined：只声明，未赋值</li>
</ul>
<h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>NaN属于数字类型，是在字符串转换为数字失败时返回的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &apos;test&apos;</span><br><span class="line">b = +a</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符：+   -    *    /     %       ++        – </li>
<li>比较运算符：&gt;   &gt;=   &lt;    &lt;=    !=    ==    ===   !==<ul>
<li>由于js是弱类型语言，在进行数据比较前默认会进行类型转换</li>
<li>当比较对象中存在数字类型时，会把其他数据转换为数字后进行比较<ul>
<li>==在代码内部可以先进行数据类型转换再进行比较，如console.log(2==”2”)</li>
<li>===在代码内部不能进行数据类型转换后进行比较，如console.log(2===”2”)</li>
</ul>
</li>
<li>当比较对象中存在字符串时，会把其他数据转换为字符串进行比较</li>
</ul>
</li>
<li>逻辑运算符：&amp;&amp;   ||   ！</li>
<li>赋值运算符：=  +=   -=  *=   /=<ul>
<li>++i 先加1再赋值</li>
<li>i++ 先赋值再加1</li>
</ul>
</li>
<li>字符串运算符：+  连接，两边操作数有一个或两个是字符串就做连接运算</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><blockquote>
<p>没有elif</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 5 &gt; 4)&#123;</span><br><span class="line">    console.log(&apos;ok&apos;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&apos;not&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var y = 5</span><br><span class="line">switch (y) &#123;</span><br><span class="line">    case 5:console.log(&apos;5&apos;);break;</span><br><span class="line">    case 2:console.log(&apos;2&apos;);break;</span><br><span class="line">    default:console.log(&apos;未知数&apos;);break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for条件循环"><a href="#for条件循环" class="headerlink" title="for条件循环"></a>for条件循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Things = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">// 初始表达式；条件表达式；自增或自减</span><br><span class="line">for (var i = Things.length - 1;i &gt;= 0;i--)&#123;</span><br><span class="line">    console.log(Things[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for遍历循环"><a href="#for遍历循环" class="headerlink" title="for遍历循环"></a>for遍历循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Things = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">for(item in Things)&#123;</span><br><span class="line">    console.log(Things[item])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i = 0</span><br><span class="line">while (i &lt; 10)&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理try-catch"><a href="#异常处理try-catch" class="headerlink" title="异常处理try-catch"></a>异常处理try-catch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //可能出现异常的代码</span><br><span class="line">    y=+x</span><br><span class="line">&#125;catch (e)&#123;</span><br><span class="line">    // 对异常的处理</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    // 无论是否异常都执行的代码</span><br><span class="line">    alert(&apos;nothing&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理throw"><a href="#异常处理throw" class="headerlink" title="异常处理throw"></a>异常处理throw</h3><p>直接抛出异常：throw Error(‘ceshi’)</p>
<h1 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h1><table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td>数字对象</td>
</tr>
<tr>
<td>String</td>
<td>字符串对象</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔对象</td>
</tr>
<tr>
<td>Array</td>
<td>数组对象</td>
</tr>
<tr>
<td>Match</td>
<td>数学对象</td>
</tr>
<tr>
<td>Date</td>
<td>日期对象</td>
</tr>
<tr>
<td>Object</td>
<td>自定义对象</td>
</tr>
<tr>
<td>Error</td>
<td>错误对象</td>
</tr>
<tr>
<td>Function</td>
<td>函数对象</td>
</tr>
<tr>
<td>RegExp</td>
<td>正则表达式对象</td>
</tr>
<tr>
<td>Global</td>
<td>全局对象</td>
</tr>
</tbody>
</table>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul>
<li>toUpperCase() 转换为大小</li>
<li>length 长度</li>
<li>toLowerCase() 转换为小写</li>
<li>trim() 去除两侧空白</li>
<li>charAt(2) 指定索引位置字符</li>
<li>indexOf(‘bc’) 指定字符串出现时首字符索引位置</li>
<li>lastIndexOf(‘bc’) 指定字符串最后一次出现的首字符索引位置</li>
<li>match(regexp) 返回匹配字符串组成的数组</li>
<li>search(regexp) 返回匹配字符串首字符索引位置</li>
<li>substring(n, m) 取索引n到m之间的字符串</li>
<li>substr(n, m)从索引n开始取m个字符</li>
<li>slice(n, m) 取索引n到m之间的字符串</li>
<li>replace(‘bc’, ‘12’)将字符串内的第一次出现’bc’替换成’12’</li>
<li>split(‘ ‘, 3) 使用空格切割字符串,最多返回3个分割后的元素</li>
<li>concat(‘12’) 字符串末尾追加字符串’12’</li>
</ul>
<h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><ul>
<li>join(‘#’) 使用’#’链接数组元素拼接成字符串</li>
<li>concat(4, 5) 在数组内追加元素</li>
<li>sort() 排序【默认以字符的ASCII码排序】</li>
<li>reverse() 倒序输出</li>
<li>slice(2, 4) 切片操作（包含开始不包含结束，索引可以为负数）</li>
<li>splice(1, 2, ‘c’) 参数1为开始操作的索引，参数2为删除的元素个数，参数3为为替换或插入的元素</li>
<li>push() 在末尾追加元素</li>
<li>pop() 弹出末尾元素</li>
<li>unshift() 在开头添加元素</li>
<li>shift() 弹出开头元素</li>
<li>toString() 转换为字符串输出</li>
</ul>
<h3 id="数字的排序"><a href="#数字的排序" class="headerlink" title="数字的排序"></a>数字的排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Insort (a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line">var arry = [11, 2, 13]</span><br><span class="line">console.log(arry.sort(Insort))</span><br></pre></td></tr></table></figure>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><ul>
<li>Date()有参数时为创建时间对象，无参数时为获取当前时间</li>
<li>getFullYear() 获取指定的时间属性(此处为年)</li>
<li>toLocaleString() 将时间对象转换为本地格式的字符串</li>
</ul>
<h2 id="数学对象"><a href="#数学对象" class="headerlink" title="数学对象"></a>数学对象</h2><ul>
<li>Math.random() 获取0~1之间的随机数</li>
<li>Math.round(n) 通过四舍五入将n转换为整数</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>定义和调用：由于js是整体加载完才会执行，所以函数定义和调用的前后顺序无关</li>
<li>参数个数：func_name.length</li>
<li>arguments对象：可以接受任意个参数并组成数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addnum () &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        sum+=arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line">alert(addnum(1, 2, 3, 6))</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(</span><br><span class="line">    function (x, y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;(4, 5)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>windows对象：一个html文档对应一个windows对象</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>alert(‘123’) 弹出含有确认按钮的提示框</li>
<li>confirm(‘确认’) 弹出含有确认和取消按钮的提示框，可以接收用户的点击信息（true或false）</li>
<li>prompt(‘请输入数字：’) 弹出可以输入的提示框，可以接收用户的输入信息</li>
<li>open(url,,’浏览器设置’) 打开一个新的浏览器窗口</li>
<li>close() 关闭浏览器窗口</li>
<li>setTimeout(close_win, 5000) 在指定的毫秒数之后执行函数或表达式</li>
<li>clearTimeout(ID) 清除设置的一次性任务</li>
<li>setInterval(getinfo, 1000) 设置每隔多少毫秒执行函数或表达式</li>
<li>clearInterval(ID) 清除设置的周期性任务</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><h3 id="一次性任务"><a href="#一次性任务" class="headerlink" title="一次性任务"></a>一次性任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_window = open(&apos;http://www.baidu.com&apos;, &apos;&apos;, &apos;width=1000,height=500&apos;)</span><br><span class="line">function close_win () &#123;</span><br><span class="line">    new_window.close();</span><br><span class="line">&#125;</span><br><span class="line">id = setTimeout(close_win, 5000)</span><br><span class="line">clearTimeout(id)</span><br></pre></td></tr></table></figure>
<h3 id="周期性任务"><a href="#周期性任务" class="headerlink" title="周期性任务"></a>周期性任务</h3><ul>
<li>html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; onclick=&quot;start()&quot; id=&quot;time&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;stop()&quot; value=&quot;停止&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>javascript</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getinfo() &#123;</span><br><span class="line">    var text = document.getElementById(&apos;time&apos;)</span><br><span class="line">    var date = new Date().toLocaleString();</span><br><span class="line">    text.value = date</span><br><span class="line">&#125;</span><br><span class="line">var ID = undefined</span><br><span class="line">function start() &#123;</span><br><span class="line">    if (ID == undefined)&#123;</span><br><span class="line">        getinfo();</span><br><span class="line">        ID = setInterval(getinfo, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function stop() &#123;</span><br><span class="line">    if (ID != undefined)&#123;</span><br><span class="line">        clearInterval(ID);</span><br><span class="line">        ID = undefined;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>一个html就是一个DOM对象</p>
</blockquote>
<ul>
<li>document对象（整个html）</li>
<li>element对象（标签元素）</li>
<li>text对象（文本内容）</li>
<li>attribute对象（标签属性）</li>
<li>注释对象（标签注释）</li>
</ul>
<h2 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h2><p><strong>由于正文标签只有在全部加载后才能进行查找，所以所有涉及到标签查找的js必须位于body标签的末尾</strong></p>
<h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><ul>
<li>document.getElementById()：通过ID属性查找</li>
<li>document.getElementsByTagName()：通过标签名查找</li>
<li>document.getElementsByName()：通过name属性查找</li>
<li>document.getElementsByClassName()：通过class属性查找</li>
</ul>
<h3 id="导航查找"><a href="#导航查找" class="headerlink" title="导航查找"></a>导航查找</h3><blockquote>
<p>需要先通过直接查找确定一个基点<br>如：var ele = document.getElementsByClassName(“box2_div”)[0];</p>
</blockquote>
<ul>
<li>ele.parentElement 父节点标签</li>
<li>ele.children 所有子节点标签</li>
<li>ele.firstElementChild 第一个子节点标签</li>
<li>ele.lastElementChild 最后一个子节点标签</li>
<li>ele.nextElementSibling 下一个兄弟节点标签</li>
<li>ele.previousElementSibling 上一个兄弟节点标签</li>
</ul>
<h2 id="节点增删"><a href="#节点增删" class="headerlink" title="节点增删"></a>节点增删</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tag = document.createElement(&apos;input&apos;)</span><br><span class="line">tag.type = &apos;text&apos;</span><br><span class="line">tag.innerText = &apos;aa&apos;</span><br></pre></td></tr></table></figure>
<h3 id="添加子节点"><a href="#添加子节点" class="headerlink" title="添加子节点"></a>添加子节点</h3><ul>
<li>在标签内末尾添加子节点：ele.append(tag)</li>
<li>在标签内指定子标签前添加子节点：ele.insertBefore(tag, ele1)</li>
</ul>
<h3 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h3><p>ele.removeChild(ele1)</p>
<h3 id="替换子节点"><a href="#替换子节点" class="headerlink" title="替换子节点"></a>替换子节点</h3><p>ele.replaceChild(new_node, old_node)</p>
<h2 id="节点修改"><a href="#节点修改" class="headerlink" title="节点修改"></a>节点修改</h2><h3 id="节点文本操作"><a href="#节点文本操作" class="headerlink" title="节点文本操作"></a>节点文本操作</h3><ul>
<li>设置文本：tag.innerText</li>
<li>设置为html：tag.innerHTML</li>
</ul>
<h3 id="节点类操作"><a href="#节点类操作" class="headerlink" title="节点类操作"></a>节点类操作</h3><ul>
<li>类名：ele.className、ele.classList</li>
<li>添加类：ele.classList.add(‘he’)</li>
<li>删除类：ele.classList.remove(‘yuan’)</li>
</ul>
<h3 id="节点属性操作"><a href="#节点属性操作" class="headerlink" title="节点属性操作"></a>节点属性操作</h3><ul>
<li>获取属性值：ele.getAttribute(‘age’)</li>
<li>设置属性值：ele.setAttribute(‘sex’, ‘nv’)</li>
<li>删除属性值：ele.removeAttribute(‘age’)</li>
</ul>
<h2 id="节点事件"><a href="#节点事件" class="headerlink" title="节点事件"></a>节点事件</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>在标签中设置相应事件，并调用相关函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; onclick=&quot;stop()&quot; value=&quot;停止&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在js文件中查找相关标签并触发相关事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ele = document.getElementById(&apos;bb&apos;)</span><br><span class="line">ele.onclick = function () &#123;</span><br><span class="line">    alert(&apos;ok&apos;);</span><br><span class="line">    //this指代当前标签</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h3><ul>
<li>onlick：鼠标单击</li>
<li>ondbclick：鼠标双击</li>
<li>onfocus：元素获取焦点【input标签】</li>
<li>onblur：元素失去焦点【input标签】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ele = document.getElementById(&apos;aa&apos;)</span><br><span class="line">ele.onfocus = function (argument) &#123;</span><br><span class="line">    this.value = &apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">ele.onblur = function (argument) &#123;</span><br><span class="line">    if(!this.value.trim())&#123;</span><br><span class="line">        this.value = &apos;ceshi&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>onchange：当域的内容被改变（如下拉框）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ele = document.getElementById(&apos;age&apos;);</span><br><span class="line">ele.onchange = function () &#123;</span><br><span class="line">    confirm(&apos;确定？&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>onkeydown 当某个键被按下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.onkeydown=function (event) &#123;</span><br><span class="line">    // 兼容设置</span><br><span class="line">    event=event||window.event;</span><br><span class="line">    // asicc码</span><br><span class="line">    var keynum=event.keyCode;</span><br><span class="line">    // asicc转字符</span><br><span class="line">    var keychar=String.fromCharCode(keynum);</span><br><span class="line">    console.log(keychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>onkeypress：当某个键被按下并松开</li>
<li>onkeyup：当某个键被松开</li>
<li>onload：一个页面或一张图像完成加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ele= document.getElementsByTagName(&apos;body&apos;)[0]</span><br><span class="line">ele.onload=function () &#123;</span><br><span class="line">    alert(&apos;ok&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//window.onload事件中可以定义整个窗口加载完执行的动作，</span><br><span class="line">//从而可以在head标签下的script中定义html中的标签事件</span><br><span class="line">window.onload=function (argument) &#123;</span><br><span class="line">    /* body... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>onmousedown：鼠标按钮被按下</li>
<li>onmousemove：鼠标移动</li>
<li>onmouseover：鼠标移动到某个元素上</li>
<li>onmouseout：鼠标从某个元素离开</li>
<li>onmouseleave：鼠标从元素离开</li>
<li>onselect：文本被选中</li>
<li>onsubmit：确认按钮被点击（只能用于form元素）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ele = document.getElementsByTagName(&apos;form&apos;)[0]</span><br><span class="line">ele.onsubmit=function (event) &#123;</span><br><span class="line">    if(this.firstElementChild.value == &apos;test&apos;)&#123;</span><br><span class="line">        console.log(&apos;请不要测试！&apos;);</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//阻止默认事件方式1</span><br><span class="line">ele.onsubmit=function (argument) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//阻止默认事件方式2</span><br><span class="line">ele.onsubmit=function (event) &#123;</span><br><span class="line">    event.preventDefault(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>event.stopPropagation 阻止事件扩散</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele2.onclick=function (event) &#123;</span><br><span class="line">    alert(456);</span><br><span class="line">    //阻止事件从子元素扩展到父元素</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascrip</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发之jquery学习</title>
    <url>/blog/2018/06/08/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91/web%E5%BC%80%E5%8F%91%E4%B9%8Bjquery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>jquery是一个快速、简洁的JavaScript框架，</li>
<li>它封装了JavaScript是常用的功能模块，提供了一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互</li>
<li><a href="https://jquery.com/" target="_blank" rel="noopener">下载地址</a></li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>语法：$(selector).action()</li>
<li>导入方式：<code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.1.1.js&quot;&gt;&lt;/script&gt;</code></li>
</ul>
<h2 id="echo循环"><a href="#echo循环" class="headerlink" title="echo循环"></a>echo循环</h2><h3 id="无标签对象的循环"><a href="#无标签对象的循环" class="headerlink" title="无标签对象的循环"></a>无标签对象的循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lis = [11, 22, 33];</span><br><span class="line">$.each(lis, function (index, val) &#123;</span><br><span class="line">    console.log(index, val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="有标签对象的循环"><a href="#有标签对象的循环" class="headerlink" title="有标签对象的循环"></a>有标签对象的循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;li&quot;).each(function(index, el) &#123;</span><br><span class="line">     if ($(this).text() == &apos;22&apos;) &#123;</span><br><span class="line">        $(this).css(&apos;color&apos;, &apos;red&apos;);</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h1><blockquote>
<p>jquery支持链式操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;.title&apos;).click(function(event) &#123;</span><br><span class="line">  //jquery支持链式操作</span><br><span class="line">  $(this).next().removeClass(&apos;hide&apos;).parent().siblings().children(&apos;.con&apos;).addClass(&apos;hide&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h2><ul>
<li>标签选择器：<code>$(&quot;tag&quot;)</code></li>
<li>ID选择器：<code>$(&quot;#id&quot;)</code></li>
<li>类选择器：<code>$(&quot;.class&quot;)</code></li>
<li>自定义属性选择器：<code>$(&#39;[egon=&quot;ceshi1&quot;]&#39;) $(&#39;[egon]&#39;)</code></li>
</ul>
<h2 id="导航查找"><a href="#导航查找" class="headerlink" title="导航查找"></a>导航查找</h2><blockquote>
<p>需先通过基本选择器确定一个基点</p>
</blockquote>
<ul>
<li><code>$(&quot;.box2&quot;).sibling()</code>：所有兄弟标签</li>
<li><code>$(&quot;.box2&quot;).next()</code>：下一个兄弟</li>
<li><code>$(&quot;.box2&quot;).nextAll()</code>：下面所有兄弟</li>
<li><code>$(&quot;.box2&quot;).nextUntil(&#39;.p3&#39;)</code>：下面直到.p3标签的所有兄弟</li>
<li><code>$(&quot;.box2&quot;).prev()</code>：前面兄弟</li>
<li><code>$(&quot;.box2&quot;).prevAll()</code>：前面所有兄弟</li>
<li><code>$(&quot;.box2&quot;).prevUntil(&quot;.p3&quot;)</code>：前面直到.p3标签的所有兄弟</li>
<li><code>$(&quot;.box2&quot;).children(&#39;p&#39;)</code>：寻找子标签</li>
<li><code>$(&quot;.box2&quot;).find(&#39;p&#39;)</code>：寻找后代标签</li>
<li><code>$(&quot;.box2&quot;).parent()</code>：查找父标签</li>
</ul>
<h2 id="混合查找"><a href="#混合查找" class="headerlink" title="混合查找"></a>混合查找</h2><ul>
<li>逻辑“或”连接：<code>$(&quot;.class,#id,div&quot;)</code></li>
<li>子代选择：<code>$(&quot;.outer&gt;p&quot;)</code></li>
<li>后代选择：<code>$(&quot;.outer p&quot;)</code></li>
<li>向下的兄弟选择：<code>$(&quot;.box1~p&quot;)</code></li>
<li>向下的毗邻选择（紧挨）：<code>$(&quot;.box1+p&quot;)</code></li>
</ul>
<h2 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h2><ul>
<li><code>$(&quot;ul li&quot;).eq(2)</code>：索引为2的li</li>
<li><code>$(&quot;ul li:lt(2)&quot;)</code>：索引小于2的li</li>
<li><code>$(&quot;ul li:odd&quot;)</code>：索引为奇数的li</li>
<li><code>$(&quot;ul li:even&quot;)</code>：索引为偶数的li</li>
</ul>
<h1 id="节点事件"><a href="#节点事件" class="headerlink" title="节点事件"></a>节点事件</h1><h2 id="页面载入"><a href="#页面载入" class="headerlink" title="页面载入"></a>页面载入</h2><blockquote>
<p>等同于window.load</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function (argument) &#123;</span><br><span class="line">    alert(&apos;123&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul>
<li>给已存在的标签绑定事件</li>
<li>与js区别：事件没有on关键词<ul>
<li>js：js标签对象.on事件=函数</li>
<li>jquery：js标签对象.事件(函数)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//js方式</span><br><span class="line">var ele = document.getElementsByClassName(&quot;box2&quot;)[0]</span><br><span class="line">ele.onclick = function () &#123;</span><br><span class="line">    alert(&apos;123&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//jquery方式</span><br><span class="line">$(&quot;.box2&quot;).click(</span><br><span class="line">    function () &#123;</span><br><span class="line">        alert(&quot;123&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h2><ul>
<li>无论子标签是否存在</li>
<li>父标签委派事件给子标签</li>
<li>语法：父标签.on(事件，子标签，函数)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.box1&quot;).on(&quot;click&quot;, &apos;p&apos;, function () &#123;</span><br><span class="line">    alert(345);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="节点修改"><a href="#节点修改" class="headerlink" title="节点修改"></a>节点修改</h1><h2 id="属性与值"><a href="#属性与值" class="headerlink" title="属性与值"></a>属性与值</h2><ul>
<li>添加类属性：$(“.box1”).addClass(“aa”)</li>
<li>移除类属性：$(“.box1”).removeClass(“aa”)</li>
<li>设置或获取自有属性：$(“.box1”).prop(“id”)</li>
<li>移除自有属性：$(“.box1”).removeProp(“id”)</li>
<li>设置或获取自定义属性：$(“.box1”).attr(“age”, 18)</li>
<li>移除自定义属性：$(“.box1”).removeAttr(“sex”)</li>
<li>设置或获取标签html：<code>$(&quot;.box2&quot;).html(&#39;&lt;label&gt;yes&lt;/label&gt;&#39;)</code></li>
<li>设置或获取标签文本：<code>$(&quot;.box2&quot;).text(&#39;ceshi&#39;)</code></li>
<li>清空标签内容：$(“.aaa”).empty()</li>
<li>获取input标签的value值：$(“input”).val()</li>
</ul>
<h2 id="css操作"><a href="#css操作" class="headerlink" title="css操作"></a>css操作</h2><ul>
<li>设置标签的css：$(“.box1”).css({“color”:”gold”, “background-color”:”green”})</li>
</ul>
<h2 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h2><ul>
<li>隐藏标签：$(“.box2”).hide()</li>
<li>显示标签：$(“.box2”).show()</li>
<li>标签显示隐藏切换：$(“.box”).toggle()</li>
<li>滑入：$(“”).slideUp()</li>
<li>滑出：$(“”).slideDown()</li>
<li>滑入滑出切换：$(“”).slideToggle() </li>
<li>淡入：$(“”).fadeIn() </li>
<li>淡出：$(“”).fadeOut() </li>
<li>淡入淡出切换：$(“”).fadeToggle() </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//显隐切换</span><br><span class="line">$(&quot;button&quot;).click(</span><br><span class="line">    function () &#123;</span><br><span class="line">        if($(this).text() == &apos;hide&apos;)&#123;</span><br><span class="line">            $(&quot;p&quot;).hide();</span><br><span class="line">        &#125;else if($(this).text() == &apos;show&apos;)&#123;</span><br><span class="line">            $(&quot;p&quot;).show();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            $(&quot;p&quot;).toggle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="节点增删"><a href="#节点增删" class="headerlink" title="节点增删"></a>节点增删</h1><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><ul>
<li>创建：<code>var $ele1 = $(&quot;&lt;p&gt;&quot;)</code></li>
<li>克隆：var $ele1 = $(“.aaa”).clone()</li>
</ul>
<h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><ul>
<li>父节点末尾添加：$(“div”).append($ele1)</li>
<li>父节点开始添加：$(“div”).prepend($ele1)</li>
<li>指定节点之后添加：$(“.aaa”).after($ele1)</li>
<li>指定节点之前添加：$(“.aaa”).before($ele1)</li>
</ul>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><blockquote>
<p>操作自身</p>
</blockquote>
<p>$(“.aaa”).remove() </p>
<h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><blockquote>
<p>操作自身</p>
</blockquote>
<p>$(“.aaa”).replaceWith($ele1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//添加标签【克隆】</span><br><span class="line">$(&quot;.add&quot;).click(function (event) &#123;</span><br><span class="line">    var $outer=$(this).parent().clone();</span><br><span class="line">    $outer.children(&apos;button&apos;).text(&apos;删除&apos;).attr(&apos;class&apos;, &apos;remove&apos;);</span><br><span class="line">    $(&quot;body&quot;).append($outer);</span><br><span class="line">&#125;);</span><br><span class="line">//删除标签【事件委派】</span><br><span class="line">$(&quot;body&quot;).on(&quot;click&quot;, &quot;.remove&quot;, function (event) &#123;</span><br><span class="line">    $(this).parent().remove();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>JSON（JavaScript Object Notation）：js对象标记；它使用JavaScript语法来描述数据对象，但是它仍独立于语言和平台。</li>
<li>json是存储和交换文本的语法。类似XML，但是比XML更小、更快，更易解析。</li>
<li>json文本的MIME类型是”application/json”</li>
</ul>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul>
<li>数据在名称/值对中，值可以是<ul>
<li>字符串【在双引号中】</li>
<li>数值【整数和浮点数】</li>
<li>布尔值【true和false】</li>
<li>对象</li>
<li>数组</li>
<li>null</li>
</ul>
</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数据</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>json对象转换为json字符串（stringify）：console.log(JSON.stringify({“name”: “xiaofang”}))</li>
<li>json字符串转换为json对象（parse）：console.log(JSON.parse(‘{“name”: “hejingqi”}’))</li>
</ul>
<h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步JavaScript和XML</li>
<li>异步向服务端发送数据</li>
<li>浏览器局部刷新</li>
<li>语法：$.ajax({key1: value1})</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>url：ajax向后端提交数据的url</li>
<li>type：提交数据的方式（默认get）</li>
<li>data：向服务端传送的数据</li>
<li>contentType：发送给服务端时的内容编码MIME类型(默认application/x-www-form-urlencoded)</li>
<li>dataType：客户端希望从服务端接受的数据类型【xml、html、json、text等】</li>
<li>success：当后端处理成功时，前端的处理方式</li>
<li>traditional：（true/false） 当要传输的数据为多维数组时使用</li>
<li>error：后端错误时的处理方式</li>
<li>complete：后端处理完成时的处理方式</li>
<li>statusCode：根据后端处理结果的返回码进行处理</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><ul>
<li>js实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(&quot;#username&quot;).blur(function () &#123;</span><br><span class="line">        var $user = $(this).val();</span><br><span class="line">        //csrf设置</span><br><span class="line">        $.ajaxSetup(&#123;</span><br><span class="line">                data: &#123;csrfmiddlewaretoken: &apos;&#123;&#123; csrf_token &#125;&#125;&apos;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if($user.trim().length != 0) &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;checkuser&quot;,</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                //data: &#123;username: $user&#125;,</span><br><span class="line">                //ajax的serialize方法序列化表单数据</span><br><span class="line">                data: $(&quot;form&quot;).serialize(),</span><br><span class="line">                success: function (data) &#123;</span><br><span class="line">                    console.log(data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;console.log(&apos;user is empty&apos;)&#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>python实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def checkuser(request):</span><br><span class="line">    username = request.POST.get(&apos;username&apos;)</span><br><span class="line">    if username == &apos;he&apos;:</span><br><span class="line">        return HttpResponse(&quot;user is exist&quot;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponse(&apos;user not exists&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当数据传输使用json格式时，由于django的csrf中间件默认使用“application/x-www-form-urlencoded”格式获取csrftoken值，<br>此时由于格式不匹配，造成后端无法正确获取csrftoken值从而造成csrf Forbidden错误，目前暂未解决，建议使用默认数据格式传输。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>jquery</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
</search>
